Description: Upstream changes introduced in version 4.18-1
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 ldapjdk (4.18-1) unstable; urgency=low
 .
   * control: Change the VCS header to point to the git repository.
 .
 The person named in the Author field signed this changelog entry.
Author: Timo Aaltonen <tjaalton@ubuntu.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- ldapjdk-4.18.orig/mozilla/directory/java-sdk/build.xml
+++ ldapjdk-4.18/mozilla/directory/java-sdk/build.xml
@@ -1,262 +1,64 @@
-<project name="Mozilla Java LDAP SDK" default="show" basedir=".">
+<!-- ant build file for xt-dash -->
 
-<!-- ***** BEGIN LICENSE BLOCK *****
-   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
-   -
-   - The contents of this file are subject to the Mozilla Public License Version
-   - 1.1 (the "License"); you may not use this file except in compliance with
-   - the License. You may obtain a copy of the License at
-   - http://www.mozilla.org/MPL/
-   -
-   - Software distributed under the License is distributed on an "AS IS" basis,
-   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-   - for the specific language governing rights and limitations under the
-   - License.
-   -
-   - The Original Code is mozilla.org code.
-   -
-   - The Initial Developer of the Original Code is
-   - Netscape Communications Corporation.
-   - Portions created by the Initial Developer are Copyright (C) 1999
-   - the Initial Developer. All Rights Reserved.
-   -
-   - Contributor(s):
-   -   Tony Dahbura (tony@dahbura.com) initial creation of ant build files
-   -
-   - Alternatively, the contents of this file may be used under the terms of
-   - either the GNU General Public License Version 2 or later (the "GPL"), or
-   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-   - in which case the provisions of the GPL or the LGPL are applicable instead
-   - of those above. If you wish to allow use of your version of this file only
-   - under the terms of either the GPL or the LGPL, and not to allow others to
-   - use your version of this file under the terms of the MPL, indicate your
-   - decision by deleting the provisions above and replace them with the notice
-   - and other provisions required by the GPL or the LGPL. If you do not delete
-   - the provisions above, a recipient may use your version of this file under
-   - the terms of any one of the MPL, the GPL or the LGPL.
-   -
-   - ***** END LICENSE BLOCK ***** -->
-
-
-  <!-- ===================== Initialize Property Values =================== -->
-
-    <property file="build.properties"/>
-
-  <!-- Project Properties -->
-    <property name="name"                value="java-sdk" />
-    <property name="year"                value="2007" />
-    <property name="version"             value="4.18" />
-    <property name="sdkjarfilename"      value="ldapjdk.jar" />
-    <property name="filtjarfilename"     value="ldapfilt.jar" />
-    <property name="jdnijarfilename"     value="ldapsp.jar" />
-    <property name="beansjarfilename"    value="ldapbeans.jar" />
-    <property name="doczipfilename"      value="ldapdoc.zip" />
-
-
-  <!-- Build Defaults -->
- 
-    <property name="jdk.dist"            value="${basedir}/dist/classes"/>
-    <property name="filter.dist"         value="${basedir}/dist/ldapfilt"/>
-    <property name="jndi.dist"           value="${basedir}/dist/classes"/>
-    <property name="doc.dist"            value="${basedir}/dist/doc"/>
-    <property name="package.dist"        value="${basedir}/dist/packages"/>
-    <property name="src"                 value="."/>
-    <property name="build"               value="build"/>
-    <property name="dist"                value="dist"/>
-
-    <!-- the following is to setup the correct info for sun jsse which
-        is jdk dependent -->
-    <property name="ssllibs14" value="${basedir}/ldapjdk/lib/jss32_stub.jar"/>
-    <property name="ssllibs13" value="${basedir}/ldapjdk/lib/jaas.jar:${basedir}/ldapjdk/lib/jnet.jar:${basedir}/ldapjdk/lib/jsse.jar:${basedir}/ldapjdk/lib/jss32_stub.jar"/>
-
-    <!-- we do not use the users existing classpath and instead build our own
-         comment the following line out if this is not desired -->
-    <property name="build.sysclasspath" value="ignore"/>
-
-    <!-- the following target is the default target so show some help -->
-    <target name="show">
-        <echo>The following targets are defined:
-   dist         : will build entire sdk and package all the pieces
-   dist-jdk     : will build only the ldap jdk jar (ldapjdk.jar)
-   dist-filter  : will build only the ldap filter jar (ldapfilt.jar)
-   dist-beans   : will build only the beans jar (ldapbeans.jar)
-   dist-jndi    : will build only the jndi service provider (ldapsp.jar)
-   dist-docs    : will package up all the documentation (ldapdoc.zip)
-
-   build        : will compile the entire sdk but not package
-   build-jdk    : will compile only the ldap jdk jar
-   build-filter : will compile only the filter classes
-   build-beans  : will compile only the ldap beans
-   build-jndi   : will compile only the jndi service provider
-   build-docs   : will compile the complete javadocs
-
-   clean        : will remove all compiled files and packages
-   clean-dists  : will remove all the jars and zips
-   clean-builds : will remove all the compiled classes
-        </echo>
-      </target>
-
-    <target name="init">
-        <echo>compiling for jdk version=${ant.java.version}</echo>
-        <condition property="jsselibs" value="${ssllibs13}">
-        <or>
-              <equals arg1="${ant.java.version}" arg2="1.1" />
-              <equals arg1="${ant.java.version}" arg2="1.2" />
-              <equals arg1="${ant.java.version}" arg2="1.3" />
-        </or>
-          </condition>
-        <condition property="jsselibs" value="${ssllibs14}">
-        <not>
-            <or>
-                  <equals arg1="${ant.java.version}" arg2="1.1" />
-                  <equals arg1="${ant.java.version}" arg2="1.2" />
-                  <equals arg1="${ant.java.version}" arg2="1.3" />
-            </or>
-        </not>
-          </condition>
-        <echo>ssl libraries path=${jsselibs}</echo>
-        <!-- create dist directories in case a clean was executed -->
-        <mkdir dir="${jdk.dist}"/>
-        <mkdir dir="${filter.dist}"/>
-        <mkdir dir="${jndi.dist}"/>
-        <mkdir dir="${doc.dist}"/>
-        <mkdir dir="${package.dist}"/>
-    </target>
+<project name="ldapsdk" default="all" basedir=".">
 
-  <target name="dist" depends="dist-jdk,dist-filter,dist-beans,dist-jndi,dist-docs">
-    <echo>Building all packages....</echo>
-  </target>
+  <!-- Properties -->
 
-  <target name="dist-jdk" depends="build-jdk">
-    <!-- copy errors property files in to dist area for jarfile inclusion -->
-    <mkdir dir="${jdk.dist}/netscape/ldap/errors"/>
-    <copy todir="${jdk.dist}/netscape/ldap/errors">
-      <fileset dir="${basedir}/ldapjdk/netscape/ldap/errors">
-        <include name="*.props"/>
+  <property name="name" value="ldapsdk"/>
+  <property name="src" value="src"/>
+  <property name="build" value="build"/>
+  <property name="build.classes" value="${build}/classes"/>
+  <property name="build.doc" value="${build}/api"/>
+  <property name="build.lib" value="${build}/lib"/>
+  <property name="packagenames" value="com.*,netscape.*,org.mozilla.*"/>
+
+  <!-- Targets -->
+
+  <!-- Prepare build directories -->
+  <target name="prepare">
+    <mkdir dir="${src}"/>
+    <mkdir dir="${build}"/>
+    <mkdir dir="${build.classes}"/>
+    <mkdir dir="${build.lib}"/>
+    <mkdir dir="${build.doc}"/>
+  </target>
+
+  <!-- Kill all the created directories -->
+  <target name="clean">
+    <delete dir="${build}"/>
+    <delete dir="${src}"/>
+  </target>
+
+  <!-- Build classes -->
+  <target name="classes" depends="prepare">
+    <javac srcdir="${src}" classpath="/usr/share/java/jss.jar;/usr/share/java/oro.jar" destdir="${build.classes}" debug="on" 
+optimize="on"/>
+    <copy todir="${build.classes}">
+      <fileset dir="${src}">
+        <include name="**/*.properties"/>
       </fileset>
     </copy>
-    <jar jarfile="${package.dist}/${sdkjarfilename}"
-         basedir="${jdk.dist}"
-         excludes="cvs/**"
-         includes="netscape/ldap/*.class,netscape/ldap/client/*.class,netscape/ldap/client/opers/*.class,netscape/ldap/ber/stream/*.class,netscape/ldap/controls/*.class,netscape/ldap/factory/*.class,netscape/ldap/util/*.class,netscape/ldap/errors/*.props,com/netscape/sasl/*.class,com/netscape/sasl/mechanisms/*.class,*.class" 
-    />
   </target>
 
-  <target name="dist-filter" depends="build-filter">
-    <jar jarfile="${package.dist}/${filtjarfilename}"
-         basedir="${filter.dist}"
-         excludes="cvs/**"
-         includes="netscape/ldap/util/*.class" 
-    />
-  </target>
-  
-  <target name="dist-beans" depends="build-beans">
-    <jar jarfile="${package.dist}/${beansjarfilename}"
-         basedir="${jdk.dist}"
-         excludes="cvs/**"
-         includes="netscape/ldap/beans/*" 
-    />
+  <!-- Build jar archives -->
+  <target name="jar" depends="classes">
+    <jar jarfile="${build.lib}/${name}.jar" basedir="${build.classes}"/>
   </target>
 
-  <target name="dist-jndi" depends="build-jndi">
-    <jar jarfile="${package.dist}/${jdnijarfilename}"
-         basedir="${jdk.dist}"
-         excludes="cvs/**"
-         includes="com/netscape/jndi/ldap/*.class com/netscape/jndi/ldap/common/*.class com/netscape/jndi/ldap/schema/*.class com/netscape/jndi/ldap/controls/*.class"
+  <!-- Build the full JavaDocs -->
+  <target name="javadoc" depends="prepare">
+    <javadoc sourcepath="${src}"
+            destdir="${build.doc}"
+            doctitle="${name} JavaDoc"
+            windowtitle="${name} JavaDoc"
+            package="true"
+            author="true"
+            version="true"
+            packagenames="${packagenames}"
     />
   </target>
 
-  <target name="dist-docs" depends="build-docs">
-    <jar jarfile="${package.dist}/${doczipfilename}"
-         update="no"
-         basedir="${doc.dist}"
-         excludes="cvs/**"
-         includes="*.html *.css netscape/ldap/*.html netscape/ldap/beans/*.html netscape/ldap/controls/*.html netscape/ldap/util/*.html netscape/ldap/ber/stream/*.html" 
-    />
-  </target>
-
-
-<!-- The following targets do the builds (compiles of the source files) -->
-
-    <target name="build" depends="build-jdk,build-filter,build-beans,build-jndi"/>
-
-    <target name="build-jdk" depends="init">
-        <!-- Compile the java jdk code from ${src} into ${dest} -->
-        <javac srcdir="${basedir}/ldapjdk/com" destdir="${jdk.dist}"
-            excludes="cvs/**"
-            classpath="${jsselibs}"
-        />
-        <javac srcdir="${basedir}/ldapjdk/netscape" destdir="${jdk.dist}"
-            excludes="cvs/**"
-            classpath="${jsselibs}"
-        />
-        <javac srcdir="${basedir}/tools" destdir="${jdk.dist}"
-            excludes="cvs/**"
-            classpath="${jsselibs}"
-        />
-      </target>
-
-    <target name="build-filter" depends="init,build-jdk">
-        <javac srcdir="${basedir}/ldapfilter" destdir="${filter.dist}"
-            excludes="cvs/**"
-            classpath="${jdk.dist}:${jsselibs}"
-        />
-      </target>
-
-    <target name="build-beans" depends="init">
-        <!-- Compile the java jdk bean code from ${src} into ${dest} -->
-        <javac srcdir="${basedir}/ldapbeans" destdir="${jdk.dist}"
-            excludes="cvs/**"
-            classpath="${jsselibs}"
-        />
-      </target>
-
-    <target name="build-jndi" depends="init,build-jdk">
-        <!-- Compile the java code from ${src} into ${dest} -->
-        <javac srcdir="${basedir}/ldapsp" destdir="${jndi.dist}"
-            excludes="cvs/**"
-            classpath="${jsselibs}:${basedir}/ldapsp/lib/jndi.jar"
-        />
-      </target>
-
-    <target name="build-docs">
-        <!-- Create the javadocs for the sdk -->
-        
-        <javadoc 
-                packagenames="netscape.ldap.*,netscape.ldap.beans.*,netscape.ldap.controls.*,netscape.ldap.util.*,netscape.ldap.factory.*,com.netscape.sasl.*,com.netscape.sasl.mechanisms.*,netscape.ldap.ber.stream.*"
-                 sourcepath="${basedir}/ldapbeans:${basedir}/ldapjdk"
-                 sourcefiles="${basedir}/tools/LDAPDelete.java,${basedir}/tools/LDAPModify.java,${basedir}/tools/LDAPSearch.java,${basedir}/tools/LDAPTool.java"
-                 destdir="${doc.dist}"
-                 author="true"
-                 version="true"
-                 use="true"
-                 classpath="${basedir}/ldapjdk:${basedir}/ldapjdk/lib/jss32_stub.jar:${basedir}/ldapbeans" >
-        </javadoc>
-
-        <javadoc packagenames="com.netscape.jndi.ldap.controls.*"
-                sourcepath="${basedir}/ldapsp"    
-                destdir="${doc.dist}/ldapsp"
-                classpath="${jndi.dist}:${basedir}/ldapsp:${basedir}/ldapsp/lib/jndi.jar"
-                author="true"
-                version="true"
-                use="true">
-        </javadoc>
-      </target>
-
-    <target name="clean" depends="clean-dists,clean-builds"/>
-
-    <target name="clean-dists">
-        <!-- Delete the jar and zip files -->
-        <delete includeEmptyDirs="true">
-            <fileset dir="${package.dist}" includes="*.jar *.zip" />
-        </delete>
-    </target>
-
-    <target name="clean-builds">
-        <!-- Delete the .class and javadoc files built up from builds -->
-        <delete includeEmptyDirs="true">
-            <fileset dir="${basedir}/dist" excludes="**/*.jar **/*.zip"/>
-        </delete>
-    </target>
+  <!-- Build everything -->
+  <target name="all" depends="jar,javadoc"/>
 
 </project>
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSearchListener.java
@@ -0,0 +1,197 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.*;
+
+/**
+ * Manages search results, references and responses returned on one or 
+ * more search requests
+ *
+ */
+public class LDAPSearchListener extends LDAPMessageQueue {
+
+    static final long serialVersionUID = -7163312406176592277L;
+    // this instance variable is only for cache purpose
+    private Long m_key = null;
+    private LDAPSearchConstraints m_constraints;
+
+    /**
+     * Constructs a LDAP search listener.
+     * @param asynchOp a boolean flag indicating whether the object is used 
+     * for asynchronous LDAP operations
+     * @param cons LDAP search constraints
+     * @see netscape.ldap.LDAPAsynchronousConnection
+     */
+    LDAPSearchListener ( boolean asynchOp,
+                         LDAPSearchConstraints cons ) {
+        super ( asynchOp );
+        m_constraints = cons;
+    }
+
+    /**
+     * Block until all results are in. Used for synchronous search with 
+     * batch size of zero.
+     * @return search response message.
+     * @exception Network exception error
+     */
+    LDAPResponse completeSearchOperation () throws LDAPException{
+        return completeRequest();
+    }
+
+
+    /**
+     * Blocks until a search result, reference or response is available,     * or until all operations associated with the object have completed     * or been canceled.
+     *
+     * @return a search result, search reference, search response message,
+     * or null if there are no more outstanding requests. 
+     * @exception LDAPException Network error exception
+     * @exception LDAPInterruptedException The invoking thread was interrupted
+     * @see LDAPResponse
+     * @see LDAPSearchResult
+     * @see LDAPSearchResultReference
+     */
+    public LDAPMessage getResponse () throws LDAPException{
+        return nextMessage();
+    }
+
+
+    /**
+     * Override nextMessage to wake up the LDAPConnThread if 
+     *  backlog limit has been reached 
+     */
+    LDAPMessage nextMessage()  throws LDAPException{
+        LDAPMessage result = super.nextMessage();
+
+        // Notify LDAPConnThread to wake up if backlog limit has been reached
+        if (result instanceof LDAPSearchResult || result instanceof LDAPSearchResultReference) {
+            LDAPConnThread connThread = getConnThread(result.getMessageID());
+            if (connThread != null) {
+                connThread.resultRetrieved();
+            }
+        }
+        
+        return result;
+    }
+
+    /**
+     * Merge two response listeners.
+     * Move/append the content from another response listener to this one.
+     * <P>
+     * To be used for synchronization of asynchronous LDAP operations where
+     * requests are sent by one thread but processed by another one.
+     * <P>
+     * A client may be implemented in such a way that one thread makes LDAP
+     * requests and calls l.getMessageIDs(), while another thread
+     * is responsible for
+     * processing of responses (call l.getResponse()). Both threads are using
+     * the same listener objects. In such a case, a race
+     * condition may occur, where a LDAP response message is retrieved and
+     * the request terminated (request ID removed) before the first thread
+     * has a chance to execute l.getMessageIDs().
+     * The proper way to handle this scenario is to create a separate listener
+     * for each new request, and after l.getMessageIDs() has been invoked,
+     * merge the new request with the existing one.
+     * @param listener2 the listener with which to merge
+     */
+    public void merge(LDAPSearchListener listener2) {
+        super.merge(listener2);
+    }
+    
+    /**
+     * Reports true if a response has been received from the server.
+     *
+     * @return a flag indicating whether the response message queue is empty.
+     */
+    public boolean isResponseReceived() {
+        return super.isMessageReceived();
+    }
+
+    /**
+     * Returns message IDs for all outstanding requests
+     * @return message ID array.
+     */
+    public int[] getMessageIDs() {
+        return super.getMessageIDs();
+    }
+    
+    /**
+     * Return the search constraints used to create this object.
+     * @return the search constraints used to create this object.
+     */
+    LDAPSearchConstraints getSearchConstraints() {
+        return m_constraints;
+    }
+
+    /**
+     * Set new search constraints object.
+     * @param cons LDAP search constraints
+     */
+     void setSearchConstraints(LDAPSearchConstraints cons) {
+        m_constraints = cons;
+    }
+
+    /**
+     * Resets the state of this object, so it can be recycled.
+     * Used by LDAPConnection synchronous operations.
+     */
+    void reset () {
+        super.reset();
+        m_constraints = null;
+    }
+    
+    /**
+     * Set the key of the cache entry. The listener needs to know this value
+     * when the results get processed in the queue. After the results have been
+     * saved in the vector, then the key and a vector of results are put in
+     * the cache.
+     * @param key the key of the cache entry
+     */
+    void setKey(Long key) {
+        m_key = key;
+    }
+
+    /**
+     * Get the key of the cache entry.
+     * @return the key of the cache entry.
+     */
+    Long getKey() {
+        return m_key;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPEntryComparator.java
@@ -0,0 +1,81 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * The <CODE>LDAPEntryComparator</CODE> interface represents the
+ * algorithm used to sort the search results. This interface specifies
+ * one method, <CODE>isGreater</CODE>, which compares two entries and
+ * determines the order in which the two entries should be sorted.
+ * <P>
+ *
+ * The <CODE>netscape.ldap</CODE> package includes a class that
+ * implements this interface.  The <CODE>LDAPCompareAttrNames</CODE>
+ * class represents a comparator that sorts the two entries alphabetically,
+ * based on the value of one or more attributes.
+ * <P>
+ *
+ * When calling the <CODE>sort</CODE> method of the
+ * <CODE>LDAPSearchResults</CODE> class, you need to specify
+ * a class that implements the <CODE>LDAPEntryComparator</CODE>
+ * interface.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPCompareAttrNames
+ * @see netscape.ldap.LDAPSearchResults#sort
+ */
+public interface LDAPEntryComparator {
+
+     /**
+     * Specifies the algorithm used to
+     * compare entries when sorting search results.
+     * <P>
+     *
+     * <CODE>isGreater</CODE> returns <CODE>true</CODE>
+     * if the entry specified in the first argument should
+     * be sorted before the entry specified in the second
+     * argument.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPCompareAttrNames
+     * @see netscape.ldap.LDAPSearchResults#sort
+     */
+    public boolean isGreater (LDAPEntry greater, LDAPEntry less);
+
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSaslBind.java
@@ -0,0 +1,307 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.client.opers.*;
+import netscape.ldap.ber.stream.*;
+import netscape.ldap.util.*;
+import java.io.*;
+import java.net.*;
+//import javax.security.auth.callback.CallbackHandler;
+
+/**
+ * Authenticates to a server using SASL
+ */
+public class LDAPSaslBind implements LDAPBind, java.io.Serializable {
+
+    static final long serialVersionUID = -7615315715163655443L;
+
+    /**
+     * Construct an object which can authenticate to an LDAP server
+     * using the specified name and a specified SASL mechanism.
+     *
+     * @param dn if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param mechanisms array of mechanism names, e.g. { "GSSAPI", "SKEY" }
+     * @param props optional additional properties of the desired
+     * authentication mechanism, e.g. minimum security level
+     * @param cbh a class which may be called by the SASL framework to
+     * obtain additional required information
+     */
+    public LDAPSaslBind( String dn,
+                         String[] mechanisms,
+                         String packageName,
+                         Hashtable props,
+                         /*CallbackHandler*/ Object cbh ) {
+        _dn = dn;
+        _mechanisms = mechanisms;
+        _packageName = packageName;
+        _props = props;
+        _cbh = cbh;
+
+        // 12-01-99 Disabled check for instanceof CallbackHandler so that
+        // there is no dependency on the extenal jaas.jar package. This is
+        // reqired for Communicator build where the ldap java package does not
+        // include any sasl classes.
+
+        /*if ( (cbh != null) &&
+             !(cbh instanceof javax.security.auth.callback.CallbackHandler) ) {
+            throw new IllegalArgumentException(
+                "Callback argument must implement " +
+                "javax.security.auth.callback.CallbackHandler" );
+        }*/
+    }
+
+    /**
+     * Authenticates to the LDAP server (that the object is currently
+     * connected to) using the parameter that were provided to the
+     * constructor. If the requested SASL mechanism is not
+     * available, an exception is thrown.  If the object has been
+     * disconnected from an LDAP server, this method attempts to reconnect
+     * to the server. If the object had already authenticated, the old
+     * authentication is discarded.
+     *
+     * @param ldc an active connection to a server, which will have
+     * the new authentication state on return from the method
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void bind( LDAPConnection ldc ) throws LDAPException {
+        if ( _props == null ) {
+            _props = new Hashtable();
+        }
+        if ( (!_props.containsKey( CLIENTPKGS )) &&
+             (System.getProperty( CLIENTPKGS ) == null) ) {
+            _props.put( CLIENTPKGS, ldc.DEFAULT_SASL_PACKAGE );
+        }
+        _saslClient = getClient( ldc, _packageName );
+        if ( _saslClient != null ) {
+            bind( ldc, true );
+            return;
+        } else {
+            ldc.printDebug( "LDAPSaslBind.bind: getClient " +
+                            "returned null" );
+        }
+    }
+
+    /**
+     * Get a SaslClient object from the Sasl framework
+     *
+     * @param ldc contains the host name
+     * @param packageName package containing a ClientFactory
+     * @return a SaslClient supporting one of the mechanisms
+     * of the member variable _mechanisms.
+     * @exception LDAPException on error producing a client
+     */
+    private Object getClient( LDAPConnection ldc, String packageName )
+        throws LDAPException {
+        try {
+            Object[] args = new Object[6];
+            args[0] = _mechanisms;
+            args[1] = _dn;
+            args[2] = "ldap";
+            args[3] = ldc.getHost();
+            args[4] = _props;
+            args[5] = _cbh;
+            String[] argNames = new String[6];
+            argNames[0] = "[Ljava.lang.String;";
+            argNames[1] = "java.lang.String";
+            argNames[2] = "java.lang.String";
+            argNames[3] = "java.lang.String";
+            argNames[4] = "java.util.Hashtable";
+            argNames[5] = CALLBACK_HANDLER;
+
+            // Get a mechanism driver
+            return DynamicInvoker.invokeMethod(null,
+                                               packageName+".Sasl",
+                                               "createSaslClient",
+                                               args, argNames);
+
+        } catch (Exception e) {
+            ldc.printDebug( "LDAPSaslBind.getClient: " +
+                            packageName+".Sasl.createSaslClient: " +
+                            e );
+            throw new LDAPException(e.toString(), LDAPException.OTHER);
+        }
+    }
+
+    void bind(LDAPConnection ldc, boolean rebind)
+        throws LDAPException {
+
+        if ((ldc.isConnected() && rebind) ||
+            !ldc.isConnected()) {
+            try {
+                // Get the initial request to start authentication
+                String className = _saslClient.getClass().getName();
+                ldc.printDebug( "LDAPSaslBind.bind: calling " +
+                                className+".createInitialResponse" );
+                byte[] outVals =
+                    (byte[])DynamicInvoker.invokeMethod(
+                        _saslClient,
+                        className,
+                        "createInitialResponse", null, null);
+
+                String mechanismName =
+                    (String)DynamicInvoker.invokeMethod(
+                        _saslClient,
+                        className,
+                        "getMechanismName", null, null);
+                ldc.printDebug( "LDAPSaslBind.bind: mechanism " +
+                                "name is " +
+                                mechanismName );
+                boolean isExternal = isExternalMechanism(mechanismName);
+                int resultCode = LDAPException.SASL_BIND_IN_PROGRESS;
+                JDAPBindResponse response = null;
+                while (!checkForSASLBindCompletion(resultCode)) {
+                    ldc.printDebug( "LDAPSaslBind.bind: calling " +
+                                    "saslBind" );
+                    response = saslBind(ldc, mechanismName, outVals);
+                    resultCode = response.getResultCode();
+                    ldc.printDebug( "LDAPSaslBind.bind: saslBind " +
+                                    "returned " + resultCode );
+                    if (isExternal) {
+                        continue;
+                    }
+
+                    byte[] b = response.getCredentials();
+
+                    Object[] args = {b};
+                    String[] argNames = {"[B"}; // class name for byte array
+
+                    outVals =
+                        (byte[])DynamicInvoker.invokeMethod(
+                            _saslClient,
+                            className, "evaluateChallenge",
+                            args, argNames);
+                }
+
+                // Make sure authentication REALLY is complete
+                Boolean bool =
+                    (Boolean)DynamicInvoker.invokeMethod(
+                        _saslClient,
+                        className, "isComplete", null, null);
+                if (!bool.booleanValue()) {
+                    // Authentication session hijacked!
+                    throw new LDAPException("The server indicates that " +
+                                            "authentication is successful" +
+                                            ", but the SASL driver " +
+                                            "indicates that authentication" +
+                                            " is not yet done.",
+                                            LDAPException.OTHER);
+                }
+
+                Object[] args = {ldc.getInputStream()};
+                String[] argNames = {"java.io.InputStream"};
+                InputStream is =
+                    (InputStream)DynamicInvoker.invokeMethod(
+                        _saslClient,
+                        className, "getInputStream", args, argNames);
+                ldc.setInputStream(is);
+                args[0] = ldc.getOutputStream();
+                argNames[0] = "java.io.OutputStream";
+                OutputStream os =
+                    (OutputStream)DynamicInvoker.invokeMethod(
+                        _saslClient,
+                        className, "getOutputStream", args, argNames);
+                ldc.setOutputStream(os);
+                ldc.setBound(true);
+            } catch (LDAPException e) {
+                throw e;
+            } catch (Exception e) {
+                throw new LDAPException(e.toString(), LDAPException.OTHER);
+            }
+        }
+    }
+
+    boolean isExternalMechanism(String name) {
+        return name.equalsIgnoreCase( LDAPConnection.EXTERNAL_MECHANISM );
+    }
+
+    private boolean checkForSASLBindCompletion(int resultCode)
+      throws LDAPException{
+
+        if (resultCode == LDAPException.SUCCESS) {
+            return true;
+        } else if (resultCode == LDAPException.SASL_BIND_IN_PROGRESS) {
+            return false;
+        } else {
+            throw new LDAPException("Authentication failed", resultCode);
+        }
+    }
+
+    private JDAPBindResponse saslBind(LDAPConnection ldc,
+                                      String mechanismName,
+                                      byte[] credentials)
+        throws LDAPException {
+
+        LDAPResponseListener myListener = ldc.getResponseListener ();
+
+        try {
+            ldc.sendRequest(new JDAPBindRequest(3,
+                                                _dn,
+                                                mechanismName,
+                                                credentials),
+                            myListener, ldc.getConstraints());
+            LDAPMessage response = myListener.getResponse();
+
+            JDAPProtocolOp protocolOp = response.getProtocolOp();
+            if (protocolOp instanceof JDAPBindResponse) {
+                return (JDAPBindResponse)protocolOp;
+            } else {
+                throw new LDAPException("Unknown response from the " +
+                                        "server during SASL bind",
+                                        LDAPException.OTHER);
+            }
+        } finally {
+            ldc.releaseResponseListener(myListener);
+        }
+    }
+
+    private static final String CALLBACK_HANDLER =
+        "javax.security.auth.callback.CallbackHandler";
+    private static final String CLIENTPKGS =
+        "javax.security.sasl.client.pkgs";
+    private String _dn;
+    private String[] _mechanisms;
+    private String _packageName;
+    private Hashtable _props;
+    private /*CallbackHandler*/ Object _cbh;
+    private Object _saslClient = null;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPv2.java
@@ -0,0 +1,499 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This interface summarizes the basic functionality available in the
+ * Lightweight Directory Access Protocol (LDAP) version 2. (See
+ * <A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc1777.html" TARGET="_blank">RFC 1777</A>
+ * for the definition of the protocol.)
+ * <P>
+ *
+ * In the general model for this protocol, objects exist under a directory
+ * in a particular server. Objects are identified by unique, hierarchical names
+ * called Distinguished Names, commonly abreviated "DN". An example of a DN:
+ * <pre>
+ *  cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=us
+ * </pre>
+ * Objects have attributes, of the form
+ * <pre>
+ *  attributeName = attributeValue(s)
+ * </pre>
+ * Attribute names must be Strings, and attribute values can be any 8-bit
+ * sequence (Strings or binary values).
+ *
+ * @version 1.0
+ */
+public interface LDAPv2 {
+    /**
+     * The default port number for LDAP servers.  You can specify
+     * this identifier when calling the <CODE>LDAPConnection.connect</CODE>
+     * method to connect to an LDAP server.
+     * @see netscape.ldap.LDAPConnection#connect
+     */
+    public final static int DEFAULT_PORT = 389;
+
+    /**
+     * Option specifying how aliases are dereferenced.
+     * <P>
+     *
+     * This option can have one of the following values:
+     * <UL>
+     * <LI><A HREF="#DEREF_NEVER"><CODE>DEREF_NEVER</CODE></A>
+     * <LI><A HREF="#DEREF_FINDING"><CODE>DEREF_FINDING</CODE></A>
+     * <LI><A HREF="#DEREF_SEARCHING"><CODE>DEREF_SEARCHING</CODE></A>
+     * <LI><A HREF="#DEREF_ALWAYS"><CODE>DEREF_ALWAYS</CODE></A>
+     * </UL>
+     * <P>
+     *
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int DEREF = 2;
+
+    /**
+     * Option specifying the maximum number of search results to
+     * return.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int SIZELIMIT = 3;
+
+    /**
+     * Option specifying the maximum number of milliseconds to
+     * wait for an operation to complete.
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int TIMELIMIT = 4;
+
+    /**
+     * Option specifying the maximum number of milliseconds the 
+     * server should spend returning search results before aborting
+     * the search. 
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int SERVER_TIMELIMIT = 5;
+
+    /**
+     * Option specifying whether or not referrals to other LDAP
+     * servers are followed automatically.
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     * @see netscape.ldap.LDAPRebind
+     * @see netscape.ldap.LDAPRebindAuth
+     */
+    public static final int REFERRALS = 8;
+
+    /**
+     * Option specifying the object containing the method for
+     * getting authentication information (the distinguished name
+     * and password) used during a referral.  For example, when
+     * referred to another LDAP server, your client uses this object
+     * to obtain the DN and password.  Your client authenticates to
+     * the LDAP server using this DN and password.
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     * @see netscape.ldap.LDAPRebind
+     * @see netscape.ldap.LDAPRebindAuth
+     */
+    public static final int REFERRALS_REBIND_PROC = 9;
+
+    /**
+     * Option specifying the maximum number of referrals to follow
+     * in a sequence when requesting an LDAP operation.
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int REFERRALS_HOP_LIMIT   = 10;
+    
+    /**
+     * Option specifying the object containing the method for
+     * authenticating to the server.  
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     * @see netscape.ldap.LDAPBind
+     */
+    public static final int BIND = 13;
+
+    /**
+     * Option specifying the version of the LDAP protocol
+     * used by your client when interacting with the LDAP server.
+     * If no version is set, the default version is 2.  If you
+     * are planning to use LDAP v3 features (such as controls
+     * or extended operations), you should set this version to 3
+     * or specify version 3 as an argument to the <CODE>authenticate</CODE>
+     * method of the <CODE>LDAPConnection</CODE> object.
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     * @see netscape.ldap.LDAPConnection#authenticate(int, java.lang.String, java.lang.String)
+     */
+    public static final int PROTOCOL_VERSION = 17;
+
+    /**
+     * Option specifying the number of results to return at a time.
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int BATCHSIZE = 20;
+
+
+    /*
+     * Valid options for Scope
+     */
+
+    /**
+     * Specifies that the scope of a search includes
+     * only the base DN (distinguished name).
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)
+     */
+    public static final int SCOPE_BASE = 0;
+
+    /**
+     * Specifies that the scope of a search includes
+     * only the entries one level below the base DN (distinguished name).
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)   */
+    public static final int SCOPE_ONE = 1;
+
+    /**
+     * Specifies that the scope of a search includes
+     * the base DN (distinguished name) and all entries at all levels
+     * beneath that base.
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)   */
+    public static final int SCOPE_SUB = 2;
+
+
+    /*
+     * Valid options for Dereference
+     */
+
+    /**
+     * Specifies that aliases are never dereferenced.
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int DEREF_NEVER = 0;
+
+    /**
+     * Specifies that aliases are dereferenced when searching the
+     * entries beneath the starting point of the search (but
+     * not when finding the starting entry).
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int DEREF_SEARCHING = 1;
+
+    /**
+     * Specifies that aliases are dereferenced when finding the
+     * starting point for the search (but not when searching
+     * under that starting entry).
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int DEREF_FINDING = 2;
+
+    /**
+     * Specifies that aliases are always dereferenced.
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int DEREF_ALWAYS = 3;
+
+    /**
+     * Connects to the LDAP server.
+     * @param host hostname of the LDAP server
+     * @param port port number of the LDAP server.  To specify the
+     * default port, use <CODE>DEFAULT_PORT</CODE>.
+     * @exception LDAPException Failed to connect to the server.
+     */
+    public void connect (String host, int port) throws LDAPException;
+
+    /**
+     * Connects and authenticates to the LDAP server.
+     * @param host hostname of the LDAP server
+     * @param port port number of the LDAP server. To specify the
+     * default port, use <CODE>DEFAULT_PORT</CODE>.
+     * @param dn distinguished name to use for authentication
+     * @param passwd password for authentication
+     * @exception LDAPException Failed to connect and authenticate to the server.
+     */
+    public void connect (String host, int port, String dn, String passwd)
+        throws LDAPException;
+
+    /**
+     * Disconnects from the LDAP server.  Subsequent operational calls
+     * will first try to re-establish the connection to the same LDAP server.
+     * @exception LDAPException Failed to disconnect from the server.
+     */
+    public void disconnect() throws LDAPException;
+
+    /** 
+     * Notifies the server to not send additional results associated with this
+     * <CODE>LDAPSearchResults</CODE> object, and discards any results already 
+     * received.
+     * @param results LDAPSearchResults object returned from a search
+     * @exception LDAPException Failed to notify the server.
+     */
+    public void abandon(LDAPSearchResults results) throws LDAPException;
+
+    /**
+     * Authenticates user with the LDAP server.
+     * @param DN distinguished name to use for authentication
+     * @param passwd password for authentication
+     * @exception LDAPException Failed to authenticate to the server.
+     */
+    public void authenticate (String DN, String passwd) throws LDAPException;
+
+    /**
+     * Authenticates user with the LDAP server.
+     * @param DN distinguished name to use for authentication
+     * @param passwd password for authentication
+     * @exception LDAPException Failed to authenticate to the server.
+     */
+    public void bind (String DN, String passwd) throws LDAPException;
+
+    /**
+     * Read the entry corresponding to the specified distinguished name (DN).
+     * @param DN distinguished name of the entry to retrieve
+     * @exception LDAPException Failed to retrieve the specified entry.
+     */
+    public LDAPEntry read (String DN) throws LDAPException;
+
+    /**
+     * Read the entry corresponding to the specified distinguished name (DN),
+     * and retrieve only the specified attributes.
+     * @param DN distinguished name of the entry to retrieve
+     * @param attrs names of attributes to retrieve
+     * @exception LDAPException Failed to retrieve the specified entry.
+     */
+    public LDAPEntry read (String DN, String attrs[]) throws LDAPException;
+
+    /**
+     * Read the entry corresponding to the specified distinguished name (DN),
+     * and retrieve only the specified attributes.
+     * @param DN distinguished name of the entry to retrieve
+     * @param attrs names of attributes to retrieve
+     * @param cons the constraints set for the read operation
+     * @exception LDAPException Failed to retrieve the specified entry.
+     */
+    public LDAPEntry read (String DN, String attrs[], LDAPSearchConstraints cons)
+      throws LDAPException;
+
+    /**
+     * Searches for entries in the directory.
+     * @param base starting point for the search in the directory
+     *   (distinguished name)
+     * @param scope indicates whether the scope of the search includes
+     *   only the base DN (equivalent to a read operation), only the entries
+     *   one level below the base DN, or all entries at all levels beneath
+     *   the base DN (including the base DN itself)
+     * @param filter String which describes the search criteria. The format
+     *   of the string is described fully in
+     *   <A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc1558.html" TARGET="_blank">RFC 1558</A>.
+     * @param attrs names of the attributes to return for each matching
+     *   directory entry.  If <CODE>null</CODE>, all attributes are returned.
+     * @param attrsOnly if <CODE>true</CODE>, the search will return only the names of
+     *   the attributes (and not their values)
+     * @exception LDAPException Failed to complete the requested search.
+     */
+    public LDAPSearchResults search (String base, int scope, String filter,
+      String[] attrs, boolean attrsOnly) throws LDAPException;
+
+    /**
+     * Searches for entries in the directory.
+     * @param base starting point for the search in the directory
+     *   (distinguished name)
+     * @param scope indicates whether the scope of the search includes
+     *   only the base DN (equivalent to a read operation), only the entries
+     *   one level below the base DN, or all entries at all levels beneath
+     *   the base DN (including the base DN itself)
+     * @param filter String which describes the search criteria. The format
+     *   of the string is described fully in
+     *   <A HREF="http://www.cis.ohio-state.edu/htbin/rfc/rfc1558.html" TARGET="_blank">RFC 1558</A>.
+     * @param attrs names of the attributes to return for each matching
+     *   directory entry.  If <CODE>null</CODE>, all attributes are returned.
+     * @param attrsOnly if <CODE>true</CODE>, the search will return only the names of
+     *   the attributes (and not their values)
+     * @param cons constraints specific to the search (for example, the maximum number
+     *   of entries to return or the maximum time to wait for the search operation to complete)
+     * @exception LDAPException Failed to complete the requested search.
+     */
+    public LDAPSearchResults search (String base, int scope, String filter,
+      String[] attrs, boolean attrsOnly, LDAPSearchConstraints cons)
+      throws LDAPException;
+
+    /**
+     * Compares the given entry's attribute value to the specified
+     * attribute value.
+     * @param DN distinguished name of the entry that you want compared
+     * against the specified attribute value
+     * @param attr attribute name and value to use in the comparison
+     * @exception LDAPException Failed to perform the comparison.
+     */
+    public boolean compare (String DN, LDAPAttribute attr) throws LDAPException;
+
+    /**
+     * Compares the given entry's attribute value to the specified
+     * attribute value.
+     * @param DN distinguished name of the entry that you want compared
+     * against the specified attribute value
+     * @param attr attribute name and value to use in the comparison
+     * @param cons the constraints set for the compare operation
+     * @exception LDAPException Failed to perform the comparison.
+     */
+    public boolean compare (String DN, LDAPAttribute attr,
+      LDAPConstraints cons) throws LDAPException;
+
+    /**
+     * Adds an entry to the directory.
+     * @param entry new entry to add to the directory
+     * @exception LDAPException Failed to add the entry to the directory.
+     */
+    public void add (LDAPEntry entry) throws LDAPException;
+
+    /**
+     * Adds an entry to the directory.
+     * @param entry new entry to add to the directory
+     * @param cons the constraints set for the add operation
+     * @exception LDAPException Failed to add the entry to the directory.
+     */
+    public void add (LDAPEntry entry, LDAPConstraints cons)
+      throws LDAPException;
+
+    /**
+     * Modifies an attribute of a directory entry.
+     * @param DN distinguished name identifying the entry to modify
+     * @param mod the modification to make
+     * @exception LDAPException Failed to modify the specified entry.
+     */
+    public void modify (String DN, LDAPModification mod) throws LDAPException;
+
+    /**
+     * Modifies an attribute of a directory entry.
+     * @param DN distinguished name identifying the entry to modify
+     * @param mod the modification to make
+     * @param cons the constraints set for the modify operation
+     * @exception LDAPException Failed to modify the specified entry.
+     */
+    public void modify (String DN, LDAPModification mod,
+      LDAPConstraints cons) throws LDAPException;
+
+    /**
+     * Modifies the attributes of a directory entry.
+     * @param DN distinguished name identifying the entry to modify
+     * @param mods list of the modifications to make
+     * @exception LDAPException Failed to modify the specified entry.
+     */
+    public void modify (String DN, LDAPModificationSet mods ) throws LDAPException;
+
+    /**
+     * Modifies the attributes of a directory entry.
+     * @param DN distinguished name identifying the entry to modify
+     * @param mods list of the modifications to make
+     * @param cons the constraints set for the modify operation
+     * @exception LDAPException Failed to modify the specified entry.
+     */
+    public void modify (String DN, LDAPModificationSet mods,
+      LDAPConstraints cons ) throws LDAPException;
+
+    /**
+     * Removes an entry from the directory.
+     * @param DN distinguished name identifying the entry to remove
+     * @exception LDAPException Failed to remove the entry from the directory.
+     */
+    public void delete( String DN ) throws LDAPException;
+
+    /**
+     * Removes an entry from the directory.
+     * @param DN distinguished name identifying the entry to remove
+     * @param cons the constraints set for the delete operation
+     * @exception LDAPException Failed to remove the entry from the directory.
+     */
+    public void delete( String DN, LDAPConstraints cons )
+      throws LDAPException;
+
+    /**
+     * Changes the name of an entry in the directory.
+     * @param DN distinguished name (DN) of entry
+     * @param newRDN the new relative distinguished name (RDN) of the entry
+     * @param deleteOldRDN <CODE>true</CODE> if the original RDN should no longer
+     * be an attribute of the entry; <CODE>false</CODE> if it should
+     * @exception LDAPException Failed to rename the entry in the directory.
+     */
+    public void rename ( String DN, String newRDN, boolean deleteOldRDN )
+        throws LDAPException;
+
+    /**
+     * Changes the name of an entry in the directory.
+     * @param DN distinguished name (DN) of entry
+     * @param newRDN new relative distinguished name (RDN) of the entry
+     * @param deleteOldRDN specifies whether or not the original RDN remains
+     * as an attribute of the entry. If <CODE>true</CODE>, the original RDN
+     * is no longer an attribute of the entry.
+     * @param cons the constraints set for the rename operation
+     * @exception LDAPException Failed to rename the entry in the directory.
+     */
+    public void rename ( String DN, String newRDN, boolean deleteOldRDN,
+      LDAPConstraints cons ) throws LDAPException;
+
+    /**
+     * Retrieves an option that applies to the connection.
+     * The particular meaning may be implementation-dependent.
+     * The standard options are the options described by
+     * the <CODE>LDAPSearchConstraints</CODE> and <CODE>LDAPConstraints</CODE>
+     * classes.
+     * @exception LDAPException Failed to retrieve the value of the specified option.
+     */
+    public Object getOption( int option ) throws LDAPException;
+
+    /**
+     * Sets an option that applies to the connection.
+     * The particular meaning may be implementation-dependent.
+     * The standard options are the options described by
+     * the <CODE>LDAPSearchConstraints</CODE> and <CODE>LDAPConstraints</CODE>
+     * classes.
+     * @exception LDAPException Failed to set the specified option.
+     */
+    public void setOption( int option, Object value ) throws LDAPException;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPTLSSocketFactory.java
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2002
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * A socket factory interface for supporting the start TLS LDAPv3
+ * extension (RFC 2830).
+ * <P>
+ *
+ * @version 1.0
+ * @since LDAPJDK 4.17
+ */
+public interface LDAPTLSSocketFactory extends LDAPSocketFactory {
+    /**
+     * Creates an SSL socket layered over an existing socket.
+     * 
+     * Used for the start TLS operations (RFC2830).
+     *
+     * @param s An existing non-SSL socket
+     * @return A SSL socket layered over the input socket
+     * @exception LDAPException on error creating socket
+     * @see LDAPConnection#startTLS
+     */
+    public Socket makeSocket(Socket s) throws LDAPException;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPResourceBundle.java
@@ -0,0 +1,137 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class represents a locale-specific resource for a property file.
+ * It retrieves the property file for the given base name including the
+ * absolute path name and locale. The property file has to be located in the
+ * CLASSPATH and the property file's suffix is .props.
+ * <p>
+ * If the specified locale is en and us and the base name of the file is
+ * netscape/ldap/errors/ErrorCodes, then the class loader will search for
+ * the file in the following order:
+ * <pre>
+ *
+ *   ErrorCodes_en_us.props
+ *   ErrorCodes_en.props
+ *   ErrorCodes.props
+ *
+ * </pre>
+ * @see java.util.Locale
+ */
+class LDAPResourceBundle implements java.io.Serializable {
+
+    static final long serialVersionUID = -5903986665461157980L;
+    private static final boolean m_debug = false;
+    private static final String m_suffix = ".props";
+    private static final String m_locale_separator = "_";
+
+    /**
+     * Return the property resource bundle according to the base name of the
+     * property file and the locale. The class loader will find the closest match
+     * with the given locale.
+     * @return the property resource bundle.
+     * @exception IOException Gets thrown when failed to open the resource
+     *            bundle file.
+     */
+    static PropertyResourceBundle getBundle(String baseName)
+      throws IOException {
+
+        return getBundle(baseName, Locale.getDefault());
+    }
+
+    /**
+     * Return the property resource bundle according to the base name of the
+     * property file and the locale. The class loader will find the closest match
+     * with the given locale.
+     * @param baseName the base name of the property file. The base name contains
+     * no locale context and no . suffix.
+     * @param l the locale
+     * @return the property resource bundle.
+     * @exception IOException Gets thrown when failed to create a property
+     *            resource
+     */
+    static PropertyResourceBundle getBundle(String baseName, Locale l)
+      throws IOException {
+        String localeStr = m_locale_separator+l.toString();
+
+        InputStream fin = null;
+
+        while (true) {
+            if ((fin=getStream(baseName, localeStr)) != null) {
+                PropertyResourceBundle p = new PropertyResourceBundle(fin);
+                return p;
+            } else {
+
+                int index = localeStr.lastIndexOf(m_locale_separator);
+                if (index == -1) {
+                    printDebug("File "+baseName+localeStr+m_suffix+" not found");
+                    return null;
+                } else
+                    localeStr = localeStr.substring(0, index);
+            }
+        }
+    }
+
+    /**
+     * Constructs the whole absolute path name of a property file and retrieves
+     * an input stream on the file.
+     * @param baseName the base name of the property file. The base name contains
+     * no locale context and no . suffix.
+     * @param the locale string to insert into the file name
+     * @return the input stream of the property file.
+     */
+    private static InputStream getStream(String baseName, String locale) {
+        String fStr = baseName+locale+m_suffix;
+        return (ClassLoader.getSystemResourceAsStream(fStr));
+    }
+
+    /**
+     * Prints debug messages if the debug mode is on.
+     * @param str the message that is printed
+     */
+    private static void printDebug(String str) {
+        if (m_debug)
+            System.out.println(str);
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPInterruptedException.java
@@ -0,0 +1,75 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * An exception thrown when the LDAP operation being invoked has
+ * been interrupted. For example, an application might interrupt a thread that
+ * is performing a search.
+ *
+ * @version 1.0
+ */
+public class LDAPInterruptedException extends LDAPException {
+
+    static final long serialVersionUID = 5267455101797397456L;
+
+    /**
+     * Constructs a default exception with a specified string of
+     * additional information. This string appears if you call
+     * the <CODE>toString()</CODE> method.
+     * <P>
+     *
+     * @param message the additional information
+     * @see netscape.ldap.LDAPInterruptedException#toString()
+     */
+    LDAPInterruptedException( String message ) {
+        super( message, LDAPException.OTHER, null);
+    }
+
+    /**
+     * Gets the string representation of the exception.
+     */
+    public String toString() {
+        String str = "netscape.ldap.LDAPInterruptedException: ";
+        String msg = super.getMessage();
+        if (msg != null) {
+            str +=msg;
+        }            
+        return str;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPRebind.java
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * Specifies how to retrieve authentication information automatically
+ * for referrals. If you have set up the search constraints (or the options
+ * in the <CODE>LDAPConnection</CODE> object) to use automatic referral,
+ * you must define a class that implements this interface.
+ * <P>
+ *
+ * If no class implements this interface, clients that follow automatic
+ * referrals are authenticated anonymously to subsequent LDAP servers.
+ * The following example is a simple class that implements this interface.
+ * Objects of the myLDAPRebind class check the host and port of the 
+ * referred LDAP server.  If the host and port are "alway.mcom.com:389", 
+ * the directory manager's name and password are used to authenticate.
+ * For all other LDAP servers, anonymous authentication is used.
+ *
+ * <PRE>
+ * public class myLDAPRebind implements netscape.ldap.LDAPRebind
+ * {
+ *  private String myDN;
+ *  private String myPW;
+ *  private LDAPRebindAuth myRebindInfo;
+
+ *  public myLDAPRebind () {
+ *    myDN = "c=Directory Manager,o=Universal Exports,c=UK";
+ *    myPW = "alway4444";
+ *  }
+ *
+ *  public LDAPRebindAuth getRebindAuthentication( String host, int port ) {
+ *    if ( host.equalsIgnoreCase( "alway.mcom.com" ) && ( port == 389 ) ) {
+ *      myRebindInfo = new LDAPRebindAuth( myDN, myPW );
+ *    } else {
+ *      myRebindInfo = new LDAPRebindAuth( "", "" );
+ *    }
+ *    return myRebindInfo;
+ *  }
+ * } </PRE>
+ *
+ *
+ * @version 1.0
+ */
+public interface LDAPRebind {
+
+    /**
+     * Returns an <CODE>LDAPRebindAuth</CODE> object, which the calling function
+     * can use to get the DN and password to use for authentication (if the client
+     * is set up to follow referrals automatically).
+     * @return LDAPRebindAuth object containing authentication information.
+     * @see netscape.ldap.LDAPRebindAuth
+     */
+    public LDAPRebindAuth getRebindAuthentication(String host,
+      int port);
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPConnSetupMgr.java
@@ -0,0 +1,627 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * Makes a connection to a server from a list using "smart" failover.
+ * Connection attempts can be made serially from the same thread, or
+ * in parallel by creating a separate thread after the specified delay.
+ * Connection setup status is preserved for later attempts, so that servers
+ * that are more likely to be available will be tried first.
+ * <P>
+ * The total time spent opening a connection can be limited with the
+ * <CODE>ConnectTimeout</CODE> property.
+ * <P>
+ * When a connection is successfully created, a socket is opened. The socket 
+ * is passed to the LDAPConnThread. The LDAPConnThread must call
+ * invalidateConnection() if the connection is lost due to a network or 
+ * server error, or closeConnection() if the connection is deliberately terminated
+ * by the user.
+ */
+class LDAPConnSetupMgr implements java.io.Serializable {
+
+    static final long serialVersionUID = 1519402748245755307L;
+    /**
+     * Policy for opening a connection when multiple servers are used
+     */
+    private static final int SERIAL = 0;
+    private static final int PARALLEL   = 1;
+    
+    /**
+     * ServerEntry.connSetupStatus possible value. The values also represent
+     * the likelihood that the connection will be setup to a server. Lower
+     * values have higher priority. See sortDsList() method
+     */
+    private static final int CONNECTED    = 0;  
+    private static final int DISCONNECTED = 1;
+    private static final int NEVER_USED   = 2;
+    private static final int INTERRUPTED  = 3;
+    private static final int FAILED       = 4;
+    
+    /**
+     * Representation for a server in the server list.
+     */
+    class ServerEntry {
+        LDAPUrl url;
+        int    connSetupStatus;
+        Thread connSetupThread;
+
+        ServerEntry(LDAPUrl url, int status) {
+            this.url = url;
+            connSetupStatus = status;
+            connSetupThread = null;
+        }    
+        public String toString() {
+            return "{" + url + " status="+connSetupStatus+"}";
+        }
+    }
+    
+
+    /**
+     * Socket to the connected server
+     */
+    private Socket m_socket = null;
+    
+    /**
+     * Original, underlying socket to the server, see layerSocket()
+     */
+    private Socket m_origSocket = null;
+    
+
+    /**
+     * Last exception occured during connection setup
+     */
+    private LDAPException m_connException = null;
+
+    /**
+     * List of server to use for the connection setup
+     */
+    ServerEntry[] m_dsList;
+    
+    /**
+     * Index of the last connected server
+     */    
+    private int m_dsIdx = -1;
+
+    /**
+     * Socket factory for SSL connections
+     */
+    LDAPSocketFactory m_factory;
+    
+    /**
+     * Connection setup policy (PARALLEL or SERIAL)
+     */
+    int m_policy = SERIAL;
+    
+    /**
+     * Delay in ms before another connection setup thread is started.    
+     */
+    int m_connSetupDelay = -1;
+
+    /**
+     * The maximum time to wait to established the connection
+     */
+    int m_connectTimeout = 0;
+
+    /**
+     *  During connection setup, the current count of servers to which
+     *  connection attmpt has been made 
+     */
+    private transient int m_attemptCnt = 0;
+
+    /**
+     * Constructor
+     * @param host list of host names to which to connect
+     * @param port list of port numbers corresponding to the host list
+     * @param factory socket factory for SSL connections     
+     */
+    LDAPConnSetupMgr(String[] hosts, int[] ports, LDAPSocketFactory factory)  throws LDAPException{
+        m_dsList = new ServerEntry[hosts.length];
+        boolean secure = (factory != null);
+        for (int i=0; i < hosts.length; i++) {
+            String url = secure ? "ldaps://" : "ldap://";            
+            url += hosts[i] + ":" + ports[i];
+            try { 
+                m_dsList[i] = new ServerEntry(new LDAPUrl(url), NEVER_USED);
+            }
+            catch (MalformedURLException ex) {
+                throw new LDAPException("Invalid host:port " + hosts[i]+":"+ports[i],
+                                         LDAPException.PARAM_ERROR);                
+            }
+        }
+        m_factory = factory;
+    }
+
+    LDAPConnSetupMgr(String[] urls, LDAPSocketFactory factory) throws LDAPException{
+        m_dsList = new ServerEntry[urls.length];
+        for (int i=0; i < urls.length; i++) {
+            try {
+                LDAPUrl url = new LDAPUrl(urls[i]);
+                m_dsList[i] = new ServerEntry(url, NEVER_USED);
+            }
+            catch (MalformedURLException ex) {
+                throw new LDAPException("Malformed LDAP URL " + urls[i],
+                                         LDAPException.PARAM_ERROR);
+            }
+        }
+        m_factory = factory;
+    }
+
+    LDAPConnSetupMgr(LDAPUrl[] urls, LDAPSocketFactory factory) throws LDAPException{
+        m_dsList = new ServerEntry[urls.length];
+        for (int i=0; i < urls.length; i++) {
+            m_dsList[i] = new ServerEntry(urls[i], NEVER_USED);
+        }
+        m_factory = factory;
+    }
+
+    /**
+     * Try to open the connection to any of the servers in the list, limiting
+     * the time waiting for the connection to be established
+     * @return connection socket
+    */
+    synchronized Socket openConnection() throws LDAPException{
+        
+        long tcur=0, tmax = Long.MAX_VALUE;
+        Thread th = null; 
+        
+        reset();
+        
+       // If reconnecting, sort dsList so that servers more likly to
+        // be available are tried first
+        sortDsList();
+    
+        if (m_connectTimeout == 0) {
+            // No need for a separate thread, connect time not limited
+            connect();
+        }
+        else {
+        
+            // Wait for connection at most m_connectTimeout milliseconds
+            // Run connection setup in a separate thread to monitor the time
+            tmax = System.currentTimeMillis() + m_connectTimeout;
+            th = new Thread (new Runnable() {
+                public void run() {
+                    connect();
+                }
+            }, "ConnSetupMgr");
+            th.setDaemon(true);
+            th.start();
+        
+            while  (m_socket==null && (m_attemptCnt < m_dsList.length) &&
+                   (tcur = System.currentTimeMillis()) < tmax) {
+                try {
+                    wait(tmax - tcur);
+                }
+                catch (InterruptedException e) {
+                    th.interrupt();
+                    cleanup();
+                    throw new LDAPInterruptedException("Interrupted connect operation");
+                }
+            }
+        }
+
+        if (m_socket != null) {
+            return m_socket;
+        }
+
+        if  ( th != null && (tcur = System.currentTimeMillis()) >= tmax) {
+            // We have timed out 
+            th.interrupt();
+            cleanup();
+            throw new LDAPException(
+                "Connect timeout, " + getServerList() + " might be unreachable",
+                LDAPException.CONNECT_ERROR);
+        }
+
+        if (m_connException != null && m_dsList.length == 1) {
+            throw m_connException;
+        }
+
+        throw new LDAPException(
+            "Failed to connect to server " + getServerList(),
+            LDAPException.CONNECT_ERROR);
+    }
+
+    private void reset() {
+        m_socket = null;
+        m_origSocket = null;
+        m_connException = null;
+        m_attemptCnt = 0;
+                
+        for (int i=0; i < m_dsList.length; i++) {
+            m_dsList[i].connSetupThread = null;
+        }        
+    }
+    
+    private String getServerList() {
+        StringBuffer sb = new StringBuffer();
+        for (int i=0; i < m_dsList.length; i++) {
+            sb.append(i==0 ? "" : " ");
+            sb.append(m_dsList[i].url.getHost());
+            sb.append(":");
+            sb.append(m_dsList[i].url.getPort());
+        }
+        return sb.toString();
+   }
+
+    private void connect() {
+    
+        if (m_policy == SERIAL || m_dsList.length == 1) {
+            openSerial();
+        }
+        else {
+            openParallel();
+        }    
+    }
+
+    /**
+     * Called when the current connection is lost.
+     * Put the connected server at the end of the server list for
+     * the next connect attempt.    
+     */
+    synchronized void invalidateConnection() {
+        if (m_socket != null) {
+            m_dsList[m_dsIdx].connSetupStatus = FAILED;
+        
+            // Move the entry to the end of the list
+            int srvCnt = m_dsList.length, j=0;        
+            ServerEntry[] newDsList = new ServerEntry[m_dsList.length];
+            for (int i=0; i < srvCnt; i++) {
+                if (i != m_dsIdx) {
+                    newDsList[j++] = m_dsList[i];
+                }
+            }
+            newDsList[j] = m_dsList[m_dsIdx];
+            m_dsList = newDsList;
+            m_dsIdx = j;
+            
+            try {
+                m_socket.close();
+            } catch (Exception e) {
+            } finally {
+                m_socket = null;
+            }
+            
+        }
+
+        if (m_origSocket != null) {
+
+            try {
+                m_origSocket.close();
+            } catch (Exception e) {
+            } finally {
+                m_origSocket = null;
+            }
+        }        
+    }
+    
+    /**
+     * Called when the current connection is terminated by the user.
+     * Mark the connected server status as DISCONNECTED. This will
+     * put it at top of the server list for the next connect attempt.
+     */
+    void closeConnection() {
+        if (m_socket != null) {
+
+            m_dsList[m_dsIdx].connSetupStatus =  DISCONNECTED;
+            
+            try {
+                m_socket.close();
+            } catch (Exception e) {
+            } finally {
+                m_socket = null;
+            }
+        }
+
+        if (m_origSocket != null) {
+
+            try {
+                m_origSocket.close();
+            } catch (Exception e) {
+            } finally {
+                m_origSocket = null;
+            }
+        }
+    }
+
+    Socket getSocket() {
+        return m_socket;
+    }
+
+    /**
+     * Layer a new socket over the existing one (used by startTLS)
+     */
+    void layerSocket(LDAPTLSSocketFactory factory) throws LDAPException{
+        Socket s = factory.makeSocket(m_socket);
+        m_origSocket = m_socket;
+        m_socket = s;
+    }
+    
+    String getHost() {
+        if (m_dsIdx >= 0) {
+            return m_dsList[m_dsIdx].url.getHost();
+        }
+        return m_dsList[0].url.getHost();
+    }
+    
+    int getPort() {
+        if (m_dsIdx >= 0) {
+            return m_dsList[m_dsIdx].url.getPort();
+        }
+        return m_dsList[0].url.getPort();
+    }
+
+    boolean isSecure() {
+        if (m_dsIdx >= 0) {
+            return m_dsList[m_dsIdx].url.isSecure();
+        }
+        return m_dsList[0].url.isSecure();
+    }
+
+    LDAPUrl getLDAPUrl() {
+        if (m_dsIdx >= 0) {
+            return m_dsList[m_dsIdx].url;
+        }
+        return m_dsList[0].url;
+    }
+
+    int  getConnSetupDelay() {
+        return m_connSetupDelay/1000;
+    }
+    
+    /**
+     * Selects the connection failover policy
+     * @param delay in seconds for the parallel connection setup policy.
+     * Possible values are: <br>(delay=-1) use serial policy,<br>
+     * (delay=0) start immediately concurrent threads to each specified server
+     * <br>(delay>0) create a new connection setup thread after delay seconds
+     */
+    void setConnSetupDelay(int delay) {
+        m_policy = (delay < 0) ? SERIAL : PARALLEL;        
+        m_connSetupDelay = delay*1000;
+        
+    }
+    
+    int getConnectTimeout() {
+        return m_connectTimeout/1000;
+    }
+
+    /**
+     * Sets the maximum time to spend in the openConnection() call
+     * @param timeout in seconds to wait for the connection to be established
+     */
+    void setConnectTimeout(int timeout) {
+        m_connectTimeout = timeout*1000;
+    }
+    
+    /**
+     * Check if the user has voluntarily closed the connection
+     */
+    boolean isUserDisconnected() {
+        return (m_dsIdx >=0 &&
+                m_dsList[m_dsIdx].connSetupStatus == DISCONNECTED);
+    }
+    
+    /**
+     * Try  sequentially to open a new connection to a server. 
+     */
+    private void openSerial() {
+        for (int i=0; i < m_dsList.length; i++) {
+            m_dsList[i].connSetupThread = Thread.currentThread();
+            connectServer(i);
+            if (m_socket != null) {
+                return;
+            }    
+        }        
+    }
+    
+    /**
+     * Try concurrently to open a new connection a server. Create a separate
+     * thread for each connection attempt.
+     */
+    private synchronized void openParallel() {
+        for (int i=0; m_socket==null && i < m_dsList.length; i++) {
+        
+            //Create a Thread to execute connectSetver()
+            final int dsIdx = i;
+            String threadName = "ConnSetupMgr " + m_dsList[dsIdx].url;
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    connectServer(dsIdx);
+                }
+            }, threadName);
+
+            m_dsList[dsIdx].connSetupThread = t;
+            t.setDaemon(true);
+            t.start();
+        
+            // Wait before starting another thread if the delay is not zero
+            if (m_connSetupDelay != 0 && i < (m_dsList.length-1)) {
+                try {
+                    wait(m_connSetupDelay);
+                }
+                catch (InterruptedException e) {
+                    return;
+                }
+            }
+        }    
+
+        // At this point all threads are started. Wait until first thread
+        // succeeds to connect or all threads terminate
+    
+        while (m_socket == null && (m_attemptCnt < m_dsList.length)) {
+        
+            // Wait for a thread to terminate
+            try {
+                wait();
+            }
+            catch (InterruptedException e) {}
+        }
+    }
+
+    /**
+     * Connect to the server at the given index
+     */    
+    void connectServer(int idx) {
+        ServerEntry entry = m_dsList[idx];
+        Thread currThread = Thread.currentThread();
+        Socket sock = null;
+        LDAPException conex = null;
+
+        try {
+            /* If we are to create a socket ourselves, make sure it has
+               sufficient privileges to connect to the desired host */
+            if (!entry.url.isSecure()) {
+                sock = new Socket (entry.url.getHost(), entry.url.getPort());
+            } else {
+                LDAPSocketFactory factory = m_factory;
+                if (factory == null) {
+                    factory = entry.url.getSocketFactory();
+                }
+                if (factory == null) {
+                    throw new LDAPException("Can not connect, no socket factory " + entry.url,
+                                            LDAPException.OTHER);
+                }
+                sock = factory.makeSocket(entry.url.getHost(), entry.url.getPort());
+            }
+
+            sock.setTcpNoDelay( true );
+        }
+        catch (IOException e) {    
+            conex = new LDAPException("failed to connect to server " 
+            + entry.url, LDAPException.CONNECT_ERROR);
+        }
+        catch (LDAPException e) {    
+            conex = e;
+        }
+    
+        if (currThread.isInterrupted()) {
+            return;
+        }
+        
+        synchronized (this) {
+            if (m_socket == null && entry.connSetupThread == currThread) {
+                entry.connSetupThread = null;
+                if (sock != null) {
+                    entry.connSetupStatus = CONNECTED;
+                    m_socket = sock;
+                    m_dsIdx = idx;
+                    cleanup(); // Signal other concurrent threads to terminate
+                }
+                else {
+                    entry.connSetupStatus = FAILED;
+                    m_connException = conex;
+                }
+                m_attemptCnt++;
+                notifyAll();
+            }    
+        }
+    }    
+
+    /**
+     * Terminate all concurrently running connection setup threads
+     */
+    private synchronized void cleanup() {
+        Thread currThread = Thread.currentThread();
+        for (int i=0; i < m_dsList.length; i++) {
+            ServerEntry entry = m_dsList[i];
+            if (entry.connSetupThread != null && entry.connSetupThread != currThread) {
+            
+                entry.connSetupStatus = INTERRUPTED;
+                //Thread.stop() is considered to be dangerous, use Thread.interrupt().
+                //interrupt() will however not work if the thread is blocked in the
+                //socket library native connect() call, but the connect() will
+                //eventually timeout and the thread will die.
+                entry.connSetupThread.interrupt();
+                
+                entry.connSetupThread = null;                
+            }
+        }
+    }    
+
+
+    /**
+     * Sorts Server List so that servers which are more likely to be available
+     * are tried first. The likelihood of making a successful connection
+     * is determined by the connSetupStatus. Lower values have higher
+     * likelihood. Thus, the order of server access is (1) disconnected by
+     * the user (2) never used (3) interrupted connection attempt
+    *  (4) connection setup failed/connection lost
+     */
+    private void sortDsList() {
+        int srvCnt = m_dsList.length;
+        for (int i=1; i < srvCnt; i++) {
+            for (int j=0; j < i; j++) {
+                if (m_dsList[i].connSetupStatus < m_dsList[j].connSetupStatus) {
+                    // swap entries
+                    ServerEntry entry = m_dsList[j];
+                    m_dsList[j] = m_dsList[i];
+                    m_dsList[i] = entry;
+                }
+            }
+        }
+    }    
+
+    /**
+     * This is used only by the ldapjdk test libaray to simulate a
+     *  server problem and to test fail-over and rebind
+     * @return A flag whether the connection was closed
+     */
+    boolean breakConnection() {
+        try {                
+            m_socket.close();
+            return true;
+        }
+        catch (Exception e) {
+            return false;
+        }
+    }            
+
+    public String toString() {
+        String str = "dsIdx="+m_dsIdx+ " dsList=";
+        for (int i=0; i < m_dsList.length; i++) {
+            str += m_dsList[i]+ " ";
+        }
+        return str;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPMatchingRuleUseSchema.java
@@ -0,0 +1,235 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * The definition of a matching rule use in the schema.
+ * <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+ * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+ * Attribute Syntax Definitions</A> covers the types of information
+ * that need to be specified in the definition of a matching rule use.
+ * According to the RFC, the description of a matching rule use can
+ * include the following information:
+ * <P>
+ *
+ * <UL>
+ * <LI>an OID identifying the matching rule
+ * <LI>a name identifying the matching rule use
+ * <LI>a description of the matching rule use
+ * <LI>a list of attributes the matching rule applies to
+ * </UL>
+ * <P>
+ *
+ * When you construct an <CODE>LDAPMatchingRuleUseSchema</CODE> object, you can
+ * specify these types of information as arguments to the constructor or
+ * in the MatchingRuleUseDescription format specified in RFC 2252.
+ * When an LDAP client searches an LDAP server for the schema, the server
+ * returns schema information as an object with values in this
+ * format.
+ * <P>
+ *
+ * You can get the name, OID, and description of this matching rule use
+ * definition by using the <CODE>getName</CODE>, <CODE>getOID</CODE>, and
+ * <CODE>getDescription</CODE> methods inherited from the abstract class
+ * <CODE>LDAPSchemaElement</CODE>. Custom qualifiers are
+ * accessed with <CODE>getQualifier</CODE> and <CODE>getQualifierNames</CODE>
+ * from <CODE>LDAPSchemaElement</CODE>.
+  * <P>
+ *
+ * To add or remove this matching rule definition from the
+ * schema, use the <CODE>add</CODE> and <CODE>remove</CODE>
+ * methods, which this class inherits from the <CODE>LDAPSchemaElement</CODE>
+ * abstract class.
+ * <P>
+ * RFC 2252 defines MatchingRuleUseDescription follows:
+ * <P>
+ * <PRE>
+ * Values of the matchingRuleUse list the attributes which are suitable
+ * for use with an extensible matching rule.
+ *
+ *    MatchingRuleUseDescription = "(" whsp
+ *        numericoid whsp  ; MatchingRule identifier
+ *        [ "NAME" qdescrs ]
+ *        [ "DESC" qdstring ]
+ *        [ "OBSOLETE" ]
+ *       "APPLIES" oids    ; AttributeType identifiers
+ *    whsp ")"
+ * </PRE>
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPSchemaElement
+ * @see netscape.ldap.LDAPMatchingRuleSchema
+ **/
+
+public class LDAPMatchingRuleUseSchema extends LDAPAttributeSchema {
+
+
+
+    /**
+     * Constructs a matching rule use definition, using the specified
+     * information.
+     * @param name name of the matching rule
+     * @param oid object identifier (OID) of the matching rule
+     * in dotted-decimal format (for example, "1.2.3.4")
+     * @param description description of the matching rule
+     * @param attributes array of the OIDs of the attributes for which
+     * the matching rule is applicable
+     */
+    public LDAPMatchingRuleUseSchema( String name, String oid,
+                                   String description,
+                                   String[] attributes ) {
+        if ( (oid == null) || (oid.trim().length() < 1) ) {
+            throw new IllegalArgumentException( "OID required" );
+        }
+        this.name = name;
+        this.oid = oid;
+        this.description = description;
+        attrName = "matchingruleuse";
+        this.attributes = new String[attributes.length];
+        for( int i = 0; i < attributes.length; i++ ) {
+            this.attributes[i] = attributes[i];
+        }
+    }
+
+    /**
+     * Constructs a matching rule use definition based on descriptions in
+     * the MatchingRuleUseDescription format. For information on this format,
+     * (see <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+     * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+     * Attribute Syntax Definitions</A>. This is the format that LDAP servers
+     * and clients use to exchange schema information. For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with attributes that include "matchingrule" and "matchingruleuse".
+     * The values of these attributes are matching rule descriptions
+     * in this format.
+     * <P>
+     *
+     * @param use definition of the use of the matching rule in the
+     * MatchingRuleUseDescription format
+     */
+    public LDAPMatchingRuleUseSchema( String use ) {
+        attrName = "matchingruleuse";
+        parseValue( use );
+	Object p = properties.get( "APPLIES" );
+	if ( p instanceof Vector ) {
+		Vector v = (Vector)p;
+		if ( v != null ) {
+			attributes = new String[v.size()];
+			v.copyInto( attributes );
+			v.removeAllElements();
+		}
+	}
+	else if ( p instanceof String ) {
+		attributes = new String[1];
+		attributes[0] = (String)p;
+        }
+    }
+
+    /**
+     * Gets the list of the OIDs of the attribute types which can be used
+     * with the matching rule.
+     * @return array of the OIDs of the attribute types which can be used
+     * with the matching rule.
+     */
+    public String[] getApplicableAttributes() {
+        return attributes;
+    }
+
+    /**
+     * Gets the matching rule use definition in the string representation
+     * of the MatchingRuleUseDescription data type defined in X.501 (see
+     * <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+     * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol
+     * (v3): Attribute Syntax Definitions</A>
+     * for a description of these formats).
+     * This is the format that LDAP servers and clients use to exchange
+     * schema information.  (For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the attributes "matchingrules" and "matchingruleuse".  The
+     * values of these attributes are matching rule description and
+     * matching rule use description in these formats.)
+     * <P>
+     *
+     * @return a string in a format that can be used as the value of
+     * the <CODE>matchingruleuse</CODE> attribute (which describes the use of
+     * a matching rule in the schema) of a <CODE>subschema</CODE> object
+     */
+    public String getValue() {
+        String s = getValuePrefix();
+        if ( (attributes != null) && (attributes.length > 0) ) {
+            s += "APPLIES ( ";
+            for( int i = 0; i < attributes.length; i++ ) {
+                if ( i > 0 )
+                    s += " $ ";
+                s += attributes[i];
+            }
+            s += " ) ";
+        }
+        s += ')';
+        return s;
+    }
+
+    /**
+     * Gets the definition of the matching rule use in a user friendly format.
+     * This is the format that the matching rule use definition uses when
+     * you print the matching rule or the schema.
+     * @return definition of the matching rule in a user friendly format.
+     */
+    public String toString() {
+        String s = "Name: " + name + "; OID: " + oid;
+        s += "; Description: " + description;
+        if ( attributes != null ) {
+            s += "; Applies to: ";
+            for( int i = 0; i < attributes.length; i++ ) {
+                if ( i > 0 )
+                    s += ", ";
+                s += attributes[i];
+            }
+        }
+        s += getQualifierString( EXPLICIT );
+        return s;
+    }
+
+    // Qualifiers tracked explicitly
+    static final String[] EXPLICIT = { OBSOLETE };
+    
+    private String[] attributes = null;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPConnection.java
@@ -0,0 +1,5443 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.client.opers.*;
+import netscape.ldap.ber.stream.*;
+import netscape.ldap.util.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * Represents a connection to an LDAP server. <P>
+ *
+ * Use objects of this class to perform LDAP operations (such as
+ * search, modify, and add) on an LDAP server. <P>
+ *
+ * To perform an LDAP operation on a server, you need to follow
+ * these steps: <P>
+ *
+ * <OL>
+ * <LI>Create a new <CODE>LDAPConnection</CODE> object.
+ * <LI>Use the <CODE>connect</CODE> method to connect to the
+ * LDAP server.
+ * <LI>Use the <CODE>authenticate</CODE> method to authenticate
+ * to server.
+ * <LI>Perform the LDAP operation.
+ * <LI>Use the <CODE>disconnect</CODE> method to disconnect from
+ * the server when done.
+ * </OL>
+ * <P>
+ *
+ * All operations block until completion (with the exception of
+ * the search method in which the results may not all return at
+ * the same time).
+ * <P>
+ *
+ * This class also specifies a default set of constraints
+ * (such as the maximum length of time to allow for an operation before timing out)
+ * which apply to all operations. To get and set these constraints,
+ * use the <CODE>getOption</CODE> and <CODE>setOption</CODE> methods.
+ * To override these constraints for an individual operation,
+ * define a new set of constraints by creating a <CODE>LDAPConstraints</CODE>
+ * object and pass the object to the method for the operation. For search 
+ * operations, additional constraints are defined in <CODE>LDAPSearchConstraints</CODE>
+ * (a subclass of <CODE>LDAPConstraints</CODE>). To override the default search
+ * constraints, create an <CODE>LDAPSearchConstraints</CODE> object and pass it
+ * to the <CODE>search</CODE> method.
+ * <P>
+ *
+ * If you set up your client to follow referrals automatically,
+ * an operation that results in a referral will create a new connection
+ * to the LDAP server identified in the referral.  In order to have
+ * your client authenticate to that LDAP server automatically, you need
+ * to define a class that implements the <CODE>LDAPRebind</CODE> interface.
+ * In your definition of the class, you need to define a
+ * <CODE>getRebindAuthentication</CODE> method that creates an <CODE>LDAPRebindAuth</CODE>
+ * object containing the distinguished name and password to use for reauthentication.
+ * <P>
+ *
+ * Most errors that occur raise the same exception (<CODE>LDAPException</CODE>).
+ * In order to determine the exact problem that occurred, you can retrieve the
+ * result code from this exception and compare its value against a set of defined
+ * result codes.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPConstraints
+ * @see netscape.ldap.LDAPSearchConstraints
+ * @see netscape.ldap.LDAPRebind
+ * @see netscape.ldap.LDAPRebindAuth
+ * @see netscape.ldap.LDAPException
+ */
+public class LDAPConnection
+       implements LDAPv3, LDAPAsynchronousConnection, Cloneable, Serializable {
+
+    static final long serialVersionUID = -8698420087475771145L;
+
+    /**
+     * Version of the LDAP protocol used by default.
+     * <CODE>LDAP_VERSION</CODE> is 2, so your client will
+     * attempt to authenticate to LDAP servers as an LDAP v2 client.
+     * The following is an example of some code that prints the
+     * value of this variable:
+     * <P>
+     *
+     * <PRE>
+     * LDAPConnection ld = new LDAPConnection();
+     * System.out.println( "The default LDAP protocol version used is "
+     *                      ld.LDAP_VERSION );
+     * </PRE>
+     *
+     * If you want to authenticate as an LDAP v3 client,
+     * use the <A HREF="#authenticate(int, java.lang.String, java.lang.String)"><CODE>authenticate(int version, String dn, String passwd)</CODE></A> method.
+     * For example:
+     * <P>
+     *
+     * <PRE>
+     * ld.authenticate( 3, myDN, myPW );
+     * </PRE>
+     *
+     * @see netscape.ldap.LDAPConnection#authenticate(int, java.lang.String, java.lang.String)
+     */
+    public final static int LDAP_VERSION              = 2;
+    /**
+     * Name of the property specifying the version of the SDK. <P>
+     *
+     * To get the version number, pass this name to the
+     * <CODE>getProperty</CODE> method.  The SDK version number
+     * is of the type <CODE>Float</CODE>. For example:<P>
+     * <PRE>
+     *      ...
+     *      Float sdkVersion = ( Float )myConn.getProperty( myConn.LDAP_PROPERTY_SDK );
+     *      System.out.println( "SDK version: " + sdkVersion );
+     *      ... </PRE>
+     * @see netscape.ldap.LDAPConnection#getProperty(java.lang.String)
+     */
+    public final static String LDAP_PROPERTY_SDK      = "version.sdk";
+    /**
+     * Name of the property specifying the highest supported version of
+     * the LDAP protocol. <P>
+     *
+     * To get the version number, pass this name to the
+     * <CODE>getProperty</CODE> method.  The LDAP protocol version number
+     * is of the type <CODE>Float</CODE>. For example:<P>
+     * <PRE>
+     *      ...
+     *      Float LDAPVersion = ( Float )myConn.getProperty( myConn.LDAP_PROPERTY_PROTOCOL );
+     *      System.out.println( "Highest supported LDAP protocol version: " + LDAPVersion );
+     *      ... </PRE>
+     * @see netscape.ldap.LDAPConnection#getProperty(java.lang.String)
+     */
+    public final static String LDAP_PROPERTY_PROTOCOL = "version.protocol";
+    /**
+     * Name of the property specifying the types of authentication allowed by this
+     * API (for example, anonymous authentication and simple authentication). <P>
+     *
+     * To get the supported types, pass this name to the
+     * <CODE>getProperty</CODE> method.  The value of this property is
+     * of the type <CODE>String</CODE>. For example:<P>
+     * <PRE>
+     *      ...
+     *      String authTypes = ( String )myConn.getProperty( myConn.LDAP_PROPERTY_SECURITY );
+     *      System.out.println( "Supported authentication types: " + authTypes );
+     *      ... </PRE>
+     * @see netscape.ldap.LDAPConnection#getProperty(java.lang.String)
+     */
+    public final static String LDAP_PROPERTY_SECURITY = "version.security";
+
+    /**
+     * Name of the property to enable/disable LDAP message trace. <P>
+     *
+     * The property can be specified either as a system property 
+     * (java -D command line option),  or programmatically with the
+     * <CODE>setProperty</CODE> method.
+     * <P>
+     * When -D command line option is used, defining the property with
+     * no value will send the trace output to the standard error. If the 
+     * value is defined, it is assumed to be the name of an output file.
+     * If the file name is prefixed with a '+' character, the file is
+     * opened in append mode.
+     * <P>
+     * When the property is set with the <CODE>getProperty</CODE> method,
+     * the property value must be either a String (represents a file name)
+     * an OutputStream or an instance of LDAPTraceWriter. To stop tracing,
+     * <CODE>null</CODE> should be  passed as the property value.
+     * 
+     * @see netscape.ldap.LDAPConnection#setProperty(java.lang.String, java.lang.Object)
+     */
+    public final static String TRACE_PROPERTY = "com.netscape.ldap.trace";
+
+    /**
+     * Specifies the serial connection setup policy when a list of hosts is
+     * passed to  the <CODE>connect</CODE> method.
+     * @see netscape.ldap.LDAPConnection#setConnSetupDelay(int)
+     */    
+    public final static int NODELAY_SERIAL = -1;
+    /**
+     * Specifies the parallel connection setup policy with no delay when a
+     * list of hosts is passed to the <CODE>connect</CODE> method.
+     * For each host in the list, a separate thread is created to attempt
+     * to connect to the host. All threads are started simultaneously.
+     * @see netscape.ldap.LDAPConnection#setConnSetupDelay(int)
+     */    
+    public final static int NODELAY_PARALLEL = 0;
+
+    /**
+     * Constants
+     */
+    private final static String defaultFilter = "(objectClass=*)";
+    /**
+     * Internal variables
+     */
+    private LDAPSearchConstraints m_defaultConstraints =
+        new LDAPSearchConstraints();
+    
+    // A clone of constraints for the successful bind. Used by 
+    // "smart failover" for the automatic rebind
+    private LDAPConstraints m_rebindConstraints;
+
+    private Vector m_responseListeners;
+    private Vector m_searchListeners;
+
+    private String m_boundDN;
+    private String m_boundPasswd;
+    private int m_protocolVersion = LDAP_VERSION;
+    
+    private LDAPConnSetupMgr m_connMgr;
+    private int m_connSetupDelay = -1;
+    private int m_connectTimeout = 0;
+    private LDAPSocketFactory m_factory;
+
+    // A flag if m_factory is used to start TLS
+    private boolean m_isTLSFactory;
+    
+    /* m_thread does all socket i/o for the object and any clones */
+    private transient LDAPConnThread m_thread = null;
+
+    /* To manage received server controls on a per-thread basis */
+    private Hashtable m_responseControlTable = new Hashtable();
+    private LDAPCache m_cache = null;
+
+    // A flag set if startTLS() called successfully
+    private boolean m_useTLS;
+
+    // OID for the extended operation startTLS
+    final static String OID_startTLS = "1.3.6.1.4.1.1466.20037"; 
+
+    private Object m_security = null;
+    private LDAPSaslBind m_saslBinder = null;
+    private Properties m_securityProperties;
+    private Hashtable m_properties = new Hashtable();
+    private LDAPConnection m_referralConnection;
+
+    /**
+     * Properties
+     */
+    private final static Float SdkVersion = new Float(4.18f);
+    private final static Float ProtocolVersion = new Float(3.0f);
+    private final static String SecurityVersion = new String("none,simple,sasl");
+    private final static Float MajorVersion = new Float(4.0f);
+    private final static Float MinorVersion = new Float(0.18f);
+    private final static String DELIM = "#";
+    private final static String PersistSearchPackageName =
+      "netscape.ldap.controls.LDAPPersistSearchControl";
+    final static String EXTERNAL_MECHANISM = "external";
+    private final static String EXTERNAL_MECHANISM_PACKAGE =
+      "com.netscape.sasl";
+    final static String DEFAULT_SASL_PACKAGE =
+      "com.netscape.sasl";
+    final static String SCHEMA_BUG_PROPERTY =
+      "com.netscape.ldap.schema.quoting";
+    final static String SASL_PACKAGE_PROPERTY =
+      "com.netscape.ldap.saslpackage";
+
+   /**
+    * Constructs a new <CODE>LDAPConnection</CODE> object,
+    * which represents a connection to an LDAP server. <P>
+    *
+    * Calling the constructor does not actually establish
+    * the connection.  To connect to the LDAP server, use the
+    * <CODE>connect</CODE> method.
+    *
+    * @see netscape.ldap.LDAPConnection#connect(java.lang.String, int)
+    * @see netscape.ldap.LDAPConnection#authenticate(java.lang.String, java.lang.String)
+    */
+    public LDAPConnection () {
+        super();
+        m_factory = null;
+
+        m_properties.put(LDAP_PROPERTY_SDK, SdkVersion); 
+        m_properties.put(LDAP_PROPERTY_PROTOCOL, ProtocolVersion); 
+        m_properties.put(LDAP_PROPERTY_SECURITY, SecurityVersion); 
+        m_properties.put("version.major", MajorVersion); 
+        m_properties.put("version.minor", MinorVersion);
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPConnection</CODE> object that
+     * will use the specified socket factory class to create
+     * socket connections. The socket factory class must implement
+     * the <CODE>LDAPSocketFactory</CODE> interface. <BR>
+     * (For example, the <CODE>LDAPSSLSocketFactory</CODE>
+     * class implements this interface.)
+     * <P>
+     *
+     * Note that calling the <CODE>LDAPConnection</CODE> constructor
+     * does not actually establish a connection to an LDAP server.
+     * To connect to an LDAP server, use the
+     * <CODE>connect</CODE> method.  The socket connection will be
+     * constructed when this method is called.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPSocketFactory
+     * @see netscape.ldap.LDAPSSLSocketFactory
+     * @see netscape.ldap.LDAPConnection#connect(java.lang.String, int)
+     * @see netscape.ldap.LDAPConnection#authenticate(java.lang.String, java.lang.String)
+     * @see netscape.ldap.LDAPConnection#getSocketFactory
+     * @see netscape.ldap.LDAPConnection#setSocketFactory(netscape.ldap.LDAPSocketFactory)
+     */
+    public LDAPConnection ( LDAPSocketFactory factory ) {
+        this();
+        m_factory = factory;
+    }
+
+    /**
+     * Finalize method, which disconnects from the LDAP server.
+     * @exception LDAPException Thrown when the connection cannot be disconnected.
+     */
+    public void finalize() throws LDAPException {
+        if (isConnected()) {
+            disconnect();
+        }
+    }
+
+    /**
+     *  Sets the specified <CODE>LDAPCache</CODE> object as the
+     *  cache for the <CODE>LDAPConnection</CODE> object.
+     *  <P>
+     *
+     *  @param cache the <CODE>LDAPCache</CODE> object representing
+     *  the cache that the current connection should use
+     *  @see netscape.ldap.LDAPCache
+     *  @see netscape.ldap.LDAPConnection#getCache
+     */
+    public void setCache(LDAPCache cache) {
+        if (m_cache != null) {
+            m_cache.removeReference();
+        }
+        if (cache != null) {
+            cache.addReference();
+        }
+        m_cache = cache;
+        if ( m_thread != null ) {
+            m_thread.setCache( cache );
+        }
+    }
+
+    /**
+     * Gets the <CODE>LDAPCache</CODE> object associated with
+     * the current <CODE>LDAPConnection</CODE> object.
+     * <P>
+     *
+     * @return the <CODE>LDAPCache</CODE> object representing
+     * the cache that the current connection should use
+     * @see netscape.ldap.LDAPCache
+     * @see netscape.ldap.LDAPConnection#setCache(netscape.ldap.LDAPCache)
+     */
+    public LDAPCache getCache() {
+        return m_cache;
+    }
+
+    /**
+     * Gets a property of a connection. <P>
+     *
+     * You can get the following properties for a given connection: <P>
+     * <UL TYPE="DISC">
+     * <LI><CODE>LDAP_PROPERTY_SDK</CODE> <P>
+     * To get the version of this SDK, get this property.  The value of
+     * this property is of the type <CODE>Float</CODE>. <P>
+     * <LI><CODE>LDAP_PROPERTY_PROTOCOL</CODE> <P>
+     * To get the highest supported version of the LDAP protocol, get
+     * this property.
+     * The value of this property is of the type <CODE>Float</CODE>. <P>
+     * <LI><CODE>LDAP_PROPERTY_SECURITY</CODE> <P>
+     * To get a comma-separated list of the types of authentication
+     * supported, get this property.  The value of this property is of the
+     * type <CODE>String</CODE>. <P>
+     * </UL>
+     * <P>
+     *
+     * For example, the following section of code gets the version of
+     * the SDK.<P>
+     *
+     * <PRE>
+     *       ...
+     *       Float sdkVersion = ( Float )myConn.getProperty( myConn.LDAP_PROPERTY_SDK );
+     *       System.out.println( "SDK version: " + sdkVersion );
+     *       ... </PRE>
+     *
+     * @param name name of the property (for example, <CODE>LDAP_PROPERTY_SDK</CODE>) <P>
+     *
+     * @return the value of the property. <P>
+     *
+     * Since the return value is an object, you should recast it as the appropriate type.
+     * (For example, when getting the <CODE>LDAP_PROPERTY_SDK</CODE> property,
+     * recast the return value as a <CODE>Float</CODE>.) <P>
+     *
+     * If you pass this method an unknown property name, the method
+     * returns null. <P>
+     *
+     * @exception LDAPException Unable to get the value of the
+     * specified property. <P>
+     *
+     * @see netscape.ldap.LDAPConnection#LDAP_PROPERTY_SDK
+     * @see netscape.ldap.LDAPConnection#LDAP_PROPERTY_PROTOCOL
+     * @see netscape.ldap.LDAPConnection#LDAP_PROPERTY_SECURITY
+     */
+    public Object getProperty(String name) throws LDAPException {
+        return m_properties.get( name );
+    }
+
+    /**
+     * Change a property of a connection. <P>
+     *
+     * The following properties are defined:<BR> 
+     * com.netscape.ldap.schema.quoting - "standard" or "NetscapeBug"<BR> 
+     * Note: if this property is not set, the SDK will query the server 
+     * to determine if attribute syntax values and objectclass superior 
+     * values must be quoted when adding schema.<BR>
+     * com.netscape.ldap.saslpackage - the default is "com.netscape.sasl"<BR> 
+     * <P>
+     *
+     * @param name name of the property to set
+     * @param val value to set
+     * @exception LDAPException Unable to set the value of the specified
+     * property.
+     */
+    public void setProperty(String name, Object val) throws LDAPException {
+        if ( name.equalsIgnoreCase( SCHEMA_BUG_PROPERTY ) ) { 
+            m_properties.put( SCHEMA_BUG_PROPERTY, val ); 
+        } else if ( name.equalsIgnoreCase( SASL_PACKAGE_PROPERTY ) ) {
+            m_properties.put( SASL_PACKAGE_PROPERTY, val ); 
+        } else if ( name.equalsIgnoreCase( "debug" ) ) {
+            debug = ((String)val).equalsIgnoreCase( "true" ); 
+
+        } else if ( name.equalsIgnoreCase( TRACE_PROPERTY ) ) {
+
+            Object traceOutput = null;
+            if (val == null) {
+                m_properties.remove(TRACE_PROPERTY);
+            }                
+            else {
+                if (m_thread != null) {
+                    traceOutput = createTraceOutput(val);
+                }
+                m_properties.put( TRACE_PROPERTY, val ); 
+            }
+
+            if (m_thread != null) {
+                m_thread.setTraceOutput(traceOutput);
+            }
+
+        // This is used only by the ldapjdk test cases to simulate a
+        // server problem and to test fail-over and rebind            
+        } else if ( name.equalsIgnoreCase( "breakConnection" ) ) {
+            m_connMgr.breakConnection();
+
+        } else {
+            throw new LDAPException("Unknown property: " + name);
+        }
+    }
+
+    /**
+     * Evaluate the TRACE_PROPERTY value and create output stream.
+     * The value can be of type String, OutputStream or LDAPTraceWriter.
+     * The String value represents output file name. If the name is an empty
+     * string, the output is sent to System.err. If the file name is
+     * prefixed with a '+' character, the file is opened in append mode.
+     *
+     * @param out Trace output specifier. A file name, an output stream 
+     * or an instance of LDAPTraceWriter
+     * @return An output stream or an LDAPTraceWriter instance
+     */
+    Object createTraceOutput(Object out) throws LDAPException {
+                
+        if (out instanceof String) { // trace file name
+            OutputStream os = null;
+            String file = (String)out;
+            if (file.length() == 0) {
+                os = System.err;
+            }
+            else {
+                try {
+                    boolean appendMode = (file.charAt(0) == '+');
+                    if (appendMode) {
+                        file = file.substring(1);
+                    }                        
+                    FileOutputStream fos = new FileOutputStream(file, appendMode);
+                    os = new BufferedOutputStream(fos);
+                }
+                catch (IOException e) {
+                    throw new LDAPException(
+                        "Can not open output trace file " + file + " " + e);
+                }
+            }
+            return os;
+        }        
+        else if (out instanceof OutputStream)  {
+            return out;
+        }       
+        else if (out instanceof LDAPTraceWriter)  {
+            return out;
+        }       
+        else {
+            throw new LDAPException(TRACE_PROPERTY + " must be an OutputStream, a file name or an instance of LDAPTraceWriter" );
+        }
+
+    }
+    
+    /**
+     * Sets the LDAP protocol version that your client prefers to use when
+     * connecting to the LDAP server.
+     * <P>
+     *
+     * @param version the LDAP protocol version that your client uses
+     */
+    private void setProtocolVersion(int version) {
+        m_protocolVersion = version;
+    }
+
+    /**
+     * Returns the host name of the LDAP server to which you are connected.
+     * @return host name of the LDAP server.
+     */
+    public String getHost () {
+        if (m_connMgr != null) {
+            return m_connMgr.getHost();
+        }
+        return null;
+    }
+
+    /**
+     * Returns the port number of the LDAP server to which you are connected.
+     * @return port number of the LDAP server.
+     */
+    public int getPort () {
+        if (m_connMgr != null) {
+            return m_connMgr.getPort();
+        }
+        return -1;
+    }
+
+    /**
+     * Returns the distinguished name (DN) used for authentication over
+     * this connection.
+     * @return distinguished name used for authentication over this connection.
+     */
+    public String getAuthenticationDN () {
+        return m_boundDN;
+    }
+
+    /**
+     * Returns the password used for authentication over this connection.
+     * @return password used for authentication over this connection.
+     */
+    public String getAuthenticationPassword () {
+        return m_boundPasswd;
+    }
+    
+    /**
+     * Returns the maximum time to wait for the connection to be established.
+     * @return the maximum connect time in seconds or 0 (unlimited)
+     * @see netscape.ldap.LDAPConnection#setConnectTimeout
+     */
+    public int getConnectTimeout () {
+        return m_connectTimeout;
+    }
+
+    /**
+     * Specifies the maximum time to wait for the connection to be established.
+     * If the value is 0, the time is not limited.
+     * @param timeout the maximum connect time in seconds or 0 (unlimited)
+     */
+    public void setConnectTimeout (int timeout) {
+        if (timeout < 0) {
+            throw new IllegalArgumentException("Timeout value can not be negative");
+        }
+        m_connectTimeout = timeout;
+        if (m_connMgr != null) {
+            m_connMgr.setConnectTimeout(m_connectTimeout);
+        }
+    }
+        
+    /**
+     * Returns the delay in seconds when making concurrent connection attempts to
+     * multiple servers.
+     * @return the delay in seconds between connection attempts:<br>
+     * <CODE>NODELAY_SERIAL</CODE> The serial connection setup policy is enabled
+     * (no concurrency).<br>
+     * <CODE>NODELAY_PARALLEL</CODE> The parallel connection setup policy with no delay
+     *  is enabled.<br>
+     * <CODE>delay > 0</CODE> The parallel connection setup policy with the delay of 
+     * <CODE>delay</CODE> seconds is enabled.
+     * @see netscape.ldap.LDAPConnection#setConnSetupDelay
+     */
+    public int getConnSetupDelay () {
+        return m_connSetupDelay;
+    }
+
+    /**
+     * Specifies the delay in seconds when making concurrent connection attempts to
+     * multiple servers.
+     * <P>Effectively, selects the connection setup policy when a list of hosts is passed
+     * to the <CODE>connect</CODE> method.
+     * 
+     * <br>If the serial policy is selected, the default one, an attempt is made to
+     * connect to the first host in the list. The next entry in
+     * the list is tried only if the attempt to connect to the current host fails.
+     * This might cause your application to block for unacceptably long time if a host is down.
+     *
+     * <br>If the parallel policy is selected, multiple connection attempts may run
+     * concurrently on a separate thread. A new connection attempt to the next entry
+     * in the list can be started with or without delay.
+     * <P>You must set the <CODE>ConnSetupDelay</CODE> before making the call to the 
+     * <CODE>connect</CODE> method.
+     * 
+     * @param delay the delay in seconds between connection attempts. Possible values are:<br>
+     * <CODE>NODELAY_SERIAL</CODE> Use the serial connection setup policy.<br>
+     * <CODE>NODELAY_PARALLEL</CODE> Use the parallel connection setup policy with no delay.
+     * Start all connection setup threads immediately.<br>
+     * <CODE>delay > 0</CODE> Use the parallel connection setup policy with delay.
+     * Start another connection setup thread after <CODE>delay</CODE> seconds.<br>
+     * @see netscape.ldap.LDAPConnection#NODELAY_SERIAL
+     * @see netscape.ldap.LDAPConnection#NODELAY_PARALLEL
+     * @see netscape.ldap.LDAPConnection#connect(java.lang.String, int)
+     */
+    public void setConnSetupDelay (int delay) {
+        m_connSetupDelay = delay;
+        if (m_connMgr != null) {
+            m_connMgr.setConnSetupDelay(delay);
+        }
+    }
+
+    /**
+     * Gets the object representing the socket factory used to establish
+     * a connection to the LDAP server or for the start TLS operation.
+     * <P>
+     *
+     * @return the object representing the socket factory used to
+     * establish a connection to a server or for the start TLS operation.
+     * @see netscape.ldap.LDAPSocketFactory
+     * @see netscape.ldap.LDAPSSLSocketFactory
+     * @see netscape.ldap.LDAPConnection#setSocketFactory(netscape.ldap.LDAPSocketFactory)
+     * @see netscape.ldap.LDAPConnection#startTLS
+     */
+    public LDAPSocketFactory getSocketFactory () {
+        return m_factory;
+    }
+
+    /**
+     * Specifies the object representing the socket factory that you
+     * want to use to establish a connection to a server or for the
+     * start TLS operation.
+     * <P>
+     * If the socket factory is to be used to establish a connection 
+     * <CODE>setSocketFactory()</CODE> must be called before 
+     * <CODE>connect()</CODE>. For the start TLS operation 
+     * <CODE>setSocketFactory()</CODE> must be called after <CODE>connect()</CODE>.
+     * @param factory the object representing the socket factory that
+     * you want to use to establish a connection to a server or for
+     * the start TLS operation.
+     * @see netscape.ldap.LDAPSocketFactory
+     * @see netscape.ldap.LDAPSSLSocketFactory
+     * @see netscape.ldap.LDAPConnection#getSocketFactory
+     * @see netscape.ldap.LDAPConnection#startTLS
+     */
+    public void setSocketFactory (LDAPSocketFactory factory) {
+        m_factory = factory;
+        m_isTLSFactory = false;
+    }
+
+    /**
+     * Indicates whether the connection represented by this object
+     * is open at this time.
+     * @return <CODE>true</CODE> if connected to an LDAP server over this connection.
+     * If not connected to an LDAP server, returns <CODE>false</CODE>.
+     */
+    public synchronized boolean isConnected() {
+        return m_thread != null && m_thread.isConnected();
+    }
+
+    /**
+     * Indicates whether this client has authenticated to the LDAP server
+     * @return <CODE>true,</CODE>, if authenticated. If not
+     * authenticated, or if authenticated as an anonymous user (with
+     * either a blank name or password), returns <CODE>false</CODE>.
+     */
+    public boolean isAuthenticated () {
+        boolean bound = false;
+        synchronized (this) {
+            bound = (m_thread != null) && m_thread.isBound();
+        }
+        return bound;
+    }
+
+    /**
+     * Mark the connection bind state
+     */
+    synchronized void setBound(boolean bound) {
+        if (m_thread != null) {
+            if (!bound) {
+                m_thread.setBound(false);
+            }
+            // sasl bind
+            else if (m_saslBinder != null) {
+                 m_thread.setBound(true);
+            }
+            // simple bind
+            else {
+                m_thread.setBound(!isAnonymousUser());
+            }
+        }
+    }
+
+    
+    boolean isAnonymousUser() {
+        return (m_boundDN == null) || m_boundDN.equals("") ||
+               (m_boundPasswd == null) || m_boundPasswd.equals("");        
+    }
+ 
+    /**
+     * Connects to the specified host and port.  If this LDAPConnection object
+     * represents an open connection, the connection is closed first
+     * before the new connection is opened.
+     * <P>
+     *
+     * For example, the following section of code establishes a connection with
+     * the LDAP server running on the host ldap.netscape.com and the port 389.
+     * <P>
+     *
+     * <PRE>
+     * String ldapHost = "ldap.netscape.com";
+     * int ldapPort = 389;
+     * LDAPConnection myConn = new LDAPConnection();
+     * try {
+     *     myConn.connect( ldapHost, ldapPort );
+     * } catch ( LDAPException e ) {
+     *     System.out.println( "Unable to connect to " + ldapHost +
+     *                         " at port " + ldapPort );
+     *     return;
+     * }
+     * System.out.println( "Connected to " + ldapHost + " at port " + ldapPort )
+     * </PRE>
+     *<P>
+     * You can limit the time spent waiting for the connection to be established
+     * by calling <CODE>setConnectTimeout</CODE> before <CODE>connect</CODE>. 
+     * <P>
+     * @param host host name of the LDAP server to which you want to connect.
+     * This value can also be a space-delimited list of hostnames or
+     * hostnames and port numbers (using the syntax
+     * <I>hostname:portnumber</I>). For example, you can specify
+     * the following values for the <CODE>host</CODE> argument:<BR>
+     *<PRE>
+     *   myhost
+     *   myhost hishost:389 herhost:5000 whathost
+     *   myhost:686 myhost:389 hishost:5000 whathost:1024
+     *</PRE>
+     * If multiple servers are specified in the <CODE>host</CODE> list, the connection
+     *  setup policy specified with the <CODE>ConnSetupDelay</CODE> property controls
+     * whether connection attempts are made serially or concurrently.
+     * <P>
+     * @param port port number of the LDAP server to which you want to connect.
+     * This parameter is ignored for any host in the <CODE>host</CODE>
+     * parameter which includes a colon and port number.
+     * @exception LDAPException The connection failed.
+     * @see netscape.ldap.LDAPConnection#setConnSetupDelay
+     * @see netscape.ldap.LDAPConnection#setConnectTimeout
+     */
+    public void connect(String host, int port) throws LDAPException {
+        connect( host, port, null, null, m_defaultConstraints, false );
+    }
+
+    /**
+     * Connects to the specified host and port and uses the specified DN and
+     * password to authenticate to the server.  If this LDAPConnection object
+     * represents an open connection, the connection is closed first
+     * before the new connection is opened.
+     * <P>
+     *
+     * For example, the following section of code establishes a connection
+     * with the LDAP server running on ldap.netscape.com at port 389.  The
+     * example also attempts to authenticate the client as Barbara Jensen.
+     * <P>
+     *
+     * <PRE>
+     * String ldapHost = "ldap.netscape.com";
+     * int ldapPort = 389;
+     * String myDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * String myPW = "hifalutin";
+     * LDAPConnection myConn = new LDAPConnection();
+     * try {
+     *     myConn.connect( ldapHost, ldapPort, myDN, myPW );
+     * } catch ( LDAPException e ) {
+     *     switch( e.getLDAPResultCode() ) {
+     *         case e.NO_SUCH_OBJECT:
+     *             System.out.println( "The specified user does not exist." );
+     *             break;
+     *         case e.INVALID_CREDENTIALS:
+     *             System.out.println( "Invalid password." );
+     *             break;
+     *         default:
+     *             System.out.println( "Error number: " + e.getLDAPResultCode() );
+     *             System.out.println( "Failed to connect to " + ldapHost + " at port " + ldapPort );
+     *             break;
+     *     }
+     *     return;
+     * }
+     * System.out.println( "Connected to " + ldapHost + " at port " + ldapPort );
+     * </PRE>
+     *<P>
+     * You can limit the time spent waiting for the connection to be established
+     * by calling <CODE>setConnectTimeout</CODE> before <CODE>connect</CODE>. 
+     * <P>
+     * @param host host name of the LDAP server to which you want to connect.
+     * This value can also be a space-delimited list of hostnames or
+     * hostnames and port numbers (using the syntax
+     * <I>hostname:portnumber</I>). For example, you can specify
+     * the following values for the <CODE>host</CODE> argument:<BR>
+     *<PRE>
+     *   myhost
+     *   myhost hishost:389 herhost:5000 whathost
+     *   myhost:686 myhost:389 hishost:5000 whathost:1024
+     *</PRE>
+     * If multiple servers are specified in the <CODE>host</CODE> list, the connection
+     *  setup policy specified with the <CODE>ConnSetupDelay</CODE> property controls
+     * whether connection attempts are made serially or concurrently.
+     * <P>
+     * @param port port number of the LDAP server to which you want to connect.
+     * This parameter is ignored for any host in the <CODE>host</CODE>
+     * parameter which includes a colon and port number.
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @exception LDAPException The connection or authentication failed.
+     * @see netscape.ldap.LDAPConnection#setConnSetupDelay
+     * @see netscape.ldap.LDAPConnection#setConnectTimeout
+     */
+    public void connect(String host, int port, String dn, String passwd)
+        throws LDAPException {
+        connect(host, port, dn, passwd, m_defaultConstraints, true);
+    }
+
+    /**
+     * Connects to the specified host and port and uses the specified DN and
+     * password to authenticate to the server.  If this LDAPConnection object
+     * represents an open connection, the connection is closed first
+     * before the new connection is opened. This method allows the user to 
+     * specify the preferences for the bind operation.
+     *<P>
+     * You can limit the time spent waiting for the connection to be established
+     * by calling <CODE>setConnectTimeout</CODE> before <CODE>connect</CODE>. 
+     * <P>
+     * @param host host name of the LDAP server to which you want to connect.
+     * This value can also be a space-delimited list of hostnames or
+     * hostnames and port numbers (using the syntax
+     * <I>hostname:portnumber</I>). For example, you can specify
+     * the following values for the <CODE>host</CODE> argument:<BR>
+     *<PRE>
+     *   myhost
+     *   myhost hishost:389 herhost:5000 whathost
+     *   myhost:686 myhost:389 hishost:5000 whathost:1024
+     *</PRE>
+     * If multiple servers are specified in the <CODE>host</CODE> list, the connection
+     *  setup policy specified with the <CODE>ConnSetupDelay</CODE> property controls
+     * whether connection attempts are made serially or concurrently.
+     * <P>
+     * @param port port number of the LDAP server to which you want to connect.
+     * This parameter is ignored for any host in the <CODE>host</CODE>
+     * parameter which includes a colon and port number.
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @param cons preferences for the bind operation
+     * @exception LDAPException The connection or authentication failed.
+     * @see netscape.ldap.LDAPConnection#setConnSetupDelay
+     * @see netscape.ldap.LDAPConnection#setConnectTimeout
+     */
+    public void connect(String host, int port, String dn, String passwd,
+        LDAPConstraints cons) throws LDAPException {
+        connect(host, port, dn, passwd, cons, true);
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void connect(String host, int port, String dn, String passwd,
+        LDAPSearchConstraints cons) throws LDAPException {
+        connect(host, port, dn, passwd, (LDAPConstraints)cons);
+    }
+
+
+    private void connect(String host, int port, String dn, String passwd,
+      LDAPConstraints cons, boolean doAuthenticate) 
+        throws LDAPException {
+        if ( isConnected() ) {
+            disconnect ();
+        }
+        if ((host == null) || (host.equals(""))) {
+            throw new LDAPException ( "no host for connection",
+                                      LDAPException.PARAM_ERROR );
+        }
+
+        /* Parse the list of hosts */    
+        int defaultPort = port;
+        StringTokenizer st = new StringTokenizer( host );
+        String hostList[] = new String[st.countTokens()];
+        int portList[] = new int[st.countTokens()];
+        int i = 0;
+        while( st.hasMoreTokens() ) {
+            String s = st.nextToken();
+            int colon = s.indexOf( ':' );
+            if ( colon > 0 ) {
+                hostList[i] = s.substring( 0, colon );
+                portList[i] = Integer.parseInt( s.substring( colon+1 ) );
+            } else {
+                hostList[i] = s;
+                portList[i] = defaultPort;
+            }
+            i++;
+        }
+
+        /* Create the Connection Setup Manager */
+        m_connMgr = new LDAPConnSetupMgr(hostList, portList,
+                                         m_isTLSFactory ? null : m_factory);
+        m_connMgr.setConnSetupDelay(m_connSetupDelay);
+        m_connMgr.setConnectTimeout(m_connectTimeout);
+    
+        connect();
+
+        if (doAuthenticate) {
+            authenticate(dn, passwd, cons);
+        }
+    }
+
+    void connect(LDAPUrl[] urls) throws LDAPException {
+        m_connMgr = new LDAPConnSetupMgr(urls, m_factory);
+        m_connMgr.setConnSetupDelay(m_connSetupDelay);
+        m_connMgr.setConnectTimeout(m_connectTimeout);
+        connect();
+    }
+    
+    /**
+     * Connects to the specified host and port and uses the specified DN and
+     * password to authenticate to the server, with the specified LDAP
+     * protocol version. If the server does not support the requested
+     * protocol version, an exception is thrown. If this LDAPConnection
+     * object represents an open connection, the connection is closed first
+     * before the new connection is opened. This is equivalent to
+     * <CODE>connect(host, port)</CODE> followed by <CODE>authenticate(version, dn, passwd)</CODE>.<P>
+     *
+     * @param version requested version of LDAP: currently 2 or 3
+     * @param host a hostname to which to connect or a dotted string representing
+     * the IP address of this host.
+     * Alternatively, this can be a space-delimited list of host names.
+     * Each host name may include a trailing colon and port number. In the
+     * case where more than one host name is specified, the connection setup
+     * policy specified with the <CODE>ConnSetupDelay</CODE> property controls
+     * whether connection attempts are made serially or concurrently.<P>
+     *
+     * <PRE>
+     *   Examples:
+     *      "directory.knowledge.com"
+     *      "199.254.1.2"
+     *      "directory.knowledge.com:1050 people.catalog.com 199.254.1.2"
+     * </PRE>
+     * @param port the TCP or UDP port number to which to connect or contact.
+     * The default LDAP port is 389. "port" is ignored for any host name which
+     * includes a colon and port number.
+     * @param dn if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param passwd if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name and passwd as password.
+     * @exception LDAPException The connection or authentication failed.
+     * @see netscape.ldap.LDAPConnection#setConnSetupDelay
+     */
+    public void connect(int version, String host, int port, String dn,
+        String passwd) throws LDAPException {
+
+        connect(version, host, port, dn, passwd, m_defaultConstraints);
+    }
+
+    /**
+     * Connects to the specified host and port and uses the specified DN and
+     * password to authenticate to the server, with the specified LDAP
+     * protocol version. If the server does not support the requested
+     * protocol version, an exception is thrown. This method allows the user
+     * to specify preferences for the bind operation. If this LDAPConnection
+     * object represents an open connection, the connection is closed first
+     * before the new connection is opened. This is equivalent to
+     * <CODE>connect(host, port)</CODE> followed by <CODE>authenticate(version, dn, passwd)</CODE>.<P>
+     *
+     * @param version requested version of LDAP: currently 2 or 3
+     * @param host a hostname to which to connect or a dotted string representing
+     * the IP address of this host.
+     * Alternatively, this can be a space-delimited list of host names.
+     * Each host name may include a trailing colon and port number. In the
+     * case where more than one host name is specified, the connection setup
+     * policy specified with the <CODE>ConnSetupDelay</CODE> property controls
+     * whether connection attempts are made serially or concurrently.<P>
+     *
+     * <PRE>
+     *   Examples:
+     *      "directory.knowledge.com"
+     *      "199.254.1.2"
+     *      "directory.knowledge.com:1050 people.catalog.com 199.254.1.2"
+     * </PRE>
+     * @param port the TCP or UDP port number to which to connect or contact.
+     * The default LDAP port is 389. "port" is ignored for any host name which
+     * includes a colon and port number.
+     * @param dn if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param passwd if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name and passwd as password
+     * @param cons preferences for the bind operation
+     * @exception LDAPException The connection or authentication failed.
+     * @see netscape.ldap.LDAPConnection#setConnSetupDelay
+     */
+    public void connect(int version, String host, int port, String dn,
+        String passwd, LDAPConstraints cons) throws LDAPException {
+
+        setProtocolVersion(version);
+        connect(host, port, dn, passwd, cons);
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void connect(int version, String host, int port, String dn,
+        String passwd, LDAPSearchConstraints cons) throws LDAPException {
+
+        connect(version, host, port, dn, passwd, (LDAPConstraints)cons);
+    }
+
+    /**
+     * Internal routine to connect with internal params
+     * @exception LDAPException failed to connect
+     */
+    private synchronized void connect () throws LDAPException {
+        if ( isConnected() ) {
+            return;
+        }
+
+        if (m_connMgr == null) {
+            throw new LDAPException ( "no connection parameters",
+                                      LDAPException.PARAM_ERROR );
+        }        
+
+        if (m_thread == null) {
+            m_thread = new LDAPConnThread(m_connMgr, m_cache, getTraceOutput());
+        }
+
+        m_thread.connect(this);
+
+        checkClientAuth();
+    }
+
+    /**
+     * Returns the trace output object if set by the user
+     */
+    Object getTraceOutput() throws LDAPException {
+        
+        // Check first if trace output has been set using setProperty()
+        Object traceOut = m_properties.get(TRACE_PROPERTY);
+        if (traceOut != null) {
+            return createTraceOutput(traceOut);
+        }
+        
+        // Check if the property has been set with java -Dcom.netscape.ldap.trace
+        // If the property does not have a value, send the trace to the System.err,
+        // otherwise use the value as the output file name
+        try {
+            traceOut = System.getProperty(TRACE_PROPERTY);
+            if (traceOut != null) {
+                return createTraceOutput(traceOut);
+            }
+        }
+        catch (Exception e) {
+            ;// In browser access to property might not be allowed
+        }
+        return null;
+    }        
+        
+        
+    /**
+     * Performs certificate-based authentication if client authentication was
+     * specified at construction time.
+     * @exception LDAPException if certificate-based authentication fails.
+     */
+    private void checkClientAuth() throws LDAPException {
+
+        // if this is SSL
+        if ((m_factory != null) &&
+            (m_factory instanceof LDAPSSLSocketFactoryExt)) {
+
+            if (((LDAPSSLSocketFactoryExt)m_factory).isClientAuth()) {
+                authenticate(null, EXTERNAL_MECHANISM,
+                             EXTERNAL_MECHANISM_PACKAGE, null, null);
+            }
+        }
+    }
+
+    /**
+     * Abandons a current search operation, notifying the server not
+     * to send additional search results.
+     *
+     * @param searchResults the search results returned when the search
+     * was started
+     * @exception LDAPException Failed to notify the LDAP server.
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)
+     * @see netscape.ldap.LDAPSearchResults
+     */
+    public void abandon( LDAPSearchResults searchResults )
+                             throws LDAPException {
+        if ( (!isConnected()) || (searchResults == null) ) {
+            return;
+        }
+
+        int id = searchResults.getMessageID();
+        if ( id != -1 ) {
+            abandon( id );
+        }
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which you are currently
+     * connected) using the specified name and password.
+     * If you are not connected to the LDAP server, this
+     * method attempts to reconnect to the server.
+     * <P>
+     *
+     * For example, the following section of code authenticates the
+     * client as Barbara Jensen.  The code assumes that the client
+     * has already established a connection with an LDAP server.
+     * <P>
+     *
+     * <PRE>
+     * String myDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * String myPW = "hifalutin";
+     * try {
+     *     myConn.authenticate( myDN, myPW );
+     * } catch ( LDAPException e ) {
+     *     switch( e.getLDAPResultCode() ) {
+     *         case e.NO_SUCH_OBJECT:
+     *             System.out.println( "The specified user does not exist." );
+     *             break;
+     *         case e.INVALID_CREDENTIALS:
+     *             System.out.println( "Invalid password." );
+     *             break;
+     *         default:
+     *             System.out.println( "Error number: " + e.getLDAPResultCode() );
+     *             System.out.println( "Failed to authentice as " + myDN );
+     *             break;
+     *     }
+     *     return;
+     * }
+     * System.out.println( "Authenticated as " + myDN );
+     * </PRE>
+     *
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void authenticate(String dn, String passwd) throws LDAPException {
+        authenticate(m_protocolVersion, dn, passwd, m_defaultConstraints);
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which you are currently
+     * connected) using the specified name and password. The
+     * default protocol version (version 2) is used. If the server
+     * doesn't support the default version, an LDAPException is thrown
+     * with the error code PROTOCOL_ERROR. This method allows the
+     * user to specify the preferences for the bind operation.
+     *
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @param cons preferences for the bind operation
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void authenticate(String dn, String passwd,
+      LDAPConstraints cons) throws LDAPException {
+        authenticate(m_protocolVersion, dn, passwd, cons);
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void authenticate(String dn, String passwd,
+      LDAPSearchConstraints cons) throws LDAPException {
+        authenticate(dn, passwd, (LDAPConstraints)cons);
+    }
+
+    /**
+     * Authenticates to the LDAP server (that you are currently
+     * connected to) using the specified name and password, and
+     * requesting that the server use at least the specified
+     * protocol version. If the server doesn't support that
+     * level, an LDAPException is thrown with the error code
+     * PROTOCOL_ERROR.
+     *
+     * @param version required LDAP protocol version
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void authenticate(int version, String dn, String passwd)
+      throws LDAPException {
+        authenticate(version, dn, passwd, m_defaultConstraints);
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which you are currently
+     * connected) using the specified name and password, and
+     * requesting that the server use at least the specified
+     * protocol version. If the server doesn't support that
+     * level, an LDAPException is thrown with the error code
+     * PROTOCOL_ERROR. This method allows the user to specify the
+     * preferences for the bind operation.
+     *
+     * @param version required LDAP protocol version
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @param cons preferences for the bind operation
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void authenticate(int version, String dn, String passwd,
+      LDAPConstraints cons) throws LDAPException {
+        m_protocolVersion = version;
+        m_boundDN = dn;
+        m_boundPasswd = passwd;
+        forceNonSharedConnection();
+        simpleBind(cons);
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void authenticate(int version, String dn, String passwd,
+      LDAPSearchConstraints cons) throws LDAPException {
+        authenticate(version, dn, passwd, (LDAPConstraints)cons);
+    }
+
+    /**
+     * Authenticates to the LDAP server (that the object is currently
+     * connected to) using the specified name and whatever SASL mechanisms
+     * are supported by the server. Each supported mechanism in turn
+     * is tried until authentication succeeds or an exception is thrown.
+     * If the object has been disconnected from an LDAP server, this
+     * method attempts to reconnect to the server. If the object had
+     * already authenticated, the old authentication is discarded.
+     *
+     * @param dn if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param cbh a class which the SASL framework can call to obtain 
+     * additional required information
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void authenticate(String dn, Hashtable props,
+                             /*CallbackHandler*/ Object cbh)
+        throws LDAPException {
+
+        // Get the list of mechanisms from the server
+        String[] attrs = { "supportedSaslMechanisms" };
+        LDAPEntry entry = read( "", attrs );
+        LDAPAttribute attr = entry.getAttribute( attrs[0] );
+        if ( attr == null ) {
+            throw new LDAPException( "Not found in root DSE: " +
+                                     attrs[0],
+                                     LDAPException.NO_SUCH_ATTRIBUTE );
+        }
+        authenticate( dn, attr.getStringValueArray(), props, cbh );
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name and a specified SASL mechanism
+     * or set of mechanisms. If the requested SASL mechanism is not
+     * available, an exception is thrown.  If the object has been
+     * disconnected from an LDAP server, this method attempts to reconnect
+     * to the server. If the object had already authenticated, the old
+     * authentication is discarded.
+     *
+     * @param dn if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param mechanisms a list of acceptable mechanisms. The first one
+     * for which a Mechanism Driver can be instantiated is returned.
+     * @param cbh a class which the SASL framework can call to
+     * obtain additional required information
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     * @see netscape.ldap.LDAPConnection#authenticate(java.lang.String,
+     * java.util.Hashtable, java.lang.Object)
+     */
+    public void authenticate(String dn, String[] mechanisms,
+                             Hashtable props, /*CallbackHandler*/ Object cbh)
+        throws LDAPException {
+
+        authenticate( dn, mechanisms, DEFAULT_SASL_PACKAGE, props, cbh );
+    }
+    
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name and a specified SASL mechanism
+     * or set of mechanisms. If the requested SASL mechanism is not
+     * available, an exception is thrown.  If the object has been
+     * disconnected from an LDAP server, this method attempts to reconnect
+     * to the server. If the object had already authenticated, the old
+     * authentication is discarded.
+     *
+     * @param dn if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param mechanism a single mechanism name, e.g. "GSSAPI"
+     * @param packageName a package containing a SASL ClientFactory,
+     * e.g. "myclasses.SASL". If null, a system default is used.
+     * @param cbh a class which the SASL framework can call to
+     * obtain additional required information
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     * @deprecated Please use authenticate without packageName
+     * instead.
+     */
+    public void authenticate(String dn, String mechanism, String packageName,
+                             Hashtable props, /*CallbackHandler*/ Object cbh)
+        throws LDAPException {
+
+        authenticate( dn, new String[] {mechanism}, packageName, props, cbh );
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name and a specified SASL mechanism
+     * or set of mechanisms. If the requested SASL mechanism is not
+     * available, an exception is thrown.  If the object has been
+     * disconnected from an LDAP server, this method attempts to reconnect
+     * to the server. If the object had already authenticated, the old
+     * authentication is discarded.
+     *
+     * @param dn if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param mechanisms a list of acceptable mechanisms. The first one
+     * for which a Mechanism Driver can be instantiated is returned.
+     * @param packageName a package containing a SASL ClientFactory,
+     * e.g. "myclasses.SASL". If null, a system default is used.
+     * @param cbh a class which the SASL framework can call to
+     * obtain additional required information
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     * @deprecated Please use authenticate without packageName
+     * instead.
+     */
+    public void authenticate(String dn, String[] mechanisms,
+                             String packageName,
+                             Hashtable props, /*CallbackHandler*/ Object cbh)
+        throws LDAPException {
+
+        forceNonSharedConnection();
+
+        m_boundDN = null;
+        m_protocolVersion = 3; // Must be 3 for SASL
+        if ( props == null ) {
+            props = new Hashtable();
+        }
+        m_saslBinder = new LDAPSaslBind( dn, mechanisms, packageName,
+                                         props, cbh );
+        m_saslBinder.bind( this );
+        m_boundDN = dn;
+    }
+    
+    /**
+     * Authenticates to the LDAP server (that the object is currently
+     * connected to) using the specified name and password  and allows you
+     * to specify constraints for this LDAP add operation by using an
+     *  <CODE>LDAPConstraints</CODE> object. If the object
+     * has been disconnected from an LDAP server, this method attempts to
+     * reconnect to the server. If the object had already authenticated, the
+     * old authentication is discarded.
+     * 
+     * @param version Required LDAP protocol version.
+     * @param dn If non-null and non-empty, specifies that the connection
+     * and all operations through it should be authenticated with dn as the
+     * distinguished name.
+     * @param passwd If non-null and non-empty, specifies that the connection
+     * and all operations through it should be authenticated with dn as the
+     * distinguished name and passwd as password.
+     * @param listener Handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons Constraints specific to the operation.
+     * @return LDAPResponseListener Handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener authenticate(int version,
+                                             String dn,
+                                             String passwd,
+                                             LDAPResponseListener listener,
+                                             LDAPConstraints cons) 
+                                             throws LDAPException{
+        if (cons == null) {
+            cons = m_defaultConstraints;
+        }
+
+        m_boundDN = dn;
+        m_boundPasswd = passwd;
+        m_protocolVersion = version;
+
+        forceNonSharedConnection();
+
+        if (listener == null) {
+            listener = new LDAPResponseListener(/*asynchOp=*/true);
+        }
+
+        sendRequest(new JDAPBindRequest(version, m_boundDN, m_boundPasswd),
+            listener, cons);
+
+        return listener;
+    }
+    
+    /**
+     * Authenticates to the LDAP server (that the object is currently
+     * connected to) using the specified name and password  and allows you
+     * to specify constraints for this LDAP add operation by using an
+     *  <CODE>LDAPConstraints</CODE> object. If the object
+     * has been disconnected from an LDAP server, this method attempts to
+     * reconnect to the server. If the object had already authenticated, the
+     * old authentication is discarded.
+     * 
+     * @param version Required LDAP protocol version.
+     * @param dn If non-null and non-empty, specifies that the connection
+     * and all operations through it should be authenticated with dn as the
+     * distinguished name.
+     * @param passwd If non-null and non-empty, specifies that the connection
+     * and all operations through it should be authenticated with dn as the
+     * distinguished name and passwd as password.
+     * @param listener Handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener Handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener authenticate(int version,
+                                             String dn,
+                                             String passwd,
+                                             LDAPResponseListener listener) 
+                                             throws LDAPException{
+        return authenticate( version, dn, passwd, listener, m_defaultConstraints );
+    }
+    
+    /** 
+     * Authenticates to the LDAP server (to which you are currently
+     * connected) using the specified name and password.
+     * If you are not already connected to the LDAP server, this
+     * method attempts to reconnect to the server.
+     * <P>
+     *
+     * For example, the following section of code authenticates the
+     * client as Barbara Jensen.  The code assumes that the client
+     * has already established a connection with an LDAP server.
+     * <P>
+     *
+     * <PRE>
+     * String myDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * String myPW = "hifalutin";
+     * try {
+     *     myConn.bind( myDN, myPW );
+     * } catch ( LDAPException e ) {
+     *     switch( e.getLDAPResultCode() ) {
+     *         case e.NO_SUCH_OBJECT:
+     *             System.out.println( "The specified user does not exist." );
+     *             break;
+     *         case e.INVALID_CREDENTIALS:
+     *             System.out.println( "Invalid password." );
+     *             break;
+     *         default:
+     *             System.out.println( "Error number: " + e.getLDAPResultCode() );
+     *             System.out.println( "Failed to authentice as " + myDN );
+     *             break;
+     *     }
+     *     return;
+     * }
+     * System.out.println( "Authenticated as " + myDN );
+     * </PRE>
+     *
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void bind(String dn, String passwd) throws LDAPException {
+        authenticate(m_protocolVersion, dn, passwd, m_defaultConstraints);
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which you are currently
+     * connected) using the specified name and password. The
+     * default protocol version (version 2) is used. If the server
+     * doesn't support the default version, an LDAPException is thrown
+     * with the error code PROTOCOL_ERROR. This method allows the
+     * user to specify the preferences for the bind operation.
+     *
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @param cons preferences for the bind operation
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void bind(String dn, String passwd,
+                     LDAPConstraints cons) throws LDAPException {
+        authenticate(m_protocolVersion, dn, passwd, cons);
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which you are currently
+     * connected) using the specified name and password, and
+     * requests that the server use at least the specified
+     * protocol version. If the server doesn't support that
+     * level, an LDAPException is thrown with the error code
+     * PROTOCOL_ERROR.
+     *
+     * @param version required LDAP protocol version
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void bind(int version, String dn, String passwd)
+        throws LDAPException {
+        authenticate(version, dn, passwd, m_defaultConstraints);
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which you are currently
+     * connected) using the specified name and password, and
+     * requesting that the server use at least the specified
+     * protocol version. If the server doesn't support that
+     * level, an LDAPException is thrown with the error code
+     * PROTOCOL_ERROR. This method allows the user to specify the
+     * preferences for the bind operation.
+     *
+     * @param version required LDAP protocol version
+     * @param dn distinguished name used for authentication
+     * @param passwd password used for authentication
+     * @param cons preferences for the bind operation
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void bind(int version, String dn, String passwd,
+      LDAPConstraints cons) throws LDAPException {
+        authenticate(version, dn, passwd, cons);
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name and whatever SASL mechanisms
+     * are supported by the server. Each supported mechanism in turn
+     * is tried until authentication succeeds or an exception is thrown.
+     * If the object has been disconnected from an LDAP server, this
+     * method attempts to reconnect to the server. If the object had
+     * already authenticated, the old authentication is discarded.
+     *
+     * @param dn if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param cbh a class which the SASL framework can call to
+     * obtain additional required information
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void bind(String dn, Hashtable props,
+                     /*CallbackHandler*/ Object cbh)
+        throws LDAPException {
+        authenticate(dn, props, cbh);
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name and a specified SASL mechanism
+     * or set of mechanisms. If the requested SASL mechanism is not
+     * available, an exception is thrown.  If the object has been
+     * disconnected from an LDAP server, this method attempts to reconnect
+     * to the server. If the object had already authenticated, the old
+     * authentication is discarded.
+     *
+     * @param dn if non-null and non-empty, specifies that the connection and
+     * all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param mechanisms a list of acceptable mechanisms. The first one
+     * for which a Mechanism Driver can be instantiated is returned.
+     * @param cbh a class which the SASL framework can call to
+     * obtain additional required information
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     * @see netscape.ldap.LDAPConnection#bind(java.lang.String,
+     * java.util.Hashtable, java.lang.Object)
+     */
+    public void bind(String dn, String[] mechanisms,
+                     Hashtable props, /*CallbackHandler*/ Object cbh)
+        throws LDAPException {
+        authenticate(dn, mechanisms, props, cbh);
+    }
+
+    /**
+     * Begin using the Transport Layer Security (TLS) protocol for session
+     * privacy.
+     * <P>
+     * Before <CODE>startTLS()</CODE> is called, a socket factory of type
+     * <CODE>LDAPTLSSocketFactory</CODE> must be set for the connection.
+     * The factory must be set after the <CODE>connect()</CODE> call. 
+     * <P>
+     * <PRE>
+     * LDAPConnection ldc = new LDAPConnection();
+     * try {
+     *     ldc.connect(host, port);
+     *     ldc.setSocketFactory(new JSSSocketFactory());
+     *     ldc.startTLS();
+     *     ldc.autheticate(3, userdn, userpw);
+     * }
+     * catch (LDAPException e) {
+     * ...
+     * }
+     * </PRE>
+     * <P>
+     * If the socket factory of the connection is not capable of initiating a
+     * TLS session , an LDAPException is thrown with the error code
+     * TLS_NOT_SUPPORTED.
+     * <P>
+     * If the server does not support the transition to a TLS session, an
+     * LDAPException is thrown with the error code returned by the server.
+     * If there are outstanding LDAP operations on the connection or the 
+     * connection is already in the secure mode, an LDAPException is thrown. 
+     * 
+     * @exception LDAPException Failed to convert to a TLS session.
+     * @see netscape.ldap.LDAPTLSSocketFactory
+     * @see netscape.ldap.LDAPConnection#setSocketFactory(netscape.ldap.LDAPSocketFactory)
+     * @see netscape.ldap.LDAPConnection#isTLS
+     * @since LDAPJDK 4.17
+     */        
+    public void startTLS() throws LDAPException {        
+
+        if (m_useTLS) {
+            throw new LDAPException("Already using TLS",
+                                    LDAPException.OTHER);
+        }
+
+        if (m_factory == null || !( m_factory instanceof LDAPTLSSocketFactory)) {
+            throw new LDAPException("No socket factory for the startTLS operation",
+                                    LDAPException.OTHER);
+        }
+
+        // Denote that m_factory is to be used from now on used for TLS and not for
+        // SSL connections.
+        m_isTLSFactory = true;
+
+        checkConnection(/*rebind=*/true);
+
+        // If some requests still in progress, throw exception
+        synchronized (this) {
+            if (isConnected() && m_thread.getRequestCount() != 0) {
+                throw new LDAPException(
+                        "Connection has outstanding LDAP operations",
+                        LDAPException.OTHER);
+            }
+        }
+
+        // Send startTLS extended op
+        try {
+            LDAPExtendedOperation response = 
+                extendedOperation(new LDAPExtendedOperation(OID_startTLS, null),
+                                  m_defaultConstraints);
+        }
+        catch (LDAPException ex) {
+            ex.setExtraMessage("Cannot start TLS");
+            throw ex;
+        }
+
+        /**
+         * Server accepted startTLS request, try to initiate TLS over the
+         * current socket.
+         */
+        try {
+            m_thread.layerSocket((LDAPTLSSocketFactory)m_factory);
+            m_useTLS = true;
+        }
+        catch (LDAPException ex) {
+            ex.setExtraMessage("Failed to start TLS");
+            throw ex;
+        }
+        catch (Exception ex) {
+            throw new LDAPException("Failed to start TLS",
+                                    LDAPException.OTHER);
+        }
+    }
+
+    /**
+     * Indicates if the session is currently protected by TLS.
+     * @return <CODE>true</CODE> if TLS was activated.
+     * @since LDAPJDK 4.17
+     * @see netscape.ldap.LDAPConnection#startTLS
+     */
+    public boolean isTLS() { 
+        return m_useTLS;
+    }
+
+    /**
+     * If this connection is cloned (the physical connection is shared),
+     *  create a new physical connection.
+     */
+    void forceNonSharedConnection() throws LDAPException{
+        checkConnection(/*rebind=*/false);
+        if (m_thread != null && m_thread.getClientCount() > 1) {
+            reconnect(/*rebind=*/false);
+        }
+    }
+
+    /**
+     * Internal routine. Binds to the LDAP server.
+     * @exception LDAPException failed to bind
+     */
+    private void simpleBind (LDAPConstraints cons) throws LDAPException {
+
+        m_saslBinder = null;
+
+        LDAPResponseListener myListener = new LDAPResponseListener ( /*asynchOp=*/false );
+        try {
+
+            if (m_referralConnection != null && m_referralConnection.isConnected()) {
+                m_referralConnection.disconnect();
+            }
+            m_referralConnection = null;
+            
+            setBound(false);
+            sendRequest(new JDAPBindRequest(m_protocolVersion, m_boundDN,
+                                            m_boundPasswd),
+                        myListener, cons);
+            checkMsg( myListener.getResponse() );
+
+            setBound(true);
+            m_rebindConstraints = (LDAPConstraints)cons.clone();
+
+        } catch (LDAPReferralException e) {
+            m_referralConnection = createReferralConnection(e, cons);
+        }
+    }
+
+    /**
+     * Send a request to the server
+     */
+    synchronized void sendRequest(JDAPProtocolOp oper, LDAPMessageQueue myListener,
+                     LDAPConstraints cons) throws LDAPException {
+
+        boolean requestSent=false;
+        boolean restoreTried=false;
+
+        while (!requestSent) {
+
+            try {
+                m_thread.sendRequest(this, oper, myListener, cons);
+
+                /**
+                 * In Java, a lost socket connected is often not detected until
+                 * a read is attempted following a write. Wait for the response
+                 * from the server to be sure the connection is really there.
+                 */
+                if (!myListener.isAsynchOp()) {
+                    myListener.waitFirstMessage();
+                }
+
+                requestSent=true;
+            }
+
+            catch (IllegalArgumentException e) {
+                throw new LDAPException(e.getMessage(), LDAPException.PARAM_ERROR);
+            }
+            catch(NullPointerException e) {
+                if (isConnected() || restoreTried) {
+                    break; // give up 
+                }
+                // else try to restore the connection
+            }
+            catch (LDAPException e) {
+                if (e.getLDAPResultCode() != e.SERVER_DOWN || restoreTried) {
+                    throw e; // give up
+                }
+                // else try to restore the connection
+            }
+
+            // Try to restore the connection if needed, but no more then once
+            if (!requestSent && !restoreTried) {
+                restoreTried = true;                
+                myListener.reset();
+                boolean rebind = !(oper instanceof JDAPBindRequest);
+                restoreConnection(rebind);
+            }
+        }
+
+        if (!requestSent) {
+            throw new LDAPException("Failed to send request",
+                LDAPException.OTHER);
+        }
+    }
+
+    /**
+     * Check and restore the connection if needed.
+     * This method is used by the "smart failover" feature. If a server
+     * or network error has occurred, an attempt is made to automatically
+     * restore the connection on the next ldap operation request
+     * @param rebind true if needs rebind after reconnect
+     */
+    private void checkConnection(boolean rebind) throws LDAPException {
+
+        if (isConnected()) {
+            return;
+        }
+        // If the user has invoked disconnect() no attempt is made
+        // to restore the connection
+        if (m_connMgr == null) {
+            throw new LDAPException("not connected", LDAPException.OTHER);
+        }
+
+        restoreConnection(rebind);
+    }
+    
+    /**
+     * Reconnect and reauthenticate
+     */
+    private void restoreConnection(boolean rebind) throws LDAPException {
+        connect();
+        if (m_useTLS) {
+            m_useTLS = false;
+            startTLS();
+        }                
+
+        if (!rebind) {
+            return;
+        }
+
+        if (m_saslBinder != null) {
+            m_saslBinder.bind(this, false);
+        }
+        else if (m_rebindConstraints != null) {
+            //Needs bind
+            simpleBind(m_rebindConstraints);
+        }
+    }
+
+    /**
+     * Gets the authentication method used to bind:<BR>
+     * "none", "simple", or "sasl"
+     *
+     * @return the authentication method, or "none"
+     */
+    public String getAuthenticationMethod() {
+        if (!isAuthenticated()) {
+            return "none";
+        }
+        else {
+            return (m_saslBinder == null) ? "simple" : "sasl";
+        }
+        
+    }
+
+    /**
+     * Disconnect from the server and then reconnect using the current
+     * credentials and authentication method.<P>
+     * If TLS was enabled with the startTLS() call, reenable TLS after
+     * reconnect.
+     * @exception LDAPException if not previously connected, or if
+     * there is a failure on disconnecting or on connecting 
+     */
+    public void reconnect() throws LDAPException {        
+        reconnect(/*rebind=*/true);
+    }
+
+    void reconnect(boolean rebind) throws LDAPException {
+        // Save connect parameters that get cleared by disconnect()
+        boolean useTLS = m_useTLS;
+        LDAPConnSetupMgr connMgr = m_connMgr;
+        LDAPConstraints rebindCons = m_rebindConstraints;
+
+        disconnect();
+        m_useTLS = useTLS;
+        m_connMgr = connMgr;
+        m_rebindConstraints = rebindCons;
+        restoreConnection(rebind);
+    }
+
+    /**
+     * Disconnects from the LDAP server. Before you can perform LDAP operations
+     * again, you need to reconnect to the server by calling
+     * <CODE>connect</CODE>.
+     * @exception LDAPException Failed to disconnect from the LDAP server.
+     * @see netscape.ldap.LDAPConnection#connect(java.lang.String, int)
+     * @see netscape.ldap.LDAPConnection#connect(java.lang.String, int, java.lang.String, java.lang.String)
+     */
+    public synchronized void disconnect() throws LDAPException {
+        if (!isConnected()) {
+            return;
+        }
+
+        m_thread.deregister(this);
+
+        if (m_referralConnection != null && m_referralConnection.isConnected()) {
+            m_referralConnection.disconnect();
+        }
+        m_referralConnection = null;
+
+        if (m_cache != null) {
+            m_cache.removeReference();
+            m_cache = null;
+        }
+
+        m_responseControlTable.clear();
+        m_rebindConstraints = null;
+        m_thread = null;
+        m_connMgr = null;
+        m_useTLS = false;
+    }
+
+    /**
+     * Reads the entry for the specified distiguished name (DN) and retrieves all
+     * attributes for the entry.
+     * <P>
+     *
+     * For example, the following section of code reads the entry for
+     * Barbara Jensen and retrieves all attributes for that entry.
+     * <P>
+     *
+     * <PRE>
+     * String findDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * LDAPEntry foundEntry = null;
+     * try {
+     *     foundEntry = myConn.read( findDN );
+     * } catch ( LDAPException e ) {
+     *     switch( e.getLDAPResultCode() ) {
+     *         case e.NO_SUCH_OBJECT:
+     *             System.out.println( "The specified entry does not exist." );
+     *             break;
+     *         case e.LDAP_PARTIAL_RESULTS:
+     *             System.out.println( "Entry served by a different LDAP server." );
+     *             break;
+     *         case e.INSUFFICIENT_ACCESS_RIGHTS:
+     *             System.out.println( "You do not have the access rights to perform this operation." );
+     *             break;
+     *         default:
+     *             System.out.println( "Error number: " + e.getLDAPResultCode() );
+     *             System.out.println( "Could not read the specified entry." );
+     *             break;
+     *     }
+     *     return;
+     * }
+     * System.out.println( "Found the specified entry." );
+     * </PRE>
+     *
+     * @param DN distinguished name of the entry  to retrieve
+     * @exception LDAPException Failed to find or read the specified entry
+     * from the directory.
+     * @return LDAPEntry returns the specified entry or raises an exception
+     * if the entry is not found.
+     */
+    public LDAPEntry read (String DN) throws LDAPException {
+        return read (DN, null, m_defaultConstraints);
+    }
+
+    /**
+     * Reads the entry for the specified distiguished name (DN) and retrieves all
+     * attributes for the entry. This method allows the user to specify the
+     * preferences for the read operation.
+     * <P>
+     *
+     * For example, the following section of code reads the entry for
+     * Barbara Jensen and retrieves all attributes for that entry.
+     * <P>
+     *
+     * <PRE>
+     * String findDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * LDAPEntry foundEntry = null;
+     * try {
+     *     foundEntry = myConn.read( findDN );
+     * } catch ( LDAPException e ) {
+     *     switch( e.getLDAPResultCode() ) {
+     *         case e.NO_SUCH_OBJECT:
+     *             System.out.println( "The specified entry does not exist." );
+     *             break;
+     *         case e.LDAP_PARTIAL_RESULTS:
+     *             System.out.println( "Entry served by a different LDAP server." );
+     *             break;
+     *         case e.INSUFFICIENT_ACCESS_RIGHTS:
+     *             System.out.println( "You do not have the access rights to perform this operation." );
+     *             break;
+     *         default:
+     *             System.out.println( "Error number: " + e.getLDAPResultCode() );
+     *             System.out.println( "Could not read the specified entry." );
+     *             break;
+     *     }
+     *     return;
+     * }
+     * System.out.println( "Found the specified entry." );
+     * </PRE>
+     *
+     * @param DN distinguished name of the entry to retrieve
+     * @param cons preferences for the read operation
+     * @exception LDAPException Failed to find or read the specified entry
+     * from the directory.
+     * @return LDAPEntry returns the specified entry or raises an exception
+     * if the entry is not found.
+     */
+    public LDAPEntry read (String DN, LDAPSearchConstraints cons)
+        throws LDAPException {
+        return read (DN, null, cons);
+    }
+
+    /**
+     * Reads the entry for the specified distinguished name (DN) and
+     * retrieves only the specified attributes from the entry.
+     * <P>
+     *
+     * For example, the following section of code reads the entry for
+     * Barbara Jensen and retrieves only the <CODE>cn</CODE> and
+     * <CODE>sn</CODE> attributes.
+     * The example prints out all attributes that have been retrieved
+     * (the two specified attributes).
+     * <P>
+     *
+     * <PRE>
+     * String findDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * LDAPEntry foundEntry = null;
+     * String getAttrs[] = { "cn", "sn" };
+     * try {
+     *      foundEntry = myConn.read( findDN, getAttrs );
+     * } catch ( LDAPException e ) {
+     *      switch( e.getLDAPResultCode() ) {
+     *           case e.NO_SUCH_OBJECT:
+     *               System.out.println( "The specified entry does not exist." );
+     *               break;
+     *           case e.LDAP_PARTIAL_RESULTS:
+     *               System.out.println( "Entry served by a different LDAP server." );
+     *               break;
+     *           case e.INSUFFICIENT_ACCESS_RIGHTS:
+     *               System.out.println( "You do not have the access " +
+     *                                   "rights to perform this operation." );
+     *               break;
+     *           default:
+     *               System.out.println( "Error number: " + e.getLDAPResultCode() );
+     *               System.out.println( "Could not read the specified entry." );
+     *               break;
+     *      }
+     *      return;
+     * }
+     *
+     * LDAPAttributeSet foundAttrs = foundEntry.getAttributeSet();
+     * int size = foundAttrs.size();
+     * Enumeration itrAttrs = foundAttrs.getAttributes();
+     * System.out.println( "Attributes: " );
+     *
+     * while ( itrAttrs.hasMoreElements() ) {
+     *      LDAPAttribute anAttr = ( LDAPAttribute )itrAttrs.nextElement();
+     *      String attrName = anAttr.getName();
+     *      System.out.println( "\t" + attrName );
+     *      Enumeration itrVals = anAttr.getStringValues();
+     *      while ( itrVals.hasMoreElements() ) {
+     *           String aVal = ( String )itrVals.nextElement();
+     *           System.out.println( "\t\t" + aVal );
+     *      }
+     * }
+     * </PRE>
+     *
+     * @param DN distinguished name of the entry to retrieve
+     * @param attrs names of attributes to retrieve
+     * @return LDAPEntry returns the specified entry (or raises an
+     * exception if the entry is not found).
+     * @exception LDAPException Failed to read the specified entry from
+     * the directory.
+     */
+    public LDAPEntry read (String DN, String attrs[]) throws LDAPException {
+        return read(DN, attrs, m_defaultConstraints);
+    }
+
+    public LDAPEntry read (String DN, String attrs[],
+        LDAPSearchConstraints cons) throws LDAPException {
+        LDAPSearchResults results =
+            search (DN, SCOPE_BASE,
+                    "(|(objectclass=*)(objectclass=ldapsubentry))",
+                    attrs, false, cons);
+        if (results == null) {
+            return null;
+        }
+        LDAPEntry entry = results.next();
+        
+        // cleanup required for referral connections
+        while (results.hasMoreElements()) {
+            results.nextElement();
+        }
+        
+        return entry;
+    }
+
+    /**
+     * Reads the entry specified by the LDAP URL. <P>
+     *
+     * When you call this method, a new connection is created automatically,
+     * using the host and port specified in the URL. After finding the entry,
+     * the method closes this connection (in other words, it disconnects from
+     * the LDAP server). <P>
+     *
+     * If the URL specifies a filter and scope, these are not used.
+     * Of the information specified in the URL, this method only uses
+     * the LDAP host name and port number, the base distinguished name (DN),
+     * and the list of attributes to return. <P>
+     *
+     * The method returns the entry specified by the base DN. <P>
+     *
+     * (Note: If you want to search for more than one entry, use the
+     * <CODE>search( LDAPUrl )</CODE> method instead.) <P>
+     *
+     * For example, the following section of code reads the entry specified
+     * by the LDAP URL.
+     * <P>
+     *
+     * <PRE>
+     * String flatURL = "ldap://alway.mcom.com:3890/cn=Barbara Jenson,ou=Product Development,o=Ace Industry,c=US?cn,sn,mail";
+     * LDAPUrl myURL;
+     * try {
+     *    myURL = new LDAPUrl( flatURL );
+     * } catch ( java.net.MalformedURLException e ) {
+     *    System.out.println( "BAD URL!!!  BAD, BAD, BAD URL!!!" );
+     *    return;
+     * }
+     * LDAPEntry myEntry = null;
+     * try {
+     *    myEntry = myConn.read( myURL );
+     * } catch ( LDAPException e ) {
+     *    int errCode = e.getLDAPResultCode();
+     *    switch( errCode ) {
+     *        case ( e.NO_SUCH_OBJECT ):
+     *            System.out.println( "The specified entry " + myDN +
+     *                                " does not exist in the directory." );
+     *            return;
+     *        default:
+     *            System.out.println( "An internal error occurred." );
+     *            return;
+     *    }
+     * }
+     * </PRE>
+     *
+     * @param toGet LDAP URL specifying the entry to read
+     * @return LDAPEntry returns the entry specified by the URL (or raises
+     * an exception if the entry is not found).
+     * @exception LDAPException Failed to read the specified entry from
+     * the directory.
+     * @see netscape.ldap.LDAPUrl
+     * @see netscape.ldap.LDAPConnection#search(netscape.ldap.LDAPUrl)
+     */
+    public static LDAPEntry read (LDAPUrl toGet) throws LDAPException {
+        String host = toGet.getHost ();
+        int port = toGet.getPort();
+
+        if (host == null) {
+            throw new LDAPException ( "no host for connection",
+                                    LDAPException.PARAM_ERROR );
+        }
+
+        String[] attributes = toGet.getAttributeArray ();
+        String DN = toGet.getDN();
+        LDAPEntry returnValue;
+
+        LDAPConnection connection = new LDAPConnection ();
+        if (toGet.isSecure()) {
+            LDAPSocketFactory factory = toGet.getSocketFactory();
+            if (factory == null) {
+                throw new LDAPException("No socket factory for LDAPUrl",
+                                         LDAPException.OTHER);
+            }
+            connection.setSocketFactory(factory);
+        }
+        connection.connect (host, port);
+
+        returnValue = connection.read (DN, attributes);
+        connection.disconnect ();
+
+        return returnValue;
+    }
+
+    /**
+     * Performs the search specified by the LDAP URL. <P>
+     *
+     * For example, the following section of code searches for all entries under
+     * the <CODE>ou=Product Development,o=Ace Industry,c=US</CODE> subtree of a
+     * directory.  The example gets and prints the mail attribute for each entry
+     * found. <P>
+     *
+     * <PRE>
+     * String flatURL = "ldap://alway.mcom.com:3890/ou=Product Development,o=Ace Industry,c=US?mail?sub?objectclass=*";
+     * LDAPUrl myURL;
+     * try {
+     *    myURL = new LDAPUrl( flatURL );
+     * } catch ( java.net.MalformedURLException e ) {
+     *    System.out.println( "Incorrect URL syntax." );
+     *    return;
+     * }
+     *
+     * LDAPSearchResults myResults = null;
+     * try {
+     *    myResults = myConn.search( myURL );
+     * } catch ( LDAPException e ) {
+     *    int errCode = e.getLDAPResultCode();
+     *    System.out.println( "LDAPException: return code:" + errCode );
+     *    return;
+     * }
+     *
+     * while ( myResults.hasMoreElements() ) {
+     *    LDAPEntry myEntry = myResults.next();
+     *    String nextDN = myEntry.getDN();
+     *    System.out.println( nextDN );
+     *    LDAPAttributeSet entryAttrs = myEntry.getAttributeSet();
+     *    Enumeration attrsInSet = entryAttrs.getAttributes();
+     *    while ( attrsInSet.hasMoreElements() ) {
+     *        LDAPAttribute nextAttr = (LDAPAttribute)attrsInSet.nextElement();
+     *        String attrName = nextAttr.getName();
+     *        System.out.print( "\t" + attrName + ": " );
+     *        Enumeration valsInAttr = nextAttr.getStringValues();
+     *        while ( valsInAttr.hasMoreElements() ) {
+     *            String nextValue = (String)valsInAttr.nextElement();
+     *            System.out.println( nextValue );
+     *        }
+     *    }
+     * }
+     * </PRE>
+     * <P>
+     *
+     * To abandon the search, use the <CODE>abandon</CODE> method.
+     *
+     * @param toGet LDAP URL representing the search to perform
+     * @return LDAPSearchResults the results of the search as an enumeration.
+     * @exception LDAPException Failed to complete the search specified by
+     * the LDAP URL.
+     * @see netscape.ldap.LDAPUrl
+     * @see netscape.ldap.LDAPSearchResults
+     * @see netscape.ldap.LDAPConnection#abandon(netscape.ldap.LDAPSearchResults)
+     */
+    public static LDAPSearchResults search (LDAPUrl toGet) throws LDAPException {
+        return search (toGet, null);
+    }
+
+    /**
+     * Performs the search specified by the LDAP URL. This method also
+     * allows you to specify constraints for the search (such as the
+     * maximum number of entries to find or the
+     * maximum time to wait for search results). <P>
+     *
+     * As part of the search constraints, you can specify whether or not you
+     * want the results delivered all at once or in smaller batches.
+     * If you specify the results delivered in smaller
+     * batches, each iteration blocks until the next batch of results is
+     * returned. <P>
+     *
+     * For example, the following section of code retrieves the first 5
+     * matching entries for the search specified by the LDAP URL.  The
+     * example accomplishes this by creating a new set of search
+     * constraints where the maximum number of search results is 5. <P>
+     *
+     * <PRE>
+     * LDAPSearchConstraints mySearchConstraints = myConn.getSearchConstraints();
+     * mySearchConstraints.setMaxResults( 5 );
+     * String flatURL = "ldap://alway.mcom.com:3890/ou=Product Development,o=Ace Industry,c=US?mail?sub?objectclass=*";
+     * LDAPUrl myURL;
+     * try {
+     *    myURL = new LDAPUrl( flatURL );
+     * } catch ( java.net.MalformedURLException e ) {
+     *    System.out.println( "Incorrect URL syntax." );
+     *    return;
+     * }
+     * LDAPSearchResults myResults = null;
+     * try {
+     *    myResults = myConn.search( myURL, mySearchConstraints );
+     * } catch ( LDAPException e ) {
+     *    int errCode = e.getLDAPResultCode();
+     *    System.out.println( "LDAPException: return code:" + errCode );
+     *    return;
+     * }
+     * </PRE>
+     * <P>
+     *
+     * To abandon the search, use the <CODE>abandon</CODE> method.
+     *
+     * @param toGet LDAP URL representing the search to run
+     * @param cons constraints specific to the search
+     * @return LDAPSearchResults the results of the search as an enumeration.
+     * @exception LDAPException Failed to complete the search specified
+     * by the LDAP URL.
+     * @see netscape.ldap.LDAPUrl
+     * @see netscape.ldap.LDAPSearchResults
+     * @see netscape.ldap.LDAPConnection#abandon(netscape.ldap.LDAPSearchResults)
+     */
+    public static LDAPSearchResults search (LDAPUrl toGet,
+        LDAPSearchConstraints cons) throws LDAPException {
+        String host = toGet.getHost ();
+        int port = toGet.getPort();
+
+        if (host == null) {
+            throw new LDAPException ( "no host for connection",
+                                    LDAPException.PARAM_ERROR );
+        }
+
+        String[] attributes = toGet.getAttributeArray ();
+        String DN = toGet.getDN();
+        String filter = toGet.getFilter();
+        if (filter == null) {
+            filter = defaultFilter;
+        }
+        int scope = toGet.getScope ();
+
+        LDAPConnection connection = new LDAPConnection ();
+        if (toGet.isSecure()) {
+            LDAPSocketFactory factory = toGet.getSocketFactory();
+            if (factory == null) {
+                throw new LDAPException("No socket factory for LDAPUrl",
+                                         LDAPException.OTHER);
+            }
+            connection.setSocketFactory(factory);
+        }        
+        connection.connect (host, port);
+
+        LDAPSearchResults results;
+        if (cons != null) {
+            results = connection.search (DN, scope, filter, attributes, false, cons);
+        } else {
+            results = connection.search (DN, scope, filter, attributes, false);
+        }
+
+        results.closeOnCompletion(connection);
+
+        return results;
+    }
+
+    /**
+     * Performs the search specified by the criteria that you enter. <P>
+     *
+     * For example, the following section of code searches for all entries under
+     * the <CODE>ou=Product Development,o=Ace Industry,c=US</CODE> subtree of a
+     * directory.  The example gets and prints the mail attribute for each entry
+     * found. <P>
+     *
+     * <PRE>
+     * String myBaseDN = "ou=Product Development,o=Ace Industry,c=US";
+     * String myFilter="(objectclass=*)";
+     * String[] myAttrs = { "mail" };
+     *
+     * LDAPSearchResults myResults = null;
+     * try {
+     *    myResults = myConn.search( myBaseDN, LDAPv2.SCOPE_SUB, myFilter, myAttrs, false );
+     * } catch ( LDAPException e ) {
+     *    int errCode = e.getLDAPResultCode();
+     *    System.out.println( "LDAPException: return code:" + errCode );
+     *    return;
+     * }
+     *
+     * while ( myResults.hasMoreElements() ) {
+     *    LDAPEntry myEntry = myResults.next();
+     *    String nextDN = myEntry.getDN();
+     *    System.out.println( nextDN );
+     *    LDAPAttributeSet entryAttrs = myEntry.getAttributeSet();
+     *    Enumeration attrsInSet = entryAttrs.getAttributes();
+     *    while ( attrsInSet.hasMoreElements() ) {
+     *        LDAPAttribute nextAttr = (LDAPAttribute)attrsInSet.nextElement();
+     *        String attrName = nextAttr.getName();
+     *        System.out.println( "\t" + attrName + ":" );
+     *        Enumeration valsInAttr = nextAttr.getStringValues();
+     *        while ( valsInAttr.hasMoreElements() ) {
+     *            String nextValue = (String)valsInAttr.nextElement();
+     *            System.out.println( "\t\t" + nextValue );
+     *        }
+     *    }
+     * }
+     * </PRE>
+     * <P>
+     *
+     * To abandon the search, use the <CODE>abandon</CODE> method.
+     *
+     * @param base the base distinguished name from which to search
+     * @param scope the scope of the entries to search.  You can specify one
+     * of the following: <P>
+     * <UL>
+     * <LI><CODE>LDAPv2.SCOPE_BASE</CODE> (search only the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_ONE</CODE>
+     * (search only entries under the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_SUB</CODE>
+     * (search the base DN and all entries within its subtree) <P>
+     * </UL>
+     * <P>
+     * @param filter search filter specifying the search criteria
+     * @param attrs list of attributes that you want returned in the
+     * search results
+     * @param attrsOnly if true, returns the names but not the values of the
+     * attributes found.  If false, returns the names and values for
+     * attributes found
+     * @return LDAPSearchResults the results of the search as an enumeration.
+     * @exception LDAPException Failed to complete the specified search.
+     * @see netscape.ldap.LDAPConnection#abandon(netscape.ldap.LDAPSearchResults)
+     */
+    public LDAPSearchResults search( String base, int scope, String filter,
+        String[] attrs, boolean attrsOnly ) throws LDAPException {
+        return search( base, scope, filter, attrs, attrsOnly, m_defaultConstraints);
+    }
+
+    /**
+     * Performs the search specified by the criteria that you enter.
+     * This method also allows you to specify constraints for the search
+     * (such as the maximum number of entries to find or the
+     * maximum time to wait for search results). <P>
+     *
+     * As part of the search constraints, you can specify whether or not
+     * you want the
+     * results delivered all at once or in smaller batches.  If you
+     * specify that you want the results delivered in smaller batches,
+     * each iteration blocks until the
+     * next batch of results is returned. <P>
+     *
+     * For example, the following section of code retrieves the first 5 entries
+     * matching the specified search criteria.  The example accomplishes
+     * this by creating a new set of search constraints where the maximum
+     * number of search results is 5. <P>
+     *
+     * <PRE>
+     * String myBaseDN = "ou=Product Development,o=Ace Industry,c=US";
+     * String myFilter="(objectclass=*)";
+     * String[] myAttrs = { "mail" };
+     * LDAPSearchConstraints mySearchConstraints = myConn.getSearchConstraints();
+     * mySearchConstraints.setMaxResults( 5 );
+     *
+     * LDAPSearchResults myResults = null;
+     * try {
+     *    myResults = myConn.search( myBaseDN, LDAPv2.SCOPE_SUB, myFilter, myAttrs, false, mySearchConstraints );
+     * } catch ( LDAPException e ) {
+     *    int errCode = e.getLDAPResultCode();
+     *    System.out.println( "LDAPException: return code:" + errCode );
+     *    return;
+     * }
+     * </PRE>
+     * <P>
+     *
+     * To abandon the search, use the <CODE>abandon</CODE> method.
+     *
+     * @param base the base distinguished name from which to search
+     * @param scope the scope of the entries to search.  You can specify one
+     * of the following: <P>
+     * <UL>
+     * <LI><CODE>LDAPv2.SCOPE_BASE</CODE> (search only the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_ONE</CODE>
+     * (search only entries under the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_SUB</CODE>
+     * (search the base DN and all entries within its subtree) <P>
+     * </UL>
+     * <P>
+     * @param filter search filter specifying the search criteria
+     * @param attrs list of attributes to return in the search
+     * results
+     * @param cons constraints specific to this search (for example, the
+     * maximum number of entries to return)
+     * @param attrsOnly if true, returns the names but not the values of the
+     * attributes found.  If false, returns the names and  values for
+     * attributes found
+     * @return LDAPSearchResults the results of the search as an enumeration.
+     * @exception LDAPException Failed to complete the specified search.
+     * @see netscape.ldap.LDAPConnection#abandon(netscape.ldap.LDAPSearchResults)
+     */
+    public LDAPSearchResults search( String base, int scope, String filter,
+        String[] attrs, boolean attrsOnly, LDAPSearchConstraints cons )
+        throws LDAPException {
+        if (cons == null) {
+            cons = m_defaultConstraints;
+        }
+
+        LDAPSearchResults returnValue =
+            new LDAPSearchResults(this, cons, base, scope, filter,
+                                  attrs, attrsOnly);
+        Vector cacheValue = null;
+        Long key = null;
+        boolean isKeyValid = true;
+
+        try {
+            // get entry from cache which is a vector of JDAPMessages
+            if (m_cache != null) {
+                // create key for cache entry using search arguments
+                key = m_cache.createKey(getHost(), getPort(),base, filter,
+                                        scope, attrs, m_boundDN, cons);
+
+                cacheValue = (Vector)m_cache.getEntry(key);
+
+                if (cacheValue != null) {
+                    return (new LDAPSearchResults(cacheValue, this, cons, base, scope,
+                                                  filter, attrs, attrsOnly));
+                }
+            }
+        } catch (LDAPException e) {
+            isKeyValid = false;
+            printDebug("Exception: "+e);
+        }
+
+        checkConnection(/*rebind=*/true);
+
+        /* Is this a persistent search? */
+        boolean isPersistentSearch = false;
+        LDAPControl[] controls =
+            (LDAPControl[])getOption(LDAPv3.SERVERCONTROLS, cons);
+        for (int i = 0; (controls != null) && (i < controls.length); i++) {
+            if ( controls[i] instanceof
+                 netscape.ldap.controls.LDAPPersistSearchControl ) {
+                isPersistentSearch = true;
+                break;
+            }
+        }
+
+        // Persistent search is an asynchronous operation
+        LDAPSearchListener myListener = isPersistentSearch ? new LDAPSearchListener(/*asynchOp=*/true, cons) :
+                                        getSearchListener ( cons );
+
+        int deref = cons.getDereference();
+
+        JDAPSearchRequest request = null;        
+        try {
+            request = new JDAPSearchRequest (base, scope, deref,
+                cons.getMaxResults(), cons.getServerTimeLimit(),
+                attrsOnly, filter, attrs);
+        } catch (IllegalArgumentException e) {
+            throw new LDAPException(e.getMessage(), LDAPException.PARAM_ERROR);
+        }
+
+        // if using cache, then need to add the key to the search listener.
+        if ((m_cache != null) && (isKeyValid)) {
+            myListener.setKey(key);
+
+        }
+        
+        try {
+            sendRequest (request, myListener, cons);
+        }
+        catch (LDAPException e) {
+            releaseSearchListener (myListener);
+            throw e;                    
+        }
+
+        /* For a persistent search, don't wait for a first result, because
+           there may be none at this time if changesOnly was specified in
+           the control.
+        */
+        if ( isPersistentSearch ) {
+            returnValue.associatePersistentSearch (myListener);
+
+        } else if ( cons.getBatchSize() == 0 ) {
+            /* Synchronous search if all requested at once */
+            try {
+                /* Block until all results are in */
+                LDAPMessage response = myListener.completeSearchOperation();
+                Enumeration results = myListener.getAllMessages().elements();
+
+                checkSearchMsg(returnValue, response, cons, base, scope,
+                               filter, attrs, attrsOnly);
+
+                while (results.hasMoreElements ()) {
+                    LDAPMessage msg = (LDAPMessage)results.nextElement();
+
+                    checkSearchMsg(returnValue, msg, cons, base, scope, filter, attrs,
+                        attrsOnly);
+                }
+            } finally {
+                releaseSearchListener (myListener);
+            }
+        } else {
+            /*
+            * Asynchronous to retrieve one at a time, check to make sure
+            * the search didn't fail
+            */
+            LDAPMessage firstResult = myListener.nextMessage ();
+            if ( firstResult instanceof LDAPResponse ) {
+                try {
+                    checkSearchMsg(returnValue, firstResult, cons, base, scope,
+                                   filter, attrs, attrsOnly);
+                } finally {
+                    releaseSearchListener (myListener);
+                }
+            } else {
+                try {
+                    checkSearchMsg(returnValue, firstResult, cons, base,
+                                   scope, filter, attrs, attrsOnly);
+                } catch ( LDAPException ex ) {
+                    releaseSearchListener (myListener);
+                    throw ex;
+                }
+
+                /* we let this listener get garbage collected.. */
+                returnValue.associate (myListener);
+            }
+        }
+        return returnValue;
+    }
+
+    void checkSearchMsg(LDAPSearchResults value, LDAPMessage msg,
+        LDAPSearchConstraints cons, String dn, int scope, String filter,
+        String attrs[], boolean attrsOnly) throws LDAPException {
+
+        value.setMsgID(msg.getMessageID());
+
+        try {
+            checkMsg (msg);
+            // not the JDAPResult
+            if (msg.getProtocolOp().getType() != JDAPProtocolOp.SEARCH_RESULT) {
+                value.add (msg);
+            }
+        } catch (LDAPReferralException e) {
+            Vector res = new Vector();
+            
+            try {
+                performReferrals(e, cons, JDAPProtocolOp.SEARCH_REQUEST, dn,
+                    scope, filter, attrs, attrsOnly, null, null, null, res);
+            }
+            catch (LDAPException ex) {
+                if (msg.getProtocolOp() instanceof JDAPSearchResultReference) {
+                    // Ignore Search Result Referral Errors ?
+                    if (cons.getReferralErrors() == cons.REFERRAL_ERROR_CONTINUE) {
+                        return; // Don't want to miss all remaining results
+                    }
+                    else {
+                        throw ex;
+                    }
+                }
+                throw ex;
+            }
+
+            // the size of the vector can be more than 1 because it is possible
+            // to visit more than one referral url to retrieve the entries
+            for (int i=0; i<res.size(); i++) {
+                value.addReferralEntries((LDAPSearchResults)res.elementAt(i));
+            }
+
+            res = null;
+        } catch (LDAPException e) {
+            if ((e.getLDAPResultCode() == LDAPException.ADMIN_LIMIT_EXCEEDED) ||
+                (e.getLDAPResultCode() == LDAPException.TIME_LIMIT_EXCEEDED) ||
+                (e.getLDAPResultCode() == LDAPException.SIZE_LIMIT_EXCEEDED)) {
+                value.add(e);
+            } else {
+                throw e;
+            }
+        }
+    }
+
+    /**
+     * Checks to see if an entry contains an attribute with a specified value.
+     * Returns <CODE>true</CODE> if the entry has the value. Returns
+     * <CODE>false</CODE> if the entry does not have the value or the
+     * attribute. To represent the value that you want compared, you need
+     * to create an <CODE>LDAPAttribute</CODE> object.<P>
+     *
+     * Note that only string values can be compared. <P>
+     *
+     * For example, the following section of code checks to see if the entry
+     * "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US" contains
+     * the attribute "mail" with the value "bjensen@aceindustry.com".
+     *
+     * <PRE>
+     * ...
+     * LDAPConnection myConn = new LDAPConnection();
+     * ...
+     * String myDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * String nameOfAttr = "mail";
+     * String valOfAttr = "bjensen@aceindustry.com";
+     * LDAPAttribute cmpThisAttr = new LDAPAttribute( nameOfAttr, valOfAttr );
+     * boolean hasValue = myConn.compare( myDN, cmpThisAttr );
+     * if ( hasValue ) {
+     *     System.out.println( "Attribute and value found in entry." );
+     * } else {
+     *     System.out.println( "Attribute and value not found in entry." );
+     * }
+     * ...</PRE>
+     *
+     * @param DN the distinguished name of the entry to use in
+     * the comparison
+     * @param attr the attribute to compare against the entry.
+     * (The method checks to see if the entry has an attribute with the same name
+     * and value as this attribute.)
+     * @return true if the entry contains the specified attribute and value.
+     * @exception LDAPException Failed to perform the comparison.
+     * @see netscape.ldap.LDAPAttribute
+     */
+    public boolean compare( String DN, LDAPAttribute attr )
+        throws LDAPException {
+        return compare(DN, attr, m_defaultConstraints);
+    }
+
+    public boolean compare( String DN, LDAPAttribute attr,
+        LDAPConstraints cons) throws LDAPException {
+        checkConnection(/*rebind=*/true);
+
+        LDAPResponseListener myListener = getResponseListener ();
+        Enumeration en = attr.getStringValues();
+        String val = (String)en.nextElement();
+        JDAPAVA ass = new JDAPAVA(attr.getName(), val);
+
+        LDAPMessage response;
+        try {
+            sendRequest (new JDAPCompareRequest (DN, ass), myListener, cons);
+            response = myListener.getResponse ();
+
+            int resultCode = ((JDAPResult)response.getProtocolOp()).getResultCode();
+            if (resultCode == JDAPResult.COMPARE_FALSE) {
+                return false;
+            }
+            if (resultCode == JDAPResult.COMPARE_TRUE) {
+                return true;
+            }
+
+            checkMsg (response);
+
+        } catch (LDAPReferralException e) {
+            Vector res = new Vector();
+            performReferrals(e, cons, JDAPProtocolOp.COMPARE_REQUEST,
+                             DN, 0, null, null, false, null, null, attr, res);
+            boolean bool = false;
+            if (res.size() > 0) {
+               bool = ((Boolean)res.elementAt(0)).booleanValue();
+            }
+            return bool;
+        } finally {
+            releaseResponseListener (myListener);
+        }
+        return false; /* this should never be executed */
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public boolean compare( String DN, LDAPAttribute attr,
+        LDAPSearchConstraints cons) throws LDAPException {
+        return compare(DN, attr, (LDAPConstraints) cons);
+    }        
+    
+    /**
+     * Adds an entry to the directory. <P>
+     *
+     * Before using this method, you need to create an
+     * <CODE>LDAPEntry</CODE> object and use it to specify the
+     * distinguished name and attributes of the new entry. Make sure
+     * to specify values for all required attributes in the
+     * entry. If all required attributes are not specified and the LDAP server
+     * checks the entry against the schema, an <CODE>LDAPException</CODE>
+     * may be thrown (where the LDAP result code is
+     * <CODE>OBJECT_CLASS_VIOLATION</CODE>).<P>
+     *
+     * For example, the following section of code creates an
+     * <CODE>LDAPEntry</CODE> object for a new entry and uses the object
+     * to add the new entry to the directory. Because the definition of
+     * the LDAP <CODE>inetOrgPerson</CODE> class specifies that the
+     * <CODE>cn</CODE>, <CODE>sn</CODE>, and <CODE>objectclass</CODE>
+     * attributes are required, these attributes are specified as part
+     * of the new entry.  (<CODE>mail</CODE> is not required but is shown
+     * here as an example of specifying additional attributes.)
+     * <P>
+     *
+     * <PRE>
+     * ...
+     * String myDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     *
+     * LDAPAttribute attr1 = new LDAPAttribute( "cn", "Barbara Jensen" );
+     * LDAPAttribute attr2 = new LDAPAttribute( "sn", "Jensen" );
+     * LDAPAttribute attr3 = new LDAPAttribute( "objectclass", "top" );
+     * LDAPAttribute attr4 = new LDAPAttribute( "objectclass", "person" );
+     * LDAPAttribute attr5 = new LDAPAttribute( "objectclass", "organizationalPerson" );
+     * LDAPAttribute attr6 = new LDAPAttribute( "objectclass", "inetOrgPerson" );
+     * LDAPAttribute attr7 = new LDAPAttribute( "mail", "bjensen@aceindustry.com" );
+     *
+     * LDAPAttributeSet myAttrs = new LDAPAttributeSet();
+     * myAttrs.add( attr1 );
+     * myAttrs.add( attr2 );
+     * myAttrs.add( attr3 );
+     * myAttrs.add( attr4 );
+     * myAttrs.add( attr5 );
+     * myAttrs.add( attr6 );
+     * myAttrs.add( attr7 );
+     *
+     * LDAPEntry myEntry = new LDAPEntry( myDN, myAttrs );
+     *
+     * myConn.add( myEntry );
+     * ... </PRE>
+     *
+     * @param entry LDAPEntry object specifying the distinguished name and
+     * attributes of the new entry
+     * @exception LDAPException Failed to add the specified entry to the
+     * directory.
+     * @see netscape.ldap.LDAPEntry
+     */
+    public void add( LDAPEntry entry ) throws LDAPException {
+        add(entry, m_defaultConstraints);
+    }
+
+    /**
+     * Adds an entry to the directory and allows you to specify preferences
+     * for this LDAP add operation by using an
+     * <CODE>LDAPConstraints</CODE> object. For
+     * example, you can specify whether or not to follow referrals.
+     * You can also apply LDAP v3 controls to the operation.
+     * <P>
+     *
+     * @param entry LDAPEntry object specifying the distinguished name and
+     * attributes of the new entry
+     * @param cons the set of preferences to apply to this operation
+     * @exception LDAPException Failed to add the specified entry to the
+     * directory.
+     * @see netscape.ldap.LDAPEntry
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public void add( LDAPEntry entry, LDAPConstraints cons )
+        throws LDAPException {
+        checkConnection(/*rebind=*/true);
+
+        LDAPResponseListener myListener = getResponseListener ();
+        LDAPAttributeSet attrs = entry.getAttributeSet ();
+        LDAPAttribute[] attrList = new LDAPAttribute[attrs.size()];
+        for( int i = 0; i < attrs.size(); i++ ) {
+            attrList[i] = (LDAPAttribute)attrs.elementAt( i );
+        }
+        int attrPosition = 0;
+        LDAPMessage response;
+        try {
+            sendRequest (new JDAPAddRequest (entry.getDN(), attrList),
+                         myListener, cons);
+            response = myListener.getResponse();
+            checkMsg (response);
+        } catch (LDAPReferralException e) {
+            performReferrals(e, cons, JDAPProtocolOp.ADD_REQUEST,
+                             null, 0, null, null, false, null, entry, null, null);
+        } finally {
+            releaseResponseListener (myListener);
+        }
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void add( LDAPEntry entry, LDAPSearchConstraints cons )
+        throws LDAPException {
+        add(entry, (LDAPConstraints) cons);
+    }
+
+    /**
+     * Performs an extended operation on the directory.  Extended operations
+     * are part of version 3 of the LDAP protocol.<P>
+     *
+     * Note that in order for the extended operation to work, the server
+     * that you are connecting to must support LDAP v3 and must be configured
+     * to process the specified extended operation.
+     *
+     * @param op LDAPExtendedOperation object specifying the OID of the
+     * extended operation and the data to use in the operation
+     * @exception LDAPException Failed to execute the operation
+     * @return LDAPExtendedOperation object representing the extended response
+     * returned by the server.
+     * @see netscape.ldap.LDAPExtendedOperation
+     */
+    public LDAPExtendedOperation extendedOperation( LDAPExtendedOperation op )
+        throws LDAPException {
+
+        return extendedOperation(op, m_defaultConstraints);
+    }
+
+    /**
+     * Performs an extended operation on the directory.  Extended operations
+     * are part of version 3 of the LDAP protocol. This method allows the
+     * user to set the preferences for the operation.<P>
+     *
+     * Note that in order for the extended operation to work, the server
+     * that you are connecting to must support LDAP v3 and must be configured
+     * to process the specified extended operation.
+     *
+     * @param op LDAPExtendedOperation object specifying the OID of the
+     * extended operation and the data to use in the operation
+     * @param cons preferences for the extended operation
+     * @exception LDAPException Failed to execute the operation
+     * @return LDAPExtendedOperation object representing the extended response
+     * returned by the server.
+     * @see netscape.ldap.LDAPExtendedOperation
+     */
+    public LDAPExtendedOperation extendedOperation( LDAPExtendedOperation op,
+                                                    LDAPConstraints cons)
+        throws LDAPException {
+        checkConnection(/*rebind=*/true);
+
+        LDAPResponseListener myListener = getResponseListener ();
+        LDAPMessage response = null;
+        byte[] results = null;
+        String resultID;
+
+        try {
+            sendRequest ( new JDAPExtendedRequest( op.getID(),
+                                                   op.getValue() ),
+                          myListener, cons );
+            response = myListener.getResponse();
+            checkMsg (response);
+            JDAPExtendedResponse res = (JDAPExtendedResponse)response.getProtocolOp();
+            results = res.getValue();
+            resultID = res.getID();
+        } catch (LDAPReferralException e) {
+            return performExtendedReferrals( e, cons, op );
+        } finally {
+            releaseResponseListener (myListener);
+        }
+        return new LDAPExtendedOperation( resultID, results );
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public LDAPExtendedOperation extendedOperation( LDAPExtendedOperation op,
+                                                    LDAPSearchConstraints cons)
+        throws LDAPException {
+
+        return extendedOperation(op, (LDAPConstraints)cons);
+    }
+
+    /**
+     * Makes a single change to an existing entry in the directory.
+     * For example, changes the value of an attribute, adds a new
+     * attribute value, or removes an existing attribute value. <P>
+     *
+     * Use the <CODE>LDAPModification</CODE> object to specify the change
+     * to make and the <CODE>LDAPAttribute</CODE> object
+     * to specify the attribute value to change. The
+     * <CODE>LDAPModification</CODE> object allows you add an attribute
+     * value, change an attibute value, or remove an attribute
+     * value. <P>
+     *
+     * For example, the following section of code changes Barbara Jensen's email
+     * address in the directory to babs@aceindustry.com. <P>
+     *
+     * <PRE>
+     * ...
+     * String myEntryDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     *
+     * LDAPAttribute attrEmail = new LDAPAttribute( "mail", "babs@aceindustry.com" );
+     * LDAPModification singleChange = new LDAPModification( LDAPModification.REPLACE, attrEmail );
+     *
+     * myConn.modify( myEntryDN, singleChange );
+     * ... </PRE>
+     *
+     * @param DN the distinguished name of the entry to modify
+     * @param mod a single change to make to the entry
+     * @exception LDAPException Failed to make the specified change to the
+     * directory entry.
+     * @see netscape.ldap.LDAPModification
+     */
+    public void modify( String DN, LDAPModification mod ) throws LDAPException {
+        modify(DN, mod, m_defaultConstraints);
+    }
+
+   /**
+    * Makes a single change to an existing entry in the directory and
+    * allows you to specify preferences for this LDAP modify operation
+    * by using an <CODE>LDAPConstraints</CODE> object.
+    * For example, you can specify whether or not to follow referrals.
+    * You can also apply LDAP v3 controls to the operation.
+    * <P>
+    *
+    * @param DN the distinguished name of the entry to modify
+    * @param mod a single change to make to the entry
+    * @param cons the set of preferences to apply to this operation
+    * @exception LDAPException Failed to make the specified change to the
+    * directory entry.
+    * @see netscape.ldap.LDAPModification
+    * @see netscape.ldap.LDAPConstraints
+    */
+    public void modify( String DN, LDAPModification mod,
+        LDAPConstraints cons ) throws LDAPException {
+        LDAPModification[] mods = { mod };
+        modify (DN, mods, cons);
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void modify( String DN, LDAPModification mod,
+        LDAPSearchConstraints cons ) throws LDAPException {
+        modify (DN, mod, (LDAPConstraints)cons);
+    }        
+
+    /**
+     * Makes a set of changes to an existing entry in the directory.
+     * For example, changes attribute values, adds new attribute values,
+     * or removes existing attribute values. <P>
+     *
+     * Use the <CODE>LDAPModificationSet</CODE> object to specify the set
+     * of changes to make.  Changes are specified in terms
+     * of attribute values.  You must specify each attribute value to modify, add,
+     * or remove by an <CODE>LDAPAttribute</CODE> object.
+     * <P>
+     *
+     * For example, the following section of code changes Barbara Jensen's
+     * title, adds a telephone number to the entry, and removes the room
+     * number from the entry. <P>
+     *
+     * <PRE>
+     * ...
+     * String myEntryDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     *
+     * LDAPModificationSet manyChanges = new LDAPModificationSet();
+     * LDAPAttribute attrTelephoneNumber = new LDAPAttribute( "telephoneNumber",
+     *                                                        "555-1212" );
+     * manyChanges.add( LDAPModification.ADD, attrTelephoneNumber );
+     * LDAPAttribute attrRoomNumber = new LDAPAttribute( "roomnumber", "222" );
+     * manyChanges.add( LDAPModification.DELETE, attrRoomNumber );
+     * LDAPAttribute attrTitle = new LDAPAttribute( "title",
+     *                                       "Manager of Product Development" );
+     * manyChanges.add( LDAPModification.REPLACE, attrTitle );
+     *
+     * myConn.modify( myEntryDN, manyChanges );
+     * ... </PRE>
+     *
+     * @param DN the distinguished name of the entry to modify
+     * @param mods a set of changes to make to the entry
+     * @exception LDAPException Failed to make the specified changes to the
+     * directory entry.
+     * @see netscape.ldap.LDAPModificationSet
+     */
+    public void modify (String DN, LDAPModificationSet mods)
+        throws LDAPException {
+        modify(DN, mods, m_defaultConstraints);
+    }
+
+    /**
+     * Makes a set of changes to an existing entry in the directory and
+     * allows you to specify preferences for this LDAP modify operation
+     * by using an <CODE>LDAPConstraints</CODE> object.
+     * For example, you can specify whether or not to follow referrals.
+     * You can also apply LDAP v3 controls to the operation.
+     * <P>
+     *
+     * @param DN the distinguished name of the entry to modify
+     * @param mods a set of changes to make to the entry
+     * @param cons the set of preferences to apply to this operation
+     * @exception LDAPException Failed to make the specified changes to the
+     * directory entry.
+     * @see netscape.ldap.LDAPModificationSet
+     * @see netscape.ldap.LDAPConstraints
+     */
+     public void modify (String DN, LDAPModificationSet mods,
+         LDAPConstraints cons) throws LDAPException {
+         LDAPModification[] modList = new LDAPModification[mods.size()];
+         for( int i = 0; i < mods.size(); i++ ) {
+             modList[i] = mods.elementAt( i );
+         }
+         modify (DN, modList, cons);
+     }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+     public void modify (String DN, LDAPModificationSet mods,
+         LDAPSearchConstraints cons) throws LDAPException {
+         modify(DN, mods, (LDAPConstraints)cons);
+    }    
+     
+    /**
+     * Makes a set of changes to an existing entry in the directory.
+     * For example, changes attribute values, adds new attribute values,
+     * or removes existing attribute values. <P>
+     *
+     * Use an array of <CODE>LDAPModification</CODE> objects to specify the
+     * changes to make.  Each change must be specified by
+     * an <CODE>LDAPModification</CODE> object, and you must specify each 
+     * attribute value to modify, add, or remove by an <CODE>LDAPAttribute</CODE> 
+     * object. <P>
+     *
+     * @param DN the distinguished name of the entry to modify
+     * @param mods an array of objects representing the changes to make
+     * to the entry
+     * @exception LDAPException Failed to make the specified changes to the
+     * directory entry.
+     * @see netscape.ldap.LDAPModification
+     */
+    public void modify (String DN, LDAPModification[] mods)
+        throws LDAPException {
+        modify(DN, mods, m_defaultConstraints);
+    }
+
+    /**
+     * Makes a set of changes to an existing entry in the directory and
+     * allows you to specify preferences for this LDAP modify operation
+     * by using an <CODE>LDAPConstraints</CODE> object.
+     * For example, you can specify whether or not to follow referrals.
+     * You can also apply LDAP v3 controls to the operation.
+     * <P>
+     *
+     * @param DN the distinguished name of the entry to modify
+     * @param mods an array of objects representing the changes to make
+     * to the entry
+     * @param cons the set of preferences to apply to this operation
+     * @exception LDAPException Failed to make the specified changes to the
+     * directory entry.
+     * @see netscape.ldap.LDAPModification
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public void modify (String DN, LDAPModification[] mods,
+         LDAPConstraints cons) throws LDAPException {
+         checkConnection(/*rebind=*/true);
+
+         LDAPResponseListener myListener = getResponseListener ();
+         LDAPMessage response = null;
+         try {
+             sendRequest (new JDAPModifyRequest (DN, mods), myListener, cons);
+             response = myListener.getResponse();
+             checkMsg (response);
+         } catch (LDAPReferralException e) {
+             performReferrals(e, cons, JDAPProtocolOp.MODIFY_REQUEST,
+                              DN, 0, null, null, false, mods, null, null, null);
+         } finally {
+             releaseResponseListener (myListener);
+         }
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void modify (String DN, LDAPModification[] mods,
+         LDAPSearchConstraints cons) throws LDAPException {
+        modify(DN, mods, (LDAPConstraints)cons);
+    }        
+
+    /**
+     * Deletes the entry for the specified DN from the directory. <P>
+     *
+     * For example, the following section of code deletes the entry for
+     * Barbara Jensen from the directory. <P>
+     *
+     * <PRE>
+     * ...
+     * String myEntryDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * myConn.delete( myEntryDN );
+     * ... </PRE>
+     *
+     * @param DN distinguished name identifying the entry
+     * to remove from the directory
+     * @exception LDAPException Failed to delete the specified entry from
+     * the directory.
+     */
+    public void delete( String DN ) throws LDAPException {
+        delete(DN, m_defaultConstraints);
+    }
+
+    /**
+     * Deletes the entry for the specified DN from the directory and
+     * allows you to specify preferences for this LDAP delete operation
+     * by using an <CODE>LDAPConstraints</CODE> object. For
+     * example, you can specify whether or not to follow referrals.
+     * You can also apply LDAP v3 controls to the operation.
+     * <P>
+     *
+     * @param DN distinguished name identifying the entry 
+     * to remove from the directory
+     * @param cons the set of preferences to apply to this operation
+     * @exception LDAPException Failed to delete the specified entry from
+     * the directory.
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public void delete( String DN, LDAPConstraints cons )
+        throws LDAPException {
+        checkConnection(/*rebind=*/true);
+
+        LDAPResponseListener myListener = getResponseListener ();
+        LDAPMessage response;
+        try {
+            sendRequest (new JDAPDeleteRequest (DN), myListener, cons);
+            response = myListener.getResponse();
+            checkMsg (response);
+        } catch (LDAPReferralException e) {
+            performReferrals(e, cons, JDAPProtocolOp.DEL_REQUEST,
+                             DN, 0, null, null, false, null, null, null, null);
+        } finally {
+            releaseResponseListener (myListener);
+        }
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void delete( String DN, LDAPSearchConstraints cons )
+        throws LDAPException {
+        delete(DN, (LDAPConstraints)cons);
+    }
+
+    /**
+     * Renames an existing entry in the directory. <P>
+     *
+     * You can specify whether or not the original name of the entry is
+     * retained as a value in the entry. For example, suppose you rename
+     * the entry "cn=Barbara" to "cn=Babs".  You can keep "cn=Barbara"
+     * as a value in the entry so that the cn attribute has two values: <P>
+     *
+     * <PRE>
+     *       cn=Barbara
+     *       cn=Babs
+     * </PRE>
+     * The following example renames an entry.  The old name of the entry
+     * is kept as a value in the entry. <P>
+     *
+     * <PRE>
+     * ...
+     * String myEntryDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * String newRDN = "cn=Babs Jensen";
+     * myConn.rename( myEntryDN, newRDN, false );
+     * ... </PRE>
+     *
+     * @param DN current distinguished name of the entry
+     * @param newRDN new relative distinguished name for the entry (for example,
+     * "cn=newName")
+     * @param deleteOldRDN if <CODE>true</CODE>, the old name is not retained
+     * as an attribute value (for example, the attribute value "cn=oldName" is
+     * removed).  If <CODE>false</CODE>, the old name is retained
+     * as an attribute value (for example, the entry might now have two values
+     * for the cn attribute: "cn=oldName" and "cn=newName").
+     * @exception LDAPException Failed to rename the specified entry.
+     */
+    public void rename (String DN, String newRDN, boolean deleteOldRDN )
+        throws LDAPException {
+        rename(DN, newRDN, null, deleteOldRDN);
+    }
+
+    /**
+     * Renames an existing entry in the directory. <P>
+     *
+     * You can specify whether or not the original name of the entry is
+     * retained as a value in the entry. For example, suppose you rename
+     * the entry "cn=Barbara" to "cn=Babs".  You can keep "cn=Barbara"
+     * as a value in the entry so that the cn attribute has two values: <P>
+     *
+     * <PRE>
+     *       cn=Barbara
+     *       cn=Babs
+     * </PRE>
+     * The following example renames an entry.  The old name of the entry
+     * is kept as a value in the entry. <P>
+     *
+     * <PRE>
+     * ...
+     * String myEntryDN = "cn=Barbara Jensen,ou=Product Development,o=Ace Industry,c=US";
+     * String newRDN = "cn=Babs Jensen";
+     * myConn.rename( myEntryDN, newRDN, false );
+     * ... </PRE>
+     *
+     * @param DN current distinguished name of the entry
+     * @param newRDN new relative distinguished name for the entry (for example,
+     * "cn=newName")
+     * @param deleteOldRDN if <CODE>true</CODE>, the old name is not retained
+     * as an attribute value (for example, the attribute value "cn=oldName" is
+     * removed).  If <CODE>false</CODE>, the old name is retained
+     * as an attribute value (for example, the entry might now have two values
+     * for the cn attribute: "cn=oldName" and "cn=newName").
+     * @param cons the set of preferences to apply to this operation
+     * @exception LDAPException Failed to rename the specified entry.
+     */
+    public void rename (String DN, String newRDN, boolean deleteOldRDN,
+                        LDAPConstraints cons )
+        throws LDAPException {
+        rename(DN, newRDN, null, deleteOldRDN, cons);
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void rename (String DN, String newRDN, boolean deleteOldRDN,
+                        LDAPSearchConstraints cons )
+        throws LDAPException {
+        rename(DN, newRDN, deleteOldRDN, (LDAPConstraints)cons);
+    }
+
+    /**
+     * Renames an existing entry in the directory and (optionally)
+     * changes the location of the entry in the directory tree.<P>
+     *
+     * <B>NOTE: </B>Netscape Directory Server 3.0 does not support the
+     * capability to move an entry to a different location in the
+     * directory tree.  If you specify a value for the <CODE>newParentDN</CODE>
+     * argument, an <CODE>LDAPException</CODE> will be thrown.
+     * <P>
+     *
+     * @param dn current distinguished name of the entry
+     * @param newRDN new relative distinguished name for the entry (for example,
+     * "cn=newName")
+     * @param newParentDN if not null, the distinguished name for the
+     * entry under which the entry should be moved (for example, to move
+     * an entry under the Accounting subtree, specify this argument as
+     * "ou=Accounting, o=Ace Industry, c=US")
+     * @param deleteOldRDN if <CODE>true</CODE>, the old name is not retained
+     * as an attribute value (for example, the attribute value "cn=oldName" is
+     * removed).  If <CODE>false</CODE>, the old name is retained
+     * as an attribute value (for example, the entry might now have two values
+     * for the cn attribute: "cn=oldName" and "cn=newName").
+     * @exception LDAPException Failed to rename the specified entry.
+     */
+     public void rename(String dn,
+                        String newRDN,
+                        String newParentDN,
+                        boolean deleteOldRDN) throws LDAPException {
+          rename(dn, newRDN, newParentDN, deleteOldRDN, m_defaultConstraints);
+     }
+
+    /**
+     * Renames an existing entry in the directory and (optionally)
+     * changes the location of the entry in the directory tree. Also
+     * allows you to specify preferences for this LDAP modify DN operation
+     * by using an <CODE>LDAPConstraints</CODE> object. For
+     * example, you can specify whether or not to follow referrals.
+     * You can also apply LDAP v3 controls to the operation.
+     * <P>
+     *
+     * <B>NOTE: </B>Netscape Directory Server 3.0 does not support the
+     * capability to move an entry to a different location in the
+     * directory tree.  If you specify a value for the <CODE>newParentDN</CODE>
+     * argument, an <CODE>LDAPException</CODE> will be thrown.
+     * <P>
+     *
+     * @param DN current distinguished name of the entry
+     * @param newRDN new relative distinguished name for the entry (for example,
+     * "cn=newName")
+     * @param newParentDN if not null, the distinguished name for the
+     * entry under which the entry should be moved (for example, to move
+     * an entry under the Accounting subtree, specify this argument as
+     * "ou=Accounting, o=Ace Industry, c=US")
+     * @param deleteOldRDN if <CODE>true</CODE>, the old name is not retained
+     * as an attribute value (for example, the attribute value "cn=oldName" is
+     * removed).  If <CODE>false</CODE>, the old name is retained
+     * as an attribute value (for example, the entry might now have two values
+     * for the cn attribute: "cn=oldName" and "cn=newName").
+     * @param cons the set of preferences to apply to this operation
+     * @exception LDAPException Failed to rename the specified entry.
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public void rename (String DN,
+                           String newRDN,
+                           String newParentDN,
+                           boolean deleteOldRDN,
+                           LDAPConstraints cons)
+        throws LDAPException {
+        checkConnection(/*rebind=*/true);
+
+        LDAPResponseListener myListener = getResponseListener ();
+        try {
+            JDAPModifyRDNRequest request = null;
+            if ( newParentDN != null ) {
+                request = new JDAPModifyRDNRequest (DN,
+                                                newRDN,
+                                                deleteOldRDN,
+                                                newParentDN);
+            } else {
+                request = new JDAPModifyRDNRequest (DN,
+                                                newRDN,
+                                                deleteOldRDN);
+            }
+            sendRequest (request, myListener, cons);
+            LDAPMessage response = myListener.getResponse();
+            checkMsg (response);
+        } catch (LDAPReferralException e) {
+            performReferrals(e, cons, JDAPProtocolOp.MODIFY_RDN_REQUEST,
+                             DN, 0, newRDN, null, deleteOldRDN, null, null,
+                             null, null);
+        } finally {
+            releaseResponseListener (myListener);
+        }
+    }
+
+    /**
+     * @deprecated Please use the method signature where <CODE>cons</CODE> is
+     * <CODE>LDAPConstraints</CODE> instead of <CODE>LDAPSearchConstraints</CODE>
+     */
+    public void rename (String DN,
+                           String newRDN,
+                           String newParentDN,
+                           boolean deleteOldRDN,
+                           LDAPSearchConstraints cons)
+        throws LDAPException {
+        rename(DN, newRDN, newParentDN, deleteOldRDN, (LDAPConstraints)cons);
+    }        
+
+    /**
+     * Adds an entry to the directory.
+     *
+     * @param entry LDAPEntry object specifying the distinguished name and
+     * attributes of the new entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPEntry
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener add(LDAPEntry entry,
+                                    LDAPResponseListener listener)
+                                    throws LDAPException{
+        return add(entry, listener, m_defaultConstraints);
+    }
+ 
+    /**
+     * Adds an entry to the directory and allows you to specify constraints
+     * for this LDAP add operation by using an <CODE>LDAPConstraints</CODE>
+     * object. For example, you can specify whether or not to follow referrals.
+     * You can also apply LDAP v3 controls to the operation.
+     * <P>
+     *
+     * @param entry LDAPEntry object specifying the distinguished name and
+     * attributes of the new entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPEntry
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener add(LDAPEntry entry,
+                                    LDAPResponseListener listener,
+                                    LDAPConstraints cons)
+                                    throws LDAPException{
+
+        if (cons == null) {
+            cons = m_defaultConstraints;
+        }
+        
+        checkConnection(/*rebind=*/true);
+
+        if (listener == null) {
+            listener = new LDAPResponseListener(/*asynchOp=*/true);
+        }
+
+        LDAPAttributeSet attrs = entry.getAttributeSet ();
+        LDAPAttribute[] attrList = new LDAPAttribute[attrs.size()];
+        for( int i = 0; i < attrs.size(); i++ )
+            attrList[i] = (LDAPAttribute)attrs.elementAt( i );
+        int attrPosition = 0;
+
+        sendRequest (new JDAPAddRequest (entry.getDN(), attrList),
+                    listener, cons);
+
+        return listener;
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name and password. If the object
+     * has been disconnected from an LDAP server, this method attempts to
+     * reconnect to the server. If the object had already authenticated, the
+     * old authentication is discarded.
+     * 
+     * @param version required LDAP protocol version
+     * @param dn if non-null and non-empty, specifies that the connection
+     * and all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param passwd if non-null and non-empty, specifies that the connection
+     * and all operations through it should authenticate with dn as the
+     * distinguished name and passwd as password
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener bind(int version,
+                                     String dn,
+                                     String passwd,
+                                     LDAPResponseListener listener)
+                                     throws LDAPException{
+        return bind(version, dn, passwd, listener, m_defaultConstraints);
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name and password. If the object
+     * has been disconnected from an LDAP server, this method attempts to
+     * reconnect to the server. If the object had already authenticated, the
+     * old authentication is discarded.
+     * 
+     * @param dn if non-null and non-empty, specifies that the connection
+     * and all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param passwd if non-null and non-empty, specifies that the connection
+     * and all operations through it should authenticate with dn as the
+     * distinguished name and passwd as password
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener bind(String dn,
+                                     String passwd,
+                                     LDAPResponseListener listener)
+                                     throws LDAPException{
+        return bind(m_protocolVersion, dn, passwd, listener,
+                    m_defaultConstraints);
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name and password and allows you
+     * to specify constraints for this LDAP add operation by using an
+     *  <CODE>LDAPConstraints</CODE> object. If the object
+     * has been disconnected from an LDAP server, this method attempts to
+     * reconnect to the server. If the object had already authenticated, the
+     * old authentication is discarded.
+     * 
+     * @param dn if non-null and non-empty, specifies that the connection
+     * and all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param passwd if non-null and non-empty, specifies that the connection
+     * and all operations through it should authenticate with dn as the
+     * distinguished name and passwd as password
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener bind(String dn,
+                                     String passwd,
+                                     LDAPResponseListener listener,
+                                     LDAPConstraints cons) 
+                                     throws LDAPException{
+        return bind( m_protocolVersion, dn, passwd, listener, cons );
+    }
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name and password and allows you
+     * to specify constraints for this LDAP add operation by using an
+     *  <CODE>LDAPConstraints</CODE> object. If the object
+     * has been disconnected from an LDAP server, this method attempts to
+     * reconnect to the server. If the object had already authenticated, the
+     * old authentication is discarded.
+     * 
+     * @param version required LDAP protocol version
+     * @param dn if non-null and non-empty, specifies that the connection
+     * and all operations through it should authenticate with dn as the
+     * distinguished name
+     * @param passwd if non-null and non-empty, specifies that the connection
+     * and all operations through it should authenticate with dn as the
+     * distinguished name and passwd as password
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener bind(int version,
+                                     String dn,
+                                     String passwd,
+                                     LDAPResponseListener listener,
+                                     LDAPConstraints cons) 
+                                     throws LDAPException{
+        return authenticate( version, dn, passwd, listener, cons );
+    }
+    
+    /**
+     * Deletes the entry for the specified DN from the directory.
+     * 
+     * @param dn distinguished name of the entry to delete
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener delete(String dn,
+                                       LDAPResponseListener listener)
+                                       throws LDAPException{
+        
+        return delete(dn, listener, m_defaultConstraints);
+    }
+
+    /**
+     * Deletes the entry for the specified DN from the directory.
+     * 
+     * @param dn distinguished name of the entry to delete
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener delete(String dn,
+                                      LDAPResponseListener listener,
+                                      LDAPConstraints cons)
+                                       throws LDAPException{
+        if (cons == null) {
+            cons = m_defaultConstraints;
+        }
+
+        checkConnection(/*rebind=*/true);
+
+        if (listener == null) {
+            listener = new LDAPResponseListener(/*asynchOp=*/true);
+        }
+        
+        sendRequest (new JDAPDeleteRequest(dn), listener, cons);
+        
+        return listener;
+
+    }
+    
+    /**
+     * Makes a single change to an existing entry in the directory.
+     * For example, changes the value of an attribute, adds a new attribute
+     * value, or removes an existing attribute value.<BR>
+     * The LDAPModification object specifies both the change to make and
+     * the LDAPAttribute value to be changed.
+     * 
+     * @param dn distinguished name of the entry to modify
+     * @param mod a single change to make to an entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPModification
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener modify(String dn,
+                                       LDAPModification mod,
+                                       LDAPResponseListener listener)
+                                       throws LDAPException{
+
+        return modify(dn, mod, listener, m_defaultConstraints);
+    }
+    
+    /**
+     * Makes a single change to an existing entry in the directory.
+     * For example, changes the value of an attribute, adds a new attribute
+     * value, or removes an existing attribute value.<BR>
+     * The LDAPModification object specifies both the change to make and
+     * the LDAPAttribute value to be changed.
+     * 
+     * @param dn distinguished name of the entry to modify
+     * @param mod a single change to make to an entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPModification
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener modify(String dn,
+                                       LDAPModification mod,
+                                       LDAPResponseListener listener,
+                                       LDAPConstraints cons)
+                                       throws LDAPException{
+        if (cons == null) {
+            cons = m_defaultConstraints;
+        }
+
+        checkConnection(/*rebind=*/true);
+
+        if (listener == null) {
+            listener = new LDAPResponseListener(/*asynchOp=*/true);
+        }
+
+        LDAPModification[] modList = { mod };
+        sendRequest (new JDAPModifyRequest (dn, modList), listener, cons);        
+
+        return listener;
+    }
+
+    /**
+     * Makes a set of changes to an existing entry in the directory.
+     * For example, changes attribute values, adds new attribute values, or
+     * removes existing attribute values.
+     * <P>
+     * @param dn distinguished name of the entry to modify
+     * @param mods a set of changes to make to the entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPModificationSet
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener modify(String dn,
+                                       LDAPModificationSet mods,
+                                       LDAPResponseListener listener)
+                                       throws LDAPException{
+        return modify(dn,mods, listener, m_defaultConstraints);
+    }
+    
+    /**
+     * Makes a set of changes to an existing entry in the directory.
+     * For example, changes attribute values, adds new attribute values, or
+     * removes existing attribute values).
+     * 
+     * @param dn distinguished name of the entry to modify
+     * @param mods a set of changes to make to the entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons Constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPModificationSet
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener modify(String dn,
+                                       LDAPModificationSet mods,
+                                       LDAPResponseListener listener,
+                                       LDAPConstraints cons)
+                                       throws LDAPException{
+        if (cons == null) {
+            cons = m_defaultConstraints;
+        }
+
+        checkConnection(/*rebind=*/true);
+
+        if (listener == null) {
+            listener = new LDAPResponseListener(/*asynchOp=*/true);
+        }
+
+        LDAPModification[] modList = new LDAPModification[mods.size()];
+        for( int i = 0; i < mods.size(); i++ ) {
+            modList[i] = mods.elementAt( i );
+        }
+
+        sendRequest (new JDAPModifyRequest (dn, modList), listener, cons);        
+        return listener;
+
+    }    
+
+    /**
+     * Renames an existing entry in the directory.
+     * 
+     * @param dn current distinguished name of the entry
+     * @param newRdn new relative distinguished name for the entry
+     * @param deleteOldRdn if true, the old name is not retained as an
+     * attribute value
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener rename(String dn,
+                                       String newRdn,
+                                       boolean deleteOldRdn,
+                                       LDAPResponseListener listener)
+                                       throws LDAPException{
+        return rename(dn, newRdn, deleteOldRdn, listener, m_defaultConstraints);
+    }
+
+    /**
+     * Renames an existing entry in the directory.
+     * 
+     * @param dn current distinguished name of the entry
+     * @param newRdn new relative distinguished name for the entry
+     * @param deleteOldRdn if true, the old name is not retained as an attribute
+     * value
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener rename(String dn,
+                                       String newRdn,
+                                       boolean deleteOldRdn,
+                                       LDAPResponseListener listener,
+                                       LDAPConstraints cons)
+                                       throws LDAPException{
+        if (cons == null) {
+            cons = m_defaultConstraints;
+        }
+        
+        checkConnection(/*rebind=*/true);
+
+        if (listener == null) {
+            listener = new LDAPResponseListener(/*asynchOp=*/true);
+        }
+
+        sendRequest (new JDAPModifyRDNRequest (dn, newRdn, deleteOldRdn),
+                     listener, cons);
+        
+        return listener;
+
+    }
+        
+    
+    /**
+     * Performs the search specified by the criteria that you enter. <P>
+     * To abandon the search, use the <CODE>abandon</CODE> method.
+     *
+     * @param base the base distinguished name from which to search
+     * @param scope the scope of the entries to search.  You can specify one
+     * of the following: <P>
+     * <UL>
+     * <LI><CODE>LDAPv2.SCOPE_BASE</CODE> (search only the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_ONE</CODE>
+     * (search only entries under the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_SUB</CODE>
+     * (search the base DN and all entries within its subtree) <P>
+     * </UL>
+     * <P>
+     * @param filter search filter specifying the search criteria
+     * @param attrs list of attributes that you want returned in the
+     * search results
+     * @param typesOnly if true, returns the names but not the values of the
+     * attributes found.  If false, returns the names and values for
+     * attributes found
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPSearchListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPConnection#abandon(netscape.ldap.LDAPSearchListener)
+     */
+    public LDAPSearchListener search(String base,
+                                     int scope,
+                                     String filter,
+                                     String attrs[],
+                                     boolean typesOnly,
+                                     LDAPSearchListener listener)
+                                     throws LDAPException {
+        
+        return search(base, scope, filter, attrs, typesOnly,
+                      listener, m_defaultConstraints);
+    }
+
+    /**
+     * Performs the search specified by the criteria that you enter.
+     * This method also allows you to specify constraints for the search
+     * (such as the maximum number of entries to find or the
+     * maximum time to wait for search results). <P>
+     * To abandon the search, use the <CODE>abandon</CODE> method.
+     *
+     * @param base the base distinguished name from which to search
+     * @param scope the scope of the entries to search.  You can specify one
+     * of the following: <P>
+     * <UL>
+     * <LI><CODE>LDAPv2.SCOPE_BASE</CODE> (search only the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_ONE</CODE>
+     * (search only entries under the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_SUB</CODE>
+     * (search the base DN and all entries within its subtree) <P>
+     * </UL>
+     * <P>
+     * @param filter search filter specifying the search criteria
+     * @param attrs list of attributes that you want returned in the search
+     * results
+     * @param typesOnly if true, returns the names but not the values of the
+     * attributes found.  If false, returns the names and  values for
+     * attributes found.
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to this search (for example, the
+     * maximum number of entries to return)
+     * @return LDAPSearchListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPConnection#abandon(netscape.ldap.LDAPSearchListener)
+     */
+    public LDAPSearchListener search(String base,
+                                     int scope,
+                                     String filter,
+                                     String attrs[],
+                                     boolean typesOnly,
+                                     LDAPSearchListener listener,
+                                     LDAPSearchConstraints cons)
+                                     throws LDAPException {
+        if (cons == null) {
+            cons = m_defaultConstraints;
+        }
+
+        checkConnection(/*rebind=*/true);
+        
+        if (listener == null) {
+            listener = new LDAPSearchListener(/*asynchOp=*/true, cons);
+        }
+        
+        JDAPSearchRequest request = null;        
+        try {
+            request = new JDAPSearchRequest (base, scope, cons.getDereference(),
+                cons.getMaxResults(), cons.getServerTimeLimit(),
+                typesOnly, filter, attrs);
+        }
+        catch (IllegalArgumentException e) {
+            throw new LDAPException(e.getMessage(), LDAPException.PARAM_ERROR);
+        }
+
+        sendRequest (request, listener, cons);
+        return listener;
+        
+    }
+    
+    /**
+     * Compare an attribute value with one in the directory. The result can 
+     * be obtained by calling <CODE>getResultCode</CODE> on the 
+     * <CODE>LDAPResponse</CODE> from the <CODE>LDAPResponseListener</CODE>.
+     * The code will be <CODE>LDAPException.COMPARE_TRUE</CODE> or 
+     * <CODE>LDAPException.COMPARE_FALSE</CODE>. 
+     * 
+     * @param dn distinguished name of the entry to compare
+     * @param attr attribute with a value to compare
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     */
+    public LDAPResponseListener compare(String dn, 
+                                        LDAPAttribute attr, 
+                                        LDAPResponseListener listener)
+                                        throws LDAPException {
+
+        return compare(dn, attr, listener, m_defaultConstraints);
+    }
+    
+    /**
+     * Compare an attribute value with one in the directory. The result can 
+     * be obtained by calling <CODE>getResultCode</CODE> on the 
+     * <CODE>LDAPResponse</CODE> from the <CODE>LDAPResponseListener</CODE>.
+     * The code will be <CODE>LDAPException.COMPARE_TRUE</CODE> or 
+     * <CODE>LDAPException.COMPARE_FALSE</CODE>. 
+     * 
+     * @param dn distinguished name of the entry to compare
+     * @param attr attribute with a value to compare
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to this operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     */
+    public LDAPResponseListener compare(String dn, 
+                                        LDAPAttribute attr, 
+                                        LDAPResponseListener listener,
+                                        LDAPConstraints cons) 
+                                        throws LDAPException {
+        if (cons == null) {
+            cons = m_defaultConstraints;
+        }
+        
+        checkConnection(/*rebind=*/true);
+
+        if (listener == null) {
+            listener = new LDAPResponseListener(/*asynchOp=*/true);
+        }
+
+        Enumeration en = attr.getStringValues();
+        String val = (String)en.nextElement();
+        JDAPAVA ava = new JDAPAVA(attr.getName(), val);
+        
+        sendRequest (new JDAPCompareRequest (dn, ava), listener, cons);
+        return listener;
+    }
+    
+    /**
+     * Cancels the ldap request with the specified id and discards
+     * any results already received.
+     * 
+     * @param id an LDAP request id
+     * @exception LDAPException Failed to send request.
+     */
+    public void abandon(int id) throws LDAPException {
+
+        if (!isConnected()) {
+            return;
+        }
+        
+        try {
+            /* Tell listener thread to discard results and send an abandon request */
+            LDAPControl ctrls[] =  m_defaultConstraints.getServerControls();
+            m_thread.abandon( id, ctrls );
+                
+        } catch (Exception ignore) {}
+    }
+
+    /**
+     * Cancels all outstanding search requests associated with this
+     * LDAPSearchListener object and discards any results already received.
+     * 
+     * @param searchlistener a search listener returned from a search
+     * @exception LDAPException Failed to send request.
+     */
+    public void abandon(LDAPSearchListener searchlistener)throws LDAPException {
+        int[] ids = searchlistener.getMessageIDs();
+        for (int i=0; i < ids.length; i++) {
+            searchlistener.removeRequest(ids[i]);
+            abandon(ids[i]);
+        }
+    }
+    
+    /**
+     * Returns the value of the specified option for this
+     * <CODE>LDAPConnection</CODE> object. <P>
+     *
+     * These options represent the constraints for the current connection.
+     * To get all constraints for the current connection, call the
+     * <CODE>getSearchConstraints</CODE> method.
+     * <P>
+     *
+     * By default, the constraints apply to all operations performed
+     * through the current connection.  You can change these constraints:
+     * <P>
+     *
+     * <UL>
+     * <LI> If you want to set a constraint only for a particular operation, 
+     * create an <CODE>LDAPConstraints</CODE> object (or a 
+     * <CODE>LDAPSearchConstraints</CODE> object for a search or find operation)
+     * with your new constraints
+     * and pass it to the <CODE>LDAPConnection</CODE> method that performs the
+     * operation.
+     * <P>
+     *
+     * <LI>If you want to override these constraints for all operations
+     * performed under the current connection, call the
+     * <CODE>setOption</CODE> method to change the constraint.
+     * <P>
+     *
+     * </UL>
+     * <P>
+     *
+     * For example, the following section of code gets and prints the
+     * maximum number of search results that are returned for searches
+     * performed through this connection.  (This applies to all searches
+     * unless a different set of search constraints is specified in an
+     * <CODE>LDAPSearchConstraints</CODE> object.)
+     * <P>
+     *
+     * <PRE>
+     * LDAPConnection ld = new LDAPConnection();
+     * int sizeLimit = ( (Integer)ld.getOption( LDAPv2.SIZELIMIT ) ).intValue();
+     * System.out.println( "Maximum number of results: " + sizeLimit );
+     * </PRE>
+     *
+     * @param option you can specify one of the following options:
+     * <TABLE CELLPADDING=5>
+     * <TR VALIGN=BASELINE ALIGN=LEFT>
+     * <TH>Option</TH><TH>Data Type</TH><TH>Description</TH></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.PROTOCOL_VERSION</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the version of the LDAP protocol used by the
+     * client.
+     * <P>By default, the value of this option is 2.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.DEREF</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies when your client dereferences aliases.
+     *<PRE>
+     * Legal values for this option are:
+     *
+     * DEREF_NEVER       Aliases are never dereferenced.
+     *
+     * DEREF_FINDING     Aliases are dereferenced when find-
+     *                   ing the starting point for the
+     *                   search (but not when searching
+     *                   under that starting entry).
+     *
+     * DEREF_SEARCHING   Aliases are dereferenced when
+     *                   searching the entries beneath the
+     *                   starting point of the search (but
+     *                   not when finding the starting
+     *                   entry).
+     *
+     * DEREF_ALWAYS      Aliases are always dereferenced.
+     *</PRE>
+     * <P>By default, the value of this option is
+     * <CODE>DEREF_NEVER</CODE>.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.SIZELIMIT</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the maximum number of search results to return.
+     * If this option is set to 0, there is no maximum limit.
+     * <P>By default, the value of this option is 1000.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.TIMELIMIT</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the maximum number of milliseconds to wait for results
+     * before timing out. If this option is set to 0, there is no maximum
+     * time limit.
+     * <P>By default, the value of this option is 0.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.REFERRALS</CODE></TD>
+     * <TD><CODE>Boolean</CODE></TD>
+     * <TD>Specifies whether or not your client follows referrals automatically.
+     * If <CODE>true</CODE>, your client follows referrals automatically.
+     * If <CODE>false</CODE>, an <CODE>LDAPReferralException</CODE> is raised
+     * when referral is detected.
+     * <P>By default, the value of this option is <CODE>false</CODE>.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.REFERRALS_REBIND_PROC</CODE></TD>
+     * <TD><CODE>LDAPRebind</CODE></TD>
+     * <TD>Specifies an object with a class that implements the
+     * <CODE>LDAPRebind</CODE> interface.  You must define this class and
+     * the <CODE>getRebindAuthentication</CODE> method that will be used to
+     * get the distinguished name and password to use for authentication.
+     * Modifying this option sets the <CODE>LDAPv2.BIND</CODE> option to null.
+     * <P>By default, the value of this option is <CODE>null</CODE>.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.BIND</CODE></TD>
+     * <TD><CODE>LDAPBind</CODE></TD>
+     * <TD>Specifies an object with a class that implements the
+     * <CODE>LDAPBind</CODE>
+     * interface.  You must define this class and the
+     * <CODE>bind</CODE> method that will be used to authenticate
+     * to the server on referrals. Modifying this option sets the 
+     * <CODE>LDAPv2.REFERRALS_REBIND_PROC</CODE> to null.
+     * <P>By default, the value of this option is <CODE>null</CODE>.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.REFERRALS_HOP_LIMIT</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the maximum number of referrals in a sequence that
+     * your client will follow.  (For example, if REFERRALS_HOP_LIMIT is 5,
+     * your client will follow no more than 5 referrals in a row when resolving
+     * a single LDAP request.)
+     * <P>By default, the value of this option is 10.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.BATCHSIZE</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the number of search results to return at a time.
+     * (For example, if BATCHSIZE is 1, results are returned one at a time.)
+     * <P>By default, the value of this option is 1.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv3.CLIENTCONTROLS</CODE></TD>
+     * <TD><CODE>LDAPControl[]</CODE></TD>
+     * <TD>Specifies the client controls that may affect the handling of LDAP
+     * operations in the LDAP classes. These controls are used by the client
+     * and are not passed to the LDAP server. At this time, no client controls
+     * are defined for clients built with the Netscape LDAP classes. </TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv3.SERVERCONTROLS</CODE></TD>
+     * <TD><CODE>LDAPControl[]</CODE></TD>
+     * <TD>Specifies the server controls that are passed to the LDAP
+     * server on each LDAP operation. Not all servers support server
+     * controls; a particular server may or may not support a given
+     * server control.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>MAXBACKLOG</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the maximum number of search results to accumulate in an
+     * LDAPSearchResults before suspending the reading of input from the server.
+     * <P>By default, the value of this option is 100. The value 0 means there
+     *  is no limit.</TD></TR>
+     * </TABLE><P>
+     * @return the value for the option wrapped in an object.  (You
+     * need to cast the returned value as its appropriate type. For
+     * example, when getting the SIZELIMIT option, cast the returned
+     * value as an <CODE>Integer</CODE>.)
+     * @exception LDAPException Failed to get the specified option.
+     * @see netscape.ldap.LDAPRebind
+     * @see netscape.ldap.LDAPConstraints
+     * @see netscape.ldap.LDAPSearchConstraints
+     * @see netscape.ldap.LDAPReferralException
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.LDAPConnection#getSearchConstraints
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)
+     */
+    public Object getOption( int option ) throws LDAPException {
+        if (option == LDAPv2.PROTOCOL_VERSION) {
+            return new Integer(m_protocolVersion);
+        }
+
+        return getOption(option, m_defaultConstraints);
+    }
+
+    private static Object getOption( int option, LDAPSearchConstraints cons )
+        throws LDAPException {
+        switch (option) {
+            case LDAPv2.DEREF:
+              return new Integer (cons.getDereference());
+            case LDAPv2.SIZELIMIT:
+              return new Integer (cons.getMaxResults());
+            case LDAPv2.TIMELIMIT:
+              return new Integer (cons.getServerTimeLimit());
+            case LDAPv2.REFERRALS:
+              return new Boolean (cons.getReferrals());
+            case LDAPv2.REFERRALS_REBIND_PROC:
+              return cons.getRebindProc();
+            case LDAPv2.BIND:
+              return cons.getBindProc();
+            case LDAPv2.REFERRALS_HOP_LIMIT:
+              return new Integer (cons.getHopLimit());
+            case LDAPv2.BATCHSIZE:
+              return new Integer (cons.getBatchSize());
+            case LDAPv3.CLIENTCONTROLS:
+              return cons.getClientControls();
+            case LDAPv3.SERVERCONTROLS:
+              return cons.getServerControls();
+            case MAXBACKLOG:
+              return new Integer (cons.getMaxBacklog());
+            default:
+              throw new LDAPException ( "invalid option",
+                                        LDAPException.PARAM_ERROR );
+        }
+    }
+    
+    /**
+     * Sets the value of the specified option for this
+     * <CODE>LDAPConnection</CODE> object. <P>
+     *
+     * These options represent the constraints for the current
+     * connection.
+     * To get all constraints for the current connection, call the
+     * <CODE>getSearchConstraints</CODE> method. 
+     * <P>
+     *
+     * By default, the option that you set applies to all subsequent
+     * operations performed through the current connection. If you want to
+     * set a constraint only for a particular operation, create an
+     * <CODE>LDAPConstraints</CODE> object (or a 
+     * <CODE>LDAPSearchConstraints</CODE> object for a search or find operation)
+     * with your new constraints
+     * and pass it to the <CODE>LDAPConnection</CODE> method that performs the
+     * operation.
+     * <P>
+     *
+     * For example, the following section of code changes the constraint for
+     * the maximum number of search results that are returned for searches
+     * performed through this connection.  (This applies to all searches
+     * unless a different set of search constraints is specified in an
+     * <CODE>LDAPSearchConstraints</CODE> object.)
+     * <P>
+     *
+     * <PRE>
+     * LDAPConnection ld = new LDAPConnection();
+     * Integer newLimit = new Integer( 20 );
+     * ld.setOption( LDAPv2.SIZELIMIT, newLimit );
+     * System.out.println( "Changed the maximum number of results to " + newLimit.intValue() );
+     * </PRE>
+     *
+     * @param option you can specify one of the following options:
+     * <TABLE CELLPADDING=5>
+     * <TR VALIGN=BASELINE ALIGN=LEFT>
+     * <TH>Option</TH><TH>Data Type</TH><TH>Description</TH></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.PROTOCOL_VERSION</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the version of the LDAP protocol used by the
+     * client.
+     * <P>By default, the value of this option is 2.  If you want
+     * to use LDAP v3 features (such as extended operations or
+     * controls), you need to set this value to 3. </TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.DEREF</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies when your client dereferences aliases.
+     *<PRE>
+     * Legal values for this option are:
+     *
+     * DEREF_NEVER       Aliases are never dereferenced.
+     *
+     * DEREF_FINDING     Aliases are dereferenced when find-
+     *                   ing the starting point for the
+     *                   search (but not when searching
+     *                   under that starting entry).
+     *
+     * DEREF_SEARCHING   Aliases are dereferenced when
+     *                   searching the entries beneath the
+     *                   starting point of the search (but
+     *                   not when finding the starting
+     *                   entry).
+     *
+     * DEREF_ALWAYS      Aliases are always dereferenced.
+     *</PRE>
+     * <P>By default, the value of this option is
+     * <CODE>DEREF_NEVER</CODE>.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.SIZELIMIT</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the maximum number of search results to return.
+     * If this option is set to 0, there is no maximum limit.
+     * <P>By default, the value of this option is 1000.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.TIMELIMIT</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the maximum number of milliseconds to wait for results
+     * before timing out. If this option is set to 0, there is no maximum
+     * time limit.
+     * <P>By default, the value of this option is 0.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.REFERRALS</CODE></TD>
+     * <TD><CODE>Boolean</CODE></TD>
+     * <TD>Specifies whether or not your client follows referrals automatically.
+     * If <CODE>true</CODE>, your client follows referrals automatically.
+     * If <CODE>false</CODE>, an <CODE>LDAPReferralException</CODE> is
+     * raised when a referral is detected.
+     * <P>By default, the value of this option is <CODE>false</CODE>.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.REFERRALS_REBIND_PROC</CODE></TD>
+     * <TD><CODE>LDAPRebind</CODE></TD>
+     * <TD>Specifies an object with a class that implements the
+     * <CODE>LDAPRebind</CODE>
+     * interface.  You must define this class and the
+     * <CODE>getRebindAuthentication</CODE> method that will be used to get
+     * the distinguished name and password to use for authentication. 
+     * Modifying this option sets the <CODE>LDAPv2.BIND</CODE> option to null.
+     * <P>By default, the value of this option is <CODE>null</CODE>.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.BIND</CODE></TD>
+     * <TD><CODE>LDAPBind</CODE></TD>
+     * <TD>Specifies an object with a class that implements the
+     * <CODE>LDAPBind</CODE>
+     * interface.  You must define this class and the
+     * <CODE>bind</CODE> method that will be used to autheniticate
+     * to the server on referrals. Modifying this option sets the 
+     * <CODE>LDAPv2.REFERRALS_REBIND_PROC</CODE> to null.
+     * <P>By default, the value of this option is <CODE>null</CODE>.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.REFERRALS_HOP_LIMIT</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the maximum number of referrals in a sequence that
+     * your client will follow.  (For example, if REFERRALS_HOP_LIMIT is 5,
+     * your client will follow no more than 5 referrals in a row when resolving
+     * a single LDAP request.)
+     * <P>By default, the value of this option is 10.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv2.BATCHSIZE</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the number of search results to return at a time.
+     * (For example, if BATCHSIZE is 1, results are returned one at a time.)
+     * <P>By default, the value of this option is 1.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv3.CLIENTCONTROLS</CODE></TD>
+     * <TD><CODE>LDAPControl[]</CODE></TD>
+     * <TD>Specifies the client controls that may affect handling of LDAP
+     * operations in the LDAP classes. These controls are used by the client
+     * and are not passed to the server. At this time, no client controls
+     * are defined for clients built with the Netscape LDAP classes. </TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>LDAPv3.SERVERCONTROLS</CODE></TD>
+     * <TD><CODE>LDAPControl[]</CODE></TD>
+     * <TD>Specifies the server controls that are passed to the LDAP
+     * server on each LDAP operation. Not all servers support server
+     * controls; a particular server may or may not support a particular
+     * control.</TD></TR>
+     * <TR VALIGN=BASELINE><TD>
+     * <CODE>MAXBACKLOG</CODE></TD>
+     * <TD><CODE>Integer</CODE></TD>
+     * <TD>Specifies the maximum number of search results to accumulate in an
+     * LDAPSearchResults before suspending the reading of input from the server.
+     * <P>By default, the value of this option is 100. The value 0 means there
+     *  is no limit.</TD></TR>
+     * </TABLE><P>
+     * @param value the value to assign to the option.  The value must be
+     * the java.lang object wrapper for the appropriate parameter
+     * (e.g. boolean->Boolean,
+     *   integer->Integer)
+     * @exception LDAPException Failed to set the specified option.
+     * @see netscape.ldap.LDAPRebind
+     * @see netscape.ldap.LDAPConstraints
+     * @see netscape.ldap.LDAPSearchConstraints
+     * @see netscape.ldap.LDAPReferralException
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.LDAPConnection#getSearchConstraints
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)
+     */
+    public void setOption( int option, Object value ) throws LDAPException {
+        if (option == LDAPv2.PROTOCOL_VERSION) {
+            setProtocolVersion(((Integer)value).intValue());
+            return;
+        }
+        setOption(option, value, m_defaultConstraints);
+    }
+
+    private static void setOption( int option, Object value, LDAPSearchConstraints cons ) throws LDAPException {
+      try {
+        switch (option) {
+        case LDAPv2.DEREF:
+          cons.setDereference(((Integer)value).intValue());
+          return;
+        case LDAPv2.SIZELIMIT:
+          cons.setMaxResults(((Integer)value).intValue());
+          return;
+        case LDAPv2.TIMELIMIT:
+          cons.setTimeLimit(((Integer)value).intValue());
+          return;
+        case LDAPv2.SERVER_TIMELIMIT:
+          cons.setServerTimeLimit(((Integer)value).intValue());
+          return;
+        case LDAPv2.REFERRALS:
+          cons.setReferrals(((Boolean)value).booleanValue());
+          return;
+        case LDAPv2.BIND:
+          cons.setBindProc((LDAPBind)value);
+          return;
+        case LDAPv2.REFERRALS_REBIND_PROC:
+          cons.setRebindProc((LDAPRebind)value);
+          return;
+        case LDAPv2.REFERRALS_HOP_LIMIT:
+          cons.setHopLimit(((Integer)value).intValue());
+          return;
+        case LDAPv2.BATCHSIZE:
+          cons.setBatchSize(((Integer)value).intValue());
+          return;
+        case LDAPv3.CLIENTCONTROLS:
+          if ( value == null )
+            cons.setClientControls( (LDAPControl[]) null );
+          else if ( value instanceof LDAPControl )
+            cons.setClientControls( (LDAPControl) value );
+          else if ( value instanceof LDAPControl[] )
+            cons.setClientControls( (LDAPControl[])value );
+          else
+            throw new LDAPException ( "invalid LDAPControl",
+                                      LDAPException.PARAM_ERROR );
+          return;
+        case LDAPv3.SERVERCONTROLS:
+          if ( value == null )
+            cons.setServerControls( (LDAPControl[]) null );
+          else if ( value instanceof LDAPControl )
+            cons.setServerControls( (LDAPControl) value );
+          else if ( value instanceof LDAPControl[] )
+            cons.setServerControls( (LDAPControl[])value );
+          else
+            throw new LDAPException ( "invalid LDAPControl",
+                                      LDAPException.PARAM_ERROR );
+          return;
+        case MAXBACKLOG:
+          cons.setMaxBacklog(((Integer)value).intValue());
+          return;
+        default:
+          throw new LDAPException ("invalid option",
+                                   LDAPException.PARAM_ERROR );
+        }
+      } catch (ClassCastException cc) {
+          throw new LDAPException ("invalid option value",
+                                   LDAPException.PARAM_ERROR );
+      }
+    }
+
+    /**
+     * Returns an array of the latest controls (if any) from server.
+     * <P>
+     * To retrieve the controls from a search result, call the 
+     * <CODE>getResponseControls</CODE> method from the <CODE>LDAPSearchResults
+     * </CODE> object returned with the result.
+     * @return an array of the controls returned by an operation, or
+     * null if none.
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.LDAPSearchResults#getResponseControls
+     */
+    public LDAPControl[] getResponseControls() {
+        LDAPControl[] controls = null;
+        Thread caller = Thread.currentThread();
+      
+        /* Get the latest controls for the caller thread */
+        synchronized(m_responseControlTable) {
+            ResponseControls rspCtrls =
+                (ResponseControls) m_responseControlTable.get(caller);
+
+            if (rspCtrls != null) {
+                Vector v = rspCtrls.ctrls;
+                controls = (LDAPControl[]) v.elementAt(0);
+                v.removeElementAt(0);
+                if (v.size() == 0) {
+                    m_responseControlTable.remove(caller);
+                }
+            }
+      }
+      
+      return controls;
+    }
+
+    /**
+     * Returns an array of the latest controls associated with the 
+     * particular request. Used internally by LDAPSearchResults to
+     * get response controls returned for a search request.
+     * <P>
+     * @param msdid Message ID
+     */
+    LDAPControl[] getResponseControls(int msgID) {
+        LDAPControl[] controls = null;
+
+        synchronized(m_responseControlTable) {            
+            Enumeration itr = m_responseControlTable.keys();          
+            while (itr.hasMoreElements()) {
+                Object client = itr.nextElement();
+                ResponseControls rspCtrls = (ResponseControls)m_responseControlTable.get(client);
+
+                if (msgID == rspCtrls.msgID) {
+                    Vector v = rspCtrls.ctrls;
+                    controls = (LDAPControl[]) v.elementAt(0);
+                    v.removeElementAt(0);
+                    if (v.size() == 0) {
+                        m_responseControlTable.remove(client);
+                    }
+                    break;
+                }
+            }
+        }
+      
+        return controls;
+    }
+    
+    /**
+     * Returns the set of constraints that apply to all operations
+     * performed through this connection (unless you specify a different
+     * set of constraints when calling a method). 
+     * <P>
+     *
+     * Note that if you want to get individual constraints (rather than
+     * getting the
+     * entire set of constraints), call the <CODE>getOption</CODE> method.
+     * <P>
+     *
+     * Typically, you might call the <CODE>getConstraints</CODE> method
+     * to create a slightly different set of constraints for a particular 
+     * operation.
+     * <P>
+     *
+     * For example, the following section of code changes the timeout
+     * to 3000 milliseconds for a specific rename. Rather than construct a new
+     * set of constraints from scratch, the example gets the current
+     * settings for the connections and just changes the setting for the
+     * timeout.
+     * <P>
+     *
+     * Note that this change only applies to the searches performed with this
+     * custom set of constraints.  All other searches performed through this
+     * connection use the original set of search constraints.
+     * <P>
+     *
+     * <PRE>
+     * ...
+     * LDAPConstraints myOptions = ld.getConstraints();
+     * myOptions.setTimeout( 3000 );
+     * ld.search( "cn=William Jensen, ou=Accounting, o=Ace Industry,c=US",
+     *            "cn=Will Jensen",
+     *            null,
+     *            false,
+     *            myOptions );
+     * ...
+     * </PRE>
+     *
+     * @return a copy of the <CODE>LDAPConstraints</CODE> object representing the
+     * set of constraints that apply (by default) to all operations
+     * performed through this connection.
+     * @see netscape.ldap.LDAPConstraints
+     * @see netscape.ldap.LDAPConnection#getOption
+     */
+    public LDAPConstraints getConstraints () {
+        return (LDAPConstraints)getSearchConstraints();
+    }
+   
+    /**
+     * Returns the set of search constraints that apply to all searches
+     * performed through this connection (unless you specify a different
+     * set of search constraints when calling the <CODE>search</CODE>
+     * method). 
+     * <P>
+     *
+     * Note that if you want to get individual constraints (rather than
+     * getting the
+     * entire set of constraints), call the <CODE>getOption</CODE> method.
+     * <P>
+     *
+     * Typically, you might call the <CODE>getSearchConstraints</CODE> method
+     * to create a slightly different set of search constraints
+     * to apply to a particular search.
+     * <P>
+     *
+     * For example, the following section of code changes the maximum number
+     * of results to 10 for a specific search. Rather than construct a new
+     * set of search constraints from scratch, the example gets the current
+     * settings for the connections and just changes the setting for the
+     * maximum results.
+     * <P>
+     *
+     * Note that this change only applies to the searches performed with this
+     * custom set of constraints.  All other searches performed through this
+     * connection use the original set of search constraints.
+     * <P>
+     *
+     * <PRE>
+     * ...
+     * LDAPSearchConstraints myOptions = ld.getSearchConstraints();
+     * myOptions.setMaxResults( 10 );
+     * String[] myAttrs = { "objectclass" };
+     * LDAPSearchResults myResults = ld.search( "o=Ace Industry,c=US",
+     *                                          LDAPv2.SCOPE_SUB,
+     *                                          "(objectclass=*)",
+     *                                          myAttrs,
+     *                                          false,
+     *                                          myOptions );
+     * ...
+     * </PRE>
+     *
+     * @return a copy of the <CODE>LDAPSearchConstraints</CODE> object 
+     * representing the set of search constraints that apply (by default) to 
+     * all searches performed through this connection.
+     * @see netscape.ldap.LDAPSearchConstraints
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)  
+     */
+    public LDAPSearchConstraints getSearchConstraints () {
+        return (LDAPSearchConstraints)m_defaultConstraints.clone();
+    }
+
+
+    /**
+     * Set the default constraint set for all operations. 
+     * @param cons <CODE>LDAPConstraints</CODE> object to use as the default
+     * constraint set
+     * @see netscape.ldap.LDAPConnection#getConstraints
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public void setConstraints(LDAPConstraints cons) {
+        m_defaultConstraints.setHopLimit(cons.getHopLimit());
+        m_defaultConstraints.setReferrals(cons.getReferrals());
+        m_defaultConstraints.setTimeLimit(cons.getTimeLimit());
+        m_defaultConstraints.setBindProc(cons.getBindProc());
+        m_defaultConstraints.setRebindProc(cons.getRebindProc());
+
+        LDAPControl[] tClientControls = cons.getClientControls();
+        LDAPControl[] oClientControls = null;
+
+        if ( (tClientControls != null) &&
+             (tClientControls.length > 0) ) {
+            oClientControls = new LDAPControl[tClientControls.length]; 
+            for( int i = 0; i < tClientControls.length; i++ ) {
+                oClientControls[i] = (LDAPControl)tClientControls[i].clone();
+            }
+        } 
+        m_defaultConstraints.setClientControls(oClientControls);
+ 
+        LDAPControl[] tServerControls = cons.getServerControls();
+        LDAPControl[] oServerControls = null;
+
+        if ( (tServerControls != null) && 
+             (tServerControls.length > 0) ) {
+            oServerControls = new LDAPControl[tServerControls.length];
+            for( int i = 0; i < tServerControls.length; i++ ) {
+                oServerControls[i] = (LDAPControl)tServerControls[i].clone();
+            }
+        }
+        m_defaultConstraints.setServerControls(oServerControls);
+    }
+    
+    /**
+     * Set the default constraint set for all search operations. 
+     * @param cons <CODE>LDAPSearchConstraints</CODE> object to use as the
+     * default constraint set
+     * @see netscape.ldap.LDAPConnection#getSearchConstraints
+     * @see netscape.ldap.LDAPSearchConstraints
+     */
+    public void setSearchConstraints(LDAPSearchConstraints cons) {
+        m_defaultConstraints = (LDAPSearchConstraints)cons.clone();
+    }
+
+    /**
+     * Gets the stream for reading from the listener socket
+     *
+     * @return the stream for reading from the listener socket, or
+     * <CODE>null</CODE> if there is none
+     */
+    public InputStream getInputStream() {
+        return (m_thread != null) ? m_thread.getInputStream() : null;
+    }
+
+    /**
+     * Sets the stream for reading from the listener socket if
+     * there is one
+     *
+     * @param is the stream for reading from the listener socket
+     */
+    public void setInputStream( InputStream is ) {
+        if ( m_thread != null ) {
+            m_thread.setInputStream( is );
+        }
+    }
+
+    /**
+     * Gets the stream for writing to the socket
+     *
+     * @return the stream for writing to the socket, or
+     * <CODE>null</CODE> if there is none
+     */
+    public OutputStream getOutputStream() {
+        return (m_thread != null) ? m_thread.getOutputStream() : null;
+    }
+
+    /**
+     * Sets the stream for writing to the socket
+     *
+     * @param os the stream for writing to the socket, if there is one
+     */
+    public void setOutputStream( OutputStream os ) {
+        if ( m_thread != null ) {
+            m_thread.setOutputStream( os );
+        }
+    }
+
+    /**
+     * Get a new listening agent from the internal buffer of available agents.
+     * These objects are used to make the asynchronous LDAP operations
+     * synchronous.
+     * @return response listener object
+     */
+    synchronized LDAPResponseListener getResponseListener () {
+        if (m_responseListeners == null) {
+            m_responseListeners = new Vector (5);
+        }
+
+        LDAPResponseListener l;
+        if ( m_responseListeners.size() < 1 ) {
+            l = new LDAPResponseListener ( /*asynchOp=*/false );
+        }
+        else {
+            l = (LDAPResponseListener)m_responseListeners.elementAt (0);
+            m_responseListeners.removeElementAt (0);
+        }
+        return l;
+    }
+
+    /**
+     * Get a new search listening agent from the internal buffer of available
+     * agents. These objects are used to make the asynchronous LDAP operations
+     * synchronous.
+     * @return a search response listener object
+     */
+    private synchronized LDAPSearchListener getSearchListener (
+        LDAPSearchConstraints cons ) {
+        if (m_searchListeners == null) {
+            m_searchListeners = new Vector (5);
+        }
+
+        LDAPSearchListener l;
+        if ( m_searchListeners.size() < 1 ) {
+            l = new LDAPSearchListener ( /*asynchOp=*/false, cons );
+        }
+        else {
+            l = (LDAPSearchListener)m_searchListeners.elementAt (0);
+            m_searchListeners.removeElementAt (0);
+            l.setSearchConstraints(cons);
+        }
+        return l;
+    }
+
+    /**
+     * Put a listening agent into the internal buffer of available agents.
+     * These objects are used to make the asynchronous LDAP operations
+     * synchronous.
+     * @param l listener to buffer
+     */
+    synchronized void releaseResponseListener (LDAPResponseListener l) {
+        if (m_responseListeners == null) {
+            m_responseListeners = new Vector (5);
+        }
+
+        l.reset ();
+        m_responseListeners.addElement (l);
+    }
+
+    /**
+     * Put a search listening agent into the internal buffer of available
+     * agents. These objects are used to make the asynchronous LDAP
+     * operations synchronous.
+     * @param l listener to buffer
+     */
+    synchronized void releaseSearchListener (LDAPSearchListener l) {
+
+        if (l.isAsynchOp()) { // persistent search 
+            return;
+        }
+
+        if (m_searchListeners == null) {
+            m_searchListeners = new Vector (5);
+        }
+
+        l.reset ();
+        m_searchListeners.addElement (l);
+    }
+
+    /**
+     * Checks the message (assumed to be a return value).  If the resultCode
+     * is anything other than SUCCESS, it throws an LDAPException describing
+     * the server's (error) response.
+     * Extract response controls from the message, if any avaialble.
+     * @param m server response to validate
+     * @exception LDAPException failed to check message
+     */
+    void checkMsg (LDAPMessage m) throws LDAPException {
+
+      // Check for response controls
+      LDAPControl[] ctrls = m.getControls();
+      if (ctrls != null) {
+          int msgID = m.getMessageID();
+          setResponseControls(Thread.currentThread(), msgID, ctrls);
+      }
+    
+      if (m.getProtocolOp() instanceof JDAPResult) {
+          JDAPResult response = (JDAPResult)(m.getProtocolOp());
+          int resultCode = response.getResultCode ();
+
+          if (resultCode == JDAPResult.SUCCESS) {
+              return;
+          }
+
+          if (resultCode == JDAPResult.REFERRAL) {
+              throw new LDAPReferralException ("referral", resultCode,
+                                               response.getReferrals());
+          }
+
+          if (resultCode == JDAPResult.LDAP_PARTIAL_RESULTS) {
+              throw new LDAPReferralException ("referral", resultCode,
+                                               response.getErrorMessage());
+          } else {
+              throw new LDAPException ("error result", resultCode,
+                response.getErrorMessage(),
+                response.getMatchedDN());
+          }
+
+      } else if (m.getProtocolOp() instanceof JDAPSearchResultReference) {
+          String[] referrals =
+            ((JDAPSearchResultReference)m.getProtocolOp()).getUrls();
+          throw new LDAPReferralException ("referral",
+                                           JDAPResult.SUCCESS, referrals);
+      } else {
+          return;
+      }
+    }
+
+    /**
+     * Set response controls for the current connection for a particular 
+     * thread. Get the oldest returned controls and remove them from the 
+     * queue. If the connection is executing a persistent search, there may
+     * be more than one set of controls in the queue. For any other 
+     * operation, there will only ever be at most one set of controls 
+     * (controls from any earlier operation are replaced by controls 
+     * received on the latest operation on this connection by this thread).
+     * @param current the target thread
+     * @param con the server response controls
+     */
+    void setResponseControls( Thread client, int msgID, LDAPControl[] ctrls ) {
+        synchronized(m_responseControlTable) {
+            ResponseControls rspCtrls = (ResponseControls)m_responseControlTable.get(client);
+
+            if (rspCtrls == null || rspCtrls.msgID != msgID) {
+                rspCtrls = new ResponseControls(msgID, ctrls);
+
+                m_responseControlTable.put(client, rspCtrls);
+            }
+            else {
+                rspCtrls.addControls(ctrls);
+            }
+        }
+    }
+
+    /**
+     * Set up connection for referral.
+     * @param u referral URL
+     * @param cons search constraints
+     * @return new LDAPConnection, already connected and authenticated
+     */
+    private LDAPConnection referralConnect( LDAPUrl[] refList,
+                                            LDAPConstraints cons )
+        throws LDAPException {
+        LDAPConnection connection = new LDAPConnection (getSocketFactory());
+        
+        // Set the same connection setup failover policy as for this connection
+        connection.setConnSetupDelay(getConnSetupDelay());
+        
+        connection.setOption(REFERRALS, new Boolean(true));
+        connection.setOption(REFERRALS_REBIND_PROC, cons.getRebindProc());
+        connection.setOption(BIND, cons.getBindProc());
+  
+        Object traceOut = getProperty(TRACE_PROPERTY);
+        if (traceOut != null) {
+            connection.setProperty(TRACE_PROPERTY, traceOut);
+        }
+          
+        // need to set the protocol version which gets passed to connection
+        connection.setOption(PROTOCOL_VERSION,
+                              new Integer(m_protocolVersion));
+
+        connection.setOption(REFERRALS_HOP_LIMIT,
+                              new Integer(cons.getHopLimit()-1));
+
+        try { 
+            connection.connect (refList);
+        }
+        catch (LDAPException e) {
+            throw new LDAPException("Referral connect failed: " + e.getMessage(),
+                e.getLDAPResultCode());
+        }
+        return connection;
+    }
+
+    private void referralRebind(LDAPConnection ldc, LDAPConstraints cons)
+        throws LDAPException{
+        try {
+            if (cons.getRebindProc() == null && cons.getBindProc() == null) {
+                ldc.authenticate (m_protocolVersion, null, null);
+            } else if (cons.getBindProc() == null) {
+                LDAPRebindAuth auth =
+                  cons.getRebindProc().getRebindAuthentication(ldc.getHost(),
+                                                               ldc.getPort());
+                ldc.authenticate(m_protocolVersion, auth.getDN(), auth.getPassword());
+            } else {
+                cons.getBindProc().bind(ldc);
+            }
+        }
+        catch (LDAPException e) {
+            throw new LDAPException("Referral bind failed: " + e.getMessage(),
+                e.getLDAPResultCode());
+        }            
+    }
+
+    /**
+     * Check for "ldap(s):///" referrals (no host:port) and replace them with
+     * "ldap(s)://currentHost:currentPort".
+     */
+    private void adjustReferrals(LDAPUrl[] urls) {
+        String host = null;
+        int port =0;
+        
+        for (int i=0; urls != null && i < urls.length; i++) {
+            host = urls[i].getHost();
+            port = urls[i].getPort();
+            if ( (host == null) || (host.length() < 1) ) {
+                // If no host:port was specified, use the latest (hop-wise) parameters
+                host = getHost();
+                port = getPort();
+                urls[i] = new  LDAPUrl (host, port,
+                                        urls[i].getDN(),
+                                        urls[i].getAttributeArray(),
+                                        urls[i].getScope(),
+                                        urls[i].getFilter(),
+                                        urls[i].isSecure());                
+            }
+        }
+    }
+
+    /**
+     * Establish the LDAPConnection to the referred server. This one is used
+     * for bind operation only since we need to keep this new connection for
+     * the subsequent operations. This new connection will be destroyed in
+     * two circumstances: disconnect gets called or the client binds as
+     * someone else.
+     * @return the new LDAPConnection to the referred server
+     */
+    LDAPConnection createReferralConnection(LDAPReferralException e,
+      LDAPConstraints cons) throws LDAPException {
+        if (cons.getHopLimit() <= 0) {
+            throw new LDAPException("exceed hop limit",
+                                    e.getLDAPResultCode(), e.getLDAPErrorMessage());
+        }
+        if (!cons.getReferrals()) {
+            throw e;
+        }
+
+        LDAPUrl[] refList = e.getURLs();
+        
+        // If there are no referrals (because the server isn't set up for
+        // them), give up here
+        if (refList == null) {
+            throw new LDAPException("No target URL in referral",
+                                    LDAPException.NO_RESULTS_RETURNED);
+        }
+        adjustReferrals(refList);
+        
+        LDAPConnection connection = referralConnect(refList, cons);
+
+        // which one did we connect to...
+        LDAPUrl refURL = connection.m_connMgr.getLDAPUrl();
+
+        String refDN = refURL.getDN();
+        if ((refDN == null) || (refDN.equals(""))) {
+            refDN = m_boundDN;
+        }
+
+        try {
+            connection.authenticate(m_protocolVersion, refDN, m_boundPasswd);
+        }
+        catch (LDAPException authEx) {
+            // Disconnect needed to terminate the LDAPConnThread
+            try  {                
+                connection.disconnect();
+            }
+            catch (LDAPException ignore) {}
+            throw authEx;
+        }
+        return connection;
+    }
+
+    /**
+     * Follows a referral.
+     * @param e referral exception
+     * @param cons search constraints
+     */
+    void performReferrals(LDAPReferralException e,
+                          LDAPConstraints cons, int ops,
+                          /* unions of different operation parameters */
+                          String dn, int scope, String filter, String types[],
+                          boolean attrsOnly, LDAPModification mods[],
+                          LDAPEntry entry,
+                          LDAPAttribute attr,
+                          /* result */
+                          Vector results
+        ) throws LDAPException {
+
+        LDAPUrl refURL = null;
+        LDAPConnection connection = null;
+        
+        try {        
+
+            if (cons.getHopLimit() <= 0) {
+                throw new LDAPException("exceed hop limit",
+                                        e.getLDAPResultCode(),
+                                        e.getLDAPErrorMessage());
+            }
+            if (!cons.getReferrals()) {
+                if (ops == JDAPProtocolOp.SEARCH_REQUEST) {
+                    LDAPSearchResults res = new LDAPSearchResults();
+                    res.add(e);
+                    results.addElement(res);
+                    return;
+                } else {
+                    throw e;
+                }
+            }
+
+            LDAPUrl urls[] = e.getURLs();
+            // If there are no referrals (because the server isn't configured to
+            // return one), give up here
+            if ( urls == null || urls.length == 0) {
+                return;
+            }
+            adjustReferrals(urls);
+                
+            // Check if we can use m_referralConnection to follow this referral                
+            if (m_referralConnection != null && m_referralConnection.isConnected()) {
+                String refHost = m_referralConnection.getHost();
+                int    refPort = m_referralConnection.getPort();
+                try {
+                    // Compare ipAddr:port for each referral with the m_referralConnection
+                    String refAddr = InetAddress.getByName(refHost).getHostAddress();                    
+                    for (int i = 0; i < urls.length; i++) {
+                        String urlHost = urls[i].getHost();
+                        int    urlPort = urls[i].getPort();
+                        String urlAddr = InetAddress.getByName(urlHost).getHostAddress();
+                        if (refAddr == urlAddr && refPort == urlPort) {
+                            refURL = urls[i];
+                            break;
+                        }
+                    }
+                }
+                catch (UnknownHostException ex) {
+                    // Compare host names rather than ip addr
+                    for (int i = 0; i < urls.length; i++) {
+                        if (refHost == urls[i].getHost() &&
+                            refPort == urls[i].getPort()) {
+                            refURL = urls[i];
+                            break;
+                        }
+                    }
+                }
+            }
+
+            if (refURL != null) {
+                connection = m_referralConnection;
+            }
+            else {
+                connection = referralConnect( urls, cons );
+                    
+                // which one did we connect to...
+                refURL = connection.m_connMgr.getLDAPUrl();
+                    
+                // Authenticate
+                referralRebind(connection, cons);
+            }
+
+            String newDN = refURL.getDN();
+            String DN = null;
+            if ((newDN == null) || (newDN.equals(""))) {
+                DN = dn;
+            } else {
+                DN = newDN;
+            }
+            // If this was a one-level search, and a direct subordinate
+            // has a referral, there will be a "?base" in the URL, and
+            // we have to rewrite the scope from one to base
+            if ( refURL.getUrl().indexOf("?base") > -1 ) {
+                scope = SCOPE_BASE;
+            }
+
+            LDAPSearchConstraints newcons = (LDAPSearchConstraints)cons.clone();
+            newcons.setHopLimit( cons.getHopLimit()-1 );
+
+            referralOperation(connection, newcons, ops, DN, scope, filter,
+                             types, attrsOnly, mods, entry, attr, results);
+
+        }
+        catch (LDAPException ex) {
+            if (refURL != null) {
+                ex.setExtraMessage("Failed to follow referral to " + refURL);
+            }
+            else {
+                ex.setExtraMessage("Failed to follow referral");
+            }
+            throw ex;
+        }
+    }
+
+    void referralOperation(LDAPConnection connection, 
+                          LDAPConstraints cons, int ops, String dn, int scope,
+                          String filter, String types[], boolean attrsOnly,
+                          LDAPModification mods[], LDAPEntry entry,
+                          LDAPAttribute attr,
+                          Vector results) throws LDAPException {
+ 
+        LDAPSearchResults res = null;
+        try {
+            switch (ops) {
+                case JDAPProtocolOp.SEARCH_REQUEST:
+
+                    res = connection.search(dn, scope, filter,
+                                            types, attrsOnly, 
+                                            (LDAPSearchConstraints)cons);
+                    if (res != null) {
+                        res.closeOnCompletion(connection);
+                        results.addElement(res);
+                    } else {
+                        if ((m_referralConnection == null) ||
+                          (!connection.equals(m_referralConnection)))
+                            connection.disconnect();
+                    }
+                    break;
+                case JDAPProtocolOp.MODIFY_REQUEST:
+                    connection.modify(dn, mods, cons);
+                    break;
+                case JDAPProtocolOp.ADD_REQUEST:
+                    if ((dn != null) && (!dn.equals("")))
+                         entry.setDN(dn);
+                    connection.add(entry, cons);
+                    break;
+                case JDAPProtocolOp.DEL_REQUEST:
+                    connection.delete(dn, cons);
+                    break;
+                case JDAPProtocolOp.MODIFY_RDN_REQUEST:
+                    connection.rename(dn, filter /* newRDN */, 
+                      attrsOnly /* deleteOld */, cons);
+                    break;
+                case JDAPProtocolOp.COMPARE_REQUEST:
+                    boolean bool = connection.compare(dn, attr, cons);
+                    results.addElement(new Boolean(bool));
+                    break;
+                default:
+                    /* impossible */
+                    break;
+            }
+        } catch (LDAPException ee) {
+            throw ee;
+        } finally {
+            if ((connection != null) && 
+                ((ops != JDAPProtocolOp.SEARCH_REQUEST) || (res == null)) &&
+                ((m_referralConnection == null) || 
+                 (!connection.equals(m_referralConnection)))) {
+                connection.disconnect();
+            }
+        }
+    }
+
+    /**
+     * Follows a referral for an extended operation.
+     * @param e referral exception
+     * @param cons search constraints
+     */
+    private LDAPExtendedOperation performExtendedReferrals(
+        LDAPReferralException e,
+        LDAPConstraints cons, LDAPExtendedOperation op )
+        throws LDAPException {
+
+        if (cons.getHopLimit() <= 0) {
+            throw new LDAPException("exceed hop limit",
+                                    e.getLDAPResultCode(),
+                                    e.getLDAPErrorMessage());
+        }
+        if (!cons.getReferrals()) {
+            throw e;
+        }
+
+        LDAPUrl u[] = e.getURLs();
+        // If there are no referrals (because the server isn't configured to
+        // return one), give up here
+        if ( u == null || u.length == 0) {
+            return null;
+        }
+        adjustReferrals(u);
+        
+        LDAPConnection connection = referralConnect( u, cons);
+        referralRebind(connection, cons);
+        LDAPExtendedOperation results =
+            connection.extendedOperation( op );
+        connection.disconnect();
+        return results; /* return right away if operation is successful */
+        
+    }
+
+    /**
+     * Returns a new <CODE>LDAPConnection</CODE> object that shares
+     * the physical connection to the LDAP server but has its own state.
+     *     
+     * The returned <CODE>LDAPConnection</CODE> object contains the same
+     * state as the current connection, including:
+     * <UL>
+     * <LI>the default search constraints
+     * <LI>host name and port number of the LDAP server
+     * <LI>the DN and password used to authenticate to the LDAP server
+     * <LI>the cache
+     * </UL>
+     * <P>
+     * @return the <CODE>LDAPconnection</CODE> object representing the
+     * new object.
+     */
+    public synchronized Object clone() {
+
+        LDAPConnection c = null; 
+        
+        try {
+            if (m_thread != null) {
+                checkConnection(/*rebind=*/true);
+            }
+        }
+        catch (LDAPException ignore) {}
+        
+        try {
+            c = (LDAPConnection)super.clone();
+            c.m_defaultConstraints =
+                (LDAPSearchConstraints)m_defaultConstraints.clone();
+            c.m_responseListeners = null;
+            c.m_searchListeners = null;            
+            c.m_properties = (Hashtable)m_properties.clone();
+            c.m_responseControlTable = new Hashtable();
+
+            if (c.m_cache != null) {
+                c.m_cache.addReference();
+            }
+
+            if (isConnected()) {
+                /* share current connection thread */
+                c.m_thread.register(c);
+            }
+            else {
+                c.m_thread  = null;
+                c.m_connMgr = null;
+            }
+
+        } catch (Exception ignore) {}
+
+        return c;
+    }
+
+    /**
+     * Sets up basic connection privileges for Communicator.
+     * @return true if in Communicator and connections okay.
+     */
+    private static boolean checkCommunicator() {
+        try {
+            java.lang.reflect.Method m = LDAPCheckComm.getMethod(
+              "netscape.security.PrivilegeManager", "enablePrivilege");
+            if (m == null) {
+                printDebug("Method is null");
+                return false;
+            }
+
+            Object[] args = new Object[1];
+            args[0] = new String("UniversalConnect");
+            m.invoke( null, args);
+            printDebug( "UniversalConnect enabled" );
+            args[0] = new String("UniversalPropertyRead");
+            m.invoke( null, args);
+            printDebug( "UniversalPropertyRead enabled" );
+            return true;
+        } catch (LDAPException e) {
+            printDebug("Exception: "+e.toString());
+        } catch (Exception ie) {
+            printDebug("Exception on invoking " + "enablePrivilege: "+ie.toString());
+        }
+        return false;
+    }
+
+    /**
+     * Reports if the class is running in a Netscape browser.
+     * @return <CODE>true</CODE> if the class is running in a Netscape browser.
+     */
+    public static boolean isNetscape() {
+        return isCommunicator;
+    }
+
+    static void printDebug( String msg ) {
+        if ( debug ) {
+            System.out.println( msg );
+        }
+    }
+
+    /**
+     * Returns the string representation for this <CODE>LDAPConnection</CODE>.
+     * <P>
+     * For example:
+     *
+     * <PRE>LDAPConnection {ldap://dilly:389 (2) ldapVersion:3 bindDN:"uid=admin,o=iplanet.com"}</PRE>
+     * 
+     * For cloned connections, the number of LDAPConnection instances sharing the 
+     * same physical connection is shown in parenthesis following the ldap url. 
+     * If a LDAPConnection is not cloned, this number is omitted from the string
+     * representation.
+     *
+     * @return string representation of the connection.
+     * @see netscape.ldap.LDAPConnection#clone
+     */    
+    public String toString() {
+        int cloneCnt = (m_thread == null) ? 0 : m_thread.getClientCount();
+        StringBuffer sb = new StringBuffer("LDAPConnection {");
+        //url
+        if (m_connMgr != null) {
+            sb.append(m_connMgr.getLDAPUrl().getServerUrl());
+        }
+        // clone count
+        if (cloneCnt > 1) {
+            sb.append(" (");
+            sb.append(cloneCnt);
+            sb.append(")");
+        }
+        // ldap version
+        sb.append(" ldapVersion:");
+        sb.append(m_protocolVersion);
+        // bind DN
+        sb.append(" bindDN:\"");
+        if (getAuthenticationDN() != null) {
+            sb.append(getAuthenticationDN());
+        }
+        sb.append("\"}");
+        
+        return sb.toString();
+    }
+
+    /** 
+     * A helper class for collecting response controls. Used as a value 
+     * in m_responseControlTable
+     */
+    class ResponseControls {
+        int msgID;
+        Vector ctrls;
+        
+        public ResponseControls(int msgID, LDAPControl[] ctrls) {
+            this.msgID = msgID;
+            this.ctrls = new Vector();
+            this.ctrls.addElement(ctrls);
+        }
+
+        void addControls(LDAPControl[] ctrls) {
+            this.ctrls.addElement(ctrls);
+        }
+    }
+
+    
+    /**
+     * Prints out the LDAP Java SDK version and the highest LDAP
+     * protocol version supported by the SDK. To view this
+     * information, open a terminal window, and enter:
+     * <PRE>java netscape.ldap.LDAPConnection
+     * </PRE>
+     * @param args not currently used
+     */
+    public static void main(String[] args) {
+        System.out.println("LDAP SDK Version is "+SdkVersion);
+        System.out.println("LDAP Protocol Version is "+ProtocolVersion);
+    }
+
+    /**
+     * Option specifying the maximum number of unread entries to be cached in any
+     * LDAPSearchResults without suspending reading from the server.
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int MAXBACKLOG   = 30;
+
+    private static boolean isCommunicator = checkCommunicator();
+    private static boolean debug = false;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSyntaxSchema.java
@@ -0,0 +1,193 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * The definition of a syntax type in the schema.
+ * <A HREF="http://www.ietf.org/rfc/rfc2252.txt"
+ * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+ * LDAP Subschema Attribute</A> covers the types of information
+ * to specify when defining a syntax.
+ * The description of a syntax can include the following:
+ * <P>
+ *
+ * <UL>
+ * <LI>an OID identifying the syntax
+ * <LI>a description of the attribute type
+ * </UL>
+ * <P>
+ *
+ * When you construct an <CODE>LDAPSyntaxSchema</CODE> object, you can
+ * specify these types of information as arguments to the constructor or
+ * in the ldapSyntaxes format specified in RFC 2252.
+ * When an LDAP client searches an LDAP server for the schema, the server
+ * returns schema information as an object with attribute values in this
+ * format.
+ * <P>
+ * RFC 2252 defines SyntaxDescription as follows:
+ * <P>
+ * <PRE>
+ *     SyntaxDescription = "(" whsp
+ *        numericoid whsp
+ *        [ "DESC" qdstring ]
+ *        whsp ")"
+ * </PRE>
+ *<P>
+ * Syntax definitions do not have a name, so the <CODE>getName</CODE>
+ * method inherited from <CODE>LDAPSchemaElement</CODE> returns "".
+ * To get the OID and description of this syntax type
+ * definition, use the <CODE>getOID</CODE> and
+ * <CODE>getDescription</CODE> methods inherited from the abstract class
+ * <CODE>LDAPSchemaElement</CODE>.
+ * <P>
+ *
+ * To add or remove this syntax type definition from the
+ * schema, use the <CODE>add</CODE> and <CODE>remove</CODE>
+ * methods, which this class inherits from the <CODE>LDAPSchemaElement</CODE>
+ * abstract class.
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPSchemaElement
+ **/
+
+public class LDAPSyntaxSchema extends LDAPSchemaElement {
+
+    static final long serialVersionUID = 3590667117475688132L;
+
+    /**
+     * Constructs a blank element.
+     */
+    protected LDAPSyntaxSchema() {
+        super();
+    }
+
+    /**
+     * Constructs a syntax type definition, using the specified
+     * information.
+     * @param oid object identifier (OID) of the syntax type
+     * in dotted-string format (for example, "1.2.3.4")
+     * @param description description of syntax type
+     */
+    public LDAPSyntaxSchema( String oid, String description ) {
+        super( "", oid, description );
+        attrName = "ldapSyntaxes";
+        syntaxElement.syntax = syntaxElement.syntaxCheck( oid );
+        syntaxElement.syntaxString = oid;
+    }
+
+    /**
+     * Constructs a syntax type definition based on a description in
+     * the ldapSyntaxes format. For information on this format,
+     * (see <A HREF="http://www.ietf.org/rfc/rfc2252.txt"
+     * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+     * LDAP Subschema Attribute</A>.  This is the format that LDAP servers
+     * and clients use to exchange schema information.  (For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the syntaxs "objectclasses" and "ldapSyntaxes".  The
+     * values of "ldapSyntaxes" are syntax type descriptions
+     * in this format.)
+     * <P>
+     *
+     * @param raw definition of the syntax type in the
+     * ldapSyntaxes format
+     */
+    public LDAPSyntaxSchema( String raw ) {
+        attrName = "ldapSyntaxes";
+        parseValue( raw );
+    }
+
+    /**
+     * Gets the syntax of the schema element
+     * @return one of the following values:
+     * <UL>
+     * <LI><CODE>cis</CODE> (case-insensitive string)
+     * <LI><CODE>ces</CODE> (case-exact string)
+     * <LI><CODE>binary</CODE> (binary data)
+     * <LI><CODE>int</CODE> (integer)
+     * <LI><CODE>telephone</CODE> (telephone number -- identical to cis,
+     * but blanks and dashes are ignored during comparisons)
+     * <LI><CODE>dn</CODE> (distinguished name)
+     * <LI><CODE>unknown</CODE> (not a known syntax)
+     * </UL>
+     */
+    public int getSyntax() {
+        return syntaxElement.syntax;
+    }
+
+    /**
+     * Gets the syntax of the syntax type in dotted-decimal format,
+     * for example "1.2.3.4.5"
+     * @return The syntax syntax in dotted-decimal format.
+     */
+    public String getSyntaxString() {
+        return syntaxElement.syntaxString;
+    }
+
+    /**
+     * Prepares a value in RFC 2252 format for submission to a server
+     *
+     * @return a String ready for submission to an LDAP server.
+     */
+    public String getValue() {
+        String s = getValuePrefix();
+        String val = getCustomValues();
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        s += ')';
+        return s;
+    }
+
+    /**
+     * Gets the definition of the syntax type in a user friendly format.
+     * This is the format that the syntax type definition uses when
+     * printing the syntax type or the schema.
+     * @return definition of the syntax type in a user friendly format.
+     */
+    public String toString() {
+        String s = "OID: " + oid;
+        s += "; Description: " + description;
+        s += getQualifierString( null );
+        return s;
+    }
+
+    protected LDAPSyntaxSchemaElement syntaxElement =
+        new LDAPSyntaxSchemaElement();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSchema.java
@@ -0,0 +1,953 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * This object represents the schema of an LDAP v3 server.
+ * You can use the <CODE>fetchSchema</CODE> method to retrieve
+ * the schema used by a server. (The server must support LDAP v3
+ * and the capability to retrieve the schema over the LDAP protocol.)
+ * <P>
+ *
+ * After you retrieve the schema, you can use this object to get
+ * the object class, attribute type, and matching rule descriptions
+ * in the schema.  You can also add your own object classes,
+ * attribute types, and matching rules to the schema.
+ * <P>
+ *
+ * To remove any object classes, attribute types, and matching rules
+ * that you added, call the <CODE>remove</CODE> methods of the
+ * <CODE>LDAPObjectClassSchema</CODE>, <CODE>LDAPAttributeSchema</CODE>,
+ * and <CODE>LDAPMatchingRuleSchema</CODE> classes.  (This method is
+ * inherited from the <CODE>LDAPSchemaElement</CODE> class.)
+ * <P>
+ *
+ * The following class is an example of an LDAP client that can
+ * fetch the schema, get and print object class descriptions and
+ * attribute type descriptions, and add object classes and attribute
+ * types to the schema over the LDAP protocol.
+ * <P>
+ *
+ * <PRE>
+ * import netscape.ldap.*;
+ * public class TestSchema {
+ *     public static void main( String[] args ) {
+ *         String HOSTNAME = "ldap.netscape.com";
+ *         int PORT_NUMBER = DEFAULT_PORT;
+ *         String ROOT_DN = "cn=Directory Manager";
+ *         String ROOT_PASSWORD = "23skidoo";
+ *
+ *         LDAPConnection ld = new LDAPConnection();
+ *
+ *         // Construct a new <CODE>LDAPSchema</CODE> object to get the schema.
+ *         LDAPSchema dirSchema = new LDAPSchema();
+ *
+ *         try {
+ *             // Connect to the server.
+ *             ld.connect( HOSTNAME, PORT_NUMBER );
+ *
+ *             // Get the schema from the directory.
+ *             dirSchema.fetchSchema( ld );
+ *
+ *             // Get and print the inetOrgPerson object class description.
+ *             LDAPObjectClassSchema objClass = dirSchema.getObjectClass(
+ *                 "inetOrgPerson" );
+ *             if ( objClass != null ) {
+ *                 System.out.println("inetOrgPerson := "+objClass.toString());
+ *             }
+ *
+ *             // Get and print the definition of the userPassword attribute.
+ *             LDAPAttributeSchema attrType = dirSchema.getAttribute(
+ *                 "userpassword" );
+ *             if ( attrType != null ) {
+ *                 System.out.println("userPassword := " + attrType.toString());
+ *             }
+ *
+ *             // Create a new object class definition.
+ *             String[] requiredAttrs = {"cn", "mail"};
+ *             String[] optionalAttrs = {"sn", "phoneNumber"};
+ *             LDAPObjectClassSchema newObjClass =
+ *                     new LDAPObjectClassSchema( "newInetOrgPerson",
+ *                                                "1.2.3.4.5.6.7",
+ *                                                "top",
+ *                                                "Experiment",
+ *                                                requiredAttrs,
+ *                                                optionalAttrs );
+ *
+ *             // Authenticate as root DN to get permissions to edit the schema.
+ *             ld.authenticate( ROOT_DN, ROOT_PASSWORD );
+ *
+ *             // Add the new object class to the schema.
+ *             newObjClass.add( ld );
+ *
+ *             // Create a new attribute type "hairColor".
+ *             LDAPAttributeSchema newAttrType =
+ *                     new LDAPAttributeSchema( "hairColor",
+ *                                              "1.2.3.4.5.4.3.2.1",
+ *                                              "Blonde, red, etc",
+ *                                              LDAPAttributeSchema.cis,
+ *                                              false );
+ *             // Add a custom qualifier
+ *             newObjClass.setQualifier( "X-OWNER", "John Jacobson" );
+ *
+ *             // Add the new attribute type to the schema.
+ *             newAttrType.add( ld );
+ *
+ *             // Fetch the schema again to verify that changes were made.
+ *             dirSchema.fetchSchema( ld );
+ *
+ *             // Get and print the new attribute type.
+ *             newAttrType = dirSchema.getAttribute( "hairColor" );
+ *             if ( newAttrType != null ) {
+ *                 System.out.println("hairColor := " + newAttrType.toString());
+ *             }
+ *
+ *             // Get and print the new object class.
+ *             newObjClass = dirSchema.getObjectClass( "newInetOrgPerson" );
+ *             if ( newObjClass != null ) {
+ *                 System.out.println("newInetOrgPerson := " +newObjClass.toString());
+ *             }
+ *
+ *             ld.disconnect();
+ *
+ *         } catch ( Exception e ) {
+ *             System.err.println( e.toString() );
+ *             System.exit( 1 );
+ *         }
+ *
+ *         System.exit( 0 );
+ *     }
+ * }
+ * </PRE>
+ *
+ * If you are using the Netscape Directory Server 3.0, you can also
+ * verify that the class and attribute type have been added through
+ * the directory server manager (go to Schema | Edit or View Attributes
+ * or Schema | Edit or View Object Classes).
+ * <P>
+ *
+ * To remove the classes and attribute types added by the example,
+ * see the examples under the <CODE>LDAPSchemaElement</CODE> class.
+ * <P>
+ *
+ * @see netscape.ldap.LDAPAttributeSchema
+ * @see netscape.ldap.LDAPObjectClassSchema
+ * @see netscape.ldap.LDAPMatchingRuleSchema
+ * @see netscape.ldap.LDAPSchemaElement
+ * @version 1.0
+ * @author Rob Weltman
+ **/
+public class LDAPSchema implements java.io.Serializable {
+
+    static final long serialVersionUID = -3911737419783579398L;
+
+    /**
+     * Constructs a new <CODE>LDAPSchema</CODE> object.
+     * Once you construct the object, you can get
+     * the schema by calling <CODE>fetchSchema</CODE>.
+     * <P>
+     *
+     * You can also print out the schema by using the
+     * <CODE>main</CODE> method. For example, you can enter
+     * the following command:
+     * <PRE>
+     * java netscape.ldap.LDAPSchema myhost.mydomain.com 389
+     * </PRE>
+     *
+     * Note that you need to call <CODE>fetchSchema</CODE>
+     * to get the schema from the server.  Constructing the
+     * object does not fetch the schema.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPSchema#fetchSchema
+     * @see netscape.ldap.LDAPSchema#main
+     */
+    public LDAPSchema() {
+    }
+
+    public LDAPSchema( LDAPEntry entry ) {
+        initialize( entry );
+    }
+
+    /**
+     * Adds an object class schema definition to the current schema.
+     * You can also add object class schema definitions by calling the
+     * <CODE>add</CODE> method of your newly constructed
+     * <CODE>LDAPObjectClassSchema</CODE> object.
+     * <P>
+     *
+     * To remove an object class schema definition that you have added,
+     * call the <CODE>getObjectClass</CODE> method to get the
+     * <CODE>LDAPObjectClassSchema</CODE> object representing your
+     * object class and call the <CODE>remove</CODE> method.
+     * <P>
+     *
+     * <B>NOTE: </B>For information on the <CODE>add</CODE> and
+     * <CODE>remove</CODE> methods of <CODE>LDAPObjectClassSchema</CODE>,
+     * see the documentation for <CODE>LDAPSchemaElement</CODE>.
+     * (These methods are inherited from <CODE>LDAPSchemaElement</CODE>.)
+     * <P>
+     *
+     * @param objectSchema <CODE>LDAPObjectClassSchema</CODE> object
+     * representing the object class schema definition to add
+     * @see netscape.ldap.LDAPObjectClassSchema
+     * @see netscape.ldap.LDAPSchemaElement#add
+     * @see netscape.ldap.LDAPSchemaElement#remove
+     */
+    public void addObjectClass( LDAPObjectClassSchema objectSchema ) {
+        objectClasses.put( objectSchema.getName().toLowerCase(),
+                           objectSchema );
+    }
+
+    /**
+     * Add an attribute type schema definition to the current schema.
+     * You can also add attribute type schema definitions by calling the
+     * <CODE>add</CODE> method of your newly constructed
+     * <CODE>LDAPAttributeSchema</CODE> object.
+     * <P>
+     *
+     * To remove an attribute type schema definition that you have added,
+     * call the <CODE>getAttribute</CODE> method to get the
+     * <CODE>LDAPAttributeSchema</CODE> object representing your
+     * attribute type and call the <CODE>remove</CODE> method.
+     * <P>
+     *
+     * <B>NOTE: </B>For information on the <CODE>add</CODE> and
+     * <CODE>remove</CODE> methods of <CODE>LDAPAttributeSchema</CODE>,
+     * see the documentation for <CODE>LDAPSchemaElement</CODE>.
+     * (These methods are inherited from <CODE>LDAPSchemaElement</CODE>.)
+     * <P>
+     *
+     * @param attrSchema <CODE>LDAPAttributeSchema</CODE> object
+     * representing the attribute type schema definition to add
+     * @see netscape.ldap.LDAPAttributeSchema
+     * @see netscape.ldap.LDAPSchemaElement#add
+     * @see netscape.ldap.LDAPSchemaElement#remove
+     */
+    public void addAttribute( LDAPAttributeSchema attrSchema ) {
+        attributes.put( attrSchema.getName().toLowerCase(), attrSchema );
+    }
+
+    /**
+     * Add a matching rule schema definition to the current schema.
+     * You can also add matching rule schema definitions by calling the
+     * <CODE>add</CODE> method of your newly constructed
+     * <CODE>LDAPMatchingRuleSchema</CODE> object.
+     * <P>
+     *
+     * To remove an attribute type schema definition that you have added,
+     * call the <CODE>getMatchingRule</CODE> method to get the
+     * <CODE>LDAPMatchingRuleSchema</CODE> object representing your
+     * matching rule and call the <CODE>remove</CODE> method.
+     * <P>
+     *
+     * <B>NOTE: </B>For information on the <CODE>add</CODE> and
+     * <CODE>remove</CODE> methods of <CODE>LDAPMatchingRuleSchema</CODE>,
+     * see the documentation for <CODE>LDAPSchemaElement</CODE>.
+     * (These methods are inherited from <CODE>LDAPSchemaElement</CODE>.)
+     * <P>
+     *
+     * @param matchSchema <CODE>LDAPMatchingRuleSchema</CODE> object
+     * representing the matching rule schema definition to add
+     * @see netscape.ldap.LDAPMatchingRuleSchema
+     * @see netscape.ldap.LDAPSchemaElement#add
+     * @see netscape.ldap.LDAPSchemaElement#remove
+     */
+    public void addMatchingRule( LDAPMatchingRuleSchema matchSchema ) {
+        matchingRules.put( matchSchema.getName().toLowerCase(), matchSchema );
+    }
+
+    /**
+     * Add a syntax schema definition to the current schema.
+     * You can also add syntax schema definitions by calling the
+     * <CODE>add</CODE> method of your newly constructed
+     * <CODE>LDAPSyntaxSchema</CODE> object.
+     * <P>
+     *
+     * To remove a syntax schema definition that you have added,
+     * call the <CODE>getSyntax</CODE> method to get the
+     * <CODE>LDAPSyntaxSchema</CODE> object representing your
+     * syntax type and call the <CODE>remove</CODE> method.
+     * <P>
+     *
+     * <B>NOTE: </B>For information on the <CODE>add</CODE> and
+     * <CODE>remove</CODE> methods of <CODE>LDAPSyntaxSchema</CODE>,
+     * see the documentation for <CODE>LDAPSchemaElement</CODE>.
+     * (These methods are inherited from <CODE>LDAPSchemaElement</CODE>.)
+     * <P>
+     *
+     * @param syntaxSchema <CODE>LDAPSyntaxSchema</CODE> object
+     * representing the syntax schema definition to add
+     * @see netscape.ldap.LDAPSyntaxSchema
+     * @see netscape.ldap.LDAPSchemaElement#add
+     * @see netscape.ldap.LDAPSchemaElement#remove
+     */
+    public void addSyntax( LDAPSyntaxSchema syntaxSchema ) {
+        String name = syntaxSchema.getName().toLowerCase();
+        if ( name.length() < 1 ) {
+            name = syntaxSchema.getOID();
+        }
+        syntaxes.put( name, syntaxSchema );
+    }
+
+    /**
+     * Add a structure rule definition to the current schema.
+     * You can also add structure rule definitions by calling the
+     * <CODE>add</CODE> method of your newly constructed
+     * <CODE>LDAPDITStructureRuleSchema</CODE> object.
+     * <P>
+     *
+     * To remove a structure rule definition that you have added,
+     * call the <CODE>getDITStructureRule</CODE> method to get the
+     * <CODE>LDAPDITStructureRuleSchema</CODE> object representing your
+     * rule and call the <CODE>remove</CODE> method.
+     * <P>
+     *
+     * <B>NOTE: </B>For information on the <CODE>add</CODE> and
+     * <CODE>remove</CODE> methods of <CODE>LDAPSyntaxSchema</CODE>,
+     * see the documentation for <CODE>LDAPSchemaElement</CODE>.
+     * (These methods are inherited from <CODE>LDAPSchemaElement</CODE>.)
+     * <P>
+     *
+     * @param rule <CODE>LDAPDITStructureRuleSchema</CODE> object
+     * representing the structure rule definition to add
+     * @see netscape.ldap.LDAPDITStructureRuleSchema
+     * @see netscape.ldap.LDAPSchemaElement#add
+     * @see netscape.ldap.LDAPSchemaElement#remove
+     */
+    public void addDITStructureRule( LDAPDITStructureRuleSchema rule ) {
+        String name = rule.getName().toLowerCase();
+        structureRulesByName.put( name, rule );
+        structureRulesById.put( new Integer( rule.getRuleID() ), rule );
+    }
+
+    /**
+     * Add a content rule definition to the current schema.
+     * You can also add content rule definitions by calling the
+     * <CODE>add</CODE> method of your newly constructed
+     * <CODE>LDAPDITContentRuleSchema</CODE> object.
+     * <P>
+     *
+     * To remove a content rule definition that you have added,
+     * call the <CODE>getDITContentRule</CODE> method to get the
+     * <CODE>LDAPDITContentRuleSchema</CODE> object representing your
+     * rule and call the <CODE>remove</CODE> method.
+     * <P>
+     *
+     * <B>NOTE: </B>For information on the <CODE>add</CODE> and
+     * <CODE>remove</CODE> methods of <CODE>LDAPSyntaxSchema</CODE>,
+     * see the documentation for <CODE>LDAPSchemaElement</CODE>.
+     * (These methods are inherited from <CODE>LDAPSchemaElement</CODE>.)
+     * <P>
+     *
+     * @param rule <CODE>LDAPDITContentRuleSchema</CODE> object
+     * representing the content rule definition to add
+     * @see netscape.ldap.LDAPDITContentRuleSchema
+     * @see netscape.ldap.LDAPSchemaElement#add
+     * @see netscape.ldap.LDAPSchemaElement#remove
+     */
+    public void addDITContentRule( LDAPDITContentRuleSchema rule ) {
+        String name = rule.getName().toLowerCase();
+        contentRules.put( name, rule );
+    }
+
+    /**
+     * Add a name form definition to the current schema.
+     * You can also add name form definitions by calling the
+     * <CODE>add</CODE> method of your newly constructed
+     * <CODE>LDAPNameFormSchema</CODE> object.
+     * <P>
+     *
+     * To remove a name form definition that you have added,
+     * call the <CODE>getNameForm</CODE> method to get the
+     * <CODE>LDAPNameFormSchema</CODE> object representing your
+     * nameForm type and call the <CODE>remove</CODE> method.
+     * <P>
+     *
+     * <B>NOTE: </B>For information on the <CODE>add</CODE> and
+     * <CODE>remove</CODE> methods of <CODE>LDAPNameFormSchema</CODE>,
+     * see the documentation for <CODE>LDAPSchemaElement</CODE>.
+     * (These methods are inherited from <CODE>LDAPSchemaElement</CODE>.)
+     * <P>
+     *
+     * @param nameForm <CODE>LDAPNameFormSchema</CODE> object
+     * representing the name form definition to add
+     * @see netscape.ldap.LDAPNameFormSchema
+     * @see netscape.ldap.LDAPSchemaElement#add
+     * @see netscape.ldap.LDAPSchemaElement#remove
+     */
+    public void addNameForm( LDAPNameFormSchema nameForm ) {
+        String name = nameForm.getName().toLowerCase();
+        nameForms.put( name, nameForm );
+    }
+
+    /**
+     * Gets an enumeration ofthe object class definitions in this schema.
+     * @return an enumeration of object class definitions.
+     */
+    public Enumeration getObjectClasses() {
+        return objectClasses.elements();
+    }
+
+    /**
+     * Gets an enumeration ofthe attribute type definitions in this schema.
+     * @return an enumeration of attribute type definitions.
+     */
+    public Enumeration getAttributes() {
+        return attributes.elements();
+    }
+
+    /**
+     * Gets an enumeration ofthe matching rule definitions in this schema.
+     * @return an enumeration of matching rule definitions.
+     */
+    public Enumeration getMatchingRules() {
+        return matchingRules.elements();
+    }
+
+    /**
+     * Get an enumeration of the syntaxes in this schema.
+     * @return an enumeration of syntax objects
+     */
+    public Enumeration getSyntaxes() {
+        return syntaxes.elements();
+    }
+
+    /**
+     * Get an enumeration of the structure rules in this schema.
+     * @return an enumeration of structure rule objects
+     */
+    public Enumeration getDITStructureRules() {
+        return structureRulesByName.elements();
+    }
+
+    /**
+     * Get an enumeration of the content rules in this schema.
+     * @return an enumeration of content rule objects
+     */
+    public Enumeration getDITContentRules() {
+        return contentRules.elements();
+    }
+
+    /**
+     * Get an enumeration of the name forms in this schema.
+     * @return an enumeration of name form objects
+     */
+    public Enumeration getNameForms() {
+        return nameForms.elements();
+    }
+
+    /**
+     * Gets the definition of the object class with the specified name.
+     * @param name name of the object class to find
+     * @return an <CODE>LDAPObjectClassSchema</CODE> object representing
+     * the object class definition, or <CODE>null</CODE> if not found.
+     */
+    public LDAPObjectClassSchema getObjectClass( String name ) {
+        return (LDAPObjectClassSchema)objectClasses.get( name.toLowerCase() );
+    }
+
+    /**
+     * Gets the definition of the attribute type with the specified name.
+     * @param name name of the attribute type to find
+     * @return an <CODE>LDAPAttributeSchema</CODE> object representing
+     * the attribute type definition, or <CODE>null</CODE> if not found.
+     */
+    public LDAPAttributeSchema getAttribute( String name ) {
+        return (LDAPAttributeSchema)attributes.get( name.toLowerCase() );
+    }
+
+    /**
+     * Gets the definition of a matching rule with the specified name.
+     * @param name name of the matching rule to find
+     * @return an <CODE>LDAPMatchingRuleSchema</CODE> object representing
+     * the matching rule definition, or <CODE>null</CODE> if not found.
+     */
+    public LDAPMatchingRuleSchema getMatchingRule( String name ) {
+        return (LDAPMatchingRuleSchema)matchingRules.get( name.toLowerCase() );
+    }
+
+    /**
+     * Gets the definition of a syntax with the specified name.
+     * @param name name of the syntax to find
+     * @return an <CODE>LDAPSyntaxSchema</CODE> object representing
+     * the syntax definition, or <CODE>null</CODE> if not found.
+     */
+    public LDAPSyntaxSchema getSyntax( String name ) {
+        return (LDAPSyntaxSchema)syntaxes.get( name.toLowerCase() );
+    }
+
+    /**
+     * Gets the definition of a structure rule with the specified name.
+     * @param name name of the rule to find
+     * @return an <CODE>LDAPDITStructureRuleSchema</CODE> object representing
+     * the rule, or <CODE>null</CODE> if not found.
+     */
+    public LDAPDITStructureRuleSchema getDITStructureRule( String name ) {
+        return (LDAPDITStructureRuleSchema)structureRulesByName.get(
+            name.toLowerCase() );
+    }
+
+    /**
+     * Gets the definition of a structure rule with the specified name.
+     * @param ID ID of the rule to find
+     * @return an <CODE>LDAPDITStructureRuleSchema</CODE> object representing
+     * the rule, or <CODE>null</CODE> if not found.
+     */
+    public LDAPDITStructureRuleSchema getDITStructureRule( int ID ) {
+        return (LDAPDITStructureRuleSchema)structureRulesById.get(
+            new Integer( ID ) );
+    }
+
+    /**
+     * Gets the definition of a content rule with the specified name.
+     * @param name name of the rule to find
+     * @return an <CODE>LDAPDITContentRuleSchema</CODE> object representing
+     * the rule, or <CODE>null</CODE> if not found.
+     */
+    public LDAPDITContentRuleSchema getDITContentRule( String name ) {
+        return (LDAPDITContentRuleSchema)contentRules.get(
+            name.toLowerCase() );
+    }
+
+    /**
+     * Gets the definition of a name form with the specified name.
+     * @param name name of the name form to find
+     * @return an <CODE>LDAPNameFormSchema</CODE> object representing
+     * the syntax definition, or <CODE>null</CODE> if not found.
+     */
+    public LDAPNameFormSchema getNameForm( String name ) {
+        return (LDAPNameFormSchema)nameForms.get( name.toLowerCase() );
+    }
+
+    /**
+     * Get an enumeration of the names of the object classes in this schema.
+     * @return an enumeration of object class names (all lower-case).
+     */
+    public Enumeration getObjectClassNames() {
+        return objectClasses.keys();
+    }
+
+    /**
+     * Get an enumeration of the names of the attribute types in this schema.
+     * @return an enumeration of attribute names (all lower-case).
+     */
+    public Enumeration getAttributeNames() {
+        return attributes.keys();
+    }
+
+    /**
+     * Get an enumeration of the names of the matching rules in this schema.
+     * @return an enumeration of matching rule names (all lower-case).
+     */
+    public Enumeration getMatchingRuleNames() {
+        return matchingRules.keys();
+    }
+
+    /**
+     * Get an enumeration of the names of the syntaxes in this schema.
+     * @return an enumeration of syntax names (all lower-case).
+     */
+    public Enumeration getSyntaxNames() {
+        return syntaxes.keys();
+    }
+
+    /**
+     * Get an enumeration of the names of the structure rules in this schema.
+     * @return an enumeration of names of the structure rule objects
+     */
+    public Enumeration getDITStructureRuleNames() {
+        return structureRulesByName.keys();
+    }
+
+    /**
+     * Get an enumeration of the names of the content rules in this schema.
+     * @return an enumeration of names of the content rule objects
+     */
+    public Enumeration getDITContentRuleNames() {
+        return contentRules.keys();
+    }
+
+    /**
+     * Get an enumeration of the names of the name forms in this schema.
+     * @return an enumeration of names of name form objects
+     */
+    public Enumeration getNameFormNames() {
+        return nameForms.keys();
+    }
+
+    /**
+     * Retrieve the schema for a specific entry.
+     * @param ld an active connection to a Directory Server
+     * @param dn the entry for which to fetch schema
+     * @exception LDAPException on failure.
+     */
+    public void fetchSchema( LDAPConnection ld, String dn )
+        throws LDAPException {
+        /* Find the subschemasubentry value for this DN */
+        String entryName = getSchemaDN( ld, dn );
+        Enumeration en;
+
+        /* Get the entire schema definition entry */
+        LDAPEntry entry = readSchema( ld, entryName );
+        initialize( entry );
+    }
+
+    /**
+     * Extract all schema elements from subschema entry
+     *
+     * @param entry entry containing schema definitions
+     */
+    protected void initialize( LDAPEntry entry ) {
+        /* Get all object class definitions */
+        LDAPAttribute attr = entry.getAttribute( "objectclasses" );
+        Enumeration en;
+        if ( attr != null ) {
+            en = attr.getStringValues();
+            while( en.hasMoreElements() ) {
+                LDAPObjectClassSchema sch =
+                    new LDAPObjectClassSchema( (String)en.nextElement() );
+                addObjectClass( sch );
+            }
+        }
+
+        /* Get all attribute definitions */
+        attr = entry.getAttribute( "attributetypes" );
+        if ( attr != null ) {
+            en = attr.getStringValues();
+            while( en.hasMoreElements() ) {
+                LDAPAttributeSchema sch =
+                    new LDAPAttributeSchema( (String)en.nextElement() );
+                addAttribute( sch );
+            }
+        }
+
+        /* Get all syntax definitions */
+        attr = entry.getAttribute( "ldapsyntaxes" );
+        if ( attr != null ) {
+            en = attr.getStringValues();
+            while( en.hasMoreElements() ) {
+                LDAPSyntaxSchema sch =
+                    new LDAPSyntaxSchema( (String)en.nextElement() );
+                addSyntax( sch );
+            }
+        }
+
+        /* Get all structure rule definitions */
+        attr = entry.getAttribute( "ldapditstructurerules" );
+        if ( attr != null ) {
+            en = attr.getStringValues();
+            while( en.hasMoreElements() ) {
+                LDAPDITStructureRuleSchema sch =
+                    new LDAPDITStructureRuleSchema(
+                        (String)en.nextElement() );
+                addDITStructureRule( sch );
+            }
+        }
+
+        /* Get all content rule definitions */
+        attr = entry.getAttribute( "ldapditcontentrules" );
+        if ( attr != null ) {
+            en = attr.getStringValues();
+            while( en.hasMoreElements() ) {
+                LDAPDITContentRuleSchema sch =
+                    new LDAPDITContentRuleSchema(
+                        (String)en.nextElement() );
+                addDITContentRule( sch );
+            }
+        }
+
+        /* Get all name form definitions */
+        attr = entry.getAttribute( "nameforms" );
+        if ( attr != null ) {
+            en = attr.getStringValues();
+            while( en.hasMoreElements() ) {
+                LDAPNameFormSchema sch =
+                    new LDAPNameFormSchema(
+                        (String)en.nextElement() );
+                addNameForm( sch );
+            }
+        }
+
+        /* Matching rules are tricky, because we have to match up a
+           rule with its use. First get all the uses. */
+        Hashtable h = new Hashtable();
+        attr = entry.getAttribute( "matchingruleuse" );
+        if ( attr != null ) {
+            en = attr.getStringValues();
+            while( en.hasMoreElements() ) {
+                String use = (String)en.nextElement();
+                LDAPMatchingRuleSchema sch =
+                    new LDAPMatchingRuleSchema( null, use );
+                h.put( sch.getOID(), use );
+            }
+        }
+        /* Now get the rules, and assign uses to them */
+        attr = entry.getAttribute( "matchingrules" );
+        if ( attr != null ) {
+            en = attr.getStringValues();
+            while( en.hasMoreElements() ) {
+                String raw = (String)en.nextElement();
+                LDAPMatchingRuleSchema sch =
+                    new LDAPMatchingRuleSchema( raw, null );
+                String use = (String)h.get( sch.getOID() );
+                if ( use != null )
+                    sch = new LDAPMatchingRuleSchema( raw, use );
+                addMatchingRule( sch );
+            }
+        }
+    }
+
+    /**
+     * Retrieve the entire schema from the root of a Directory Server.
+     * @param ld an active connection to a Directory Server
+     * @exception LDAPException on failure.
+     */
+    public void fetchSchema( LDAPConnection ld ) throws LDAPException {
+        fetchSchema( ld, "" );
+    }
+
+    /**
+     * Read one attribute definition from a server to determine if
+     * attribute syntaxes are quoted (a bug, present in Netscape
+     * and Novell servers).
+     * @param ld an active connection to a Directory Server
+     * @return <CODE>true</CODE> if standards-compliant.
+     * @exception LDAPException on failure.
+     */
+    static boolean isAttributeSyntaxStandardsCompliant( LDAPConnection ld )
+        throws LDAPException {
+
+        /* Check if this has already been investigated */
+        String schemaBug = (String)ld.getProperty( ld.SCHEMA_BUG_PROPERTY );
+        if ( schemaBug != null ) {
+            return schemaBug.equalsIgnoreCase( "standard" );
+        }
+
+        boolean compliant = true;
+        /* Get the schema definitions for attributes */
+        String entryName = getSchemaDN( ld, "" );
+        String[] attrs = { "attributetypes" };
+        LDAPEntry entry = ld.read( entryName, attrs );
+        /* Get all attribute definitions, and check the first one */
+        LDAPAttribute attr = entry.getAttribute( "attributetypes" );
+        if ( attr != null ) {
+            Enumeration en = attr.getStringValues();
+            if( en.hasMoreElements() ) {
+                compliant = !isSyntaxQuoted( (String)en.nextElement() );
+            }
+        }
+        ld.setProperty( ld.SCHEMA_BUG_PROPERTY, compliant ? "standard" :
+                        "NetscapeBug" );
+        return compliant;
+    }
+
+    /**
+     * Parses an attribute schema definition to see if the SYNTAX value
+     * is quoted. It shouldn't be (according to RFC 2252), but it is for
+     * some LDAP servers. It will either be:<BR>
+     * <CODE>SYNTAX 1.3.6.1.4.1.1466.115.121.1.15</CODE> or<BR>
+     * <CODE>SYNTAX '1.3.6.1.4.1.1466.115.121.1.15'</CODE>
+     * @param raw Definition of the attribute type in the
+     * AttributeTypeDescription format.
+     */
+    static boolean isSyntaxQuoted( String raw ) {
+        int ind = raw.indexOf( " SYNTAX " );
+        if ( ind >= 0 ) {
+            ind += 8;
+            int l = raw.length() - ind;
+            // Extract characters
+            char[] ch = new char[l];
+            raw.getChars( ind, raw.length(), ch, 0 );
+            ind = 0;
+            // Skip to ' or start of syntax value
+            while( (ind < ch.length) && (ch[ind] == ' ') ) {
+                ind++;
+            }
+            if ( ind < ch.length ) {
+                return ( ch[ind] == '\'' );
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Displays the schema (including the descriptions of its object
+     * classes, attribute types, and matching rules) in an easily
+     * readable format (not the same as the format expected by
+     * an LDAP server).
+     * @return a string containing the schema in printable format.
+     */
+    public String toString() {
+        String s = "Object classes:\n";
+        Enumeration en = getObjectClasses();
+        while( en.hasMoreElements() ) {
+            s += en.nextElement().toString();
+            s += '\n';
+        }
+        s += "Attributes:\n";
+        en = getAttributes();
+        while( en.hasMoreElements() ) {
+            s += en.nextElement().toString();
+            s += '\n';
+        }
+        s += "Matching rules:\n";
+        en = getMatchingRules();
+        while( en.hasMoreElements() ) {
+            s += en.nextElement().toString();
+            s += '\n';
+        }
+        s += "Syntaxes:\n";
+        en = getSyntaxes();
+        while( en.hasMoreElements() ) {
+            s += en.nextElement().toString();
+            s += '\n';
+        }
+        return s;
+    }
+
+    /**
+     * Retrieve the DN of the schema definitions for a specific entry.
+     * @param ld an active connection to a Directory Server
+     * @param dn the entry for which to fetch schema
+     * @exception LDAPException on failure.
+     */
+    static String getSchemaDN( LDAPConnection ld, String dn )
+        throws LDAPException {
+        if ( (ld == null) || !ld.isConnected() ) {
+            throw new LDAPException( "No connection", LDAPException.OTHER );
+        }
+        String[] attrs = { "subschemasubentry" };
+        LDAPEntry entry = ld.read( dn, attrs );
+        if ( entry == null ) {
+            throw new LDAPException( "", LDAPException.NO_SUCH_OBJECT );
+        }
+        LDAPAttribute attr = entry.getAttribute( attrs[0] );
+        String entryName = "cn=schema";
+        if ( attr != null ) {
+            Enumeration en = attr.getStringValues();
+            if ( en.hasMoreElements() ) {
+                entryName = (String)en.nextElement();
+            }
+        }
+        return entryName;
+    }
+
+    private static LDAPEntry readSchema( LDAPConnection ld, String dn,
+                                         String[] attrs )
+                                         throws LDAPException {
+        LDAPSearchResults results = ld.search (dn, ld.SCOPE_BASE,
+                                               "objectclass=subschema",
+                                               attrs, false);
+        if ( !results.hasMoreElements() ) {
+            throw new LDAPException( "Cannot read schema",
+                                     LDAPException.INSUFFICIENT_ACCESS_RIGHTS );
+        }
+        return results.next ();
+    }
+
+    private static LDAPEntry readSchema( LDAPConnection ld, String dn )
+                                         throws LDAPException {
+        return readSchema( ld, dn, new String[] { "*", "ldapSyntaxes",
+                        "matchingRules", "attributeTypes", "objectClasses" } );        
+    }
+
+    /**
+     * Helper for "main" to print out schema elements.
+     * @param en enumeration of schema elements
+     */
+    private static void printEnum( Enumeration en ) {
+        while( en.hasMoreElements() ) {
+            LDAPSchemaElement s = (LDAPSchemaElement)en.nextElement();
+            System.out.println( "  " + s );
+//            System.out.println( "  " + s.getValue() );
+        }
+    }
+
+    /**
+     * Fetch the schema from the LDAP server at the specified
+     * host and port, and print out the schema (including descriptions
+     * of its object classes, attribute types, and matching rules).
+     * The schema is printed in an easily readable format (not the
+     * same as the format expected by an LDAP server).  For example,
+     * you can enter the following command to print the schema:
+     * <PRE>
+     * java netscape.ldap.LDAPSchema myhost.mydomain.com 389
+     * </PRE>
+     *
+     * @param args the host name and the port number of the LDAP server
+     * (for example, <CODE>netscape.ldap.LDAPSchema directory.netscape.com
+     * 389</CODE>)
+     */
+    public static void main( String[] args ) {
+        if ( args.length < 2 ) {
+            System.err.println( "Usage: netscape.ldap.LDAPSchema HOST PORT" );
+            System.exit(1 );
+        }
+        int port = Integer.parseInt( args[1] );
+        LDAPConnection ld = new LDAPConnection();
+        try {
+            ld.connect( args[0], port );
+            LDAPSchema schema = new LDAPSchema();
+            schema.fetchSchema( ld );
+            ld.disconnect();
+            System.out.println( "Object classes: " );
+            printEnum( schema.getObjectClasses() );
+            System.out.println( "\nAttributes: " );
+            printEnum( schema.getAttributes() );
+            System.out.println( "\nMatching rules: " );
+            printEnum( schema.getMatchingRules() );
+            System.out.println( "\nSyntaxes: " );
+            printEnum( schema.getSyntaxes() );
+            System.exit( 0 );
+        } catch ( LDAPException e ) {
+            System.err.println( e );
+        }
+    }
+
+    private Hashtable objectClasses = new Hashtable();
+    private Hashtable attributes = new Hashtable();
+    private Hashtable matchingRules = new Hashtable();
+    private Hashtable syntaxes = new Hashtable();
+    private Hashtable structureRulesByName = new Hashtable();
+    private Hashtable structureRulesById = new Hashtable();
+    private Hashtable contentRules = new Hashtable();
+    private Hashtable nameForms = new Hashtable();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPv3.java
@@ -0,0 +1,213 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.client.opers.*;
+import java.io.*;
+
+/**
+ * Specifies additional features available in version 3 of the
+ * LDAP protocol. (To view preliminary information on this work
+ * in progress, see the LDAP v3 internet draft.  You can find the
+ * latest version of this document listed under the Internet-Drafts
+ * section of the
+ * <A HREF="http://www.ietf.cnri.reston.va.us/html.charters/asid-charter.html"
+ * TARGET=_blank">ASID home page</A>.)
+ *
+ * @version 1.0
+ */
+public interface LDAPv3 extends LDAPv2 {
+
+    /**
+     * Connects and authenticates to the LDAP server using the specified version of the
+     * LDAP protocol.
+     * @param version requested version of the LDAP protocol: currently 2 or 3
+     * @param host hostname of the LDAP server
+     * @param port port number of the LDAP server. To specify the
+     * default port, use <CODE>DEFAULT_PORT</CODE>.
+     * @param dn distinguished name to use for authentication
+     * @param passwd password for authentication
+     * @exception LDAPException Failed to connect and authenticate to the server.
+     */
+    public void connect(int version, String host, int port, String dn,
+      String passwd) throws LDAPException;
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name, password, and version
+     * of the LDAP protocol. If the server does not support the requested 
+     * protocol version, an exception is thrown.  If the object has been 
+     * disconnected from an LDAP server, this method attempts to reconnect 
+     * to the server. If the object had already authenticated, the old 
+     * authentication is discarded.
+     * @param version requested LDAP protocol version: currently 2 or 3.
+     * @param dn if non-null and non-empty, specifies that the
+     * connection and all operations through it should
+     * authenticate with dn as the distinguished name
+     * @param passwd if non-null and non-empty, specifies that the
+     * connection and all operations through it should
+     * authenticated with passwd as password
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void authenticate(int version,
+                             String dn,
+                             String passwd)
+                             throws LDAPException;
+
+    /**
+     * Authenticates to the LDAP server (to which the object is currently
+     * connected) using the specified name, password, and version of the
+     * LDAP protocol. If the server does not support the requested
+     * version of the protocol, an exception is thrown.  If the
+     * object has been disconnected from an LDAP server, this method
+     * attempts to reconnect to the server. If the object had already
+     * authenticated, the old authentication is discarded.
+     * @param version requested LDAP protocol version: currently 2 or 3.
+     * @param dn if non-null and non-empty, specifies that the
+     * connection and all operations through it should authenticate
+     * with dn as the distinguished name
+     * @param passwd if non-null and non-empty, specifies that the
+     * connection and all operations through it should authenticate
+     * with passwd as password
+     * @exception LDAPException Failed to authenticate to the LDAP server.
+     */
+    public void bind(int version,
+                     String dn,
+                     String passwd)
+                     throws LDAPException;
+    
+    /**
+     * Performs an extended operation on the directory. Extended operations
+     * are part of version 3 of the LDAP protocol.
+     * <P>
+     *
+     * @param op LDAPExtendedOperation object specifying the OID of the
+     * extended operation and the data to use in the operation
+     * @exception LDAPException Failed to execute the operation
+     * @return LDAPExtendedOperation object representing the extended response
+     * returned by the server.
+     * @see LDAPExtendedOperation
+     */
+    public LDAPExtendedOperation extendedOperation( LDAPExtendedOperation op )
+                                     throws LDAPException;
+
+    /**
+     * Renames and moves an entry in the directory.
+     * @param DN original distinguished name (DN) for the entry
+     * @param newRDN new relative distinguished name (RDN) for the entry
+     * @param newParentDN distinguished name of the new parent entry of the
+     * specified entry
+     * @param deleteOldRDN specifies whether or not to remove the old RDN
+     * when renaming and moving the entry. If <code>true</code>, the old RDN will be deleted.
+     * @exception LDAPException Failed to rename the specified entry.
+     */
+    public void rename( String DN, String newRDN, String newParentDN,
+      boolean deleteOldRDN ) throws LDAPException;
+
+    /**
+     * Renames and moves an entry in the directory.
+     * @param DN original distinguished name (DN) for the entry
+     * @param newRDN new relative distinguished name (RDN) for the entry
+     * @param newParentDN distinguished name of the new parent entry of the
+     * specified entry
+     * @param deleteOldRDN specifies whether or not to remove the old RDN
+     * when renaming and moving the entry. If <code>true</code>, the old RDN will be deleted.
+     * @param cons the constraints set for the rename operation
+     * @exception LDAPException Failed to rename the specified entry.
+     */
+    public void rename( String DN, String newRDN, String newParentDN,
+      boolean deleteOldRDN, LDAPConstraints cons ) throws LDAPException;
+
+    /**
+     * Returns an array of the latest controls (if any) from the server.
+     * @return an array of the controls returned by an operation,
+     * or <CODE>null</CODE> if none.
+     * @see netscape.ldap.LDAPControl
+     */
+    public LDAPControl[] getResponseControls();
+
+    /**
+     * Option specifying client controls for LDAP operations. These
+     * controls are interpreted by the client and are not passed
+     * to the LDAP server.
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int CLIENTCONTROLS   = 11;
+
+    /**
+     * Option specifying server controls for LDAP operations. These
+     * controls are passed to the LDAP server. They may also be returned by
+     * the server.
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public static final int SERVERCONTROLS   = 12;
+
+    /**
+     * Attribute type that you can specify in the LDAPConnection
+     * search method if you don't want to retrieve any of the
+     * attribute types for entries found by the search.
+     * @see netscape.ldap.LDAPConnection#search
+     */
+    public static final String NO_ATTRS = "1.1";
+
+    /**
+     * Attribute type that you can specify in the LDAPConnection
+     * search method if you want to retrieve all attribute types.
+     * You can use this if you want to retrieve all attributes in
+     * addition to an operational attribute.  For example:
+     * <P>
+     *
+     * <PRE>
+     * ...
+     * String [] MY_ATTRS = { LDAPv3.ALL_USER_ATTRS, "modifiersName",
+     *     "modifyTimestamp" };
+     * LDAPSearchResults res = ld.search( MY_SEARCHBASE,
+     *     LDAPConnection.SCOPE_SUB, MY_FILTER, MY_ATTRS, false, cons );
+     * ...
+     * </PRE>
+     * @see netscape.ldap.LDAPConnection#search
+     */
+    public static final String ALL_USER_ATTRS = "*";
+
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPControl.java
@@ -0,0 +1,529 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.io.*;
+import java.util.*;
+import java.lang.reflect.*;
+import netscape.ldap.ber.stream.*;
+import netscape.ldap.client.*;
+import netscape.ldap.util.*;
+import netscape.ldap.controls.*;
+
+/**
+ * Represents arbitrary control data that can be used with a
+ * a particular LDAP operation.  LDAP controls are part of version 3
+ * of the LDAP protocol.
+ * <P>
+ *
+ * LDAP controls allow you to extend the functionality of
+ * an LDAP operation.  For example, you can use an LDAP control
+ * for the search operation to sort search results on an LDAP server.
+ * <P>
+ *
+ * An LDAP control can be either a <B>server control</B> or
+ * a <B>client control</B>:
+ * <P>
+ * <UL>
+ * <LI><B>Server controls</B> can be sent to the LDAP server or returned
+ * by the server on any operation.
+ * <LI><B>Client controls</B> are intended to affect only the client side
+ * of the operation.
+ * </UL>
+ * <P>
+ *
+ * An LDAP control consists of the following information:
+ * <P>
+ * <UL>
+ * <LI>A unique object ID (OID) that identifies the control.<P>
+ * <LI>A &quot;criticality&quot; field, which indicates whether or
+ * not the control is critical to the operation. (If the control is
+ * critical to the operation and the server does not support the control,
+ * the server should not execute the operation.)<P>
+ * <LI>Data pertaining to the control.<P>
+ * </UL>
+ * <P>
+ *
+ * To determine which server controls are supported by a particular server,
+ * you need to search for the root DSE (DSA-specific entry, where DSA is
+ * another term for &quot;LDAP server&quot;) and find the values of the
+ * <CODE>supportedControl</CODE> attribute.  This attribute contains the
+ * object IDs (OIDs) of the controls supported by this server.
+ * <P>
+ *
+ * The following section of code demonstrates how to get the list
+ * of the server controls supported by an LDAP server.
+ * <P>
+ *
+ * <PRE>
+ * public static void main( String[] args )
+ * {
+ *   LDAPConnection ld = new LDAPConnection();
+ *   try {
+ *     String MY_HOST = "localhost";
+ *     int MY_PORT = 389;
+ *     ld.connect( MY_HOST, MY_PORT );
+ *     try {
+ *       ld.authenticate( 3, "cn=Directory Manager", "23skidoo" );
+ *     } catch( LDAPException e ) {
+ *       System.out.println( "LDAP server does not support v3." );
+ *       ld.disconnect();
+ *       System.exit(1);
+ *     }
+ *
+ *     String MY_FILT = "(objectclass=*)";
+ *     String MY_BASE = "";
+ *     String getAttrs[] = { "supportedControl" };
+ *     LDAPSearchResults res = ld.search( MY_BASE,
+ *       LDAPConnection.SCOPE_BASE, MY_FILT, getAttrs, false );
+ *
+ *     while ( res.hasMoreElements() ) {
+ *       LDAPEntry findEntry = (LDAPEntry)res.nextElement();
+ *       LDAPAttributeSet findAttrs = findEntry.getAttributeSet();
+ *       Enumeration enumAttrs = findAttrs.getAttributes();
+ *
+ *         while ( enumAttrs.hasMoreElements() ) {
+ *           LDAPAttribute anAttr = (LDAPAttribute)enumAttrs.nextElement();
+ *           String attrName = anAttr.getName();
+ *           System.out.println( attrName );
+ *           Enumeration enumVals = anAttr.getStringValues();
+ *
+ *           while ( enumVals.hasMoreElements() ) {
+ *             String aVal = ( String )enumVals.nextElement();
+ *             System.out.println( "\t" + aVal );
+ *           }
+ *         }
+ *      }
+ *   }
+ *   catch( LDAPException e ) {
+ *     System.out.println( "Error: " + e.toString() );
+ *   }
+ *   try {
+ *     ld.disconnect();
+ *   }
+ *   catch( LDAPException e ) {
+ *     System.exit(1);
+ *   }
+ *   System.exit(0);
+ * }
+ * </PRE>
+ * <P>
+ *
+ * If you compile and run this example against an LDAP server that
+ * supports v3 of the protocol, you might receive the following results:
+ * <P>
+ *
+ * <PRE>
+ * supportedcontrol
+ *   2.16.840.1.113730.3.4.2
+ *   2.16.840.1.113730.3.4.3
+ *   2.16.840.1.113730.3.4.4
+ *   2.16.840.1.113730.3.4.5
+ *   1.2.840.113556.1.4.473
+ * </PRE>
+ * <P>
+ *
+ * For more information on LDAP controls, see the Internet-Draft on
+ * the LDAP v3 protocol. (Note that this internet draft is still a
+ * work in progress.  You can find the latest draft at the <A
+ * HREF="http://www.ietf.cnri.reston.va.us/html.charters/asid-charter.html"
+ * TARGET="_blank">ASID home page</A>.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPv3#CLIENTCONTROLS
+ * @see netscape.ldap.LDAPv3#SERVERCONTROLS
+ * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean)
+ * @see netscape.ldap.LDAPConnection#getOption
+ * @see netscape.ldap.LDAPConnection#setOption
+ * @see netscape.ldap.LDAPConnection#getResponseControls
+ * @see netscape.ldap.LDAPConstraints#getClientControls
+ * @see netscape.ldap.LDAPConstraints#getServerControls
+ * @see netscape.ldap.LDAPConstraints#setClientControls
+ * @see netscape.ldap.LDAPConstraints#setServerControls
+ */
+public class LDAPControl implements Cloneable, java.io.Serializable {
+    static final long serialVersionUID = 5149887553272603753L;
+    public final static String MANAGEDSAIT       = "2.16.840.1.113730.3.4.2";
+    /* Password information sent back to client */
+    public final static String PWEXPIRED         = "2.16.840.1.113730.3.4.4";
+    public final static String PWEXPIRING        = "2.16.840.1.113730.3.4.5";
+
+    /**
+     * Default constructor for the <CODE>LDAPControl</CODE> class.
+     */
+    public LDAPControl()
+    {
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPControl</CODE> object using the
+     * specified object ID (OID), &quot;criticality&quot; field, and
+     * data to be used by the control.
+     * <P>
+     *
+     * @param id the object ID (OID) identifying the control
+     * @param critical <CODE>true</CODE> if the LDAP operation should be
+     * cancelled when the server does not support this control (in other
+     * words, this control is critical to the LDAP operation)
+     * @param vals control-specific data
+     * @see netscape.ldap.LDAPConstraints#setClientControls
+     * @see netscape.ldap.LDAPConstraints#setServerControls
+     */
+    public LDAPControl(String id,
+             boolean critical,
+             byte vals[]) {
+        m_oid = id;
+        m_critical = critical;
+        m_value = vals;
+    }
+    
+    /**
+     * Gets the object ID (OID) of the control.
+     * @return object ID (OID) of the control.
+     */
+    public String getID() {
+        return m_oid;
+    }
+
+    /**
+     * Specifies whether or not the control is critical to the LDAP operation.
+     * @return <CODE>true</CODE> if the LDAP operation should be cancelled when
+     * the server does not support this control.
+     */
+    public boolean isCritical() {
+        return m_critical;
+    }
+
+    /**
+     * Gets the data in the control.
+     * @return the data in the control as a byte array.
+     */
+    public byte[] getValue() {
+        return m_value;
+    }
+
+    /**
+     * Gets the ber representation of control.
+     * @return ber representation of control.
+     */
+    BERElement getBERElement() {
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BEROctetString (m_oid));
+        seq.addElement(new BERBoolean (m_critical));
+        if ( (m_value == null) || (m_value.length < 1) )
+            seq.addElement(new BEROctetString ((byte[])null));
+        else {
+            seq.addElement(new BEROctetString (m_value, 0, m_value.length));
+        }
+        return seq;
+    }
+    
+    /** 
+     * Associates a class with an oid. This class must be an extension of 
+     * <CODE>LDAPControl</CODE>, and should implement the <CODE>LDAPControl(
+     * String oid, boolean critical, byte[] value)</CODE> constructor to 
+     * instantiate the control. 
+     * @param oid the string representation of the oid
+     * @param controlClass the class that instantatiates the control associated
+     * with oid
+     * @exception netscape.ldap.LDAPException If the class parameter is not
+     * a subclass of <CODE>LDAPControl</CODE> or the class parameter does not
+     * implement the <CODE>LDAPControl(String oid, boolean critical, byte[] value)
+     * </CODE> constructor.
+     */
+    public static void register(String oid, Class controlClass) throws 
+        LDAPException {
+
+        if (controlClass == null) {
+	    return;
+        }
+
+	// 1. make sure controlClass is a subclass of LDAPControl
+	Class superClass = controlClass;
+	while (superClass != LDAPControl.class && superClass != null) {
+	    superClass = superClass.getSuperclass();
+	}
+
+	if (superClass == null) 
+	    throw new LDAPException("controlClass must be a subclass of " +
+				    "LDAPControl", LDAPException.PARAM_ERROR);
+
+	// 2. make sure controlClass has the proper constructor
+	Class[] cparams = { String.class, boolean.class, byte[].class };
+	try {
+	    controlClass.getConstructor(cparams);
+	} catch (NoSuchMethodException e) {
+	    throw new LDAPException("controlClass does not implement the " +
+				    "correct contstructor", 
+				    LDAPException.PARAM_ERROR);
+	}
+
+        // 3. check if the hash table exists
+        if (m_controlClassHash == null) {
+            m_controlClassHash = new Hashtable();
+	}
+
+	// 4. add the controlClass
+        m_controlClassHash.put(oid, controlClass);
+    }
+
+    /**
+     * Returns the <CODE>Class</CODE> that has been registered to oid.
+     * @param oid a String that associates the control class to a control
+     * @return a <CODE>Class</CODE> that can instantiate a control of the
+     * type specified by oid.
+     * @see netscape.ldap.LDAPControl#register
+     *
+     */
+    protected static Class lookupControlClass(String oid) {
+        if (m_controlClassHash == null) {
+	    return null;
+        }
+      
+	return (Class)m_controlClassHash.get(oid);
+    }
+    
+    /**
+     * Returns a <CODE>LDAPControl</CODE> object instantiated by the Class
+     * associated by <CODE>LDAPControl.register</CODE> to the oid. If
+     * no Class is found for the given control, or an exception occurs when 
+     * attempting to instantiate the control, a basic <CODE>LDAPControl</CODE>
+     * is instantiated using the parameters. 
+     * @param oid the oid of the control to instantiate
+     * @param critical <CODE>true</CODE> if this is a critical control
+     * @param value the byte value for the control
+     * @return a newly instantiated <CODE>LDAPControl</CODE>.
+     * @see netscape.ldap.LDAPControl#register
+     */ 
+  protected static LDAPControl createControl(String oid, boolean critical,
+                                             byte[] value) {
+        
+	Class controlClass = lookupControlClass(oid);
+	
+	if (controlClass == null) {
+	    return new LDAPControl(oid, critical, value);
+	}
+
+	Class[] cparams = { String.class, boolean.class, byte[].class };
+	Constructor creator = null;
+	try {
+	    creator = controlClass.getConstructor(cparams);
+	} catch (NoSuchMethodException e) {
+	    //shouldn't happen, but...
+	    System.err.println("Caught java.lang.NoSuchMethodException while" +
+			       " attempting to instantiate a control of type " +
+			       oid);
+	    return new LDAPControl(oid, critical, value);
+	}
+	
+	Object[] oparams = { oid, new Boolean(critical), value } ;
+	LDAPControl returnControl = null;
+	try {
+	    returnControl = (LDAPControl)creator.newInstance(oparams);
+	} catch (Exception e) {
+	    String eString = null;
+	    if (e instanceof InvocationTargetException) {
+	        eString = ((InvocationTargetException)
+		          e).getTargetException().toString();
+	    } else {
+	        eString = e.toString();
+	    }
+	
+	    System.err.println("Caught " + eString + " while attempting to" +
+			       " instantiate a control of type " +
+			       oid);
+	    returnControl = new LDAPControl(oid, critical, value);
+   	}
+
+	return returnControl;
+    }
+
+    /**
+     * Returns a <CODE>LDAPControl</CODE> object instantiated by the Class
+     * associated by <CODE>LDAPControl.register</CODE> to the oid. If
+     * no Class is found for the given control, or an exception occurs when 
+     * attempting to instantiate the control, a basic <CODE>LDAPControl</CODE>
+     * is instantiated using the parameters.
+     * @param el the <CODE>BERElement</CODE> containing the control
+     * @return a newly instantiated <CODE>LDAPControl</CODE>.
+     * @see netscape.ldap.LPAPControl#register
+     * 
+     * Note:
+     * This code was extracted from <CODE>JDAPControl(BERElement el)</CODE>
+     * constructor.
+     */ 
+  static LDAPControl parseControl(BERElement el) {
+        BERSequence s = (BERSequence)el;
+        String oid = null;
+        boolean critical = false;
+        byte[] value = null;
+        try{
+            oid = new String(((BEROctetString)s.elementAt(0)).getValue(), "UTF8");
+        } catch(Throwable x) {}
+        
+        Object obj = s.elementAt(1);
+        if (obj instanceof BERBoolean) {
+            critical = ((BERBoolean)obj).getValue();
+        }            
+        else {
+            value = ((BEROctetString)obj).getValue();
+        }            
+
+        if (s.size() >= 3) {
+            value = ((BEROctetString)s.elementAt(2)).getValue();
+        }
+        
+        return createControl(oid, critical, value);
+  }
+      
+
+  /**
+     * Instantiates all of the controls contained within the LDAP message 
+     * fragment specified by data and returns them in an <CODE>LDAPControl</CODE>
+     * array. This fragment can be either the entire LDAP message or just the 
+     * control section of the message.
+     * <P>
+     * If an exception occurs when instantiating a control, that control is 
+     * returned as a basic <CODE>LDAPControl</CODE>.
+     * @param data the LDAP message fragment in raw BER format
+     * @return an <CODE>LDAPControl</CODE> array containing all of the controls
+     * from the message fragment.
+     * @exception java.lang.IOException If the data passed to this method
+     * is not a valid LDAP message fragment.
+     * @see netscape.ldap.LDAPControl#register
+     */
+    public static LDAPControl[] newInstance(byte[] data) throws IOException {
+        
+        int[] bread = { 0 };
+	
+  	BERElement el = BERElement.getElement(new JDAPBERTagDecoder(), 
+                                          new ByteArrayInputStream(data),
+                                          bread);
+
+	LDAPControl[] jc = null;
+	try {
+	    // see if data is a LDAP message
+	    LDAPMessage msg = LDAPMessage.parseMessage(el);
+	    return msg.getControls();
+	} catch (IOException e) {
+  	    // that didn't work; let's see if its just the controls 
+	    BERTag tag = (BERTag)el;
+	    if ( tag.getTag() == (BERTag.CONSTRUCTED|BERTag.CONTEXT|0) ) {
+	        BERSequence controls = (BERSequence)tag.getValue();
+		jc = new LDAPControl[controls.size()];
+		for (int i = 0; i < controls.size(); i++) {
+		    jc[i] = parseControl(controls.elementAt(i));
+		}
+	    }
+	}
+	
+	return jc;
+	    
+    }
+
+    /**
+     * Creates a copy of the control.
+     * @return copy of the control.
+     */
+    public Object clone() {
+        byte[] vals = null;
+        if ( m_value != null ) {
+            vals = new byte[m_value.length];
+            for( int i = 0; i < m_value.length; i++ )
+                vals[i] = m_value[i];
+        }
+        LDAPControl control = new LDAPControl( m_oid, m_critical, vals );
+
+        return control;
+    }
+
+    /**
+     * Create a "flattened" BER encoding from a BER,
+     * and return it as a byte array.
+     * @param ber a BER encoded sequence
+     * @return the byte array of encoded data.
+     */
+    protected byte[] flattenBER( BERSequence ber ) {
+        /* Suck out the data and return it */
+        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
+        try {
+            ber.write( outStream );
+        } catch ( IOException e ) {
+            return null;
+        }
+        return outStream.toByteArray();
+    }
+
+    /**
+     * Return a string representation of the control for debugging
+     *
+     * @return a string representation of the control.
+     */
+    public String toString() {
+        if (getID().equals(MANAGEDSAIT)) {
+            return "{MANAGEDSITControl: isCritical=" + isCritical() + "}";
+        }
+        String s = getID() + ' ' + isCritical();
+        if ( m_value != null ) {
+            s += ' ' + LDIF.toPrintableString( m_value );
+        }
+        return "LDAPControl {" + s + '}';
+    }
+
+    private String m_oid;
+    protected boolean m_critical = false;
+    protected byte[] m_value = null;
+    static private Hashtable m_controlClassHash = null;
+    static {
+        try {
+            LDAPControl.register( LDAPPasswordExpiringControl.EXPIRING,
+                                  LDAPPasswordExpiringControl.class );
+            LDAPControl.register( LDAPPasswordExpiredControl.EXPIRED,
+                                  LDAPPasswordExpiredControl.class );
+            LDAPControl.register( LDAPEntryChangeControl.ENTRYCHANGED,
+                                  LDAPEntryChangeControl.class );
+            LDAPControl.register( LDAPSortControl.SORTRESPONSE,
+                                  LDAPSortControl.class );
+            LDAPControl.register( LDAPVirtualListResponse.VIRTUALLISTRESPONSE,
+                                  LDAPVirtualListResponse.class );
+        } catch (LDAPException e) {
+        }
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPModification.java
@@ -0,0 +1,164 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import netscape.ldap.ber.stream.*;
+
+/**
+ * Specifies changes to be made to the values of an attribute.  The change is
+ * specified in terms of the following aspects:
+ * <P>
+ *
+ * <UL>
+ * <LI>the type of modification (add, replace, or delete the value of an attribute)
+ * <LI>the type of value being modified (string or binary)
+ * <LI>the name of the attribute being modified
+ * <LI>the actual value
+ * </UL>
+ * <P>
+ *
+ * After you specify a change to an attribute, you can execute the change
+ * by calling the <CODE>LDAPConnection.modify</CODE> method and specifying
+ * the DN of the entry that you want to modify.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPConnection#modify(java.lang.String, netscape.ldap.LDAPModification)
+ */
+public class LDAPModification implements java.io.Serializable {
+
+    static final long serialVersionUID = 4836472112866826595L;
+
+    /**
+     * Specifies that a value should be added to an attribute.
+     */
+    public static final int ADD     = 0;
+
+    /**
+     * Specifies that a value should be removed from an attribute.
+     */
+    public static final int DELETE  = 1;
+
+    /**
+     * Specifies that a value should replace the existing value in an attribute.
+     */
+    public static final int REPLACE = 2;
+
+    /**
+     * Internal variables
+     */
+    private int operation;
+    private LDAPAttribute attribute;
+
+    /**
+     * Specifies a modification to be made to an attribute.
+     * @param op the type of modification to make. This can be one of the following:
+     *   <P>
+     *   <UL>
+     *   <LI><CODE>LDAPModification.ADD</CODE> (the value should be added to the attribute)
+     *   <LI><CODE>LDAPModification.DELETE</CODE> (the value should be removed from the attribute)
+     *   <LI><CODE>LDAPModification.REPLACE</CODE> (the value should replace the existing value of the attribute)
+     *   </UL><P>
+     * @param attr the attribute (possibly with values) to modify
+     * @see netscape.ldap.LDAPAttribute
+     */
+    public LDAPModification( int op, LDAPAttribute attr ) {
+        operation = op;
+        attribute = attr;
+    }
+
+    /**
+     * Returns the type of modification specified by this object.
+     * @return one of the following types of modifications:
+     *   <P>
+     *   <UL>
+     *   <LI><CODE>LDAPModification.ADD</CODE> (the value should be added to the attribute)
+     *   <LI><CODE>LDAPModification.DELETE</CODE> (the value should be removed from the attribute)
+     *   <LI><CODE>LDAPModification.REPLACE</CODE> (the value should replace the existing value of the attribute)
+     *   </UL><P>
+     */
+    public int getOp() {
+        return operation;
+    }
+
+    /**
+     * Returns the attribute (possibly with values) to be modified.
+     * @return the attribute to be modified.
+     * @see netscape.ldap.LDAPAttribute
+     */
+    public LDAPAttribute getAttribute() {
+        return attribute;
+    }
+
+    /**
+     * Retrieves the BER (Basic Encoding Rules) representation
+     * of the current modification.
+     * @return BER representation of the modification.
+     */
+    public BERElement getBERElement() {
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BEREnumerated(operation));
+        seq.addElement(attribute.getBERElement());
+        return seq;
+    }
+
+    /**
+     * Retrieves the string representation of the current
+     * modification. For example:
+     *
+     * <PRE>
+     * LDAPModification: REPLACE, LDAPAttribute {type='mail', values='babs@ace.com'}
+     * LDAPModification: ADD, LDAPAttribute {type='description', values='This entry was modified with the modattrs program'}
+     * </PRE>
+     *
+     * @return string representation of the current modification.
+     */
+    public String toString() {
+        String s = "LDAPModification: ";
+        if ( operation == ADD )
+            s += "ADD, ";
+        else if ( operation == DELETE )
+            s += "DELETE, ";
+        else if ( operation == REPLACE )
+            s += "REPLACE, ";
+        else
+            s += "INVALID OP, ";
+        s += attribute;
+        return s;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPAttributeSet.java
@@ -0,0 +1,423 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.client.opers.*;
+
+/**
+ * Represents a set of attributes (for example, the set of attributes
+ * in an entry).
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPAttribute
+ */
+public class LDAPAttributeSet implements Cloneable, java.io.Serializable {
+    static final long serialVersionUID = 5018474561697778100L;
+    Hashtable attrHash = null;
+    LDAPAttribute[] attrs = new LDAPAttribute[0];
+    /* If there are less attributes than this in the set, it's not worth
+     creating a Hashtable - faster and cheaper most likely to string
+     comparisons. Most applications fetch attributes once only, anyway */
+    static final int ATTR_COUNT_REQUIRES_HASH = 5;
+
+    /**
+     * Constructs a new set of attributes.  This set is initially empty.
+     */
+    public LDAPAttributeSet() {
+    }
+
+    /**
+     * Constructs an attribute set.
+     * @param attrs the list of attributes
+     */
+    public LDAPAttributeSet( LDAPAttribute[] attrs ) {
+        this.attrs = attrs;
+    }
+
+    public synchronized Object clone() {
+        try {
+            LDAPAttributeSet attributeSet = new LDAPAttributeSet();
+            attributeSet.attrs = new LDAPAttribute[attrs.length];
+            for (int i = 0; i < attrs.length; i++) {
+                attributeSet.attrs[i] = new LDAPAttribute(attrs[i]);
+            }
+             return attributeSet;
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns an enumeration of the attributes in this attribute set.
+     * @return enumeration of the attributes in this set.
+     */
+    public Enumeration getAttributes () {
+        Vector v = new Vector();
+        synchronized(this) {
+            for (int i=0; i<attrs.length; i++) {
+                v.addElement(attrs[i]);
+            }
+        }
+        return v.elements();
+    }
+
+    /**
+     * Creates a new attribute set containing only the attributes
+     * that have the specified subtypes.
+     * <P>
+     *
+     * For example, suppose an attribute set contains the following attributes:
+     * <P>
+     *
+     * <PRE>
+     * cn
+     * cn;lang-ja
+     * sn;phonetic;lang-ja
+     * sn;lang-us
+     * </PRE>
+     *
+     * If you call the <CODE>getSubset</CODE> method and pass
+     * <CODE>lang-ja</CODE> as the argument, the method returns
+     * an attribute set containing the following attributes:
+     * <P>
+     *
+     * <PRE>
+     * cn;lang-ja
+     * sn;phonetic;lang-ja
+     * </PRE>
+     *
+     * @param subtype semi-colon delimited list of subtypes
+     * to find within attribute names. 
+     * For example:
+     * <PRE>
+     *     "lang-ja"        // Only Japanese language subtypes
+     *     "binary"         // Only binary subtypes
+     *     "binary;lang-ja" // Only Japanese language subtypes
+     *                         which also are binary
+     * </PRE>
+     * @return attribute set containing the attributes that have
+     * the specified subtypes.
+     * @see netscape.ldap.LDAPAttribute
+     * @see netscape.ldap.LDAPAttributeSet#getAttribute
+     * @see netscape.ldap.LDAPEntry#getAttributeSet
+     */
+    public LDAPAttributeSet getSubset(String subtype) {
+        LDAPAttributeSet attrs = new LDAPAttributeSet();
+        if ( subtype == null )
+            return attrs;
+        StringTokenizer st = new StringTokenizer(subtype, ";");
+        if( st.countTokens() < 1 )
+            return attrs;
+        String[] searchTypes = new String[st.countTokens()];
+        int i = 0;
+        while( st.hasMoreElements() ) {
+            searchTypes[i] = (String)st.nextElement();
+            i++;
+        }
+        Enumeration attrEnum = getAttributes();
+        while( attrEnum.hasMoreElements() ) {
+            LDAPAttribute attr = (LDAPAttribute)attrEnum.nextElement();
+            if( attr.hasSubtypes( searchTypes ) )
+                attrs.add( new LDAPAttribute( attr ) );
+        }
+        return attrs;
+    }
+
+    /**
+     * Returns a single attribute that exactly matches the specified attribute
+     * name.
+     * @param attrName name of attribute to return
+     * For example:
+     *<PRE>
+     *     "cn"            // Only a non-subtyped version of cn
+     *     "cn;lang-ja"    // Only a Japanese version of cn
+     *</PRE>
+     * @return attribute that has exactly the same name, or null
+     * (if no attribute in the set matches the specified name).
+     * @see netscape.ldap.LDAPAttribute
+     */
+    public LDAPAttribute getAttribute( String attrName ) {
+        prepareHashtable();
+        if (attrHash != null) {
+            return (LDAPAttribute)attrHash.get( attrName.toLowerCase() );
+        } else {
+            for (int i = 0; i < attrs.length; i++) {
+                if (attrName.equalsIgnoreCase(attrs[i].getName())) {
+                    return attrs[i];
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Prepares hashtable for fast attribute lookups.
+     */
+    private void prepareHashtable() {
+        if ((attrHash == null) && (attrs.length >= ATTR_COUNT_REQUIRES_HASH)) {
+            attrHash = new Hashtable();
+            for (int j = 0; j < attrs.length; j++) {
+                attrHash.put( attrs[j].getName().toLowerCase(), attrs[j] );
+            }
+        }
+    }
+
+    /**
+     * Returns the subtype that matches the attribute name specified
+     * by <CODE>attrName</CODE> and the language specificaton identified
+     * by <CODE>lang</CODE>.
+     * <P>
+     *
+     * If no attribute in the set has the specified name and subtype,
+     * the method returns <CODE>null</CODE>.
+     *
+     * Attributes containing subtypes other than <CODE>lang</CODE>
+     * (for example, <CODE>cn;binary</CODE>) are returned only if
+     * they contain the specified <CODE>lang</CODE> subtype and if
+     * the set contains no attribute having only the <CODE>lang</CODE>
+     * subtype.  (For example, <CODE>getAttribute( "cn", "lang-ja" )</CODE>
+     * returns <CODE>cn;lang-ja;phonetic</CODE> only if the 
+     * <CODE>cn;lang-ja</CODE> attribute does not exist.)
+     * <P>
+     *
+     * If null is specified for the <CODE>lang</CODE> argument,
+     * calling this method is the same as calling the
+     * <CODE>getAttribute(attrName)</CODE> method.
+     * <P>
+     *
+     * For example, suppose an entry contains only the following attributes:
+     * <P>
+     * <UL>
+     * <LI><CODE>cn;lang-en</CODE>
+     * <LI><CODE>cn;lang-ja-JP-kanji</CODE>
+     * <LI><CODE>sn</CODE>
+     * </UL>
+     * <P>
+     *
+     * Calling the following methods will return the following values:
+     * <P>
+     * <UL>
+     * <LI><CODE>getAttribute( "cn" )</CODE> returns <CODE>null</CODE>.
+     * <LI><CODE>getAttribute( "sn" )</CODE> returns the "<CODE>sn</CODE>" attribute.
+     * <LI><CODE>getAttribute( "cn", "lang-en-us" )</CODE> returns the "<CODE>cn;lang-en</CODE>" attribute.
+     * <LI><CODE>getAttribute( "cn", "lang-en" )</CODE> returns the "<CODE>cn;lang-en</CODE>" attribute.
+     * <LI><CODE>getAttribute( "cn", "lang-ja" )</CODE> returns <CODE>null</CODE>.
+     * <LI><CODE>getAttribute( "sn", "lang-en" )</CODE> returns the "<CODE>sn</CODE>" attribute.
+     *</UL>
+     * <P>
+     * @param attrName name of attribute to find in the entry
+     * @param lang a language specification
+     * @return the attribute that matches the base name and that best
+     * matches any specified language subtype.
+     * @see netscape.ldap.LDAPAttribute
+     */
+    public LDAPAttribute getAttribute( String attrName, String lang ) {
+        if ( (lang == null) || (lang.length() < 1) )
+            return getAttribute( attrName );
+
+        String langLower = lang.toLowerCase();
+        if ((langLower.length() < 5) ||
+            ( !langLower.substring( 0, 5 ).equals( "lang-" ) )) {
+            return null;
+        }
+        StringTokenizer st = new StringTokenizer( langLower, "-" );
+        // Skip first token, which is "lang-"
+        st.nextToken();
+        String[] langComponents = new String[st.countTokens()];
+        int i = 0;
+        while ( st.hasMoreTokens() ) {
+            langComponents[i] = st.nextToken();
+            i++;
+        }
+
+        String searchBasename = LDAPAttribute.getBaseName(attrName);
+        String[] searchTypes = LDAPAttribute.getSubtypes(attrName);
+        LDAPAttribute found = null;
+        int matchCount = 0;
+        for( i = 0; i < attrs.length; i++ ) {
+            boolean isCandidate = false;
+            LDAPAttribute attr = attrs[i];
+            // Same base name?
+            if ( attr.getBaseName().equalsIgnoreCase(searchBasename) ) {
+                // Accept any subtypes?
+                if( (searchTypes == null) || (searchTypes.length < 1) ) {
+                    isCandidate = true;
+                } else {
+                    // No, have to check each subtype for inclusion
+                    if( attr.hasSubtypes( searchTypes ) )
+                    isCandidate = true;
+                }
+            }
+            String attrLang = null;
+            if ( isCandidate ) {
+                attrLang = attr.getLangSubtype();
+                // At this point, the base name and subtypes are okay
+                if ( attrLang == null ) {
+                    // If there are no language attributes, this one is okay
+                    found = attr;
+                } else {
+                    // We just have to check for language match
+                    st = new StringTokenizer( attrLang.toLowerCase(), "-" );
+                    // Skip first token, which is "lang-"
+                    st.nextToken();
+                    // No match if the attribute's language spec is longer
+                    // than the target one
+                    if ( st.countTokens() > langComponents.length )
+                        continue;
+
+                    // How many subcomponents of the language match?
+                    int j = 0;
+                    while ( st.hasMoreTokens() ) {
+                        if ( !langComponents[j].equals( st.nextToken() ) ) {
+                            j = 0;
+                            break;
+                        }
+                        j++;
+                    }
+                    if ( j > matchCount ) {
+                        found = attr;
+                        matchCount = j;
+                    }
+                }
+            }
+        }
+        return found;
+    }
+
+    /**
+     * Returns the attribute at the position specified by the index.
+     * For example, if you specify the index 0, the method returns the
+     * first attribute in the set. The index is 0-based.
+     *
+     * @param index index of the attribute to obtain
+     * @return attribute at the position specified by the index.
+     */
+    public LDAPAttribute elementAt (int index) {
+        return attrs[index];
+    }
+
+    /**
+     * Removes the attribute at the position specified by the index.
+     * For example, if you specify the index 0, the method removes the
+     * first attribute in the set.  The index is 0-based.
+     *
+     * @param index index of the attribute to remove
+     */
+    public void removeElementAt (int index) {
+        if ((index >= 0) && (index < attrs.length)) {
+            synchronized(this) {
+                LDAPAttribute[] vals = new LDAPAttribute[attrs.length-1];
+                int j = 0;
+                for (int i = 0; i < attrs.length; i++) {
+                    if (i != index) {
+                        vals[j++] = attrs[i];
+                    }
+                }
+                if (attrHash != null) {
+                    attrHash.remove(attrs[index].getName().toLowerCase());
+                }
+                attrs = vals;
+            }
+        }
+    }
+
+    /**
+     * Returns the number of attributes in this set.
+     * @return number of attributes in this attribute set.
+     */
+    public int size () {
+        return attrs.length;
+    }
+
+    /**
+     * Adds the specified attribute to this attribute set.
+     * @param attr attribute to add to this set
+     */
+    public synchronized void add( LDAPAttribute attr ) {
+        if (attr != null) {
+            LDAPAttribute[] vals = new LDAPAttribute[attrs.length+1];
+            for (int i = 0; i < attrs.length; i++)
+                vals[i] = attrs[i];
+            vals[attrs.length] = attr;
+            attrs = vals;
+            if (attrHash != null) {
+                attrHash.put( attr.getName().toLowerCase(), attr );
+            }
+        }
+    }
+
+    /**
+     * Removes the specified attribute from the set.
+     * @param name name of the attribute to remove
+     */
+    public synchronized void remove( String name ) {
+        for( int i = 0; i < attrs.length; i++ ) {
+            if ( name.equalsIgnoreCase( attrs[i].getName() ) ) {
+                removeElementAt(i);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Retrieves the string representation of all attributes
+     * in the attribute set.  For example:
+     *
+     * <PRE>
+     * LDAPAttributeSet: LDAPAttribute {type='cn', values='Barbara Jensen,Babs
+     * Jensen'}LDAPAttribute {type='sn', values='Jensen'}LDAPAttribute {type='
+     * givenname', values='Barbara'}LDAPAttribute {type='objectclass', values=
+     * 'top,person,organizationalPerson,inetOrgPerson'}LDAPAttribute {type='ou',
+     * values='Product Development,People'}
+     * </PRE>
+     *
+     * @return string representation of all attributes in the set.
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer("LDAPAttributeSet: ");
+        for( int i = 0; i < attrs.length; i++ ) {
+            if (i != 0) {
+                sb.append(" ");
+            }            
+            sb.append(attrs[i].toString());
+        }
+        return sb.toString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPConnThread.java
@@ -0,0 +1,787 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.client.opers.*;
+import netscape.ldap.ber.stream.*;
+import netscape.ldap.util.*;
+import java.io.*;
+import java.net.*;
+import java.text.SimpleDateFormat;
+
+/**
+ * Multiple LDAPConnection clones can share a single physical connection,
+ * which is maintained by a thread.
+ *
+ *   +----------------+
+ *   | LDAPConnection | --------+
+ *   +----------------+         |
+ *                              |
+ *   +----------------+         |        +----------------+
+ *   | LDAPConnection | --------+------- | LDAPConnThread |
+ *   +----------------+         |        +----------------+
+ *                              |
+ *   +----------------+         |
+ *   | LDAPConnection | --------+
+ *   +----------------+
+ *
+ * All LDAPConnections send requests and get responses from
+ * LDAPConnThread (a thread).
+ */
+class LDAPConnThread implements Runnable {
+
+    /**
+     * Constants
+     */
+    private final static int MAXMSGID = Integer.MAX_VALUE;
+    private final static int BACKLOG_CHKCNT = 50;
+
+    /**
+     * Internal variables
+     */
+    transient private static int m_highMsgId;
+    transient private InputStream m_serverInput, m_origServerInput;
+    transient private OutputStream m_serverOutput, m_origServerOutput;
+    transient private Hashtable m_requests;
+    transient private Hashtable m_messages = null;
+    transient private Vector m_registered;   
+    transient private LDAPCache m_cache = null;
+    transient private Thread m_thread = null;
+    transient private Object m_sendRequestLock = new Object();
+    transient private LDAPConnSetupMgr m_connMgr = null;
+    transient private Object m_traceOutput = null;
+    transient private int m_backlogCheckCounter = BACKLOG_CHKCNT;
+    transient private boolean m_bound;
+
+    /**
+     * Connection IDs for ldap trace messages
+     */
+    transient private static int m_nextId;
+    transient private int m_id;
+    
+
+    // Time Stemp format Hour(0-23):Minute:Second.Milliseconds used for trace msgs
+    static SimpleDateFormat m_timeFormat = new SimpleDateFormat("HH:mm:ss.SSS");
+        
+    /**
+     * Constructs a connection thread that maintains connection to the
+     * LDAP server.
+     * @param connMgr the connection setup manager
+     * @param cache cache object or null
+     * @param traceOutput trace object or null
+     */
+    public LDAPConnThread(LDAPConnSetupMgr connMgr, LDAPCache cache, Object traceOutput) {
+        m_requests = new Hashtable ();
+        m_registered = new Vector ();
+        m_connMgr = connMgr;
+        setCache( cache );
+        setTraceOutput(traceOutput);
+    }
+
+    synchronized void connect(LDAPConnection ldc) throws LDAPException{
+
+        if (m_thread != null) {
+            return;
+        }
+
+        try {
+            m_connMgr.openConnection();
+            m_serverInput  = new BufferedInputStream (m_connMgr.getSocket().getInputStream());
+            m_serverOutput = new BufferedOutputStream(m_connMgr.getSocket().getOutputStream());
+            register(ldc);
+        } catch (IOException e) {
+            throw new LDAPException ( "failed to connect to server " +
+                  m_connMgr.getHost(), LDAPException.CONNECT_ERROR );
+        }
+
+        m_id = m_nextId++;        
+        String url = m_connMgr.getLDAPUrl().getServerUrl();
+
+        if (m_traceOutput != null) {
+            StringBuffer sb = new StringBuffer(" Connected to ");
+            sb.append(url);
+            logTraceMessage(sb);
+        }
+
+        String threadID = "LDAPConnThread-" + m_id + " " + url;
+        m_thread = new Thread(this, threadID);
+        m_thread.setDaemon(true);
+        m_thread.start();
+    }
+
+    public synchronized String toString() {
+        if (m_thread != null) {
+            return m_thread.getName();
+        }
+        else {
+            return "LDAPConnThread-" + m_id + " <disconnected>";
+        }
+    }
+
+    /**
+     * Layer a SSL socket over the current non-SSL one
+     */
+    void layerSocket(LDAPTLSSocketFactory factory) throws Exception {
+        synchronized (m_sendRequestLock) {
+            try {
+                m_connMgr.layerSocket(factory);
+                setInputStream(m_connMgr.getSocket().getInputStream());
+                setOutputStream(m_connMgr.getSocket().getOutputStream());
+            }
+            catch (Exception e) {
+                m_serverInput  = m_origServerInput;
+                m_serverOutput = m_origServerOutput;
+                throw e;
+            }
+        }
+    }
+
+    void setBound(boolean bound) {
+        m_bound = bound;
+    }
+
+    boolean isBound() {
+        return (m_thread != null) && m_bound;
+    }
+
+    InputStream getInputStream() {
+        return m_serverInput;
+    }
+
+    void setInputStream( InputStream is ) {
+        m_serverInput = is;
+    }
+
+    OutputStream getOutputStream() {
+        return m_serverOutput;
+    }
+
+    void setOutputStream( OutputStream os ) {
+        m_serverOutput = os;
+    }
+
+    int getRequestCount() {
+        return m_requests.size();
+    }
+
+    void setTraceOutput(Object traceOutput) {
+        synchronized (m_sendRequestLock) {
+            if (traceOutput == null) {
+               m_traceOutput = null;
+            }
+            else if (traceOutput instanceof OutputStream) {
+                m_traceOutput = new PrintWriter((OutputStream)traceOutput);
+            }
+            else if (traceOutput instanceof LDAPTraceWriter) {
+                m_traceOutput = traceOutput;
+            }
+        }            
+    }
+    
+    void logTraceMessage(StringBuffer msg) {
+
+        String timeStamp = m_timeFormat.format(new Date());
+        StringBuffer sb = new StringBuffer(timeStamp);
+        sb.append(" ldc="); 
+        sb.append(m_id);
+
+        synchronized( m_sendRequestLock ) {
+            if (m_traceOutput instanceof PrintWriter) {
+                PrintWriter traceOutput = (PrintWriter)m_traceOutput;
+                traceOutput.print(sb); // header
+                traceOutput.println(msg);
+                traceOutput.flush();
+            }
+            else if (m_traceOutput instanceof LDAPTraceWriter) {
+                sb.append(msg);
+                ((LDAPTraceWriter)m_traceOutput).write(sb.toString());
+            }
+        }
+    }
+    
+    /**
+     * Set the cache to use for searches.
+     * @param cache The cache to use for searches; <CODE>null</CODE> for no cache
+     */
+    synchronized void setCache( LDAPCache cache ) {
+        m_cache = cache;
+        m_messages = (m_cache != null) ? new Hashtable() : null;
+    }
+
+    /**
+     * Allocates a new LDAP message ID.  These are arbitrary numbers used to
+     * correlate client requests with server responses.
+     * @return new unique msgId
+     */
+    private int allocateId () {
+        synchronized (m_sendRequestLock) {
+            m_highMsgId = (m_highMsgId + 1) % MAXMSGID;
+            return m_highMsgId;
+        }            
+    }
+
+    /**
+     * Sends LDAP request via this connection thread.
+     * @param request request to send
+     * @param toNotify response listener to invoke when the response
+     *          is ready
+     */
+    void sendRequest (LDAPConnection conn, JDAPProtocolOp request,
+        LDAPMessageQueue toNotify, LDAPConstraints cons)
+         throws LDAPException {
+
+        if (m_thread == null) {
+            throw new LDAPException ( "Not connected to a server",
+                                       LDAPException.SERVER_DOWN );
+        }
+
+        LDAPMessage msg = 
+            new LDAPMessage(allocateId(), request, cons.getServerControls());
+
+        if ( toNotify != null ) {
+            /* Only worry about toNotify if we expect a response... */
+            m_requests.put (new Integer (msg.getMessageID()), toNotify);
+
+            /* Notify the backlog checker that there may be another outstanding
+               request */
+            resultRetrieved(); 
+
+            toNotify.addRequest(msg.getMessageID(), conn, this, cons.getTimeLimit());
+        }
+
+        if (!sendRequest(msg, /*ignoreErrors=*/false)) {
+            throw new LDAPException("Server or network error",
+                                     LDAPException.SERVER_DOWN);
+        }
+    }
+
+    private boolean sendRequest (LDAPMessage msg, boolean ignoreErrors) {
+        synchronized( m_sendRequestLock ) {
+            try {
+                if (m_traceOutput != null) {
+                    logTraceMessage(msg.toTraceString());
+                }                    
+                msg.write (m_serverOutput);
+                m_serverOutput.flush();
+                return true;
+            }
+            catch (IOException e) {
+                if (!ignoreErrors) {
+                    networkError(e);
+                }
+            }
+            catch (NullPointerException e) {
+                // m_serverOutput is null bacause of network error
+                if (!ignoreErrors) {
+                    if (m_thread != null) {
+                        throw e;
+                    }
+                }
+            }
+            return false;
+        }
+    }
+
+    private void sendUnbindRequest(LDAPControl[] ctrls) {
+        LDAPMessage msg = 
+            new LDAPMessage(allocateId(), new JDAPUnbindRequest(), ctrls);
+        sendRequest(msg, /*ignoreErrors=*/true);
+    }
+    
+    private void sendAbandonRequest(int id, LDAPControl[] ctrls) {
+        LDAPMessage msg = 
+            new LDAPMessage(allocateId(), new JDAPAbandonRequest(id), ctrls);
+        sendRequest(msg, /*ignoreErrors=*/true);
+    }
+
+    /**
+     * Register with this connection thread.
+     * @param conn LDAP connection
+     */
+    public synchronized void register(LDAPConnection conn) {
+        if (!m_registered.contains(conn))
+            m_registered.addElement(conn);
+    }
+
+    int getClientCount() {
+        return m_registered.size();
+    }
+
+    boolean isConnected() {
+        return m_thread != null;
+    }
+
+    /**
+     * De-Register with this connection thread. If all the connection
+     * is deregistered. Then, this thread should be killed.
+     * @param conn LDAP connection
+     */
+    /**
+     * De-Register with this connection thread. If all the connection
+     * is deregistered. Then, this thread should be killed.
+     * @param conn LDAP connection
+     */
+    synchronized void deregister(LDAPConnection conn) {
+
+        if (m_thread == null) {
+            return;
+        }
+        
+        m_registered.removeElement(conn);
+        if (m_registered.size() == 0) {
+            
+            // No more request processing
+            Thread t = m_thread;               
+            m_thread = null;
+
+            try {
+                // Notify the server
+                sendUnbindRequest(conn.getConstraints().getServerControls());
+                
+                // interrupt the thread
+                try {
+                    t.interrupt();
+                    wait(500);
+                }
+                catch (InterruptedException ignore) {}
+                 
+            } catch (Exception e) {
+                LDAPConnection.printDebug(e.toString());
+            }
+            finally {
+                cleanUp(null);
+            }
+        }
+    }
+
+
+    /**
+     * Clean up after the thread shutdown.
+     * The list of registered clients m_registered is left in the current state
+     * to enable the clients to recover the connection.
+     */
+    private void cleanUp(LDAPException ex) {
+
+        resultRetrieved();
+
+        try {
+            m_serverOutput.close ();
+        } catch (Exception e) {
+        } finally {
+            m_serverOutput = null;
+        }
+
+        try {
+            m_serverInput.close ();
+        } catch (Exception e) {
+        } finally {
+            m_serverInput = null;
+        }
+
+        if (m_origServerInput != null) {
+            try {
+                m_origServerInput.close ();
+            } catch (Exception e) {
+            } finally {
+                m_origServerInput = null;
+            }
+        }
+
+        if (m_origServerOutput != null) {
+            try {
+                m_origServerOutput.close ();
+            } catch (Exception e) {
+            } finally {
+                m_origServerOutput = null;
+            }
+        }
+
+        // Notify the Connection Manager 
+        if (ex != null) {
+            // the connection is lost
+            m_connMgr.invalidateConnection();
+        }
+        else {
+            // the connection is closed
+            m_connMgr.closeConnection();
+        }
+
+        // Set the status for all outstanding requests
+        Enumeration requests = m_requests.elements();
+        while (requests.hasMoreElements()) {
+            try { 
+                LDAPMessageQueue listener =
+                    (LDAPMessageQueue)requests.nextElement();
+                if (ex != null) {
+                    listener.setException(this, ex);
+                }
+                else {
+                    listener.removeAllRequests(this);
+                }
+            }
+            catch (Exception ignore) {}
+        }            
+        m_requests.clear();
+
+        if (m_messages != null) {
+            m_messages.clear();
+        }
+
+        m_bound = false;
+    }
+
+    /**
+     * Sleep if there is a backlog of search results
+     */
+    private void checkBacklog() throws InterruptedException{
+
+        while (true) {
+
+            if (m_requests.size() == 0) {
+                return;
+            }
+            
+            Enumeration listeners = m_requests.elements();
+            while( listeners.hasMoreElements() ) {
+                LDAPMessageQueue l = (LDAPMessageQueue)listeners.nextElement();
+
+                // If there are clients waiting for a regular response
+                // message, skip backlog checking
+                if ( !(l instanceof LDAPSearchListener) ) {
+                    return;
+                }
+
+                LDAPSearchListener sl = (LDAPSearchListener)l;
+                
+                // should never happen, but just in case
+                if (sl.getSearchConstraints() == null) {
+                    return;
+                }
+
+                int slMaxBacklog = sl.getSearchConstraints().getMaxBacklog();
+                int slBatchSize  = sl.getSearchConstraints().getBatchSize();
+                
+                // Disabled backlog check ?
+                if (slMaxBacklog == 0) {
+                    return;
+                }
+                
+                // Synch op with zero batch size ?
+                if (!sl.isAsynchOp() && slBatchSize == 0) {
+                    return;
+                }
+                
+                // Max backlog not reached for at least one listener ?
+                // (if multiple requests are in progress)
+                if (sl.getMessageCount() < slMaxBacklog) {
+                    return;
+                }                    
+            }
+                                   
+            synchronized(this) {
+                wait(3000);
+            }
+        }
+    }
+
+
+
+    /**
+     * This is called when a search result has been retrieved from the incoming
+     * queue. We use the notification to unblock the listener thread, if it
+     * is waiting for the backlog to lighten.
+     */
+    synchronized void resultRetrieved() {
+        notifyAll();
+    }
+
+    /**
+     * Reads from the LDAP server input stream for incoming LDAP messages.
+     */
+    public void run() {
+
+        LDAPMessage msg = null;
+        JDAPBERTagDecoder decoder = new JDAPBERTagDecoder();
+        int[] nread = new int[1];        
+
+        while (Thread.currentThread() == m_thread) {
+            try  {
+
+                // Check every BACKLOG_CHKCNT messages if the backlog is not too high
+                if (--m_backlogCheckCounter <= 0) {
+                    m_backlogCheckCounter = BACKLOG_CHKCNT;
+                    checkBacklog();
+                }
+
+                nread[0] = 0;                
+                BERElement element = BERElement.getElement(decoder,
+                                                           m_serverInput,
+                                                           nread);
+                msg = LDAPMessage.parseMessage(element);
+
+                if (m_traceOutput != null) {
+                    logTraceMessage(msg.toTraceString());
+                }                    
+
+                // passed in the ber element size to approximate the size of the cache
+                // entry, thereby avoiding serialization of the entry stored in the
+                // cache
+                processResponse (msg, nread[0]);
+                Thread.yield();                
+
+            } catch (Exception e)  {
+                if (Thread.currentThread() == m_thread) {
+                    networkError(e);
+                }
+                else {
+                    resultRetrieved();
+                }
+            }
+        }
+    }
+
+    /**
+     * When a response arrives from the LDAP server, it is processed by
+     * this routine.  It will pass the message on to the listening object
+     * associated with the LDAP msgId.
+     * @param msg New message from LDAP server
+     */
+    private void processResponse (LDAPMessage msg, int size) {
+        Integer messageID = new Integer (msg.getMessageID());
+        LDAPMessageQueue l = (LDAPMessageQueue)m_requests.get (messageID);
+        if (l == null) {
+            return; /* nobody is waiting for this response (!) */
+        }
+
+        if (m_cache != null && (l instanceof LDAPSearchListener)) {
+            cacheSearchResult((LDAPSearchListener)l, msg, size);
+        }            
+        
+        l.addMessage (msg);
+
+        if (msg instanceof LDAPResponse) { 
+            m_requests.remove (messageID);
+            if (m_requests.size() == 0) {
+                m_backlogCheckCounter = BACKLOG_CHKCNT;
+            }
+
+            // Change IO streams if startTLS extended op completed
+            if (msg instanceof LDAPExtendedResponse) {
+                LDAPExtendedResponse extrsp = (LDAPExtendedResponse) msg;
+                String extid = extrsp.getID();
+                if (extrsp.getResultCode() == 0 && extid != null &&
+                    extid.equals(LDAPConnection.OID_startTLS)) {
+                       
+                    changeIOStreams();
+                }
+            }
+        }        
+    }
+
+    private void changeIOStreams() {
+
+        // Note: For the startTLS, the new streams are layered over the
+        // existing ones so current IO streams as well as the socket MUST
+        // not be closed.
+        m_origServerInput  = m_serverInput;
+        m_origServerOutput = m_serverOutput;
+        m_serverInput  = null;
+        m_serverOutput = null;
+        
+        while (m_serverInput == null ||  m_serverOutput == null) {
+            try {
+                if (Thread.currentThread() != m_thread) {
+                    return; // user disconnected
+                }
+                Thread.sleep(200);
+            } catch (InterruptedException ignore) {}
+        }
+    }
+
+    
+    /**
+     * Collect search results to be added to the LDAPCache. Search results are
+     * packaged in a vector and temporary stored into a hashtable m_messages
+     * using the message id as the key. The vector first element (at index 0)
+     * is a Long integer representing the total size of all LDAPEntries entries.
+     * It is followed by the actual LDAPEntries.
+     * If the total size of entries exceeds the LDAPCache max size, or a referral
+     * has been received, caching of search results is disabled and the entry is 
+     * not added to the LDAPCache. A disabled search request is denoted by setting
+     * the entry size to -1.
+     */
+    private synchronized void cacheSearchResult (LDAPSearchListener l, LDAPMessage msg, int size) {
+        Integer messageID = new Integer (msg.getMessageID());
+        Long key = l.getKey();
+        Vector v = null;
+
+        if ((m_cache == null) || (key == null)) {
+            return;
+        }
+        
+        if (msg instanceof LDAPSearchResult) {
+
+            // get the vector containing the LDAPMessages for the specified messageID
+            v = (Vector)m_messages.get(messageID);
+            if (v == null) {
+                m_messages.put(messageID, v = new Vector());
+                v.addElement(new Long(0));
+            }
+
+            // Return if the entry size is -1, i.e. the caching is disabled
+            if (((Long)v.firstElement()).longValue() == -1L) {
+                return;
+            }
+            
+            // add the size of the current LDAPMessage to the lump sum
+            // assume the size of LDAPMessage is more or less the same as the size
+            // of LDAPEntry. Eventually LDAPEntry object gets stored in the cache
+            // instead of LDAPMessage object.
+            long entrySize = ((Long)v.firstElement()).longValue() + size;
+
+            // If the entrySize exceeds the cache size, discard the collected
+            // entries and disble collecting of entries for this search request
+            // by setting the entry size to -1.
+            if (entrySize > m_cache.getSize()) {
+                v.removeAllElements();
+                v.addElement(new Long(-1L));
+                return;
+            }                
+                
+            // update the lump sum located in the first element of the vector
+            v.setElementAt(new Long(entrySize), 0);
+
+            // convert LDAPMessage object into LDAPEntry which is stored to the
+            // end of the Vector
+            v.addElement(((LDAPSearchResult)msg).getEntry());
+
+        } else if (msg instanceof LDAPSearchResultReference) {
+
+            // If a search reference is received disable caching of
+            // this search request 
+            v = (Vector)m_messages.get(messageID);
+            if (v == null) {
+                m_messages.put(messageID, v = new Vector());
+            }
+            else {
+                v.removeAllElements();
+            }
+            v.addElement(new Long(-1L));
+
+        } else if (msg instanceof LDAPResponse) {
+
+            // The search request has completed. Store the cache entry
+            // in the LDAPCache if the operation has succeded and caching
+            // is not disabled due to the entry size or referrals
+            
+            boolean fail = ((LDAPResponse)msg).getResultCode() > 0;
+            v = (Vector)m_messages.remove(messageID);
+            
+            if (!fail)  {
+                // If v is null, meaning there are no search results from the
+                // server
+                if (v == null) {
+                    v = new Vector();
+                    v.addElement(new Long(0));
+                }
+
+                // add the new entry if the entry size is not -1 (caching diabled)
+                if (((Long)v.firstElement()).longValue() != -1L) {
+                    m_cache.addEntry(key, v);
+                }
+            }
+        }
+    }
+
+    /**
+     * Stop dispatching responses for a particular message ID and send 
+     * the abandon request.
+     * @param id Message ID for which to discard responses.
+     */
+    void abandon (int id, LDAPControl[] ctrls) {
+        
+        if (m_thread == null) {
+            return;
+        }
+        
+        LDAPMessageQueue l = (LDAPMessageQueue)m_requests.remove(new Integer(id));
+        // Clean up cache if enabled
+        if (m_messages != null) {
+            m_messages.remove(new Integer(id));
+        }
+        if (l != null) {
+            l.removeRequest(id);
+        }
+        resultRetrieved(); // If LDAPConnThread is blocked in checkBacklog()
+        
+        sendAbandonRequest(id, ctrls);
+    }
+
+    /**
+     * Change listener for a message ID. Required when LDAPMessageQueue.merge()
+     * is invoked.
+     * @param id Message ID for which to chanage the listener.
+     * @return Previous listener.
+     */
+    LDAPMessageQueue changeListener (int id, LDAPMessageQueue toNotify) {
+
+        if (m_thread == null) {
+            toNotify.setException(this, new LDAPException("Server or network error",
+                                                           LDAPException.SERVER_DOWN));
+            return null;
+        }
+        return (LDAPMessageQueue) m_requests.put (new Integer (id), toNotify);
+    }
+
+    /**
+     * Handles network errors.  Basically shuts down the whole connection.
+     * @param e The exception which was caught while trying to read from
+     * input stream.
+     */
+    private synchronized void networkError (Exception e) {
+
+        if (m_thread == null) {
+            return;
+        }
+        m_thread = null; // No more request processing
+        cleanUp(new LDAPException("Server or network error",
+                                  LDAPException.SERVER_DOWN));
+    }
+}
\ No newline at end of file
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPMessageQueue.java
@@ -0,0 +1,541 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.Vector;
+
+/**
+ * A queue of response messsages from the server. Multiple requests
+ * can be multiplexed on the same queue. For synchronous LDAPConnection
+ * requests, there will be only one request per queue. For asynchronous
+ * LDAPConnection requests, the user can add multiple request to the
+ * same queue.
+ * 
+ * Superclass for LDAResponseListener and LDAPSearchListener
+ *
+ */
+class LDAPMessageQueue implements java.io.Serializable {
+
+    static final long serialVersionUID = -7163312406176592278L;
+
+    /**
+     * Request entry encapsulates request parameters
+     */
+    private static class RequestEntry {
+        int id;
+        LDAPConnection connection;
+        LDAPConnThread connThread;
+        long timeToComplete;
+        
+    
+        RequestEntry(int id, LDAPConnection connection,
+                     LDAPConnThread connThread, int timeLimit) {
+            this.id= id;
+            this.connection = connection;
+            this.connThread = connThread;
+            this.timeToComplete = (timeLimit == 0) ?
+                 Long.MAX_VALUE : (System.currentTimeMillis() + timeLimit);
+        }    
+    }
+
+    /**
+     * Internal variables
+     */
+    private /*LDAPMessage */ Vector m_messageQueue = new Vector(1);
+    private /*RequestEntry*/ Vector m_requestList  = new Vector(1);
+    private LDAPException m_exception; /* For network errors */
+    private boolean m_asynchOp;
+    
+    // A flag whether there are time constrained requests 
+    private boolean m_timeConstrained;
+
+    /**
+     * Constructor
+     * @param asynchOp a boolean flag  that is true if the object is used 
+     * for asynchronous LDAP operations
+     * @see netscape.ldap.LDAPAsynchronousConnection
+     */   
+    LDAPMessageQueue (boolean asynchOp) {
+        m_asynchOp = asynchOp;
+    }
+
+    /**
+     * Returns a flag whether the listener is used for asynchronous LDAP
+     * operations
+     * @return asynchronous operation flag.
+     * @see netscape.ldap.LDAPAsynchronousConnection
+     */
+    boolean isAsynchOp() {
+        return m_asynchOp;
+    }
+
+    /**
+     * Blocks until a response is available.
+     * Used by LDAPConnection.sendRequest (synch ops) to test if the server
+     * is really available after a request had been sent.
+     * @exception LDAPException Network error exception
+     * @exception LDAPInterruptedException The invoking thread was interrupted
+     */
+    synchronized void waitFirstMessage () throws LDAPException {
+        
+        while(m_requestList.size() != 0 && m_exception == null && m_messageQueue.size() == 0) {
+            waitForMessage();
+        }
+        
+        // Network exception occurred ?
+        if (m_exception != null) {
+            LDAPException ex = m_exception;
+            m_exception = null;
+            throw ex;
+        }        
+    }
+    
+    /**
+     * Blocks until a response is available or until all operations
+     * associated with the object have completed or been canceled.
+     * @return LDAP message or null if there are no more outstanding requests.
+     * @exception LDAPException Network error exception
+     * @exception LDAPInterruptedException The invoking thread was interrupted
+     */
+    synchronized LDAPMessage nextMessage () throws LDAPException {
+        
+        while(m_requestList.size() != 0 && m_exception == null && m_messageQueue.size() == 0) {
+            waitForMessage();
+        }
+        
+        // Network exception occurred ?
+        if (m_exception != null) {
+            LDAPException ex = m_exception;
+            m_exception = null;
+            throw ex;
+        }   
+
+        // Are there any outstanding requests left
+        if (m_requestList.size() == 0) {
+            return null; // No outstanding requests
+        }
+            
+        // Dequeue the first entry
+        LDAPMessage msg = (LDAPMessage) m_messageQueue.elementAt(0);
+        m_messageQueue.removeElementAt(0);
+        
+        // Is the ldap operation completed?
+        if (msg instanceof LDAPResponse) {
+            removeRequest(msg.getMessageID());
+        }
+        
+        return msg;
+    }
+
+    /**
+     * Wait for request to complete. This method blocks until a message of
+     * type LDAPResponse has been received. Used by synchronous search 
+     * with batch size of zero (block until all results are received)
+     * @return LDAPResponse message or null if there are no more outstanding requests.
+     * @exception LDAPException Network error exception
+     * @exception LDAPInterruptedException The invoking thread was interrupted
+     */
+    synchronized LDAPResponse completeRequest () throws LDAPException {
+
+        while (true) {
+            while(m_requestList.size() != 0 && m_exception == null && m_messageQueue.size() == 0) {            
+                waitForMessage();
+            }
+
+            // Network exception occurred ?
+            if (m_exception != null) {
+                LDAPException ex = m_exception;
+                m_exception = null;
+                throw ex;
+            }   
+
+            // Are there any outstanding requests left?
+            if (m_requestList.size() == 0) {
+                return null; // No outstanding requests
+            }
+            
+            // Search an instance of LDAPResponse
+            for (int i= m_messageQueue.size()-1; i >=0; i--) {
+                LDAPMessage msg = (LDAPMessage) m_messageQueue.elementAt(i);
+                if (msg instanceof LDAPResponse) {
+                
+                    // Dequeue the entry and return
+                    m_messageQueue.removeElementAt(i);
+                    return (LDAPResponse)msg;
+                }
+            }
+
+            // Not found, wait for the next message
+            waitForMessage();
+        }            
+    }
+
+    /**
+     * Wait for a response message. Process interrupts and honor
+     * time limit if set for any request
+     */
+    synchronized private void waitForMessage () throws LDAPException{
+        
+        if (!m_timeConstrained) {
+            try {
+                wait ();
+                return;
+            } catch (InterruptedException e) {
+                throw new LDAPInterruptedException("Interrupted LDAP operation");
+            }
+        }
+
+        /**
+         * Perform time constrained wait
+         */
+        long minTimeToComplete = Long.MAX_VALUE;
+        long now = System.currentTimeMillis();
+        for (int i=0; i < m_requestList.size(); i++) {
+            RequestEntry entry = (RequestEntry)m_requestList.elementAt(i);
+            
+            // time limit exceeded ?
+            if (entry.timeToComplete <= now) {
+                entry.connection.abandon(entry.id);
+                throw new LDAPException("Time to complete operation exceeded",
+                                         LDAPException.LDAP_TIMEOUT);
+            }                
+                
+            if (entry.timeToComplete < minTimeToComplete) {
+                minTimeToComplete = entry.timeToComplete;
+            }            
+        }
+        
+        long timeLimit = (minTimeToComplete == Long.MAX_VALUE)? 
+                         0 :(minTimeToComplete - now);
+        
+        try {
+            m_timeConstrained = (timeLimit != 0);
+            wait (timeLimit);
+        } catch (InterruptedException e) {
+            throw new LDAPInterruptedException("Interrupted LDAP operation");
+        }
+    }
+
+    /**
+     * Merge two message queues.
+     * Move/append the content from another message queue to this one.
+     * 
+     * To be used for synchronization of asynchronous LDAP operations where
+     * requests are sent by one thread but processed by another one
+     * 
+     * A client may be implemented in such a way that one thread makes LDAP
+     * requests and calls l.getMessageIDs(), while another thread is
+     * responsible for
+     * processing of responses (call l.getResponse()). Both threads are using
+     * the same listener objects. In such a case, a race
+     * condition may occur, where a LDAP response message is retrieved and
+     * the request terminated (request ID removed) before the first thread
+     * has a chance to execute l.getMessageIDs().
+     * The proper way to handle this scenario is to create a separate listener
+     * for each new request, and after l.getMessageIDs() has been invoked,
+     * merge the
+     * new request with the existing one.
+     * @param mq2 message queue to merge with this one
+     */
+    void merge(LDAPMessageQueue mq2) {
+        
+        // Yield just in case the LDAPConnThread is in the process of
+        // dispatching a message
+        Thread.yield();
+        
+        synchronized(this) {
+            
+            synchronized (mq2) {
+                for (int i=0; i < mq2.m_messageQueue.size(); i++) {
+                    m_messageQueue.addElement(mq2.m_messageQueue.elementAt(i));
+                }
+                if (mq2.m_exception != null) {
+                    m_exception = mq2.m_exception;
+                }
+                for (int i=0; i < mq2.m_requestList.size(); i++) {
+                    RequestEntry entry = (RequestEntry)mq2.m_requestList.elementAt(i);
+                    m_requestList.addElement(entry);
+                    // Notify LDAPConnThread to redirect mq2 designated responses to this mq
+                    entry.connThread.changeListener(entry.id, this);
+                }
+                    
+                mq2.reset();
+                notifyAll(); // notify for mq2
+            }
+
+            notifyAll();  // notify this mq
+        }
+    }
+
+
+    /**
+     * Retrieves all messages currently in the queue without blocking
+     * @return vector of messages.
+     */
+    synchronized Vector getAllMessages() {
+        Vector result = m_messageQueue;
+        m_messageQueue = new Vector(1);
+        return result;
+    }
+    
+    /**
+     * Queues the LDAP server's response.  This causes anyone waiting
+     * in nextMessage() to unblock.
+     * @param msg response message
+     */
+    synchronized void addMessage (LDAPMessage msg) {
+        m_messageQueue.addElement(msg);
+        
+        // Mark conn as bound for asych bind operations
+        if (isAsynchOp() && msg.getType() == msg.BIND_RESPONSE) {
+            if (((LDAPResponse) msg).getResultCode() == 0) {
+                getConnection(msg.getMessageID()).setBound(true);
+            }                
+        }
+                
+        notifyAll ();
+    }
+
+    /**
+     * Signals that a network exception occured while servicing the
+     * request.  This exception will be throw to any thread waiting
+     * in nextMessage()
+     * @param connThread LDAPConnThread on which the exception occurred
+     * @param e exception
+     */
+    synchronized void setException (LDAPConnThread connThread, LDAPException e) {        
+        m_exception = e;
+        removeAllRequests(connThread);
+        notifyAll ();
+    }
+
+    /**
+     * Checks if response message is received.
+     * @return true or false.
+     */
+    boolean isMessageReceived() {
+        return m_messageQueue.size() != 0;
+    }
+
+    /**
+     * Returns the count of queued messages
+     * @return message count.
+     */
+    public int getMessageCount () {
+        return m_messageQueue.size();
+    }
+
+    /**
+     * Remove all queued messages associated with the request ID
+     * Called when a LDAP operation is abandoned
+     * 
+     * Not synchronized as its private and can be called only by
+     * abandon() and removeAllRequests()
+     * 
+     * @return count of removed messages.
+     */
+    private int removeAllMessages(int id) {
+        int removeCount=0;
+        for (int i=(m_messageQueue.size()-1); i>=0; i--) {
+            LDAPMessage msg = (LDAPMessage)m_messageQueue.elementAt(i);
+            if (msg.getMessageID() == id) {
+                m_messageQueue.removeElementAt(i);
+                removeCount++;
+            }
+        }
+        return removeCount;
+    }   
+
+    /**
+     * Resets the state of this object, so it can be recycled.
+     * Used by LDAPConnection synchronous operations.
+     * @see netscape.ldap.LDAPConnection#getResponseListener
+     * @see netscape.ldap.LDAPConnection#getSearchListener
+     */
+    void reset () {
+        m_exception = null;
+        m_messageQueue.removeAllElements();
+        m_requestList.removeAllElements();
+        m_timeConstrained = false;
+    }
+    
+    /**
+     * Returns the connection associated with the specified request id
+     * @param id request id
+     * @return connection.
+     */
+    synchronized LDAPConnection getConnection(int id) {
+        for (int i=0; i < m_requestList.size(); i++) {
+            RequestEntry entry = (RequestEntry)m_requestList.elementAt(i);
+            if (id == entry.id) {                
+                return entry.connection;
+            }
+        }
+        return null;
+
+    }
+
+    /**
+     * Returns the connection thread associated with the specified request id
+     * @param id request id.
+     * @return connection thread.
+     */
+    synchronized LDAPConnThread getConnThread(int id) {
+        for (int i=0; i < m_requestList.size(); i++) {
+            RequestEntry entry = (RequestEntry)m_requestList.elementAt(i);
+            if (id == entry.id) {                
+                return entry.connThread;
+            }
+        }
+        return null;
+
+    }
+
+    /**
+     * Returns message ID of the last request
+     * @return message ID.
+     */
+    synchronized int getMessageID() {
+        int reqCnt = m_requestList.size();
+        if ( reqCnt == 0) {
+            return -1;
+        }
+        else {
+            RequestEntry entry = (RequestEntry)m_requestList.elementAt(reqCnt-1);
+            return entry.id;
+        }
+    }
+    
+    /**
+     * Returns a list of message IDs for all outstanding requests
+     * @return message ID array.
+     */
+    synchronized int[] getMessageIDs() {
+        int[] ids = new int[m_requestList.size()];
+        for (int i=0; i < ids.length; i++) {
+            RequestEntry entry = (RequestEntry)m_requestList.elementAt(i);
+            ids[i] = entry.id;
+        }
+        return ids;
+    }    
+
+    /**
+     * Registers a LDAP request
+     * @param id LDAP request message ID
+     * @param connection LDAP Connection for the message ID
+     * @param connThread a physical connection to the server
+     * @param timeLimit the maximum number of milliseconds to wait for
+     * the request to complete 
+    */
+    synchronized void addRequest(int id, LDAPConnection connection,
+                                 LDAPConnThread connThread, int timeLimit) {
+        
+        m_requestList.addElement(new RequestEntry(id, connection,
+                                                  connThread, timeLimit));
+        if (timeLimit != 0) {
+            m_timeConstrained = true;
+        }
+        notifyAll();
+    }
+
+    /**
+     * Returns the number of outstanding requests.
+     * @return outstanding request count.
+     */    
+    public int getRequestCount() {
+        return m_requestList.size();
+    }
+    
+    /**
+     * Remove request with the specified ID
+     * Called when a LDAP operation is abandoned (called from
+     * LDAPConnThread), or terminated (called by nextMessage() when
+     * LDAPResponse message is received) 
+     * @return flag indicating whether the request was removed.
+     */
+    synchronized boolean removeRequest(int id) {
+        for (int i=0; i < m_requestList.size(); i++) {
+            RequestEntry entry = (RequestEntry)m_requestList.elementAt(i);
+            if (id == entry.id) {
+                m_requestList.removeElementAt(i);
+                removeAllMessages(id);
+                notifyAll();
+                return true;
+            }
+        }
+        return false;
+    }            
+
+    /**
+     * Remove all requests associated with the specified connThread
+     * Called when a connThread has a network error
+     * @return number of removed requests.
+     */
+    synchronized int removeAllRequests(LDAPConnThread connThread) {
+        int removeCount=0;
+        for (int i=(m_requestList.size()-1); i>=0; i--) {
+            RequestEntry entry = (RequestEntry)m_requestList.elementAt(i);
+            if (connThread == entry.connThread) {
+                m_requestList.removeElementAt(i);
+                removeCount++;
+                
+                // remove all queued messages as well
+                removeAllMessages(entry.id);
+            }
+        }
+        notifyAll();
+        return removeCount;
+    }   
+
+    /**
+     * String representation of the object
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer("LDAPMessageQueue:");
+        sb.append(" requestIDs={");
+        for (int i=0; i < m_requestList.size(); i++) {
+            if (i>0) {
+                sb.append(",");
+            }
+            sb.append(((RequestEntry)m_requestList.elementAt(i)).id);
+        }
+        sb.append("} messageCount="+m_messageQueue.size());
+        
+        return sb.toString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSearchResult.java
@@ -0,0 +1,90 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import netscape.ldap.client.opers.JDAPSearchResponse;
+
+/**
+ * A LDAPSearchResult object encapsulates a single search result.
+ *
+ * @version 1.0
+ */
+public class LDAPSearchResult extends LDAPMessage {
+
+    static final long serialVersionUID = 36890821518462301L;
+
+    /**
+     * LDAPEntry 
+     */
+    private LDAPEntry m_entry;
+    
+    /**
+     * Constructor
+     * 
+     * @param msgid message identifier
+     * @param rsp search operation response
+     * @param controls array of controls or null
+     * @see netscape.ldap.LDAPEntry
+     */
+    LDAPSearchResult(int msgid, JDAPSearchResponse rsp, LDAPControl[]controls) {
+        super(msgid, rsp, controls);
+    }
+    
+    /**
+     * Returns the entry of a server search response.
+     * @return an entry returned by the server in response to a search
+     * request.
+     * @see netscape.ldap.LDAPEntry
+     */
+    public LDAPEntry getEntry() {
+        if (m_entry == null) {
+            JDAPSearchResponse rsp = (JDAPSearchResponse)getProtocolOp();
+            LDAPAttribute[] lattrs = rsp.getAttributes();
+            LDAPAttributeSet attrs;
+            if ( lattrs != null ) {
+                attrs = new LDAPAttributeSet( lattrs );
+            }            
+            else {
+                attrs = new LDAPAttributeSet();
+            }
+            String dn = rsp.getObjectName();
+            m_entry = new LDAPEntry( dn, attrs );
+        }
+        return m_entry;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPCheckComm.java
@@ -0,0 +1,82 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * This static class checks if the caller is an applet running in
+ * Netscape Communicator. If so, it returns the appropriate method.
+ */
+class LDAPCheckComm {
+
+    /**
+     * Returns the method whose name matches the specified argument.
+     * @param classPackage the class package
+     * @param name the method name
+     * @return the method.
+     * @exception LDAPException Gets thrown if the method is not found or
+     *            the caller is not an applet running in Netscape
+     *            Communicator.
+     */
+    static java.lang.reflect.Method getMethod(String classPackage, String name) throws LDAPException {
+      SecurityManager sec = System.getSecurityManager();
+
+        if ( sec == null ) {
+            /* Not an applet, we can do what we want to */
+            return null;
+        } else if ( sec.toString().startsWith("java.lang.NullSecurityManager") ) {
+            /* Not an applet, we can do what we want to */
+            return null;
+        } else if (sec.toString().startsWith("netscape.security.AppletSecurity")) {
+            /* Running as applet. Is PrivilegeManager around? */
+            try {
+                Class c = Class.forName(classPackage);
+                java.lang.reflect.Method[] m = c.getMethods();
+                for( int i = 0; i < m.length; i++ ) {
+                    if ( m[i].getName().equals(name) ) {
+                        return m[i];
+                    }
+                }
+                throw new LDAPException("no enable privilege in " + classPackage);
+            } catch (ClassNotFoundException e) {
+                throw new LDAPException("Class not found");
+            }
+        }
+        return null;
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPExtendedResponse.java
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import netscape.ldap.client.opers.JDAPExtendedResponse;
+
+/**
+ * Represents a server response to an extended operation request.
+ * 
+ * @version 1.0
+ */
+public class LDAPExtendedResponse extends LDAPResponse
+                                  implements java.io.Serializable {
+
+    static final long serialVersionUID = -3813049515964705320L;
+
+    /**
+     * Constructor
+     * 
+     * @param msgid message identifier
+     * @param rsp extended operation response
+     * @paarm controls array of controls or null
+     */
+    LDAPExtendedResponse(int msgid, JDAPExtendedResponse rsp, LDAPControl controls[]) {
+        super(msgid, rsp, controls);
+    }
+    
+    /**
+     * Returns the OID of the response.
+     *
+     * @return the response OID.
+     */
+    public String  getID() {
+        JDAPExtendedResponse result = (JDAPExtendedResponse)getProtocolOp();
+        return result.getID();
+    }
+
+    /**
+     * Returns the OID of the response.
+     *
+     * @return the response OID.
+     * @deprecated Use <CODE>LDAPExtendedResponse.getID()</CODE>
+     */
+    public String  getOID() {
+        return getID();
+    }
+
+    /**
+     * Returns the raw bytes of the value part of the response.
+     *
+     * @return response as a raw array of bytes.
+     */
+    public byte[] getValue() {
+        JDAPExtendedResponse result = (JDAPExtendedResponse)getProtocolOp();
+        return result.getValue();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPEntry.java
@@ -0,0 +1,222 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * Represents an entry in the directory.
+ *
+ * @version 1.0
+ */
+public class LDAPEntry implements java.io.Serializable {
+
+    static final long serialVersionUID = -5563306228920012807L;
+    private String dn = null;
+    private LDAPAttributeSet attrSet = null;
+
+    /**
+     * Constructs an empty entry.
+     */
+    public LDAPEntry() {
+        dn = null;
+        attrSet = new LDAPAttributeSet();
+    }
+
+    /**
+     * Constructs a new entry with the specified distinguished name and with
+     * an empty attribute set.
+     * @param distinguishedName the distinguished name of the new entry
+     */
+    public LDAPEntry( String distinguishedName ) {
+        dn = distinguishedName;
+        attrSet = new LDAPAttributeSet();
+    }
+
+    /**
+     * Constructs a new entry with the specified distinguished name and
+     * set of attributes.
+     * @param distinguishedName the distinguished name of the new entry
+     * @param attrs the set of attributes to assign to the new entry
+     * @see netscape.ldap.LDAPAttributeSet
+     */
+    public LDAPEntry( String distinguishedName, LDAPAttributeSet attrs ) {
+        dn = distinguishedName;
+        attrSet = attrs;
+    }
+
+    /**
+     * Returns the distinguished name of the current entry.
+     * @return distinguished name of the current entry.
+     */
+    public String getDN() {
+        return dn;
+    }
+
+    void setDN(String name) {
+        dn = name;
+    }
+
+    /**
+     * Returns the attribute set of the entry.
+     * @return set of attributes in the entry.
+     * @see netscape.ldap.LDAPAttributeSet
+     */
+    public LDAPAttributeSet getAttributeSet() {
+        return attrSet;
+    }
+
+    /**
+     * Creates a new attribute set containing only the attributes
+     * that have the specified subtypes.
+     * <P>
+     *
+     * For example, suppose an entry contains the following attributes:
+     * <P>
+     *
+     * <PRE>
+     * cn
+     * cn;lang-ja
+     * sn;phonetic;lang-ja
+     * sn;lang-us
+     * </PRE>
+     *
+     * If you call the <CODE>getAttributeSet</CODE> method and pass
+     * <CODE>lang-ja</CODE> as the argument, the method returns
+     * an attribute set containing the following attributes:
+     * <P>
+     *
+     * <PRE>
+     * cn;lang-ja
+     * sn;phonetic;lang-ja
+     * </PRE>
+     *
+     * @param subtype semi-colon delimited list of subtypes
+     * that you want to find in attribute names.
+     *<PRE>
+     *     "lang-ja"        // Only Japanese language subtypes
+     *     "binary"         // Only binary subtypes
+     *     "binary;lang-ja" // Only Japanese language subtypes
+     *                         which also are binary
+     *</PRE>
+     * @return attribute set containing the attributes that have
+     * the specified subtypes.
+     * @see netscape.ldap.LDAPAttributeSet
+     * @see netscape.ldap.LDAPAttributeSet#getSubset
+     */
+    public LDAPAttributeSet getAttributeSet(String subtype) {
+        return attrSet.getSubset(subtype);
+    }
+
+    /**
+     * In an entry, returns the single attribute that exactly matches the
+     * specified attribute name.
+     * @param attrName name of attribute to return
+     * For example:
+     *<PRE>
+     *     "cn"            // Only a non-subtyped version of cn
+     *     "cn;lang-ja"    // Only a Japanese version of cn, will not
+     *                     // return "cn;lang-ja-JP-kanji", for example
+     *</PRE>
+     * @return attribute in the current entry that has exactly the same name,
+     * or null (if no attribute in the entry matches the specified name).
+     * @see netscape.ldap.LDAPAttribute
+     */
+    public LDAPAttribute getAttribute(String attrName) {
+        return attrSet.getAttribute(attrName);
+    }
+
+    /**
+     * Returns the subtype that matches "attrName" and that best matches
+     * a language specification "lang". If there are subtypes other than
+     * "lang" subtypes included in attrName, e.g. "cn;binary", only
+     * attributes with all of those subtypes are returned. If lang is
+     * null or empty, the method behaves as getAttribute(attrName). If
+     * there are no matching attributes, null is returned.
+     *
+     * Example:<PRE>
+     *  Assume the entry contains only the following attributes:
+     *     <CODE>cn;lang-en</CODE>
+     *     <CODE>cn;lang-ja-JP-kanji</CODE>
+     *     <CODE>sn</CODE>
+     *  getAttribute( "cn" ) returns <CODE>null</CODE>.
+     *  getAttribute( "sn" ) returns the "<CODE>sn</CODE>" attribute.
+     *  getAttribute( "cn", "lang-en-us" ) returns the "<CODE>cn;lang-en</CODE>" attribute.
+     *  getAttribute( "cn", "lang-en" ) returns the "<CODE>cn;lang-en</CODE>" attribute.
+     *  getAttribute( "cn", "lang-ja" ) returns <CODE>null</CODE>.
+     *  getAttribute( "sn", "lang-en" ) returns the "<CODE>sn</CODE>" attribute.
+     *</PRE>
+     * <P>
+     * @param attrName name of attribute to find in the entry
+     * @param lang a language specification (for example, <CODE>lang-en</CODE>)
+     * @return the attribute that matches the base name and that best
+     * matches any specified language subtype.
+     * @see netscape.ldap.LDAPAttribute
+     */
+    public LDAPAttribute getAttribute( String attrName, String lang ) {
+        return attrSet.getAttribute( attrName, lang );
+    }
+
+    /**
+     * Retrieves the string representation of the entry's
+     * distinguished name (DN) and its attributes.
+     * For example:
+     *
+     * <PRE>
+     * LDAPEntry: uid=bjensen, ou=People, o=airius.com; LDAPAttributeSet:
+     * LDAPAttribute {type='cn', values='Barbara Jensen,Babs Jensen'}
+     * LDAPAttribute {type='sn', values='Jensen'}LDAPAttribute {type='givenname',
+     * values='Barbara'}LDAPAttribute {type='objectclass', values='top,person,
+     * organizationalPerson,inetOrgPerson'}LDAPAttribute {type='ou',
+     * values='Product Development,People'}
+     * </PRE>
+     *
+     * @return string representation of the entry's DN and its attributes.
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer("LDAPEntry: ");
+        if ( dn != null ) {
+            sb.append(dn);
+            sb.append("; ");
+        }            
+        if ( attrSet != null ) {
+            sb.append(attrSet.toString());
+        }
+        return sb.toString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPObjectClassSchema.java
@@ -0,0 +1,448 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * The definition of an object class in the schema.
+ * <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+ * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+ * Attribute Syntax Definitions</A> covers the types of information
+ * that need to be specified in the definition of an object class.
+ * According to the RFC, the description of an object class can
+ * include the following information:
+ * <P>
+ *
+ * <UL>
+ * <LI>an OID identifying the object class
+ * <LI>a name identifying the object class
+ * <LI>a description of the object class
+ * <LI>the name of the parent object class
+ * <LI>the list of attribute types that are required in this object class
+ * <LI>the list of attribute types that are allowed (optional) in this
+ * object class
+ * </UL>
+ * <P>
+ *
+ * When you construct an <CODE>LDAPObjectSchema</CODE> object, you can specify
+ * these types of information as arguments to the constructor or in the
+ * ObjectClassDescription format specified in RFC 2252.
+ * When an LDAP client searches an LDAP server for the schema, the server
+ * returns schema information as an object with attribute values in this
+ * format.
+ * <P>
+ *
+ * RFC 2252 also notes that you can specify whether or not an object class
+ * is abstract, structural, or auxiliary in the object description.
+ * Abstract object classes are used only to derive other object classes.
+ * Entries cannot belong to an abstract object class. <CODE>top</CODE>
+ * is an abstract object class. Entries must belong to a structural
+ * object class, so most object classes are structural object classes.
+ * Objects of the <CODE>LDAPObjectClassSchema</CODE> class are structural
+ * object classes by default. Auxiliary object classes can be used to
+ * add attributes to entries of different types. For example, an
+ * auxiliary object class might be used to specify personal preference
+ * attributes. An entry can not contain just that object class, but may
+ * include it along with a structural object class, for example
+ * inetOrgPerson.
+ * If the definition of an object (in ObjectClassDescription format)
+ * specifies the AUXILIARY keyword, an <CODE>LDAPObjectClassSchema</CODE>
+ * object created from that description represents an auxiliary object class.
+ * <P>
+ *
+ * You can get the name, OID, and description of this object class
+ * definition by using the <CODE>getName</CODE>, <CODE>getOID</CODE>, and
+ * <CODE>getDescription</CODE> methods inherited from the abstract class
+ * <CODE>LDAPSchemaElement</CODE>. Optional and custom qualifiers are
+ * accessed with <CODE>getQualifier</CODE> and <CODE>getQualifierNames</CODE>
+ * from <CODE>LDAPSchemaElement</CODE>.
+ 
+ * <P>
+ *
+ * To add or remove this object class definition from the
+ * schema, use the <CODE>add</CODE> and <CODE>remove</CODE>
+ * methods, which this class inherits from the <CODE>LDAPSchemaElement</CODE>
+ * abstract class.
+ * <P>
+ * RFC 2252 defines ObjectClassDescription as follows:
+ * <P>
+ * <PRE>
+ *    ObjectClassDescription = "(" whsp
+ *        numericoid whsp      ; ObjectClass identifier
+ *        [ "NAME" qdescrs ]
+ *        [ "DESC" qdstring ]
+ *        [ "OBSOLETE" whsp ]
+ *        [ "SUP" oids ]       ; Superior ObjectClasses
+ *        [ ( "ABSTRACT" / "STRUCTURAL" / "AUXILIARY" ) whsp ]
+ *                             ; default structural
+ *        [ "MUST" oids ]      ; AttributeTypes
+ *        [ "MAY" oids ]       ; AttributeTypes
+ *    whsp ")"
+ * </PRE>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPSchemaElement
+ **/
+public class LDAPObjectClassSchema extends LDAPSchemaElement {
+
+    static final long serialVersionUID = -1732784695071118656L;
+
+    /**
+     * Constructs an object class definition, using the specified
+     * information. The type of the object class will be STRUCTURAL.
+     * @param name name of the object class
+     * @param oid object identifier (OID) of the object class
+     * in dotted-string format (for example, "1.2.3.4")
+     * @param description description of the object class
+     * @param superior name of the parent object class
+     * (the object class that the new object class inherits from)
+     * @param required array of names of attributes required
+     * in this object class
+     * @param optional array of names of optional attributes
+     * allowed in this object class
+     */
+    public LDAPObjectClassSchema( String name, String oid, String superior,
+                                  String description,
+                                  String[] required, String[] optional ) {
+        this( name, oid, superior, description, required, optional, null );
+    }
+
+    /**
+     * Constructs an object class definition, using the specified
+     * information.
+     * @param name name of the object class
+     * @param oid object identifier (OID) of the object class
+     * in dotted-string format (for example, "1.2.3.4")
+     * @param description description of the object class
+     * @param superiors names of parent object classes
+     * (the object classes that this object class inherits from)
+     * @param required array of names of attributes required
+     * in this object class
+     * @param optional array of names of optional attributes
+     * allowed in this object class
+     * @param type either ABSTRACT, STRUCTURAL, or AUXILIARY
+     * @param aliases names which are to be considered aliases for this
+     * object class; <CODE>null</CODE> if there are no aliases
+     */
+    public LDAPObjectClassSchema( String name, String oid,
+                                  String[] superiors,
+                                  String description,
+                                  String[] required, String[] optional,
+                                  int type, String[] aliases ) {
+        this( name, oid,
+              ((superiors != null) && (superiors.length > 0)) ?
+                  superiors[0] : null,
+              description, required, optional, aliases );
+        if ( (superiors != null) && (superiors.length > 1) ) {
+            setQualifier( SUPERIOR, superiors );
+        }
+        setQualifier( TYPE, typeToString( type ) );
+    }
+
+    /**
+     * Constructs an object class definition, using the specified
+     * information. The type of the object class will be STRUCTURAL.
+     * @param name name of the object class
+     * @param oid object identifier (OID) of the object class
+     * in dotted-string format (for example, "1.2.3.4")
+     * @param description description of the object class
+     * @param superior name of the parent object class
+     * (the object class that the new object class inherits from)
+     * @param required array of names of attributes required
+     * in this object class
+     * @param optional array of names of optional attributes
+     * allowed in this object class
+     */
+    protected LDAPObjectClassSchema( String name, String oid, String superior,
+                                     String description,
+                                     String[] required, String[] optional,
+                                     String[] aliases ) {
+        super( name, oid, description, aliases );
+        attrName = "objectclasses";
+        setQualifier( SUPERIOR, superior );
+        if ( required != null ) {
+            for( int i = 0; i < required.length; i++ ) {
+                must.addElement( required[i] );
+            }
+        }
+        if ( optional != null ) {
+            for( int i = 0; i < optional.length; i++ ) {
+                may.addElement( optional[i] );
+            }
+        }
+    }
+
+    /**
+     * Constructs an object class definition based on a description in
+     * the ObjectClassDescription format.  For information on this format,
+     * (see <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+     * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+     * Attribute Syntax Definitions</A>.  This is the format that LDAP servers
+     * and clients use to exchange schema information.  (For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the attributes "objectclasses" and "attributetypes".  The
+     * values of the "objectclasses" attribute are object class descriptions
+     * in this format.)
+     * <P>
+     *
+     * @param raw definition of the object in the ObjectClassDescription
+     * format
+     */
+    public LDAPObjectClassSchema( String raw ) {
+        attrName = "objectclasses";
+        parseValue( raw );
+        setQualifier( TYPE, typeToString( getType() ) );
+        Object o = properties.get( "MAY" );
+        if ( o != null ) {
+            if ( o instanceof Vector ) {
+                may = (Vector)o;
+            } else {
+                may.addElement( o );
+            }
+        }
+        o = properties.get( "MUST" );
+        if ( o != null ) {
+            if ( o instanceof Vector ) {
+                must = (Vector)o;
+            } else {
+                must.addElement( o );
+            }
+        }
+    }
+
+    /**
+     * Gets the name of the object class from which this class inherits.
+     * @return the name of the object class from which this class
+     * inherits. If it inherits from more than one class, only one
+     * is returned.
+     * @see netscape.ldap.LDAPObjectClassSchema#getSuperiors
+     */
+    public String getSuperior() {
+        String[] superiors = getSuperiors();
+        return (superiors != null) ? superiors[0] : null;
+    }
+
+    /**
+     * Gets the names of all object classes that this class inherits
+     * from. Typically only one, but RFC 2252 allows multiple
+     * inheritance.
+     * @return the names of the object classes from which this class
+     * inherits.
+     */
+    public String[] getSuperiors() {
+        return getQualifier( SUPERIOR );
+    }
+
+    /**
+     * Gets an enumeration of the names of the required attributes for
+     * this object class.
+     * @return an enumeration of the names of the required attributes
+     * for this object class.
+     */
+    public Enumeration getRequiredAttributes() {
+        return must.elements();
+    }
+
+    /**
+     * Gets an enumeration of names of optional attributes allowed
+     * in this object class.
+     * @return an enumeration of the names of optional attributes
+     * allowed in this object class.
+     */
+    public Enumeration getOptionalAttributes() {
+        return may.elements();
+    }
+
+    /**
+     * Gets the type of the object class.
+     * @return STRUCTURAL, ABSTRACT, or AUXILIARY.
+     */
+    public int getType() {
+        int type = STRUCTURAL;
+        if ( properties.containsKey( "AUXILIARY" ) ) {
+            type = AUXILIARY;
+        } else if ( properties.containsKey( "ABSTRACT" ) ) {
+            type = ABSTRACT;
+        }
+        return type;
+    }
+
+    /**
+     * Prepares a value in RFC 2252 format for submitting to a server.
+     *
+     * @param quotingBug <CODE>true</CODE> if SUP and SYNTAX values are to
+     * be quoted. That is to satisfy bugs in certain LDAP servers.
+     * @return a String ready for submission to an LDAP server.
+     */
+    String getValue( boolean quotingBug ) {
+        String s = getValuePrefix();
+        String val = getValue( SUPERIOR, quotingBug );
+        if ( (val != null) && (val.length() > 0) ) {
+            s += val + ' ';
+        }
+        String[] vals = getQualifier( TYPE );
+        if ( (vals != null) && (vals.length > 0) ) {
+            s += vals[0] + ' ';
+        }
+        val = getOptionalValues( NOVALS );
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        if ( must.size() > 0 ) {
+            s += "MUST " + vectorToList( must );
+            s += ' ';
+        }
+        if ( may.size() > 0 ) {
+            s += "MAY " + vectorToList( may );
+            s += ' ';
+        }
+        val = getCustomValues();
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        s += ')';
+        return s;
+    }
+
+    /**
+     * Gets the definition of the object class in a user friendly format.
+     * This is the format that the object class definition uses when
+     * you print the object class or the schema.
+     * @return definition of the object class in a user friendly format.
+     */
+    public String toString() {
+        String s = "Name: " + name + "; OID: " + oid +
+            "; Superior: ";
+        String[] superiors = getSuperiors();
+        if ( superiors != null ) {
+            for( int i = 0; i < superiors.length; i++ ) {
+                s += superiors[i];
+                if ( i < (superiors.length-1) ) {
+                    s += ", ";
+                }
+            }
+        }
+        s += "; Description: " + description + "; Required: ";
+        int i = 0;
+        Enumeration e = getRequiredAttributes();
+        while( e.hasMoreElements() ) {
+            if ( i > 0 )
+                s += ", ";
+            i++;
+            s += (String)e.nextElement();
+        }
+        s += "; Optional: ";
+        e = getOptionalAttributes();
+        i = 0;
+        while( e.hasMoreElements() ) {
+            if ( i > 0 )
+                s += ", ";
+            i++;
+            s += (String)e.nextElement();
+        }
+        String[] vals = getQualifier( TYPE );
+        if ( (vals != null) && (vals.length > 0) ) {
+            s += "; " + vals[0];
+        }
+        if ( isObsolete() ) {
+            s += "; OBSOLETE";
+        }
+        s += getQualifierString( IGNOREVALS );
+        s += getAliasString();
+        return s;
+    }
+
+    /**
+     * Creates a list within parentheses, with $ as delimiter
+     *
+     * @param vals values for list
+     * @return a String with a list of values.
+     */
+    protected String vectorToList( Vector vals ) {
+        String val = "( ";
+        for( int i = 0; i < vals.size(); i++ ) {
+            val += (String)vals.elementAt(i) + ' ';
+            if ( i < (vals.size() - 1) ) {
+                val += "$ ";
+            }
+        }
+        val += ')';
+        return val;
+    }
+
+    /**
+     * Returns the object class type as a String
+     *
+     * @param type one of STRUCTURAL, ABSTRACT, or AUXILIARY
+     * @return one of "STRUCTURAL", "ABSTRACT", "AUXILIARY", or <CODE>null</CODE>
+     */
+    protected String typeToString( int type ) {
+        switch( type ) {
+        case STRUCTURAL: return "STRUCTURAL";
+        case ABSTRACT: return "ABSTRACT";
+        case AUXILIARY: return "AUXILIARY";
+        default: return null;
+        }
+    }
+
+    public static final int STRUCTURAL = 0;
+    public static final int ABSTRACT = 1;
+    public static final int AUXILIARY = 2;
+
+    private Vector must = new Vector();
+    private Vector may = new Vector();
+    private int type = STRUCTURAL;
+
+    // Qualifiers known to not have values; prepare a Hashtable
+    static final String[] NOVALS = { "ABSTRACT", "STRUCTURAL",
+                                     "AUXILIARY", "OBSOLETE" };
+    static {
+        for( int i = 0; i < NOVALS.length; i++ ) {
+            novalsTable.put( NOVALS[i], NOVALS[i] );
+        }
+    }
+
+    // Qualifiers which we output explicitly in toString()
+    static final String[] IGNOREVALS = { "ABSTRACT", "STRUCTURAL",
+                                         "AUXILIARY", "MUST", "MAY",
+                                         "SUP", "OBSOLETE"};
+    // Key for type in the properties Hashtable
+    static final String TYPE = "TYPE";
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPUrl.java
@@ -0,0 +1,794 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+import java.net.MalformedURLException;
+
+/**
+ * Represents an LDAP URL. The complete specification for LDAP URLs is in
+ * <A HREF="http://ds.internic.net/rfc/rfc1959.txt"
+ * TARGET="_blank">RFC 1959</A>. In addition, the secure ldap (ldaps://) is also
+ * supported. LDAP URLs have the following format:
+ *
+ * <PRE>
+ * "ldap[s]://" [ <I>hostName</I> [":" <I>portNumber</I>] ] "/"
+ *                      <I>distinguishedName</I>
+ *          ["?" <I>attributeList</I> ["?" <I>scope</I>
+ *                      "?" <I>filterString</I> ] ]
+ * </PRE>
+ * where
+ * <P>
+ * <UL>
+ * <LI>all text within double-quotes are literal<P>
+ * <LI><CODE><I>hostName</I></CODE> and <CODE><I>portNumber</I></CODE>
+ * identify the location of the LDAP server.<P>
+ * <LI><CODE><I>distinguishedName</I></CODE> is the name of an entry
+ * within the given directory (the entry represents the starting point
+ * of the search)<P>
+ * <LI><CODE><I>attributeList</I></CODE> contains a list of attributes
+ * to retrieve (if null, fetch all attributes). This is a comma-delimited
+ * list of attribute names.<P>
+ * <LI><CODE><I>scope</I></CODE> is one of the following:
+ * <UL>
+ * <LI><CODE>base</CODE> indicates that this is a search only for the
+ * specified entry
+ * <LI><CODE>one</CODE> indicates that this is a search for matching entries
+ * one level under the specified entry (and not including the entry itself)
+ * <LI><CODE>sub</CODE> indicates that this is a search for matching entries
+ * at all levels under the specified entry (including the entry itself)
+ * </UL>
+ * <P>
+ * If not specified, <CODE><I>scope</I></CODE> is <CODE>base</CODE> by
+ * default. <P>
+ * <LI><CODE><I>filterString</I></CODE> is a human-readable representation
+ * of the search criteria. This value is used only for one-level or subtree
+ * searches.<P>
+ * </UL>
+ * <P>
+ * Note that if <CODE><I>scope</I></CODE> and <CODE><I>filterString</I></CODE>
+ * are not specified, an LDAP URL identifies exactly one entry in the
+ * directory. <P>
+ * The same encoding rules for other URLs (e.g. HTTP) apply for LDAP
+ * URLs.  Specifically, any "illegal" characters are escaped with
+ * <CODE>%<I>HH</I></CODE>, where <CODE><I>HH</I></CODE> represent the
+ * two hex digits which correspond to the ASCII value of the character.
+ * This encoding is only legal (or necessary) on the DN and filter portions
+ * of the URL.
+ *
+ * @version 1.0
+ */
+public class LDAPUrl implements java.io.Serializable {
+
+    static final long serialVersionUID = -3245440798565713641L;
+    public static String defaultFilter = "(objectClass=*)";
+
+    private String m_hostName;
+    private int m_portNumber;
+    private String m_DN;
+    private Vector m_attributes;
+    private int m_scope;
+    private String m_filter;
+    private String m_URL;
+    private boolean m_secure;
+    
+    private static LDAPSocketFactory m_factory;
+
+    /**
+     * The default port number for secure LDAP connections.
+     * @see netscape.ldap.LDAPUrl#LDAPUrl(java.lang.String, int, java.lang.String, java.lang.String[], int, java.lang.String, boolean)
+     */    
+    public static final int DEFAULT_SECURE_PORT = 636;
+
+    /**
+     * Constructs a URL object with the specified string as URL.
+     * @param url LDAP search expression in URL form
+     * @exception MalformedURLException failed to parse URL
+     */
+    public LDAPUrl (String url) throws java.net.MalformedURLException {
+        m_attributes = null;
+        m_scope = LDAPv2.SCOPE_BASE;
+        m_filter = defaultFilter;
+        m_URL = url;
+
+        parseUrl(url);
+    }
+
+    /**
+     * Parse URL as defined in RFC 1959. Beyond the RFC, the secure ldap
+     * (ldaps) is also supported.
+     */
+    private void parseUrl(String url) throws MalformedURLException {
+        StringTokenizer urlParser = new StringTokenizer (url, ":/?", true);
+        String currentToken;
+        String str = null;
+
+        try {
+            currentToken = urlParser.nextToken();
+            if (currentToken.equalsIgnoreCase ("LDAPS")) {
+                m_secure = true;
+            }
+            else if (!currentToken.equalsIgnoreCase ("LDAP")) {
+                throw new MalformedURLException ();
+            }
+
+            currentToken = urlParser.nextToken();
+            if (!currentToken.equals(":")) {
+                throw new MalformedURLException ();
+            }
+            currentToken = urlParser.nextToken();
+            if (!currentToken.equals("/")) {
+                throw new MalformedURLException ();
+            }
+            currentToken = urlParser.nextToken();
+            if (!currentToken.equals("/")) {
+                throw new MalformedURLException ();
+            }
+        
+            currentToken = urlParser.nextToken();
+        }
+        catch (NoSuchElementException e) {
+            throw new MalformedURLException ();
+        }
+            
+        // host-port
+        if (currentToken.equals ("/")) {
+            m_hostName = null;
+            m_portNumber = m_secure ? DEFAULT_SECURE_PORT : LDAPv2.DEFAULT_PORT;
+        } else if (currentToken.equals (":")) {
+                // port number without host name is not allowed
+               throw new MalformedURLException ("No hostname");
+        } else if (currentToken.equals ("?")) {
+            throw new MalformedURLException ("No host[:port]");
+        } else {
+            m_hostName = currentToken;
+            if (urlParser.countTokens() == 0) {
+                m_portNumber = m_secure ? DEFAULT_SECURE_PORT : LDAPv2.DEFAULT_PORT;
+                return;
+            }
+            currentToken = urlParser.nextToken (); // either ":" or "/"
+
+            if (currentToken.equals (":")) {
+                try {
+                    m_portNumber = Integer.parseInt (urlParser.nextToken());
+                } catch (NumberFormatException nf) {
+                    throw new MalformedURLException ("Port not a number");
+                } catch (NoSuchElementException ex) {
+                    throw new MalformedURLException ("No port number");
+                }
+                    
+                if (urlParser.countTokens() == 0) {
+                    return;
+                }
+                else if (! urlParser.nextToken().equals("/")) {
+                   throw new MalformedURLException ();
+                }
+
+            } else if (currentToken.equals ("/")) {
+                m_portNumber = m_secure ? DEFAULT_SECURE_PORT : LDAPv2.DEFAULT_PORT;
+            } else {
+                // expecting ":" or "/"
+                throw new MalformedURLException ();
+            }
+        }
+
+
+        // DN
+        if (!urlParser.hasMoreTokens ()) {
+            return;
+        }
+        m_DN = decode(readNextConstruct(urlParser));
+        if (m_DN.equals("?")) {
+            m_DN = "";
+        }
+        else if (m_DN.equals("/")) {
+            throw new MalformedURLException ();
+        }            
+            
+        // attribute
+        if (!urlParser.hasMoreTokens ()) {
+            return;
+        }        
+        str = readNextConstruct(urlParser);
+        if (!str.equals("?")) {
+            StringTokenizer attributeParser = new
+                StringTokenizer (decode(str), ", ");
+            m_attributes = new Vector ();
+
+            while (attributeParser.hasMoreTokens()) {
+                m_attributes.addElement (attributeParser.nextToken());
+            }
+        }
+
+        // scope
+        if (!urlParser.hasMoreTokens ()) {
+            return;
+        }
+        str = readNextConstruct(urlParser);
+        if (!str.equals("?")) {
+            m_scope = getScope(str);
+            if (m_scope < 0) {
+                throw new MalformedURLException("Bad scope:" + str);
+            }
+        }
+
+        // filter
+        if (!urlParser.hasMoreTokens ()) {
+            return;
+        }
+        str = readNextConstruct(urlParser);
+        m_filter = decode(str);
+        checkBalancedParentheses(m_filter);
+        if (!m_filter.startsWith("(") && !m_filter.endsWith(")")) {
+            m_filter = "(" + m_filter + ")";
+        }
+
+        // Nothing after the filter is allowed
+        if (urlParser.hasMoreTokens()) {
+            throw new MalformedURLException();
+        }
+    }    
+    
+    private void checkBalancedParentheses(String filter) throws MalformedURLException {
+        int parenCnt =0;
+        StringTokenizer filterParser = new StringTokenizer (filter, "()", true);
+        while (filterParser.hasMoreElements()) {
+            String token = filterParser.nextToken();
+            if (token.equals("(")) {
+                parenCnt++;
+            }
+            else if (token.equals(")")) {
+                if (--parenCnt < 0) {
+                    throw new MalformedURLException("Unbalanced filter parentheses");
+                }
+            }
+        }
+        
+        if (parenCnt != 0) {
+            throw new MalformedURLException("Unbalanced filter parentheses");
+        }
+    }
+        
+    /**
+     * Constructs with the specified host, port, and DN.  This form is used to
+     * create URL references to a particular object in the directory.
+     * @param host host name of the LDAP server, or null for "nearest X.500/LDAP"
+     * @param port port number of the LDAP server (use LDAPv2.DEFAULT_PORT for
+     * the default port)
+     * @param DN distinguished name of the object
+     */
+    public LDAPUrl (String host, int port, String DN) {
+        initialize(host, port, DN, null, LDAPv2.SCOPE_BASE, defaultFilter, false);
+    }
+
+    /**
+     * Constructs a full-blown LDAP URL to specify an LDAP search operation.
+     * @param host host name of the LDAP server, or null for "nearest X.500/LDAP"
+     * @param port port number of the LDAP server (use LDAPv2.DEFAULT_PORT for
+     * the default port)
+     * @param DN distinguished name of the object
+     * @param attributes list of attributes to return. Use null for "all
+     * attributes."
+     * @param scope depth of search (in DN namespace). Use one of the LDAPv2 scopes:
+     * SCOPE_BASE, SCOPE_ONE, or SCOPE_SUB.
+     * @param filter LDAP filter string (as defined in RFC 1558). Use null for
+     * no filter (this effectively makes the URL reference a single object).
+     */
+    public LDAPUrl (String host, int port, String DN,
+        String attributes[], int scope, String filter) {
+
+        this(host, port, DN, attributes, scope, filter, false);
+    }
+
+    /**
+     * Constructs a full-blown LDAP URL to specify an LDAP search operation.
+     * @param host host name of the LDAP server, or null for "nearest X.500/LDAP"
+     * @param port port number of the LDAP server (use LDAPv2.DEFAULT_PORT for
+     * the default port)
+     * @param DN distinguished name of the object
+     * @param attributes list of the attributes to return. Use null for "all
+     * attributes."
+     * @param scope depth of the search (in DN namespace). Use one of the LDAPv2 scopes: 
+     * SCOPE_BASE, SCOPE_ONE, or SCOPE_SUB.
+     * @param filter LDAP filter string (as defined in RFC 1558). Use null for
+     * no filter (this effectively makes the URL reference a single object).
+     */
+    public LDAPUrl (String host, int port, String DN,
+      Enumeration attributes, int scope, String filter) {
+
+        initialize(host, port, DN, attributes, scope, filter, false);
+    }
+
+    /**
+     * Constructs a full-blown LDAP URL to specify an LDAP search operation.
+     * @param host host name of the LDAP server, or null for "nearest X.500/LDAP"
+     * @param port port number of the LDAP server (use LDAPv2.DEFAULT_PORT for
+     * the default non-secure port or LDAPUrl.DEFAULT_SECURE_PORT for the default
+     * secure port)
+     * @param DN distinguished name of the object
+     * @param attributes list of the attributes to return. Use null for "all
+     * attributes."
+     * @param scope depth of the search (in DN namespace). Use one of the LDAPv2 scopes: 
+     * SCOPE_BASE, SCOPE_ONE, or SCOPE_SUB.
+     * @param filter LDAP filter string (as defined in RFC 1558). Use null for
+     * no filter (this effectively makes the URL reference a single object).
+     * @param secure flag if secure ldap protocol (ldaps) is to be used.
+     */
+    public LDAPUrl (String host, int port, String DN,
+      String[] attributes, int scope, String filter, boolean secure) {
+
+        if (attributes != null) {
+            Vector list = new Vector();
+            for (int k = 0; k < attributes.length; k++) {
+                list.addElement(attributes[k]);
+            }
+            initialize(host, port, DN, list.elements(), scope, filter, secure);
+        } else {
+            initialize(host, port, DN, null, scope, filter, secure);
+        }
+    }
+
+
+    /**
+     * Initializes URL object.
+     */
+    private void initialize (String host, int port, String DN,
+      Enumeration attributes, int scope, String filter, boolean secure) {
+
+        m_hostName = host;
+        m_DN = DN;
+        m_portNumber = port;
+        m_filter = (filter != null) ? filter : defaultFilter;
+        m_scope = scope;
+        m_secure = secure;
+
+        if (attributes != null) {
+            m_attributes = new Vector ();
+            while (attributes.hasMoreElements()) {
+                m_attributes.addElement (attributes.nextElement());
+            }
+        } else
+            m_attributes = null;
+
+        StringBuffer url = new StringBuffer (secure ? "ldaps://" :"ldap://");
+
+        if (host != null) {
+            url.append (host);
+            url.append (':');
+            url.append (String.valueOf (port));
+        }
+
+        url.append ('/');
+        url.append (encode (DN));
+
+        if (attributes != null) {
+            url.append ('?');
+            Enumeration attrList = m_attributes.elements();
+            boolean firstElement = true;
+
+            while (attrList.hasMoreElements()) {
+                if (!firstElement)
+                    url.append (',');
+                else
+                    firstElement = false;
+
+                url.append ((String)attrList.nextElement());
+            }
+        }
+
+        if (filter != null) {
+            if (attributes == null)
+                url.append ('?');
+
+            url.append ('?');
+
+            switch (scope) {
+              default:
+              case LDAPv2.SCOPE_BASE:
+                url.append ("base"); break;
+              case LDAPv2.SCOPE_ONE:
+                url.append ("one"); break;
+              case LDAPv2.SCOPE_SUB:
+                url.append ("sub"); break;
+            }
+
+            url.append ('?');
+            url.append (filter);
+        }
+
+        m_URL = url.toString();
+    }
+
+    /**
+     * Return the host name of the LDAP server
+     * @return LDAP host.
+     */
+    public String getHost () {
+        return m_hostName;
+    }
+
+    /**
+     * Return the port number for the LDAP server
+     * @return port number.
+     */
+    public int getPort () {
+        return m_portNumber;
+    }
+
+    /**
+     * Return the distinguished name encapsulated in the URL
+     * @return target distinguished name.
+     */
+    public String getDN () {
+        return m_DN;
+    }
+
+    /**
+     * Return the server part of the ldap url, ldap://host:port
+     * @return server url.
+     */
+    String getServerUrl() {
+        return (m_secure ? "ldaps://" : "ldap://") +
+                m_hostName + ":" + m_portNumber;
+    }
+
+    /**
+     * Return the collection of attributes specified in the URL, or null
+     * for "every attribute"
+     * @return enumeration of attributes.
+     */
+    public Enumeration getAttributes () {
+        if (m_attributes == null)
+            return null;
+        else
+            return m_attributes.elements();
+    }
+
+    /**
+     * Return the collection of attributes specified in the URL, or null
+     * for "every attribute"
+     * @return string array of attributes.
+     */
+    public String[] getAttributeArray () {
+        if (m_attributes == null)
+            return null;
+        else {
+            String[] attrNames = new String[m_attributes.size()];
+            Enumeration attrs = getAttributes();
+            int i = 0;
+
+            while (attrs.hasMoreElements())
+                attrNames[i++] = (String)attrs.nextElement();
+
+            return attrNames;
+        }
+    }
+
+    /**
+     * Returns the scope of the search, according to the values
+     * SCOPE_BASE, SCOPE_ONE, SCOPE_SUB as defined in LDAPv2.  This refers
+     * to how deep within the directory namespace the search will look
+     * @return search scope.
+     */
+    public int getScope () {
+        return m_scope;
+    }
+
+    /**
+     * Returns the scope of the search. If the scope returned is -1, then
+     * the given string is not for the scope.
+     * @param str the string against which to compare the scope type
+     * @returns the scope of the search, -1 is returned if the given string is
+     * not SUB, ONE or BASE (the acceptable LDAPv2 values for scope).
+     */
+    private int getScope(String str) {
+
+        int s = -1;
+        if (str.equalsIgnoreCase("base"))
+            s = LDAPv2.SCOPE_BASE;
+        else if (str.equalsIgnoreCase("one"))
+            s = LDAPv2.SCOPE_ONE;
+        else if (str.equalsIgnoreCase("sub"))
+            s = LDAPv2.SCOPE_SUB;
+
+        return s;
+    }
+
+    /**
+     * Returns the search filter (RFC 1558), or the default if none was
+     * specified.
+     * @return the search filter.
+     */
+    public String getFilter () {
+        return m_filter;
+    }
+
+    /**
+     * Returns a valid string representation of this LDAP URL.
+     * @return the LDAP search expression in URL form.
+     */
+    public String getUrl () {
+        return m_URL;
+    }
+
+    /**
+     * Returns true if the secure ldap protocol is used.
+     * @return true if ldaps is used.
+     */
+    public boolean isSecure() {
+        return m_secure;
+    }
+
+    /**
+     * Gets the socket factory to be used for ldaps:// URLs.
+     * <P>
+     * If the factory is not explicitly specified with
+     * <CODE>LDAPUrl.setSocketFactory</CODE>, the method will
+     * attempt the determine the default factory based on the
+     * available factories in the netscape.ldap.factory package.
+     *
+     * @return the socket factory to be used for ldaps:// URLs
+     */
+    public static LDAPSocketFactory getSocketFactory() {
+
+        if (m_factory == null) {
+
+            // No factory explicitly set, try to determine
+            // the default one.
+            try {
+                //  First try Mozilla JSSSocketFactory
+                Class c = Class.forName("netscape.ldap.factory.JSSSocketFactory");
+                m_factory = (LDAPSocketFactory) c.newInstance();
+            }
+            catch (Throwable e) {
+            }
+
+            if (m_factory != null) {
+                return m_factory;
+            }
+
+            try {
+                // then try Sun JSSESocketFactory
+                Class c = Class.forName("netscape.ldap.factory.JSSESocketFactory");
+                m_factory = (LDAPSocketFactory) c.newInstance();
+            }
+            catch (Throwable e) {
+            }
+        }
+
+        return m_factory;
+    }
+
+    /**
+     * Sets the socket factory to be used for ldaps:// URLs.
+     * Overrides the default factory assigned by the LDAPUrl
+     * class.
+     * @param factory the socket factory to be used for ldaps:// URLs
+     * @see netscape.ldap.LDAPUrl#getSocketFactory
+     */
+    public static void setSocketFactory(LDAPSocketFactory factory) {
+        m_factory = factory;
+    }
+            
+    /**
+     * Reads next construct from the given string parser.
+     * @param parser the string parser
+     * @return the next construct which can be an attribute, scope or filter.
+     * @exception java.net.MalformedURLException Get thrown when the url format
+     *            is incorrect.
+     */
+    private String readNextConstruct(StringTokenizer parser) throws
+        MalformedURLException {
+
+        try {
+            if (parser.hasMoreTokens()) {
+                String tkn = parser.nextToken();
+                if (tkn.equals("?")) { // empty construct
+                    return tkn;
+                }
+                else if (parser.hasMoreTokens()){
+                    // Remove '?' delimiter
+                    String delim = parser.nextToken();
+                    if (!delim.equals("?")) {
+                        throw new MalformedURLException();
+                    }
+                }
+                
+                return tkn;
+            }
+        } catch (NoSuchElementException e) {
+            throw new MalformedURLException();
+        }
+
+        return null;
+    }
+
+    /**
+     * Parses hex character into integer.
+     */
+    private static int hexValue (char hexChar) throws MalformedURLException {
+        if (hexChar >= '0' && hexChar <= '9')
+            return hexChar - '0';
+        if (hexChar >= 'A' && hexChar <= 'F')
+            return hexChar - 'A' + 10;
+        if (hexChar >= 'a' && hexChar <= 'f')
+            return hexChar - 'a' + 10;
+
+        throw new MalformedURLException ();
+    }
+
+    private static char hexChar (int hexValue) {
+        if (hexValue < 0 || hexValue > 0xF)
+            return 'x';
+
+        if (hexValue < 10)
+            return (char)(hexValue + '0');
+
+        return (char)((hexValue - 10) + 'a');
+    }
+
+    /**
+     * Decodes a URL-encoded string. Any occurences of %HH are decoded to the
+     * hex value represented.  However, this routine does NOT decode "+"
+     * into " ". See RFC 1738 for full details about URL encoding/decoding.
+     * @param URLEncoded a segment of a URL which was encoded using the URL
+     * encoding rules
+     * @exception MalformedURLException failed to parse URL
+     */
+    public static String decode (String URLEncoded) throws
+        MalformedURLException {
+        StringBuffer decoded = new StringBuffer (URLEncoded);
+        int srcPos = 0, dstPos = 0;
+
+        try {
+            while (srcPos < decoded.length()) {
+                if (decoded.charAt (srcPos) != '%') {
+                    if (srcPos != dstPos)
+                        decoded.setCharAt (dstPos, decoded.charAt (srcPos));
+                    srcPos++;
+                    dstPos++;
+                    continue;
+                }
+                decoded.setCharAt (dstPos, (char)
+                  ((hexValue(decoded.charAt (srcPos+1))<<4) |
+                  (hexValue(decoded.charAt (srcPos+2)))));
+                dstPos++;
+                srcPos += 3;
+            }
+        } catch (StringIndexOutOfBoundsException sioob) {
+            // Indicates that a "%" character occured without the following HH
+            throw new MalformedURLException ();
+        }
+
+        /* 070497 Url problems submitted by Netscape */
+        /* decoded.setLength (dstPos+1); */
+        decoded.setLength (dstPos);
+        return decoded.toString ();
+    }
+
+    /**
+     * Encodes an arbitrary string. Any illegal characters are encoded as
+     * %HH.  However, this routine does NOT decode "+" into " " (this is a HTTP
+     * thing, not a general URL thing).  Note that, because Sun's URLEncoder
+     * does do this encoding, we can't use it.
+     * See RFC 1738 for full details about URL encoding/decoding.
+     * @param toEncode an arbitrary string to encode for embedding within a URL
+     */
+    public static String encode (String toEncode) {
+      StringBuffer encoded = new StringBuffer (toEncode.length()+10);
+
+        for (int currPos = 0; currPos < toEncode.length(); currPos++) {
+            char currChar = toEncode.charAt (currPos);
+            if ((currChar >= 'a' && currChar <= 'z') ||
+              (currChar >= 'A' && currChar <= 'Z') ||
+              (currChar >= '0' && currChar <= '9') ||
+              ("$-_.+!*'(),".indexOf (currChar) > 0)) {
+                // this is the criteria for "doesn't need to be encoded" (whew!)
+                encoded.append (currChar);
+            } else {
+                encoded.append ("%");
+                encoded.append (hexChar ((currChar & 0xF0) >> 4));
+                encoded.append (hexChar (currChar & 0x0F));
+            }
+        }
+
+        return encoded.toString();
+    }
+
+    /**
+     * Returns the URL in String format
+     *
+     * @return the URL in String format
+     */
+    public String toString() {
+        return getUrl();
+    }
+
+    /**
+     * Reports if the two objects represent the same URL
+     *
+     * @param url the object to be compared to
+     * @return <CODE>true</CODE> if the two are equivalent
+     */
+    public boolean equals( LDAPUrl url ) {
+        if ( getHost() == null ) {
+            if ( url.getHost() != null ) {
+                return false;
+            }
+        } else if ( !getHost().equals( url.getHost() ) ) {
+            return false;
+        }
+        if ( getPort() != url.getPort() ) {
+            return false;
+        }
+        if ( getDN() == null ) {
+            if ( url.getDN() != null ) {
+                return false;
+            }
+        } else if ( !getDN().equals( url.getDN() ) ) {
+            return false;
+        }
+        if ( getFilter() == null ) {
+            if ( url.getFilter() != null ) {
+                return false;
+            }
+        } else if ( !getFilter().equals( url.getFilter() ) ) {
+            return false;
+        }
+        if ( getScope() != url.getScope() ) {
+            return false;
+        }
+
+        if ( m_attributes == null ) {
+            if ( url.m_attributes != null ) {
+                return false;
+            }
+        } else if ( m_attributes.size() != url.m_attributes.size() ) {
+            return false;
+        } else {
+            for( int i = 0; i < m_attributes.size(); i++ ) {
+                if ( m_attributes.elementAt( i ) !=
+                     url.m_attributes.elementAt( i ) ) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSSLSocketFactoryExt.java
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * Represents an SSL socket connection that you can use to connect to an
+ * LDAP server. This interface extends the base interface LDAPSocketFactory 
+ * and provides SSL-specific methods.
+ * <P>
+ *
+ * @version 1.0
+ * @see LDAPSocketFactory
+ * @see LDAPConnection#LDAPConnection(netscape.ldap.LDAPSocketFactory)
+ */
+public interface LDAPSSLSocketFactoryExt extends LDAPSocketFactory {
+
+    /**
+     * Returns the suite of ciphers used for SSL connections. These connections 
+     * are made through sockets created by the LDAPSSLSocketFactory.
+     *
+     * @return the suite of ciphers used.
+     */
+    public Object getCipherSuites();
+    
+    /**
+     * Returns <code>true</code> if client authentication is enabled.
+     * @see netscape.ldap.LDAPSSLSocketFactory#enableClientAuth
+     */
+    public boolean isClientAuth();
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPBind.java
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * Performs explicit bind processing on a referral. A client may
+ * specify an instance of this class for use on a single operation
+ * (through the <CODE>LDAPConstraints</CODE> object) or all operations 
+ * (through <CODE>LDAPConnection.setOption()</CODE>). It is typically used
+ * to control the authentication mechanism used on implicit referral 
+ * handling.
+ */
+
+public interface LDAPBind {
+
+    /**
+     * This method is called by <CODE>LDAPConnection</CODE> when 
+     * authenticating. An implementation of <CODE>LDAPBind</CODE> may access 
+     * the host, port, credentials, and other information in the 
+     * <CODE>LDAPConnection</CODE> in order to decide on an appropriate 
+     * authentication mechanism.<BR> 
+     * The bind method can also interact with a user or external module. 
+     * @exception netscape.ldap.LDAPException
+     * @see netscape.ldap.LDAPConnection#bind
+     * @param conn an established connection to an LDAP server
+     */
+
+    public void bind(LDAPConnection conn) throws LDAPException;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSocketFactory.java
@@ -0,0 +1,75 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * Represents a socket connection that you can use to connect to an
+ * LDAP server.  You can write a class that implements this interface
+ * if you want to use a TLS socket to connect to a secure server.
+ * (The <CODE>LDAPSSLSocketFactory class</CODE>, which is included
+ * in the <CODE>netscape.ldap</CODE> package, implements this
+ * interface for SSL connections.)
+ * <P>
+ *
+ * When you construct a new <CODE>LDAPConnection</CODE>
+ * object, you can specify that the connection use this socket. 
+ * To do this, pass the constructor an object of the class that 
+ * implements this interface.
+ * <P>
+ *
+ * @version 1.0
+ * @see LDAPConnection#LDAPConnection(netscape.ldap.LDAPSocketFactory)
+ * @see LDAPSSLSocketFactory
+ */
+public interface LDAPSocketFactory {
+    /**
+     * Returns a socket to the specified host name and port number.
+     * <P>
+     *
+     * @param host name of the host to which you want to connect
+     * @param port port number to which you want to connect
+     * @exception LDAPException Failed to create the socket.
+     * @see LDAPSSLSocketFactory#makeSocket(java.lang.String,int)
+     */
+    public Socket makeSocket(String host, int port)
+        throws LDAPException;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSearchResults.java
@@ -0,0 +1,592 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.client.opers.*;
+import java.io.*;
+
+/**
+ * The results of an LDAP search operation, represented as an enumeration.
+ * Note that you can only iterate through this enumeration once: if you
+ * need to use these results more than once, make sure to save the
+ * results in a separate location.
+ * <P>
+ *
+ * You can also use the results of a search in progress to abandon that search
+ * operation.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean)
+ * @see netscape.ldap.LDAPConnection#abandon(netscape.ldap.LDAPSearchResults)
+ */
+public class LDAPSearchResults implements Enumeration, java.io.Serializable {
+
+    static final long serialVersionUID = -501692208613904825L;
+    private Vector entries = null;
+    private LDAPSearchListener resultSource;
+    private boolean searchComplete = false;
+    private LDAPConnection connectionToClose;
+    private LDAPConnection currConn;
+    private boolean persistentSearch = false;
+    private LDAPSearchConstraints currCons;
+    private String currBase;
+    private int currScope;
+    private String currFilter;
+    private String[] currAttrs;
+    private boolean currAttrsOnly;
+    private Vector referralResults = new Vector();
+    private Vector exceptions;
+    private int msgID = -1;
+
+    // only used for the persistent search
+    private boolean firstResult = false;
+
+    /**
+     * Constructs an enumeration of search results.
+     * Note that this does not actually generate the results;
+     * you need to call <CODE>LDAPConnection.search</CODE> to
+     * perform the search and get the results.
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean)
+     */
+    public LDAPSearchResults() {
+        entries = new Vector();
+        connectionToClose = null;
+        searchComplete = true;
+        currCons = new LDAPSearchConstraints();
+    }
+
+    LDAPSearchResults(LDAPConnection conn, LDAPSearchConstraints cons,
+      String base, int scope, String filter, String[] attrs, boolean attrsOnly) {
+        this();
+        currConn = conn;
+        currCons = cons;
+        currBase = base;
+        currScope = scope;
+        currFilter = filter;
+        currAttrs = attrs;
+        currAttrsOnly = attrsOnly;
+    }
+
+    /**
+     * Constructs an enumeration of search results. Used when returning results
+     * from a cache.
+     * @param v the vector containing LDAPEntries
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean)
+     */
+    LDAPSearchResults(Vector v) {
+        this();
+        entries = (Vector)v.clone();
+
+        if ((entries != null) && (entries.size() >= 1)) {
+            // Each cache value is represented by a vector. The first element
+            // represents the size of all the LDAPEntries. This needs to be
+            // removed before we iterate through each LDAPEntry.
+            entries.removeElementAt(0);
+        }
+    }
+
+    LDAPSearchResults(Vector v, LDAPConnection conn,
+                      LDAPSearchConstraints cons,
+                      String base, int scope, String filter,
+                      String[] attrs, boolean attrsOnly) {
+        this(v);
+        currConn = conn;
+        currCons = cons;
+        currBase = base;
+        currScope = scope;
+        currFilter = filter;
+        currAttrs = attrs;
+        currAttrsOnly = attrsOnly;
+    }
+
+    /**
+     * Add search entry of referral
+     * @param msg LDAPSearchResult or LDAPsearchResultReference
+     */
+    void add( LDAPMessage msg ) {
+        if (msg instanceof LDAPSearchResult) {
+            entries.addElement( ((LDAPSearchResult)msg).getEntry());
+        } else if (msg instanceof LDAPSearchResultReference) {
+            /* convert to LDAPReferralException */
+            String urls[] = ((LDAPSearchResultReference)msg).getUrls();
+            if (urls != null) {
+                if (exceptions == null) {
+                    exceptions = new Vector();
+                }                    
+                exceptions.addElement(new LDAPReferralException(null, 0, urls));
+            }
+        }            
+    }
+
+    /**
+     * Add exception
+     * @param e exception
+     */
+    void add(LDAPException e) {
+        if (exceptions == null) {
+            exceptions = new Vector();
+        }
+        exceptions.addElement(e);
+    }
+
+    /**
+     * Prepares to return asynchronous results from a search
+     * @param l Listener which will provide results
+     */
+    void associate( LDAPSearchListener l) {
+        resultSource = l;
+        searchComplete = false;
+    }
+
+    void associatePersistentSearch( LDAPSearchListener l) {
+        resultSource = l;
+        persistentSearch = true;
+        searchComplete = false;
+        firstResult = true;
+    }
+
+    void addReferralEntries(LDAPSearchResults res) {
+        referralResults.addElement(res);
+    }
+
+    /**
+     * For asynchronous search, this mechanism allows the programmer to
+     * close a connection whenever the search completes.
+     * @param toClose connection to close when the search terminates
+     */
+    void closeOnCompletion (LDAPConnection toClose) {
+        if (searchComplete) {
+            try {
+                toClose.disconnect();
+            } catch (LDAPException e) {
+            }
+        } else {
+            connectionToClose = toClose;
+        }
+    }
+
+
+    /**
+     * Basic quicksort algorithm.
+     */
+    void quicksort (LDAPEntry[] toSort, LDAPEntryComparator compare,
+                     int low, int high) {
+        if (low >= high) {
+            return;
+        }
+
+        LDAPEntry pivot = toSort[low];
+        int slow = low-1, shigh = high+1;
+
+        while (true) {
+            do {
+                shigh--;
+            } while (compare.isGreater (toSort[shigh], pivot));
+            do {
+                slow++;
+            } while (compare.isGreater (pivot, toSort[slow]));
+
+            if (slow >= shigh) {
+                 break;
+            }
+
+             LDAPEntry temp = toSort[slow];
+             toSort[slow] = toSort[shigh];
+             toSort[shigh] = temp;
+        }
+
+        quicksort (toSort, compare, low, shigh);
+        quicksort (toSort, compare, shigh+1, high);
+    }
+
+    /**
+     * Sets the message ID for this search request. msgID is used
+     * to retrieve response controls.
+     * @param msgID Message ID for this search request
+     */
+    void setMsgID(int msgID) {
+        this.msgID = msgID;
+    }
+    
+    /**
+     * Returns the controls returned with this search result. If any control
+     * is registered with <CODE>LDAPControl</CODE>, an attempt is made to
+     * instantiate the control. If the instantiation fails, the control is
+     * returned as a basic <CODE>LDAPControl</CODE>.
+     * @return an array of type <CODE>LDAPControl</CODE>.
+     * @see netscape.ldap.LDAPControl#register
+     */
+    public LDAPControl[] getResponseControls() {
+        return currConn.getResponseControls(msgID);
+    }
+
+    /**
+     * Sorts the search results.
+     * <P>
+     *
+     * The comparator (<CODE>LDAPEntryComparator</CODE>) determines the
+     * sort order used.  For example, if the comparator uses the <CODE>uid</CODE>
+     * attribute for comparison, the search results are sorted according to
+     * <CODE>uid</CODE>.
+     * <P>
+     *
+     * The following section of code sorts results in ascending order,
+     * first by surname and then by common name.
+     *
+     * <PRE>
+     * String[]  sortAttrs = {"sn", "cn"};
+     * boolean[] ascending = {true, true};
+     *
+     * LDAPConnection ld = new LDAPConnection();
+     * ld.connect( ... );
+     * LDAPSearchResults res = ld.search( ... );
+     * res.sort( new LDAPCompareAttrNames(sortAttrs, ascending) );
+     * </PRE>
+     * NOTE: If the search results arrive asynchronously, the <CODE>sort</CODE>
+     * method blocks until all the results are returned.
+     * <P>
+     *
+     * If some of the elements of the Enumeration have already been fetched,
+     * the cursor is reset to the (new) first element.
+     * <P>
+     *
+     * @param compare comparator used to determine the sort order of the results
+     * @see LDAPEntryComparator
+     */
+    public synchronized void sort(LDAPEntryComparator compare) {
+        while (!searchComplete) {
+            fetchResult();
+        }
+
+        // if automatic referral, then add to the entries, otherwise, dont do it
+        // since the elements in referralResults are LDAPReferralException.
+        if (currCons.getReferrals()) {
+            while (referralResults.size() > 0) {
+                Object obj = null;
+                if ((obj=nextReferralElement()) != null) {
+                    if (obj instanceof LDAPException) {
+                        add((LDAPException)obj); // put it back
+                    }                    
+                    else {
+                        entries.addElement(obj);                      
+                    }
+                }
+            }
+        }
+
+        int numEntries = entries.size();
+        if (numEntries <= 0) {
+            return;
+        }
+
+        LDAPEntry[] toSort = new LDAPEntry[numEntries];
+        entries.copyInto (toSort);
+
+        if (toSort.length > 1) {
+            quicksort (toSort, compare, 0, numEntries-1);
+        }
+
+        entries.removeAllElements();
+        for (int i = 0; i < numEntries; i++) {
+            entries.addElement (toSort[i]);
+        }
+    }
+
+    /**
+     * Returns the next LDAP entry from the search results
+     * and throws an exception if the next result is a referral, or 
+     * if a sizelimit or timelimit error occurred.
+     * <P>
+     *
+     * You can use this method in conjunction with the
+     * <CODE>hasMoreElements</CODE> method to iterate through
+     * each entry in the search results.  For example:
+     * <PRE>
+     * LDAPSearchResults res = ld.search( MY_SEARCHBASE,
+     *                         LDAPConnection.SCOPE_BASE, MY_FILTER,
+     *                         null, false );
+     * while ( res.hasMoreElements() ) {
+     *   try {
+     *     LDAPEntry findEntry = res.next();
+     *   } catch ( LDAPReferralException e ) {
+     *     LDAPUrl refUrls[] = e.getURLs();
+     *     for ( int i = 0; i < refUrls.length; i++ ) {
+     *     // Your code for handling referrals
+     *     }
+     *     continue;
+     *   } catch ( LDAPException e ) {
+     *     // Your code for handling errors on limits exceeded 
+     *     continue; 
+     *   } 
+     *   ...
+     * }
+     * </PRE>
+     * @return the next LDAP entry in the search results.
+     * @exception LDAPReferralException A referral (thrown
+     * if the next result is a referral), or LDAPException 
+     * if a limit on the number of entries or the time was 
+     * exceeded.
+     * @see netscape.ldap.LDAPSearchResults#hasMoreElements()
+     */
+    public LDAPEntry next() throws LDAPException {
+        Object o = nextElement();
+        if ((o instanceof LDAPReferralException) ||
+            (o instanceof LDAPException)) {
+            throw (LDAPException)o;
+        }
+        if (o instanceof LDAPEntry) {
+            return (LDAPEntry)o;
+        }
+        return null;
+    }
+
+    /**
+     * Returns the next result from a search.  You can use this method
+     * in conjunction with the <CODE>hasMoreElements</CODE> method to
+     * iterate through all elements in the search results.
+     * <P>
+     *
+     * Make sure to cast the
+     * returned element as the correct type.  For example:
+     * <PRE>
+     * LDAPSearchResults res = ld.search( MY_SEARCHBASE,
+     *                         LDAPConnection.SCOPE_BASE, MY_FILTER,
+     *                         null, false );
+     * while ( res.hasMoreElements() ) {
+     *   Object o = res.nextElement(); 
+     *   if ( o instanceof LDAPEntry ) { 
+     *     LDAPEntry findEntry = (LDAPEntry)o; 
+     *     ... 
+     *   } else if ( o instanceof LDAPReferralException ) { 
+     *     LDAPReferralException e = (LDAPReferralException)o; 
+     *     LDAPUrl refUrls[] = e.getURLs(); 
+     *     ... 
+     *   } else if ( o instanceof LDAPException ) { 
+     *     LDAPException e = (LDAPException)o; 
+     *     ... 
+     *   } 
+     * } 
+     * </PRE> 
+     * @return the next element in the search results.
+     * @see netscape.ldap.LDAPSearchResults#hasMoreElements()
+     */
+    public Object nextElement() {
+        if ( entries.size() > 0 ) {
+            Object obj = entries.elementAt(0);
+            entries.removeElementAt(0);
+            return obj;
+        }
+
+        if (referralResults.size() > 0) {
+            return nextReferralElement();
+        }
+
+        if ((exceptions != null) && (exceptions.size() > 0)) {
+            Object obj = exceptions.elementAt(0);
+            exceptions.removeElementAt(0);
+            return obj;
+        }
+
+        return null;
+    }
+
+    Object nextReferralElement() {
+        LDAPSearchResults res =
+          (LDAPSearchResults)referralResults.elementAt(0);
+        if ((!res.persistentSearch && res.hasMoreElements()) || 
+          (res.persistentSearch)) {
+            Object obj = res.nextElement();
+            if (obj != null) {
+                return obj;
+            }
+
+            if ((obj == null) || (!res.hasMoreElements())) {
+                referralResults.removeElementAt(0);
+            }
+        } else {
+            referralResults.removeElementAt(0);
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns <CODE>true</CODE> if there are more search results
+     * to be returned. You can use this method in conjunction with the
+     * <CODE>nextElement</CODE> or <CODE>next</CODE> methods to iterate
+     * through each entry in the results. For example:
+     * <PRE>
+     * LDAPSearchResults res = ld.search( MY_SEARCHBASE,
+     *                         LDAPConnection.SCOPE_BASE, MY_FILTER,
+     *                         null, false );
+     * while ( res.hasMoreElements() ) {
+     *   LDAPEntry findEntry = (LDAPEntry)res.nextElement();
+     *   ...
+     * }
+     * </PRE>
+     * @return <CODE>true</CODE> if there are more search results.
+     * @see netscape.ldap.LDAPSearchResults#nextElement()
+     * @see netscape.ldap.LDAPSearchResults#next()
+     */
+    public boolean hasMoreElements() {
+
+        while ((entries.size() == 0) && (!searchComplete)) {
+            fetchResult();
+        }
+
+        if ((entries.size() == 0) && 
+          ((exceptions == null) || (exceptions.size() == 0))) {
+            while (referralResults.size() > 0) {
+                LDAPSearchResults res =
+                  (LDAPSearchResults)referralResults.elementAt(0);
+                if (res.hasMoreElements())
+                    return true;
+                else
+                    referralResults.removeElementAt(0);
+            }
+        }
+
+        return ((entries.size() > 0) || 
+          ((exceptions != null) && (exceptions.size() > 0)));
+    }
+
+    /**
+     * Returns a count of queued search results immediately available for
+     * processing.
+     * A search result is either a search entry or an exception. If the
+     * search is asynchronous (batch size not 0), this reports the number
+     * of results received so far.
+     * @return count of search results immediatly available for processing
+     */
+    public int getCount() {
+
+        while (resultSource != null && resultSource.getMessageCount() > 0) {
+            fetchResult();
+        }
+
+        int count = entries.size();
+        
+        for ( int i = 0; i < referralResults.size(); i++ ) {
+            LDAPSearchResults res =
+                (LDAPSearchResults)referralResults.elementAt(i);
+            count += res.getCount();
+        } 
+
+        if ( exceptions != null ) {
+            count += exceptions.size();
+        } 
+
+        return count;
+    }
+
+    /**
+     * Returns message ID.
+     * @return Message ID.
+     */
+    int getMessageID() {
+        if ( resultSource == null ) {
+            return -1;
+        }
+        return resultSource.getMessageID();
+    }
+
+    /**
+     * Fetchs the next result, for asynchronous searches.
+     */
+    private synchronized void fetchResult() {
+
+        /* Asynchronous case */
+        if ( resultSource != null ) {
+            synchronized( this ) {
+                if (searchComplete || firstResult) {
+                    firstResult = false;
+                    return;
+                }
+
+                LDAPMessage msg = null;
+                try {
+                    msg = resultSource.nextMessage();
+                } catch (LDAPException e) {
+                    add(e);
+                    currConn.releaseSearchListener(resultSource);
+                    searchComplete = true;
+                    return;
+                }
+                    
+
+                if (msg == null) { // Request abandoned
+                    searchComplete = true;
+                    currConn.releaseSearchListener(resultSource); 
+                    return; 
+
+                } else if (msg instanceof LDAPResponse) {
+                    try {
+                        // check response and see if we need to do referral
+                        // v2: referral stored in the JDAPResult
+                        currConn.checkSearchMsg(this, msg, currCons,
+                                                currBase, currScope, currFilter,
+                                                currAttrs, currAttrsOnly);
+                  } catch (LDAPException e) {
+                      add(e);
+                  } finally {
+                      currConn.releaseSearchListener(resultSource);
+                  }
+                  searchComplete = true;
+                  if (connectionToClose != null) {
+                      try {
+                          connectionToClose.disconnect ();
+                      } catch (LDAPException e) {
+                      }
+                      connectionToClose = null;
+                  }
+                  return;
+                } else {
+                    try {
+                        currConn.checkSearchMsg(this, msg, currCons,
+                          currBase, currScope, currFilter, currAttrs, currAttrsOnly);
+                    } catch (LDAPException e) {
+                        add(e);
+                    }
+                }
+            }
+        }
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPTraceWriter.java
@@ -0,0 +1,74 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * The <CODE>LDAPTraceWriter</CODE> interface enables logging of LDAP
+ * trace messages in environments where an OutputStream can not be used.
+ * <P>
+ * The interface is primarily meant for integrating LDAP tracing with the
+ * servlet log facility:
+ * <P>
+ * <PRE>
+ *     servletCtx = config.getServletContext();
+ *     ...
+ *     LDAPConnection ld = new LDAPConnection();
+ *     ld.setProperty(ld.TRACE_PROPERTY, 
+ *            new LDAPTraceWriter() { 
+ *                public void write (String msg) {
+ *                    servletCtx.log(msg);
+ *                }
+ *            });
+ * <PRE>
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPConnection#setProperty(java.lang.String, java.lang.Object)
+ */
+public interface LDAPTraceWriter {
+
+     /**
+     * Writes an LDAP trace message.
+     * 
+     * @param msg An incoming or outgoing LDAP message
+     *
+     * @see netscape.ldap.LDAPConnection#setProperty(java.lang.String, java.lang.Object)
+     */
+    public void write (String msg);
+
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSchemaElement.java
@@ -0,0 +1,816 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ *
+ * Abstract class representing an element (such as an object class
+ * definition, an attribute type definition, or a matching rule
+ * definition) in the schema. The specific types of elements are
+ * represented by the <CODE>LDAPObjectClassSchema</CODE>,
+ * <CODE>LDAPAttributeSchema</CODE>, and <CODE>LDAPMatchingRuleSchema</CODE>
+ * subclasses.
+ * <P>
+ *
+ * <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+ * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+ * Attribute Syntax Definitions</A> covers the types of information
+ * that need to be specified in the definition of an object class,
+ * attribute type, or matching rule.  All of these schema elements
+ * can specify the following information:
+ * <P>
+ *
+ * <UL>
+ * <LI>a name identifying the element
+ * <LI>an OID identifying the element
+ * <LI>a description of the element
+ * <LI>a qualifier "OBSOLETE"
+ * </UL>
+ * <P>
+ *
+ * In addition, there are optional standard qualifiers for attribute
+ * types (see LDAPAttributeSchema), and implementation-specific
+ * qualifiers may be added. Non-standard qualifiers must have names
+ * starting with X-, e.g. "X-OWNER 'John Jacobson'". Optional and
+ * non-standard qualifiers can be accessed with <CODE>getQualifier</CODE> and
+ * <CODE>setQualifier</CODE>, and enumerated with
+ * <CODE>getQualifierNames</CODE>.
+ * <P>
+ *
+ * The <CODE>LDAPSchemaElement</CODE> class implements methods that
+ * you can use with different types of schema elements (object class
+ * definitions, attribute type definitions, and matching rule definitions).
+ * You can do the following:
+ * <UL>
+ * <LI>get the name of a schema element
+ * <LI>get the OID of a schema element
+ * <LI>get the description of a schema element
+ * <LI>add an element to the schema
+ * <LI>remove an element from the schema
+ * </UL>
+ * <P>
+ *
+ * @see netscape.ldap.LDAPObjectClassSchema
+ * @see netscape.ldap.LDAPAttributeSchema
+ * @see netscape.ldap.LDAPMatchingRuleSchema
+ * @version 1.0
+ **/
+
+public abstract class LDAPSchemaElement implements java.io.Serializable {
+
+    static final long serialVersionUID = -3972153461950418863L;
+
+    /**
+     * Constructs a blank element.
+     */
+    protected LDAPSchemaElement() {
+    }
+
+    /**
+     * Constructs a definition explicitly.
+     * @param name name of element
+     * @param oid dotted-string object identifier
+     * @param description description of element
+     */
+    protected LDAPSchemaElement( String name, String oid,
+                                 String description ) {
+        this( name, oid, description, null );
+    }
+
+    /**
+     * Constructs a definition explicitly.
+     * @param name name of element
+     * @param oid dotted-string object identifier
+     * @param description description of element
+     * @param aliases names which are to be considered aliases for this
+     * element; <CODE>null</CODE> if there are no aliases
+     */
+    protected LDAPSchemaElement( String name, String oid,
+                                 String description, String[] aliases ) {
+        if ( oid == null ) {
+            throw new IllegalArgumentException( "OID required" );
+        }
+        this.name = name;
+        this.oid = oid;
+        this.description = description;
+        if ( (aliases != null) && (aliases.length > 0) ) {
+            this.aliases = aliases;
+        }
+    }
+
+    /**
+     * Gets the name of the object class, attribute type, or matching rule.
+     * @return the name of the object class, attribute type, or
+     * matching rule.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Gets the object ID (OID) of the object class, attribute type,
+     * or matching rule in dotted-string format (for example, "1.2.3.4").
+     * @return the OID of the object class, attribute type,
+     * or matching rule.
+     */
+    public String getID() {
+        return oid;
+    }
+
+    /**
+     * Gets the object ID (OID) of the object class, attribute type,
+     * or matching rule in dotted-string format (for example, "1.2.3.4").
+     * @return the OID of the object class, attribute type,
+     * or matching rule.
+     * @deprecated Use <CODE>LDAPSchemaElement.getID()</CODE>
+     */
+    public String getOID() {
+        return getID();
+    }
+
+    /**
+     * Gets the description of the object class, attribute type,
+     * or matching rule.
+     * @return the description of the object class, attribute type,
+     * or matching rule.
+     */
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * Adds, removes or modifies the definition from a Directory.
+     * @param ld an open connection to a Directory Server. Typically the
+     * connection must have been authenticated to add a definition.
+     * @param op type of modification to make
+     * @param attr attribute in the schema entry to modify
+     * @exception LDAPException if the definition can't be added/removed
+     */
+    protected void update( LDAPConnection ld, int op, LDAPAttribute attr,
+                           String dn )
+                           throws LDAPException {
+        LDAPAttribute[] attrs = new LDAPAttribute[1];
+        attrs[0] = attr;
+        update( ld, op, attrs, dn );
+    }
+
+    /**
+     * Adds, removes or modifies the definition from a Directory.
+     * @param ld an open connection to a Directory Server. Typically the
+     * connection must have been authenticated to add a definition.
+     * @param op type of modification to make
+     * @param attrs attributes in the schema entry to modify
+     * @exception LDAPException if the definition can't be added/removed.
+     */
+    protected void update( LDAPConnection ld, int op, LDAPAttribute[] attrs,
+                           String dn )
+                           throws LDAPException {
+        LDAPModificationSet mods = new LDAPModificationSet();
+        for( int i = 0; i < attrs.length; i++ ) {
+            mods.add( op, attrs[i] );
+        }
+        String entryName = LDAPSchema.getSchemaDN( ld, dn );
+        ld.modify( entryName, mods );
+    }
+
+    /**
+     * Adds, removes or modifies the definition from a Directory.
+     * @param ld an open connection to a Directory Server. Typically the
+     * connection must have been authenticated to add a definition.
+     * @param op type of modification to make
+     * @param name name of attribute in the schema entry to modify
+     * @exception LDAPException if the definition can't be added/removed
+     */
+    protected void update( LDAPConnection ld, int op, String name,
+                           String dn )
+                           throws LDAPException {
+        boolean quotingBug =
+            !LDAPSchema.isAttributeSyntaxStandardsCompliant( ld );
+        LDAPAttribute attr = new LDAPAttribute( name,
+                                                getValue( quotingBug ) );
+        update( ld, op, attr, dn );
+    }
+
+    /**
+     * Adds the current object class, attribute type, or matching rule
+     * definition to the schema. Typically, most servers
+     * will require you to authenticate before allowing you to
+     * edit the schema.
+     * @param ld the <CODE>LDAPConnection</CODE> object representing
+     * a connection to an LDAP server
+     * @param dn the entry at which to add the schema definition
+     * @exception LDAPException if the specified definition cannot be
+     * added to the schema
+     */
+    public void add( LDAPConnection ld, String dn ) throws LDAPException {
+        update( ld, LDAPModification.ADD, attrName, dn );
+    }
+
+    /**
+     * Adds the current object class, attribute type, or matching rule
+     * definition to the schema at the root DSE. Typically, most servers
+     * will require you to authenticate before allowing you to
+     * edit the schema.
+     * @param ld the <CODE>LDAPConnection</CODE> object representing
+     * a connection to an LDAP server
+     * @exception LDAPException if the specified definition cannot be
+     * added to the schema.
+     */
+    public void add( LDAPConnection ld ) throws LDAPException {
+        add( ld, "" );
+    }
+
+    /**
+     * Replaces a single value of the object class, attribute type,
+     * or matching rule definition in the schema. Typically, most servers
+     * will require you to authenticate before allowing you to
+     * edit the schema.
+     * @param ld the <CODE>LDAPConnection</CODE> object representing
+     * a connection to an LDAP server
+     * @param newValue the new value
+     * @param dn the entry at which to modify the schema definition
+     * @exception LDAPException if the specified definition cannot be
+     * modified.
+     */
+    public void modify( LDAPConnection ld, LDAPSchemaElement newValue,
+                        String dn )
+                        throws LDAPException {
+        boolean quotingBug =
+            !LDAPSchema.isAttributeSyntaxStandardsCompliant( ld );
+        LDAPModificationSet mods = new LDAPModificationSet();
+        mods.add( LDAPModification.DELETE,
+                  new LDAPAttribute( attrName, getValue( quotingBug ) ) );
+        mods.add( LDAPModification.ADD,
+                  new LDAPAttribute( attrName,
+                                     newValue.getValue( quotingBug ) ) );
+        String entryName = LDAPSchema.getSchemaDN( ld, dn );
+        ld.modify( entryName, mods );
+    }
+
+    /**
+     * Replaces a single value of the object class, attribute type,
+     * or matching rule definition in the schema at the root DSE.
+     * Typically, most servers
+     * will require you to authenticate before allowing you to
+     * edit the schema.
+     * @param ld the <CODE>LDAPConnection</CODE> object representing
+     * a connection to an LDAP server
+     * @param newValue the new value
+     * @exception LDAPException if the specified definition cannot be
+     * modified.
+     */
+    public void modify( LDAPConnection ld, LDAPSchemaElement newValue )
+                        throws LDAPException {
+        modify( ld, newValue, "" );
+    }
+
+    /**
+     * Removes the current object class, attribute type, or matching rule
+     * definition from the schema. Typically, most servers
+     * will require you to authenticate before allowing you to
+     * edit the schema.
+     * @param ld the <CODE>LDAPConnection</CODE> object representing
+     * a connection to an LDAP server
+     * @param dn the entry at which to remove the schema definition
+     * @exception LDAPException if the specified definition cannot be
+     * removed from the schema.
+     */
+    public void remove( LDAPConnection ld, String dn ) throws LDAPException {
+        update( ld, LDAPModification.DELETE, attrName, dn );
+    }
+
+    /**
+     * Removes the current object class, attribute type, or matching rule
+     * definition from the schema at the root DSE. Typically, most servers
+     * will require you to authenticate before allowing you to
+     * edit the schema.
+     * @param ld the <CODE>LDAPConnection</CODE> object representing
+     * a connection to an LDAP server
+     * @exception LDAPException if the specified definition cannot be
+     * removed from the schema
+     */
+    public void remove( LDAPConnection ld ) throws LDAPException {
+        remove( ld, "" );
+    }
+
+    /**
+     * Reports if the element is marked as obsolete.
+     * @return <CODE>true<CODE> if the element is defined as obsolete.
+     */
+    public boolean isObsolete() {
+        return (properties == null) ? false :
+            properties.containsKey(OBSOLETE);
+    }
+
+    /**
+     * Parses a raw schema value into OID, name, description, and
+     * a Hashtable of other qualifiers and values.
+     *
+     * @param raw a raw schema definition
+     */
+    protected void parseValue( String raw ) {
+        if ( properties == null ) {
+            properties = new Hashtable();
+        }
+        int l = raw.length();
+        // Processing is faster in char array than in String
+        char[] ch = new char[l];
+        raw.getChars( 0, l, ch, 0 );
+        // Trim leading and trailing space
+        l--;
+        while( ch[l] == ' ' ) {
+            l--;
+        }
+        int start = 0;
+        while( ch[start] == ' ' ) {
+            start++;
+        }
+        // Skip past "( " and ")" to start of OID
+        start += 2;
+        // Find end of OID
+        int ind = start + 1;
+        while( ch[ind] != ' ' ) {
+            ind++;
+        }
+        oid = new String( ch, start, ind - start );
+
+        ind = ind + 1;
+        String s;
+        String val;
+        while ( ind < l ) {
+            // Skip past blanks to start of next token
+            while( ch[ind] == ' ' ) {
+                ind++;
+            }
+            // Find end of token
+            int last = ind + 1;
+            while( (last < l) && (ch[last] != ' ') )
+                last++;
+            if ( last < l ) {
+                // Found a token
+                s = new String( ch, ind, last-ind );
+                ind = last;
+                if ( novalsTable.containsKey( s ) ) {
+                    properties.put( s, "" );
+                    continue;
+                }
+            } else {
+                // Reached end of string with no end of token
+                s = "";
+                ind = l;
+                break;
+            }
+
+            // Find the start of the value of the token
+            while( (ind < l) && (ch[ind] == ' ') ) {
+                ind++;
+            }
+            last = ind + 1;
+            if ( ind >= l ) {
+                break;
+            }
+
+            boolean quoted = false;
+            boolean list = false;
+            if ( ch[ind] == '\'' ) {
+                // The value is quoted
+                quoted = true;
+                ind++;
+                while( (last < l) && (ch[last] != '\'') ) {
+                    last++;
+                }
+            } else if ( ch[ind] == '(' ) {
+                // The value is a list
+                list = true;
+                ind++;
+                while( (last < l) && (ch[last] != ')') ) {
+                    last++;
+                }
+            } else {
+                // The value is not quoted
+                while( (last < l) && (ch[last] != ' ') ) {
+                    last++;
+                }
+            }
+            if ( (ind < last) && (last <= l) ) {
+                if ( list ) {
+                    Vector v = new Vector();
+                    if ( ch[ind] == ' ' ) {
+                        ind++;
+                    }
+                    val = new String( ch, ind, last-ind-1 );
+                    // Is this a quoted list? If so, use ' as delimiter,
+                    // otherwise use ' '. The space between quoted
+                    // values will be returned as tokens containing only
+                    // white space. White space is not valid in a list
+                    // value, so we just remove all tokens containing
+                    // only white space.
+                    String delim = (val.indexOf( '\'' ) >= 0) ? "'" : " ";
+                    StringTokenizer st = new StringTokenizer( val, delim );
+                    while ( st.hasMoreTokens() ) {
+                        String tok = st.nextToken().trim();
+                        if ( (tok.length() > 0) && !tok.equals( "$" ) ) {
+                            v.addElement( tok );
+                        }
+                    }
+                    properties.put( s, v );
+                } else {
+                    val = new String( ch, ind, last-ind );
+                    if ( s.equals( "NAME" ) ) {
+                        name = val;
+                    } else if ( s.equals( "DESC" ) ) {
+                        description = val;
+                    } else {
+                        properties.put( s, val );
+                    }
+                    if ( quoted ) {
+                        last++;
+                    }
+                }
+            }
+            ind = last + 1;
+        }
+        // Aliases end up as values of NAME
+        String[] vals = getQualifier( "NAME" );
+        if ( (vals != null) && (vals.length > 0) ) {
+            name = vals[0];
+            if ( vals.length > 1 ) {
+                aliases = new String[vals.length-1];
+                System.arraycopy( vals, 1, aliases, 0, aliases.length );
+            }
+        }
+    }
+
+    /**
+     * Formats a String in the format defined in X.501 (see
+     * <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+     * >RFC 2252, Lightweight Directory Access Protocol
+     * (v3): Attribute Syntax Definitions</A>
+     * for a description of this format).
+     * This is the format that LDAP servers and clients use to exchange
+     * schema information. For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the attributes "objectclasses" and "attributetypes".  The
+     * values of the "attributetypes" attribute are attribute type
+     * descriptions in this format.
+     * <P>
+     * @return a formatted String for defining a schema element.
+     */
+    public String getValue() {
+        return getValue( false );
+    }
+
+    String getValue( boolean quotingBug ) {
+        return null;
+    }
+
+    /**
+     * Prepares the initial common part of a schema element value in
+     * RFC 2252 format for submitting to a server
+     *
+     * @return the OID, name, description, and possibly OBSOLETE
+     * fields of a schema element definition.
+     */
+    String getValuePrefix() {
+        String s = "( " + oid + ' ';
+        if ( (name != null) && (name.length() > 0) ) {
+            s += "NAME ";
+            if ( aliases != null ) {
+                s += "( " + '\'' + name + "\' ";
+                for( int i = 0; i < aliases.length; i++ ) {
+                    s += '\'' + aliases[i] + "\' ";
+                }
+                s += ") ";
+            } else {
+                s += '\'' + name + "\' ";
+            }
+        }
+        if ( description != null ) {
+            s += "DESC \'" + description + "\' ";
+        }
+        if ( isObsolete() ) {
+            s += OBSOLETE + ' ';
+        }
+        return s;
+    }
+
+    /**
+     * Gets qualifiers which may or may not be present
+     *
+
+     * @param names list of qualifiers to look up
+     * @return String in RFC 2252 format containing any values
+     * found, not terminated with ' '.
+     */
+    protected String getOptionalValues( String[] names ) {
+        String s = "";
+        for( int i = 0; i < names.length; i++ ) {
+            String[] vals = getQualifier( names[i] );
+            if ( (vals != null) && (vals.length > 0) ) {
+                s += names[i] + ' ' + vals[0];
+            }
+        }
+        return s;
+    }
+
+    /**
+     * Gets any qualifiers marked as custom (starting with "X-")
+     *
+     * @return string in RFC 2252 format, without a terminating
+     * ' '.
+     */
+    protected String getCustomValues() {
+        String s = "";
+        Enumeration en = properties.keys();
+        while( en.hasMoreElements() ) {
+            String key = (String)en.nextElement();
+            if ( !key.startsWith( "X-" ) ) {
+                continue;
+            }
+            s += getValue( key, true, false ) + ' ';
+        }
+        // Strip trailing ' '
+        if ( (s.length() > 0) && (s.charAt( s.length() - 1 ) == ' ') ) {
+            s = s.substring( 0, s.length() - 1 );
+        }
+        return s;
+    }
+
+    /**
+     * Gets a qualifier's value or values, if present, and formats
+     * the String according to RFC 2252
+     *
+     * @param key the qualifier to get
+     * @param doQuote <CODE>true</CODE> if values should be enveloped
+     * with single quotes
+     * @param doDollar <CODE>true</CODE> if a list of values should use
+     * " $ " as separator; that is true for object class attribute lists
+     * @return String in RFC 2252 format, without a terminating
+     * ' '.
+     */
+    String getValue( String key, boolean doQuote, boolean doDollar ) {
+        String s = "";
+        Object o = properties.get( key );
+        if ( o == null ) {
+            return s;
+        }
+        if ( o instanceof String ) {
+            if ( ((String)o).length() > 0 ) {
+                s += key + ' ';
+                if ( doQuote ) {
+                    s += '\'';
+                }
+                s += (String)o;
+                if ( doQuote ) {
+                    s += '\'';
+                }
+            }
+        } else {
+            s += key + " ( ";
+            Vector v = (Vector)o;
+            for( int i = 0; i < v.size(); i++ ) {
+                if ( doQuote ) {
+                    s += '\'';
+                }
+                s += (String)v.elementAt(i);
+                if ( doQuote ) {
+                    s += '\'';
+                }
+                s += ' ';
+                if ( doDollar && (i < (v.size() - 1)) ) {
+                    s += "$ ";
+                }
+            }
+            s += ')';
+        }
+
+        return s;
+    }
+
+    /**
+     * Gets a qualifier's value or values, if present, and format
+     * the String according to RFC 2252.
+     *
+     * @param key the qualifier to get
+     * @param doQuote <CODE>true</CODE> if values should be enveloped
+     * with single quotes
+     * @return String in RFC 2252 format, without a terminating
+     * ' '.
+     */
+    String getValue( String key, boolean doQuote ) {
+        return getValue( key, doQuote, true );
+    }
+
+    /**
+     * Keeps track of qualifiers which are not predefined.
+     * @param name name of qualifier
+     * @param value value of qualifier. "" for no value, <CODE>null</CODE>
+     * to remove the qualifier
+     */
+    public void setQualifier( String name, String value ) {
+        if ( properties == null ) {
+            properties = new Hashtable();
+        }
+        if ( value != null ) {
+            properties.put( name, value );
+        } else {
+            properties.remove( name );
+        }
+    }
+
+    /**
+     * Keeps track of qualifiers which are not predefined.
+     * @param name name of qualifier
+     * @param values array of values
+     */
+    public void setQualifier( String name, String[] values ) {
+        if ( values == null ) {
+            return;
+        }
+        if ( properties == null ) {
+            properties = new Hashtable();
+        }
+        Vector v = new Vector();
+        for( int i = 0; i < values.length; i++ ) {
+            v.addElement( values[i] );
+        }
+        properties.put( name, v );
+    }
+
+    /**
+     * Gets the value of a qualifier which is not predefined.
+     * @param name name of qualifier
+     * @return value or values of qualifier; <CODE>null</CODE> if not
+     * present, a zero-length array if present but with no value.
+     */
+    public String[] getQualifier( String name ) {
+        if ( properties == null ) {
+            return null;
+        }
+        Object o = properties.get( name );
+        if ( o == null ) {
+            return null;
+        }
+        if ( o instanceof Vector ) {
+            Vector v = (Vector)o;
+            String[] vals = new String[v.size()];
+            v.copyInto( vals );
+            return vals;
+        }
+        String s = (String)o;
+        if ( s.length() < 1 ) {
+            return new String[0];
+        } else {
+            return new String[] { s };
+        }
+    }
+
+    /**
+     * Gets an enumeration of all qualifiers which are not predefined.
+     * @return enumeration of qualifiers.
+     */
+    public Enumeration getQualifierNames() {
+        return properties.keys();
+    }
+
+    /**
+     * Gets the aliases of the attribute, if any
+     * @return the aliases of the attribute, or <CODE>null</CODE> if
+     * it does not have any aliases
+     */
+    public String[] getAliases() {
+        return aliases;
+    }
+
+    /**
+     * Creates a string for use in toString with any qualifiers of the element.
+     *
+     * @param ignore any qualifiers to NOT include
+     * @return a String with any known qualifiers.
+     */
+    String getQualifierString( String[] ignore ) {
+        Hashtable toIgnore = null;
+        if ( ignore != null ) {
+            toIgnore = new Hashtable();
+            for( int i = 0; i < ignore.length; i++ ) {
+                toIgnore.put( ignore[i], ignore[i] );
+            }
+        }
+        String s = "";
+        Enumeration en = getQualifierNames();
+        while( en.hasMoreElements() ) {
+            String qualifier = (String)en.nextElement();
+            if ( (toIgnore != null) && toIgnore.containsKey( qualifier ) ) {
+                continue;
+            }
+            s += "; " + qualifier;
+            String[] vals = getQualifier( qualifier );
+            if ( vals == null ) {
+                s += ' ';
+                continue;
+            }
+            s += ": ";
+            for( int i = 0; i < vals.length; i++ ) {
+                s += vals[i] + ' ';
+            }
+        }
+        // Strip trailing ' '
+        if ( (s.length() > 0) && (s.charAt( s.length() - 1 ) == ' ') ) {
+            s = s.substring( 0, s.length() - 1 );
+        }
+        return s;
+    }
+
+    /**
+     * Gets any aliases for this element
+     *
+     * @return a string with any aliases, for use in toString()
+     */
+    String getAliasString() {
+        if ( aliases != null ) {
+            String s = "; aliases:";
+            for( int i = 0; i < aliases.length; i++ ) {
+                s += ' ' + aliases[i];
+            }
+            return s;
+        }
+        return "";
+    }
+
+    // Constants for known syntax types
+    public static final int unknown = 0;
+    public static final int cis = 1;
+    public static final int binary = 2;
+    public static final int telephone = 3;
+    public static final int ces = 4;
+    public static final int dn = 5;
+    public static final int integer = 6;
+
+    protected static final String cisString =
+                                      "1.3.6.1.4.1.1466.115.121.1.15";
+    protected static final String binaryString =
+                                      "1.3.6.1.4.1.1466.115.121.1.5";
+    protected static final String telephoneString =
+                                      "1.3.6.1.4.1.1466.115.121.1.50";
+    protected static final String cesString =
+                                      "1.3.6.1.4.1.1466.115.121.1.26";
+    protected static final String intString =
+                                      "1.3.6.1.4.1.1466.115.121.1.27";
+    protected static final String dnString =
+                                      "1.3.6.1.4.1.1466.115.121.1.12";
+    // Predefined qualifiers which apply to any schema element type
+    public static final String OBSOLETE = "OBSOLETE";
+    public static final String SUPERIOR = "SUP";
+
+    // Predefined qualifiers
+    public static final String SYNTAX = "SYNTAX";
+
+    // Properties which are common to all schema elements
+    protected String oid = null;
+    protected String name = "";
+    protected String description = "";
+    protected String attrName = null;
+    protected String rawValue = null;
+    protected String[] aliases = null;
+    // Additional qualifiers
+    protected Hashtable properties = null;
+    // Qualifiers known to not have values
+    static protected Hashtable novalsTable = new Hashtable();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPDITStructureRuleSchema.java
@@ -0,0 +1,292 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * The definition of a DIT structure rule in the schema.
+ * <A HREF="http://www.ietf.org/rfc/rfc2252.txt"
+ * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+ * DIT Structure Rule Description</A> covers the types of information
+ * to specify when defining a DIT structure rule. According to the RFC, 
+ * the description of a DIT structure rule can include the following:
+ * <P>
+ *
+ * <UL>
+ * <LI>an OID identifying the attribute type
+ * <LI>a name identifying the attribute type
+ * <LI>a description of the attribute type
+ * <LI>the name of the parent attribute type
+ * <LI>the syntax used by the attribute (for example,
+ * <CODE>cis</CODE> or <CODE>int</CODE>)
+ * <LI>an indication of whether the attribute type is single-valued
+ * or multi-valued
+ * </UL>
+ * <P>
+ *
+ * When you construct an <CODE>LDAPDITStructureRuleSchema</CODE> object, you can
+ * specify these types of information as arguments to the constructor or
+ * in the AttributeTypeDescription format specified in RFC 2252.
+ * When an LDAP client searches an LDAP server for the schema, the server
+ * returns schema information as an object with attribute values in this
+ * format.
+ * <P>
+ *
+ * There are a number of additional optional description fields which
+ * are not explicitly accessible through LDAPDITStructureRuleSchema, but which
+ * can be managed with setQualifier, getQualifier, and getQualifierNames:
+ * <P>
+ *
+ * <UL>
+ * <LI>OBSOLETE
+ * </UL>
+ * <P>
+ *
+ * To get the name, OID, and description of this DIT structure rule
+ * , use the <CODE>getName</CODE>, <CODE>getOID</CODE>, and
+ * <CODE>getDescription</CODE> methods inherited from the abstract class
+ * <CODE>LDAPSchemaElement</CODE>. Optional and custom qualifiers are
+ * accessed with <CODE>getQualifier</CODE> and <CODE>getQualifierNames</CODE>
+ * from <CODE>LDAPSchemaElement</CODE>.
+ * <P>
+ *
+ * To add or remove this attribute type definition from the
+ * schema, use the <CODE>add</CODE> and <CODE>remove</CODE>
+ * methods, which this class inherits from the <CODE>LDAPSchemaElement</CODE>
+ * abstract class.
+ * <P>
+ * RFC 2252 defines DITStructureRuleDescription as follows:
+ * <P>
+ * <PRE>
+ *      DITStructureRuleDescription = "(" whsp
+ *        ruleidentifier whsp            ; DITStructureRule identifier
+ *        [ "NAME" qdescrs ]
+ *        [ "DESC" qdstring ]
+ *        [ "OBSOLETE" whsp ]
+ *        "FORM" woid whsp               ; NameForm
+ *        [ "SUP" ruleidentifiers whsp ] ; superior DITStructureRules
+ *    ")"
+ * </PRE>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPSchemaElement
+ **/
+
+public class LDAPDITStructureRuleSchema extends LDAPSchemaElement {
+
+    static final long serialVersionUID = -2823317246039655811L;
+
+    /**
+     * Constructs a blank element.
+     */
+    protected LDAPDITStructureRuleSchema() {
+        super();
+    }
+
+    /**
+     * Constructs a DIT structure rule definition, using the specified
+     * information.
+     * @param name name of the attribute type
+     * @param ruleID unique identifier of the structure rule.<BR>
+     * NOTE: this is an integer, not a dotted numerical identifier.
+     * Structure rules aren't identified by OID.
+     * @param description description of attribute type
+     * @param obsolete <code>true</code> if the rule is obsolete
+     * @param nameForm either the identifier or name of a name form.
+     * This is used to indirectly refer to the object class that this
+     * structure rule applies to.
+     * @param superiors list of superior structure rules - specified
+     * by their integer ID. The object class specified by this structure
+     * rule (via the nameForm parameter) may only be subordinate in
+     * the DIT to object classes of those represented by the structure
+     * rules here.
+     */
+    public LDAPDITStructureRuleSchema( String name, int ruleID,
+                                       String description, boolean obsolete,
+                                       String nameForm,
+                                       String[] superiors ) {
+        super( name, "", description, null );
+        this.nameForm = nameForm;
+        this.ruleID = ruleID;
+        if ( obsolete ) {
+            setQualifier( OBSOLETE, "" );
+        }
+        if ( (superiors != null) && (superiors.length > 0) ) {
+            setQualifier( SUPERIOR, superiors );
+        }
+    }
+
+    /**
+     * Constructs a DIT structure rule definition based on a description in
+     * the DITStructureRuleDescription format. For information on this format,
+     * (see <A HREF="http://www.ietf.org/rfc/rfc2252.txt"
+     * >RFC 2252, Lightweight Directory Access Protocol (v3):
+     * DIT Structure Rule Description</A>.  This is the format that
+     * LDAP servers
+     * and clients use to exchange schema information.  (For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the attributes "objectclasses" and "attributetypes".  The
+     * values of "attributetypes" are attribute type descriptions
+     * in this format.)
+     * <P>
+     *
+     * @param raw definition of the DIT structure rule in the
+     * DITStructureRuleDescription format
+     */
+    public LDAPDITStructureRuleSchema( String raw ) {
+        attrName = "ditStructureRules";
+        parseValue( raw );
+        Object o = properties.get( FORM );
+        if ( o != null ) {
+            nameForm = (String)o;
+        }
+        try {
+            ruleID = Integer.parseInt( oid );
+        } catch ( Exception e ) {
+        }
+    }
+
+    /**
+     * Returns a list of all structure rules that are superior to this
+     * structure rule. To resolve to an object class, you need to first
+     * resolve the superior id to another structure rule, then call
+     * getNameForm().getObjectClass() on that structure rule.
+     * @return the structure rules that are superior to this
+     * structure rule.
+     */
+    public String[] getSuperiors() {
+        return getQualifier( SUPERIOR );
+    }
+
+    /**
+     * Returns the rule ID for this structure rule. Note that this returns
+     * an integer rather than a dotted decimal OID. Objects of this class do
+     * not have an OID, thus getID will return null.
+     *
+     * @return the rule ID for this structure rule.
+     */
+    public int getRuleID() {
+        return ruleID;
+    }
+
+    /**
+     * Returns the NameForm that this structure rule controls. You can get
+     * the actual object class that this structure rule controls by calling
+     * getNameForm().getObjectClass().
+     *
+     * @return the NameForm that this structure rule controls.
+     */
+    public String getNameForm() {
+        return nameForm;
+    }
+
+    /**
+     * Prepares a value in RFC 2252 format for submission to a server
+     *
+     * @return a String ready for submission to an LDAP server.
+     */
+    public String getValue() {
+        String s = "( " + ruleID + ' ';
+        if ( name != null ) {
+            s += "NAME " + '\'' + name + "\' ";
+        }
+        if ( description != null ) {
+            s += "DESC \'" + description + "\' ";
+        }
+        if ( isObsolete() ) {
+            s += OBSOLETE + ' ';
+        }
+        s += FORM + " " + nameForm + ' ';
+        String val = getValue( SUPERIOR, false );
+        if ( (val != null) && (val.length() > 1) ) {
+            s += val + ' ';
+        }
+        val = getCustomValues();
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        s += ')';
+        return s;
+    }
+
+    /**
+     * Gets the definition of the rule in a user friendly format.
+     * This is the format that the rule definition uses when
+     * printing the attribute type or the schema.
+     * @return definition of the rule in a user friendly format.
+     */
+    public String toString() {
+        String s = "Name: " + name + "; ruleID: " + ruleID + "; ";
+        s += "Description: " + description;
+        if ( isObsolete() ) {
+            s += "; OBSOLETE";
+        }
+        String[] superiors = getSuperiors();
+        if ( superiors != null ) {
+            for( int i = 0; i < superiors.length; i++ ) {
+                s += superiors[i];
+                if ( i < (superiors.length-1) ) {
+                    s += ", ";
+                }
+            }
+        }
+        s += "Name form: " + nameForm + "; ";
+        s += getQualifierString( IGNOREVALS );
+        return s;
+    }
+
+    public final static String FORM = "FORM";
+
+    // Qualifiers known to not have values; prepare a Hashtable
+    static final String[] NOVALS = { "OBSOLETE" };
+    static {
+        for( int i = 0; i < NOVALS.length; i++ ) {
+            novalsTable.put( NOVALS[i], NOVALS[i] );
+        }
+    }
+
+    // Qualifiers which we output explicitly in toString()
+    static final String[] IGNOREVALS = { OBSOLETE,
+                                         FORM,
+                                         "SUP"
+                                       };
+
+    private String nameForm = null;
+    private int ruleID = 0;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSortKey.java
@@ -0,0 +1,185 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * Represents sorting instructions for a particular attribute.
+ *
+ * @version 1.0
+ */
+public class LDAPSortKey implements java.io.Serializable {
+    static final long serialVersionUID = -7044232342344864405L;
+    public final static int REVERSE = 0x81;
+
+    /**
+     * Constructs a new <CODE>LDAPSortKey</CODE> object that will
+     * sort based on the specified instructions.
+     * @param keyDescription a single attribute specification by which to sort
+     * If preceded by a hyphen ("-"), the attribute is sorted in reverse order.
+     * You can also specify the object ID (OID) of a matching rule after
+     * a colon (":"). For example:
+     * <P>
+     * <UL>
+     * <LI><CODE>"cn"</CODE> (sort by the <CODE>cn</CODE> attribute) <P>
+     * <LI><CODE>"-cn"</CODE> (sort by the <CODE>cn</CODE> attribute in
+     * reverse order) <P>
+     * <LI><CODE>"-cn:1.2.3.4"</CODE> (sort by the <CODE>cn</CODE>
+     * attribute in reverse order and use the matching rule identified
+     * by the OID 1.2.3.4) <P>
+     *</UL>
+     * @see netscape.ldap.controls.LDAPSortControl
+     * @see netscape.ldap.controls.LDAPVirtualListControl
+     */
+    public LDAPSortKey( String keyDescription ) {
+        if ( (keyDescription != null) && (keyDescription.length() > 0) ) {
+            if ( keyDescription.charAt( 0 ) == '-' ) {
+                m_reverse = true;
+                m_key = keyDescription.substring( 1 );
+            } else {
+                m_reverse = false;
+                m_key = keyDescription;
+            }
+            int colonIndex = m_key.indexOf( ':' );
+            if ( colonIndex == 0 )
+                m_key = null;
+            else if ( colonIndex > 0 ) {
+                m_matchRule = m_key.substring( colonIndex+1 );
+                m_key = m_key.substring( 0, colonIndex );
+            }
+        }
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPSortKey</CODE> object that will
+     * sort based on the specified attribute and sort order.
+     * @param key a single attribute by which to sort.  For example:
+     * <P>
+     * <UL>
+     * <LI><CODE>"cn"</CODE> (sort by the <CODE>cn</CODE> attribute)
+     * <LI><CODE>"givenname"</CODE> (sort by the <CODE>givenname</CODE>
+     * attribute)
+     * </UL>
+     * @param reverse if <CODE>true</CODE>, the sorting is done in
+     * descending order
+     * @see netscape.ldap.controls.LDAPSortControl
+     * @see netscape.ldap.controls.LDAPVirtualListControl
+     */
+    public LDAPSortKey( String key,
+                        boolean reverse) {
+        m_key = key;
+        m_reverse = reverse;
+        m_matchRule = null;
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPSortKey</CODE> object that will
+     * sort based on the specified attribute, sort order, and matching
+     * rule.
+     * @param key a single attribute by which to sort. For example:
+     * <P>
+     * <UL>
+     * <LI><CODE>"cn"</CODE> (sort by the <CODE>cn</CODE> attribute)
+     * <LI><CODE>"givenname"</CODE> (sort by the <CODE>givenname</CODE>
+     * attribute)
+     * </UL>
+     * @param reverse if <CODE>true</CODE>, the sorting is done in
+     * descending order
+     * @param matchRule object ID (OID) of the matching rule for
+     * the attribute (for example, <CODE>1.2.3.4</CODE>)
+     * @see netscape.ldap.controls.LDAPSortControl
+     * @see netscape.ldap.controls.LDAPVirtualListControl
+     */
+    public LDAPSortKey( String key,
+                        boolean reverse,
+                        String matchRule) {
+        m_key = key;
+        m_reverse = reverse;
+        m_matchRule = matchRule;
+    }
+
+    /**
+     * Returns the attribute by which to sort.
+     * @return a single attribute by which to sort.
+     */
+    public String getKey() {
+        return m_key;
+    }
+
+    /**
+     * Returns <CODE>true</CODE> if sorting is to be done in descending order.
+     * @return <CODE>true</CODE> if sorting is to be done in descending order.
+     */
+    public boolean getReverse() {
+        return m_reverse;
+    }
+
+    /**
+     * Returns the object ID (OID) of the matching rule used for sorting.
+     * If no matching rule is specified, <CODE>null</CODE> is returned.
+     * @return the object ID (OID) of the matching rule, or <CODE>null</CODE>
+     * if the sorting instructions specify no matching rule.
+     */
+    public String getMatchRule() {
+        return m_matchRule;
+    }
+
+    public String toString() {
+        
+        StringBuffer sb = new StringBuffer("{SortKey:");
+        
+        sb.append(" key=");
+        sb.append(m_key);
+        
+        sb.append(" reverse=");
+        sb.append(m_reverse);
+
+        if (m_matchRule != null) {
+            sb.append(" matchRule=");
+            sb.append(m_matchRule);
+        }
+        
+        sb.append("}");
+
+        return sb.toString();
+    }
+
+    private String m_key;
+    private boolean m_reverse;
+    private String m_matchRule;
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPReferralException.java
@@ -0,0 +1,184 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.client.opers.*;
+import java.io.*;
+
+/**
+ * Represents the situation in which the LDAP server refers the client to
+ * another LDAP server.  This exception constructs a list of referral URLs from
+ * the LDAP error message returned by the server.  You can get this list by
+ * using the <CODE>getURLs</CODE> method.
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPException
+ */
+public class LDAPReferralException extends LDAPException {
+
+    static final long serialVersionUID = 1771536577344289897L;
+    private String m_referrals[] = null; /* modified for LDAPv3 */
+
+    /**
+     * Constructs a default exception with no specific error information.
+     */
+    public LDAPReferralException() {
+    }
+
+    /**
+     * Constructs a default exception with a specified string as
+     * additional information. This form is used for lower-level errors.
+     * @param message the additional error information
+     */
+    public LDAPReferralException( String message ) {
+        super( message );
+    }
+
+    /**
+     * Constructs a default exception with a specified string as
+     * additional information. This form is used for higher-level LDAP
+     * operational errors.
+     * @param message the additional error information
+     * @param resultCode result code
+     * @param serverErrorMessage error message
+     */
+    public LDAPReferralException( String message, int resultCode,
+        String serverErrorMessage ) {
+        super(message, resultCode, serverErrorMessage);
+    }
+
+    /**
+     * Constructs an exception with a list of LDAP URLs to other LDAP servers.
+     * This list of referrals points the client to LDAP servers that may
+     * contain the requested entries.
+     * @param message the additional error information
+     * @param resultCode result code
+     * @param referrals array of LDAP URLs identifying other LDAP servers that
+     * may contain the requested entries
+     */
+    public LDAPReferralException( String message, int resultCode,
+        String referrals[] ) {
+        super(message, resultCode, null);
+        m_referrals = referrals;
+    }
+
+    /**
+     * Gets the list of referrals (LDAP URLs to other servers) returned by the LDAP server.
+     * You can use this list to find the LDAP server that can fulfill your request.
+     *
+     * If you have set up your search constraints (or the <CODE>LDAPConnection</CODE> object)
+     * to follow referrals automatically, any operation that results in a referral will use
+     * this list to create new connections to the LDAP servers in this list.
+     *
+     * @return list of LDAP URLs to other LDAP servers.
+     */
+    public LDAPUrl[] getURLs() {
+        if (getLDAPErrorMessage() == null) {
+            return constructsURL(m_referrals);
+        } else {
+            return constructsURL(extractReferrals(getLDAPErrorMessage()));
+        }
+    }
+
+    private LDAPUrl[] constructsURL(String referrals[]) {
+        if (referrals == null) {
+            return null;
+        }
+        LDAPUrl u[] = new LDAPUrl[referrals.length];
+        if (u == null) {
+            return null;
+        }
+        for (int i = 0; i < referrals.length; i++) {
+            try {
+                u[i] = new LDAPUrl(referrals[i]);
+            } catch (Exception e) {
+                return null;
+            }
+        }
+        return u;
+    }
+
+    /**
+     * Extract referral string from the error message. The
+     * error string is based on "Referrals Within the
+     * LDAPv2 Protocol".
+     * @param error string
+     */
+    private String[] extractReferrals(String error) {
+        if (error == null)
+            return null;
+        StringTokenizer st = new StringTokenizer(error, "\n");
+        Vector v = new Vector();
+        boolean referrals = false;
+        while (st.hasMoreTokens()) {
+            String token = st.nextToken();
+            if (referrals) {
+                v.addElement(token);
+            } else {
+                if (token.startsWith("Referral:"))
+                    referrals = true;
+            }
+        }
+
+        if (v.size() == 0)
+            return null;
+        String res[] = new String[v.size()];
+        for (int i = 0; i < v.size(); i++) {
+            res[i] = (String)v.elementAt(i);
+        }
+        return res;
+    }
+    
+   /**
+     * Gets the string representation of the referral exception,
+     * which includes the result code, the message sent back
+     *  from the LDAP server and the list of referrals.
+     *
+     * @return string representation of exception.
+     * @see netscape.ldap.LDAPException#errorCodeToString(int)
+     */
+    public String toString() {
+        String str = super.toString();
+        for (int i=0; i < m_referrals.length; i++) {
+            str += "\n" + m_referrals[i];
+        }
+        return str;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPMessage.java
@@ -0,0 +1,296 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.opers.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+
+/**
+ * Base class for LDAP request and response messages.
+ * This class represents the LDAPMessage in RFC2251. The
+ * message is the entity that got transferred back and
+ * fro between the server and the client interface. Each
+ * message has a protocol operation. The protocol operation
+ * indicates if it is a request or response.
+ * <pre>
+ * LDAPMessage ::= SEQUENCE {
+ *   messageID MessageID,
+ *   protocolOp CHOICE {
+ *     bindRequest BindRequest,
+ *     ...
+ *   }
+ *   controls [0] Controls OPTIONAL
+ * }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class LDAPMessage implements java.io.Serializable {
+
+    static final long serialVersionUID = -1364094245850026720L;
+
+    public final static int BIND_REQUEST        = 0;
+    public final static int BIND_RESPONSE       = 1;
+    public final static int UNBIND_REQUEST      = 2;
+    public final static int SEARCH_REQUEST      = 3;
+    public final static int SEARCH_RESPONSE     = 4;
+    public final static int SEARCH_RESULT       = 5;
+    public final static int MODIFY_REQUEST      = 6;
+    public final static int MODIFY_RESPONSE     = 7;
+    public final static int ADD_REQUEST         = 8;
+    public final static int ADD_RESPONSE        = 9;
+    public final static int DEL_REQUEST         = 10;
+    public final static int DEL_RESPONSE        = 11;
+    public final static int MODIFY_RDN_REQUEST  = 12;
+    public final static int MODIFY_RDN_RESPONSE = 13;
+    public final static int COMPARE_REQUEST     = 14;
+    public final static int COMPARE_RESPONSE    = 15;
+    public final static int ABANDON_REQUEST     = 16;
+    public final static int SEARCH_RESULT_REFERENCE = 19;
+    public final static int EXTENDED_REQUEST    = 23;
+    public final static int EXTENDED_RESPONSE   = 24;
+        
+    /**
+     * Internal variables
+     */
+    private int m_msgid;
+    private JDAPProtocolOp m_protocolOp = null;
+    private LDAPControl m_controls[] = null;
+
+    /**
+     * Constructs a ldap message.
+     * @param msgid message identifier
+     * @param op operation protocol
+     */
+    LDAPMessage(int msgid, JDAPProtocolOp op) {
+        m_msgid = msgid;
+        m_protocolOp = op;
+    }
+
+    LDAPMessage(int msgid, JDAPProtocolOp op, LDAPControl controls[]) {
+        m_msgid = msgid;
+        m_protocolOp = op;
+        m_controls = controls; /* LDAPv3 additions */
+    }
+
+    /**
+     * Creates a ldap message from a BERElement. This method is used
+     * to parse LDAP response messages
+     *
+     * @param element ber element constructed from incoming byte stream
+     */
+    static LDAPMessage parseMessage(BERElement element) throws IOException {
+        int l_msgid;
+        JDAPProtocolOp l_protocolOp = null;
+        LDAPControl l_controls[] = null;
+        
+        if (element.getType() != BERElement.SEQUENCE)
+            throw new IOException("SEQUENCE in jdap message expected");
+        BERSequence seq = (BERSequence)element;
+        BERInteger msgid = (BERInteger)seq.elementAt(0);
+        l_msgid = msgid.getValue();
+        BERElement protocolOp = (BERElement)seq.elementAt(1);
+        if (protocolOp.getType() != BERElement.TAG) {
+            throw new IOException("TAG in protocol operation is expected");
+        }
+        BERTag tag = (BERTag)protocolOp;
+        switch (tag.getTag()&0x1f) {
+            case JDAPProtocolOp.BIND_RESPONSE:
+                l_protocolOp = new JDAPBindResponse(protocolOp);
+  	        break;
+            case JDAPProtocolOp.SEARCH_RESPONSE:
+                l_protocolOp = new JDAPSearchResponse(protocolOp);
+  	        break;
+            /*
+             * If doing search without bind,
+             * x500.arc.nasa.gov returns tag SEARCH_REQUEST tag
+             * in SEARCH_RESULT.
+             */
+            case JDAPProtocolOp.SEARCH_REQUEST:
+            case JDAPProtocolOp.SEARCH_RESULT:
+                l_protocolOp = new JDAPSearchResult(protocolOp);
+  	        break;
+            case JDAPProtocolOp.MODIFY_RESPONSE:
+                l_protocolOp = new JDAPModifyResponse(protocolOp);
+  	        break;
+            case JDAPProtocolOp.ADD_RESPONSE:
+                l_protocolOp = new JDAPAddResponse(protocolOp);
+      	    break;
+            case JDAPProtocolOp.DEL_RESPONSE:
+                l_protocolOp = new JDAPDeleteResponse(protocolOp);
+          	break;
+            case JDAPProtocolOp.MODIFY_RDN_RESPONSE:
+                l_protocolOp = new JDAPModifyRDNResponse(protocolOp);
+          	break;
+            case JDAPProtocolOp.COMPARE_RESPONSE:
+                l_protocolOp = new JDAPCompareResponse(protocolOp);
+          	break;
+            case JDAPProtocolOp.SEARCH_RESULT_REFERENCE:
+                l_protocolOp = new JDAPSearchResultReference(protocolOp);
+          	break;
+            case JDAPProtocolOp.EXTENDED_RESPONSE:
+                l_protocolOp = new JDAPExtendedResponse(protocolOp);
+          	break;
+            default:
+                throw new IOException("Unknown protocol operation");
+        }
+
+        /* parse control */
+        if (seq.size() >= 3) {
+            tag = (BERTag)seq.elementAt(2);
+            if ( tag.getTag() == (BERTag.CONSTRUCTED|BERTag.CONTEXT|0) ) {
+                BERSequence controls = (BERSequence)tag.getValue();
+                l_controls = new LDAPControl[controls.size()];
+                for (int i = 0; i < controls.size(); i++) {
+                    l_controls[i] = LDAPControl.parseControl(controls.elementAt(i));
+    		    }
+            }
+        }
+        
+        if (l_protocolOp instanceof JDAPSearchResponse) {
+            return new LDAPSearchResult(l_msgid,
+                (JDAPSearchResponse) l_protocolOp, l_controls);
+        }            
+        else if (l_protocolOp instanceof JDAPSearchResultReference) {
+            return new LDAPSearchResultReference(l_msgid,
+                (JDAPSearchResultReference) l_protocolOp, l_controls);
+        }            
+        else if (l_protocolOp instanceof JDAPExtendedResponse) {
+            return new LDAPExtendedResponse(l_msgid,
+                (JDAPExtendedResponse) l_protocolOp, l_controls);
+        }
+        else {
+            return new LDAPResponse(l_msgid, l_protocolOp, l_controls);
+        }            
+    }
+
+    /**
+     * Returns the message identifer.
+     * @return message identifer.
+     */
+    public int getMessageID(){
+        return m_msgid;
+    }
+
+    /**
+     * Returns the LDAP operation type of the message
+     * @return message type.
+     */
+    public int getType(){
+        return m_protocolOp.getType();
+    }
+
+    /**
+     * Retrieves the protocol operation.
+     * @return protocol operation.
+     */
+    JDAPProtocolOp getProtocolOp() {
+        return m_protocolOp;
+    }
+
+    /**
+     * Retrieves list of controls.
+     * @return controls.
+     */
+    public LDAPControl[] getControls() {
+        return m_controls;
+    }
+
+    /**
+     * Writes the ber encoding to stream.
+     * @param s output stream
+     */
+    void write(OutputStream s) throws IOException {
+        BERSequence seq = new BERSequence();
+        BERInteger i = new BERInteger(m_msgid);
+        seq.addElement(i);
+        BERElement e = m_protocolOp.getBERElement();
+        if (e == null) {
+            throw new IOException("Bad BER element");
+        }
+        seq.addElement(e);
+        if (m_controls != null) { /* LDAPv3 additions */
+            BERSequence c = new BERSequence();
+            for (int j = 0; j < m_controls.length; j++) {
+                c.addElement(m_controls[j].getBERElement());
+            }
+            BERTag t = new BERTag(BERTag.CONTEXT|BERTag.CONSTRUCTED|0, c, true);
+            seq.addElement(t);
+        }
+        seq.write(s);
+    }
+
+    /**
+     * Returns string representation of an LDAP message.
+     * @return LDAP message.
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer("[LDAPMessage] ");
+        sb.append(m_msgid);
+        sb.append(" ");
+        sb.append(m_protocolOp.toString());
+
+        for (int i =0; m_controls != null && i < m_controls.length; i++) {
+            sb.append(" ");
+            sb.append(m_controls[i].toString());
+        }
+        return sb.toString();
+    }
+    
+    /**
+     * Returns string representation of a ldap message with
+     * the time stamp. Used for message trace
+     * @return ldap message with the time stamp
+     */
+    StringBuffer toTraceString() {
+        StringBuffer sb = new StringBuffer(" op=");
+        sb.append(m_msgid);
+        sb.append(" ");
+        sb.append(m_protocolOp.toString());
+
+        for (int i =0; m_controls != null && i < m_controls.length; i++) {
+            sb.append(" ");
+            sb.append(m_controls[i].toString());
+        }
+        return sb;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSSLSocketWrapFactory.java
@@ -0,0 +1,371 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.io.*;
+import java.net.*;
+import java.util.Hashtable;
+
+/**
+ * Creates an SSL socket connection to an LDAP Server. This class is provided
+ * by the package in which the SSL socket does not extend Socket object.
+ * The class internally provides a wrapper to convert the SSL socket extending
+ * the Object class to the one extending the Socket class.
+ * This factory class implements the <CODE>LDAPSocketFactory</CODE> interface.
+ * <P>
+ *
+ * To use this class, pass the instance of this factory object to the
+ * <CODE>LDAPConnection</CODE> constructor.
+ *
+ * @version 1.0
+ * @see LDAPSocketFactory
+ * @see LDAPConnection#LDAPConnection(netscape.ldap.LDAPSocketFactory)
+ */
+public class LDAPSSLSocketWrapFactory
+             implements LDAPSSLSocketFactoryExt, java.io.Serializable {
+
+    static final long serialVersionUID = -4171548771815037740L;
+
+    /**
+     * The constructor with the specified package for security
+     * @param className the name of a class which has an implementation
+     * of the SSL Socket extending Object class
+     */
+    public LDAPSSLSocketWrapFactory(String className) {
+        m_packageName = new String(className);
+    }
+
+    /**
+     * The constructor with the specified package for security and the
+     * specified cipher suites.
+     * @param className the name of a class which has an implementation
+     * of the SSL Socket extending Object class
+     * @param cipherSuites the cipher suites
+     */
+    public LDAPSSLSocketWrapFactory(String className, Object cipherSuites) {
+        m_packageName = new String(className);
+        m_cipherSuites = cipherSuites;
+    }
+
+    /**
+     * Returns socket to the specified host name and port number.
+     * @param host the host to connect to
+     * @param port the port number
+     * @return the socket to the host name and port number as passed in.
+     * @exception LDAPException A socket to the specified host and port
+     * could not be created.
+     */
+    public Socket makeSocket(String host, int port) throws LDAPException {
+
+        LDAPSSLSocket s = null;
+
+        try {
+            if (m_cipherSuites == null)
+                s = new LDAPSSLSocket(host, port, m_packageName);
+            else
+                s = new LDAPSSLSocket(host, port, m_packageName,
+                  m_cipherSuites);
+            return s;
+        } catch (Exception e) {
+            System.err.println("Exception: "+e.toString());
+            throw new LDAPException("Failed to create SSL socket",
+              LDAPException.CONNECT_ERROR);
+        }
+    }
+
+    /**
+     * Returns <code>true</code> if client authentication is to be used.
+     * @return <code>true</code> if client authentication is enabled; 
+     * <code>false</code>if client authentication is disabled.
+     */
+    public boolean isClientAuth() {
+        return m_clientAuth;
+    }
+
+    /**
+     * <B>(Not implemented yet)</B> <BR>
+     * Enables client authentication for an application running in
+     * a java VM which provides transparent certificate database management.
+     * Calling this method has no effect after makeSocket() has been
+     * called.
+     * @exception LDAPException Since this method is not yet implemented,
+     * calling this method throws an exception.
+     */
+    public void enableClientAuth() throws LDAPException {
+        throw new LDAPException("Client Authentication is not implemented yet.");
+    }
+
+    /**
+     * Returns the name of the class that implements SSL sockets for this factory.
+     *
+     * @return the name of the class that implements SSL sockets for this factory.
+     */
+    public String getSSLSocketImpl() {
+        return m_packageName;
+    }
+
+    /**
+     * Returns the suite of ciphers used for SSL connections made through
+     * sockets created by this factory.
+     *
+     * @return the suite of ciphers used.
+     */
+    public Object getCipherSuites() {
+        return m_cipherSuites;
+    }
+
+    /**
+     * Indicates if client authentication is on.
+     */
+    private boolean m_clientAuth = false;
+
+    /**
+     * Name of class implementing SSLSocket.
+     */
+    private String m_packageName = null;
+
+    /**
+     * The cipher suites
+     */
+    private Object m_cipherSuites = null;
+}
+
+// LDAPSSLSocket class wraps the implementation of the SSL socket
+class LDAPSSLSocket extends Socket {
+
+    public LDAPSSLSocket(String host, int port, String packageName)
+      throws LDAPException {
+        super();
+        m_packageName = packageName;
+        try {
+            // instantiate the SSLSocketFactory implementation, and
+            // find the right constructor
+            Class c = Class.forName(m_packageName);
+            java.lang.reflect.Constructor[] m = c.getConstructors();
+
+            for (int i = 0; i < m.length; i++) {
+                /* Check if the signature is right: String, int */
+                Class[] params = m[i].getParameterTypes();
+
+                if ((params.length == 2) &&
+                    (params[0].getName().equals("java.lang.String")) &&
+                    (params[1].getName().equals("int"))) {
+                    Object[] args = new Object[2];
+                    args[0] = host;
+                    args[1] = new Integer(port);
+                    m_socket = (Object)(m[i].newInstance(args));
+                    return;
+                }
+            }
+            throw new LDAPException("No appropriate constructor in " +
+              m_packageName, LDAPException.PARAM_ERROR);
+        } catch (ClassNotFoundException e) {
+            throw new LDAPException("Class " + m_packageName + " not found",
+              LDAPException.OTHER);
+        } catch (Exception e) {
+            throw new LDAPException("Failed to create SSL socket",
+              LDAPException.CONNECT_ERROR);
+        }
+    }
+
+    public LDAPSSLSocket(String host, int port, String packageName,
+      Object cipherSuites) throws LDAPException {
+        super();
+        m_packageName = packageName;
+        String cipherClassName = null;
+        if (cipherSuites != null)
+            cipherClassName = cipherSuites.getClass().getName();
+
+        try {
+            // instantiate the SSLSocketFactory implementation, and
+            // find the right constructor
+            Class c = Class.forName(m_packageName);
+            java.lang.reflect.Constructor[] m = c.getConstructors();
+
+            for (int i = 0; i < m.length; i++) {
+                /* Check if the signature is right: String, int */
+                Class[] params = m[i].getParameterTypes();
+                if (cipherSuites == null)
+                    throw new LDAPException("Cipher Suites is required");
+
+                if ((params.length == 3) &&
+                    (params[0].getName().equals("java.lang.String")) &&
+                    (params[1].getName().equals("int")) &&
+                    (params[2].getName().equals(cipherClassName))) {
+                    Object[] args = new Object[3];
+                    args[0] = host;
+                    args[1] = new Integer(port);
+                    args[2] = cipherSuites;
+                    m_socket = (Object)(m[i].newInstance(args));
+                    return;
+                }
+            }
+            throw new LDAPException("No appropriate constructor in " +
+              m_packageName, LDAPException.PARAM_ERROR);
+        } catch (ClassNotFoundException e) {
+            throw new LDAPException("Class " + m_packageName + " not found",
+              LDAPException.OTHER);
+        } catch (Exception e) {
+            throw new LDAPException("Failed to create SSL socket",
+              LDAPException.CONNECT_ERROR);
+        }
+    }
+
+    public InputStream getInputStream() {
+        try {
+            Object obj = invokeMethod(m_socket, "getInputStream", null);
+            return (InputStream)obj;
+        } catch (LDAPException e) {
+            printDebug(e.toString());
+        }
+
+        return null;
+    }
+
+    public OutputStream getOutputStream() {
+        try {
+            Object obj = invokeMethod(m_socket, "getOutputStream", null);
+            return (OutputStream)obj;
+        } catch (LDAPException e) {
+            printDebug(e.toString());
+        }
+
+        return null;
+    }
+
+    public void close() throws IOException {
+        try {
+            invokeMethod(m_socket, "close", null);
+        } catch (LDAPException e) {
+            printDebug(e.toString());
+        }
+    }
+
+    public void close(boolean wait) throws IOException {
+        try {
+            Object[] args = new Object[1];
+            args[0] = new Boolean(wait);
+            invokeMethod(m_socket, "close", args);
+        } catch (LDAPException e) {
+            printDebug(e.toString());
+        }
+    }
+
+    public InetAddress getInetAddress() {
+        try {
+            Object obj = invokeMethod(m_socket, "getInetAddress", null);
+            return (InetAddress)obj;
+        } catch (LDAPException e) {
+            printDebug(e.toString());
+        }
+
+        return null;
+    }
+
+    public int getLocalPort() {
+        try {
+            Object obj = invokeMethod(m_socket, "getLocalPort", null);
+            return ((Integer)obj).intValue();
+        } catch (LDAPException e) {
+            printDebug(e.toString());
+        }
+
+        return -1;
+    }
+
+    public int getPort() {
+        try {
+            Object obj = invokeMethod(m_socket, "getPort", null);
+            return ((Integer)obj).intValue();
+        } catch (LDAPException e) {
+           printDebug(e.toString());
+        }
+
+        return -1;
+    }
+
+    private Object invokeMethod(Object obj, String name, Object[] args) throws
+      LDAPException {
+        try {
+            java.lang.reflect.Method m = getMethod(name);
+            if (m != null) {
+                return (m.invoke(obj, args));
+            }
+        } catch (Exception e) {
+            throw new LDAPException("Invoking "+name+": "+
+              e.toString(), LDAPException.PARAM_ERROR);
+        }
+
+        return null;
+    }
+
+    private java.lang.reflect.Method getMethod(String name) throws
+      LDAPException {
+        try {
+            java.lang.reflect.Method method = null;
+            if ((method = (java.lang.reflect.Method)(m_methodLookup.get(name)))
+              != null)
+                return method;
+
+            Class c = Class.forName(m_packageName);
+            java.lang.reflect.Method[] m = c.getMethods();
+            for (int i = 0; i < m.length; i++ ) {
+                if (m[i].getName().equals(name)) {
+                    m_methodLookup.put(name, m[i]);
+                    return m[i];
+                }
+            }
+            throw new LDAPException("Method " + name + " not found in " +
+              m_packageName);
+        } catch (ClassNotFoundException e) {
+            throw new LDAPException("Class "+ m_packageName + " not found");
+        }
+    }
+
+    private void printDebug(String msg) {
+        if (m_debug) {
+            System.out.println(msg);
+        }
+    }
+
+    private final boolean m_debug = true;
+    private Object m_socket;
+    private Hashtable m_methodLookup = new Hashtable();
+    private String m_packageName = null;
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPExtendedOperation.java
@@ -0,0 +1,174 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * Version 3 of the LDAP protocol include the means to define additional
+ * operations (&quot;extended operations&quot;) beyond the standard LDAP
+ * operations. An LDAP v3 client can send an extended operation request,
+ * identifying the operation by its unique object ID (OID).  The server
+ * receives the request and if OID corresponds to an operation supported
+ * by the server, the server procoess the request and sends an extended
+ * operation response back to the client.
+ * <P>
+ *
+ * Objects of this class can be used to represent extended operation
+ * requests (sent by your client) or extended operation responses
+ * (returned by an LDAP v3 server).
+ * <P>
+ *
+ * To determine which extended operations are supported by a server,
+ * you need to search for the root DSE (DSA-specific entry, where DSA is
+ * another term for &quot;LDAP server&quot;) and find the values of the
+ * <CODE>supportedExtension</CODE> attribute.  This attribute contains the
+ * object IDs (OIDs) of the extended operations supported by this server.
+ * <P>
+ *
+ * The following section of code demonstrates how to get the list
+ * of the extended operations supported by an LDAP server.
+ * <P>
+ *
+ * <PRE>
+ * public static void main( String[] args )
+ * {
+ *   LDAPConnection ld = new LDAPConnection();
+ *   try {
+ *     String MY_HOST = "localhost";
+ *     int MY_PORT = 389;
+ *     ld.connect( MY_HOST, MY_PORT );
+ *     try {
+ *       ld.authenticate( 3, "cn=Directory Manager", "23skidoo" );
+ *     } catch( LDAPException e ) {
+ *       System.out.println( "LDAP server does not support v3." );
+ *       ld.disconnect();
+ *       System.exit(1);
+ *     }
+ *
+ *     String MY_FILT = "(objectclass=*)";
+ *     String MY_BASE = "";
+ *     String getAttrs[] = { "supportedExtension" };
+ *     LDAPSearchResults res = ld.search( MY_BASE,
+ *       LDAPConnection.SCOPE_BASE, MY_FILT, getAttrs, false );
+ *
+ *     while ( res.hasMoreElements() ) {
+ *       LDAPEntry findEntry = (LDAPEntry)res.nextElement();
+ *       LDAPAttributeSet findAttrs = findEntry.getAttributeSet();
+ *       Enumeration enumAttrs = findAttrs.getAttributes();
+ *
+ *         while ( enumAttrs.hasMoreElements() ) {
+ *           LDAPAttribute anAttr = (LDAPAttribute)enumAttrs.nextElement();
+ *           String attrName = anAttr.getName();
+ *           System.out.println( attrName );
+ *           Enumeration enumVals = anAttr.getStringValues();
+ *
+ *           while ( enumVals.hasMoreElements() ) {
+ *             String aVal = ( String )enumVals.nextElement();
+ *             System.out.println( "\t" + aVal );
+ *           }
+ *         }
+ *      }
+ *   }
+ *   catch( LDAPException e ) {
+ *     System.out.println( "Error: " + e.toString() );
+ *   }
+ *   try {
+ *     ld.disconnect();
+ *   }
+ *   catch( LDAPException e ) {
+ *     System.exit(1);
+ *   }
+ *   System.exit(0);
+ * }
+ * </PRE>
+ * <P>
+ *
+ * If you compile and run this example against an LDAP server that
+ * supports v3 of the protocol, you might receive the following results:
+ * <P>
+ *
+ * <PRE>
+ * supportedextension
+ *   1.2.3.4
+ * </PRE>
+ * <P>
+ *
+ * For more information on LDAP controls, see the Internet-Draft on
+ * the LDAP v3 protocol. (Note that this internet draft is still a
+ * work in progress.  You can find the latest draft at the <A
+ * HREF="http://www.ietf.cnri.reston.va.us/html.charters/asid-charter.html"
+ * TARGET="_blank">ASID home page</A>.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPConnection#extendedOperation(netscape.ldap.LDAPExtendedOperation)
+ * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String, java.lang.String[], boolean)
+ *
+ */
+public class LDAPExtendedOperation implements java.io.Serializable {
+
+    static final long serialVersionUID = 4010382829133611945L;
+
+    /**
+     * Construct an object
+     * @param oid identifier for the particular operation
+     * @param vals operation-specific data
+     */
+    public LDAPExtendedOperation( String oid, byte[] vals ) {
+        m_oid = oid;
+        m_vals = vals;
+    }
+
+    /**
+     * Get the identifier for this operation.
+     * @return oid identifier for the particular operation.
+     */
+    public String getID() {
+        return m_oid;
+    }
+
+    /**
+     * Get the data for this operation.
+     * @return vals operation-specific data.
+     */
+    public byte[] getValue() {
+        return m_vals;
+    }
+
+    private String m_oid;
+    private byte[] m_vals;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPAttributeSchema.java
@@ -0,0 +1,386 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * The definition of an attribute type in the schema.
+ * <A HREF="http://www.ietf.org/rfc/rfc2252.txt"
+ * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+ * Attribute Syntax Definitions</A> covers the types of information
+ * to specify when defining an attribute type. According to the RFC, 
+ * the description of an attribute type can include the following:
+ * <P>
+ *
+ * <UL>
+ * <LI>an OID identifying the attribute type
+ * <LI>a name identifying the attribute type
+ * <LI>a description of the attribute type
+ * <LI>the name of the parent attribute type
+ * <LI>the syntax used by the attribute (for example,
+ * <CODE>cis</CODE> or <CODE>int</CODE>)
+ * <LI>an indication of whether the attribute type is single-valued
+ * or multi-valued
+ * </UL>
+ * <P>
+ *
+ * When you construct an <CODE>LDAPAttributeSchema</CODE> object, you can
+ * specify these types of information as arguments to the constructor or
+ * in the AttributeTypeDescription format specified in RFC 2252.
+ * When an LDAP client searches an LDAP server for the schema, the server
+ * returns schema information as an object with attribute values in this
+ * format.
+ * <P>
+ *
+ * There a number of additional optional description fields which
+ * are not explicitly accessible through LDAPAttributeSchema, but which
+ * can be managed with setQualifier, getQualifier, and getQualifierNames:
+ * <P>
+ *
+ * <UL>
+ * <LI>EQUALITY
+ * <LI>ORDERING
+ * <LI>SUBSTR
+ * <LI>COLLECTIVE
+ * <LI>NO-USER-MODIFICATION
+ * <LI>USAGE
+ * <LI>OBSOLETE
+ * </UL>
+ * <P>
+ *
+ * To get the name, OID, and description of this attribute type
+ * definition, use the <CODE>getName</CODE>, <CODE>getOID</CODE>, and
+ * <CODE>getDescription</CODE> methods inherited from the abstract class
+ * <CODE>LDAPSchemaElement</CODE>. Optional and custom qualifiers are
+ * accessed with <CODE>getQualifier</CODE> and <CODE>getQualifierNames</CODE>
+ * from <CODE>LDAPSchemaElement</CODE>.
+ * <P>
+ *
+ * To add or remove this attribute type definition from the
+ * schema, use the <CODE>add</CODE> and <CODE>remove</CODE>
+ * methods, which this class inherits from the <CODE>LDAPSchemaElement</CODE>
+ * abstract class.
+ * <P>
+ * RFC 2252 defines AttributeTypeDescription as follows:
+ * <P>
+ * <PRE>
+ *     AttributeTypeDescription = "(" whsp
+ *          numericoid whsp              ; AttributeType identifier
+ *        [ "NAME" qdescrs ]             ; name used in AttributeType
+ *        [ "DESC" qdstring ]            ; description
+ *        [ "OBSOLETE" whsp ]
+ *        [ "SUP" woid ]                 ; derived from this other
+ *                                       ; AttributeType
+ *        [ "EQUALITY" woid              ; Matching Rule name
+ *        [ "ORDERING" woid              ; Matching Rule name
+ *        [ "SUBSTR" woid ]              ; Matching Rule name
+ *        [ "SYNTAX" whsp noidlen whsp ] ; see section 4.3
+ *        [ "SINGLE-VALUE" whsp ]        ; default multi-valued
+ *        [ "COLLECTIVE" whsp ]          ; default not collective
+ *        [ "NO-USER-MODIFICATION" whsp ]; default user modifiable
+ *        [ "USAGE" whsp AttributeUsage ]; default userApplications
+ *        whsp ")"
+ *
+ *    AttributeUsage =
+ *        "userApplications"     /
+ *        "directoryOperation"   /
+ *        "distributedOperation" / ; DSA-shared
+ *        "dSAOperation"          ; DSA-specific, value depends on server
+ * </PRE>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPSchemaElement
+ **/
+
+public class LDAPAttributeSchema extends LDAPSchemaElement {
+
+    static final long serialVersionUID = 2482595821879862595L;
+
+    /**
+     * Constructs a blank element.
+     */
+    protected LDAPAttributeSchema() {
+        super();
+    }
+
+    /**
+     * Constructs an attribute type definition, using the specified
+     * information.
+     * @param name name of the attribute type
+     * @param oid object identifier (OID) of the attribute type
+     * in dotted-string format (for example, "1.2.3.4")
+     * @param description description of attribute type
+     * @param syntax syntax of this attribute type. The value of this
+     * argument can be one of the following:
+     * <UL>
+     * <LI><CODE>cis</CODE> (case-insensitive string)
+     * <LI><CODE>ces</CODE> (case-exact string)
+     * <LI><CODE>binary</CODE> (binary data)
+     * <LI><CODE>int</CODE> (integer)
+     * <LI><CODE>telephone</CODE> (telephone number -- identical to cis,
+     * but blanks and dashes are ignored during comparisons)
+     * <LI><CODE>dn</CODE> (distinguished name)
+     * </UL>
+     * @param single <CODE>true</CODE> if the attribute type is single-valued
+     */
+    public LDAPAttributeSchema( String name, String oid, String description,
+                                int syntax, boolean single ) {
+        this( name, oid, description, cisString, single );
+        syntaxElement.syntax = syntax;
+        String syntaxType = syntaxElement.internalSyntaxToString( syntax );
+        if ( syntaxType != null ) {
+            syntaxElement.syntaxString = syntaxType;
+        }
+        setQualifier( SYNTAX, getSyntaxString() );
+    }
+
+    /**
+     * Constructs an attribute type definition, using the specified
+     * information.
+     * @param name name of the attribute type
+     * @param oid object identifier (OID) of the attribute type
+     * in dotted-string format (for example, "1.2.3.4")
+     * @param description description of attribute type
+     * @param syntaxString syntax of this attribute type in dotted-string
+     * format (for example, "1.2.3.4.5")
+     * @param single <CODE>true</CODE> if the attribute type is single-valued
+     */
+    public LDAPAttributeSchema( String name, String oid, String description,
+                                String syntaxString, boolean single ) {
+        this( name, oid, description, syntaxString, single, null, null );
+    }
+
+    /**
+     * Constructs an attribute type definition, using the specified
+     * information.
+     * @param name name of the attribute type
+     * @param oid object identifier (OID) of the attribute type
+     * in dotted-string format (for example, "1.2.3.4")
+     * @param description description of attribute type
+     * @param syntaxString syntax of this attribute type in dotted-string
+     * format (for example, "1.2.3.4.5")
+     * @param single <CODE>true</CODE> if the attribute type is single-valued
+     * @param superior superior attribute as a name or OID; <CODE>null</CODE>
+     * if there is no superior
+     * @param aliases names which are to be considered aliases for this
+     * attribute; <CODE>null</CODE> if there are no aliases
+     */
+    public LDAPAttributeSchema( String name, String oid, String description,
+                                String syntaxString, boolean single,
+                                String superior, String[] aliases ) {
+        super( name, oid, description, aliases );
+        attrName = "attributetypes";
+        syntaxElement.syntax = syntaxElement.syntaxCheck( syntaxString );
+        syntaxElement.syntaxString = syntaxString;
+        setQualifier( SYNTAX, syntaxElement.syntaxString );
+        if ( single ) {
+            setQualifier( SINGLE, "" );
+        }
+        if ( (superior != null) && (superior.length() > 0) ) {
+            setQualifier( SUPERIOR, superior );
+        }
+    }
+
+    /**
+     * Constructs an attribute type definition based on a description in
+     * the AttributeTypeDescription format. For information on this format,
+     * (see <A HREF="http://www.ietf.org/rfc/rfc2252.txt"
+     * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+     * Attribute Syntax Definitions</A>.  This is the format that LDAP servers
+     * and clients use to exchange schema information.  (For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the attributes "objectclasses" and "attributetypes".  The
+     * values of "attributetypes" are attribute type descriptions
+     * in this format.)
+     * <P>
+     *
+     * @param raw definition of the attribute type in the
+     * AttributeTypeDescription format
+     */
+    public LDAPAttributeSchema( String raw ) {
+        attrName = "attributetypes";
+        parseValue( raw );
+        String val = (String)properties.get( SYNTAX );
+        if ( val != null ) {
+            syntaxElement.syntaxString = val;
+            syntaxElement.syntax = syntaxElement.syntaxCheck( val );
+        }
+    }
+
+    /**
+     * Determines if the attribute type is single-valued.
+     * @return <code>true</code> if single-valued,
+     * <code>false</code> if multi-valued.
+     */
+    public boolean isSingleValued() {
+        return (properties != null) ? properties.containsKey( SINGLE ) :
+            false;
+    }
+
+    /**
+     * Gets the name of the attribute that this attribute inherits from,
+     * if any.
+     * @return the name of the attribute from which this attribute
+     * inherits, or <CODE>null</CODE> if it does not have a superior.
+     */
+    public String getSuperior() {
+        String[] val = getQualifier( SUPERIOR );
+        return ((val != null) && (val.length > 0)) ? val[0] : null;
+    }
+
+    /**
+     * Gets the syntax of the schema element
+     * @return one of the following values:
+     * <UL>
+     * <LI><CODE>cis</CODE> (case-insensitive string)
+     * <LI><CODE>ces</CODE> (case-exact string)
+     * <LI><CODE>binary</CODE> (binary data)
+     * <LI><CODE>int</CODE> (integer)
+     * <LI><CODE>telephone</CODE> (telephone number -- identical to cis,
+     * but blanks and dashes are ignored during comparisons)
+     * <LI><CODE>dn</CODE> (distinguished name)
+     * <LI><CODE>unknown</CODE> (not a known syntax)
+     * </UL>
+     */
+    public int getSyntax() {
+        return syntaxElement.syntax;
+    }
+
+    /**
+     * Gets the syntax of the attribute type in dotted-decimal format,
+     * for example "1.2.3.4.5"
+     * @return The attribute syntax in dotted-decimal format.
+     */
+    public String getSyntaxString() {
+        return syntaxElement.syntaxString;
+    }
+
+    /**
+     * Prepares a value in RFC 2252 format for submission to a server
+     *
+     * @param quotingBug <CODE>true</CODE> if SUP and SYNTAX values are to
+     * be quoted. This is required to work with bugs in certain LDAP servers.
+     * @return a String ready for submission to an LDAP server.
+     */
+    String getValue( boolean quotingBug ) {
+        String s = getValuePrefix();
+        String val = getValue( SUPERIOR, false );
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        val = getOptionalValues( MATCHING_RULES );
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        val = getValue( SYNTAX, quotingBug );
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        if ( isSingleValued() ) {
+            s += SINGLE + ' ';
+        }
+        val = getOptionalValues( NOVALS );
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        val = getOptionalValues( new String[] {USAGE} );
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        val = getCustomValues();
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        s += ')';
+        return s;
+    }
+
+    /**
+     * Gets the definition of the attribute type in a user friendly format.
+     * This is the format that the attribute type definition uses when
+     * printing the attribute type or the schema.
+     * @return definition of the attribute type in a user friendly format.
+     */
+    public String toString() {
+        String s = "Name: " + name + "; OID: " + oid + "; Type: ";
+        s += syntaxElement.syntaxToString();
+        s += "; Description: " + description + "; ";
+        if ( isSingleValued() ) {
+            s += "single-valued";
+        } else {
+            s += "multi-valued";
+        }
+        s += getQualifierString( IGNOREVALS );
+        s += getAliasString();
+        return s;
+    }
+
+    // Predefined qualifiers
+    public static final String EQUALITY = "EQUALITY";
+    public static final String ORDERING = "ORDERING";
+    public static final String SUBSTR = "SUBSTR";
+    public static final String SINGLE = "SINGLE-VALUE";
+    public static final String COLLECTIVE = "COLLECTIVE";
+    public static final String NO_USER_MODIFICATION = "NO-USER-MODIFICATION";
+    public static final String USAGE = "USAGE";
+    
+    // Qualifiers known to not have values; prepare a Hashtable
+    static String[] NOVALS = { SINGLE,
+                               COLLECTIVE,
+                               NO_USER_MODIFICATION };
+    static {
+        for( int i = 0; i < NOVALS.length; i++ ) {
+            novalsTable.put( NOVALS[i], NOVALS[i] );
+        }
+    }
+    static final String[] MATCHING_RULES = { EQUALITY,
+                                             ORDERING,
+                                             SUBSTR };
+    // Qualifiers which we output explicitly in toString()
+    static final String[] IGNOREVALS = { SINGLE,
+                                         OBSOLETE,
+                                         SUPERIOR,
+                                         SINGLE,
+                                         COLLECTIVE,
+                                         NO_USER_MODIFICATION,
+                                         SYNTAX};
+
+    protected LDAPSyntaxSchemaElement syntaxElement =
+        new LDAPSyntaxSchemaElement();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPConstraints.java
@@ -0,0 +1,406 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * Represents a set of operation preferences.
+ * You can set these preferences for a particular operation
+ * by creating an <CODE>LDAPConstraints</CODE> object,
+ * specifying your preferences, and passing the object to
+ * the proper <CODE>LDAPConnection</CODE> method.
+ * <P>
+ *
+ * @version 1.0
+ */
+public class LDAPConstraints implements Cloneable, java.io.Serializable {
+
+    static final long serialVersionUID = 6506767263918312029L;
+    private int m_hop_limit;
+    private LDAPBind m_bind_proc;
+    private LDAPRebind m_rebind_proc;
+    private boolean referrals;
+    private int m_time_limit;
+    private LDAPControl[] m_clientControls;
+    private LDAPControl[] m_serverControls;
+
+    /**
+     * Constructs an <CODE>LDAPConstraints</CODE> object that specifies
+     * the default set of constraints.
+     */
+    public LDAPConstraints() {
+        m_time_limit = 0;
+        referrals = false;
+        m_bind_proc = null;
+        m_rebind_proc = null;
+        m_hop_limit = 5;
+        m_clientControls = null;
+        m_serverControls = null;
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPConstraints</CODE> object and allows you
+     * to specify the constraints in that object.
+     * <P>
+     * @param msLimit maximum time in milliseconds to wait for results (0
+     * by default, which means that there is no maximum time limit)
+     * @param doReferrals specify <CODE>true</CODE> to follow referrals
+     * automatically, or <CODE>False</CODE> to throw an
+     * <CODE>LDAPReferralException</CODE> error if the server sends back
+     * a referral (<CODE>False</CODE> by default)
+     * @param rebind_proc specifies the object that
+     * implements the <CODE>LDAPRebind</CODE> interface (you need to
+     * define this class).  The object will be used when the client
+     * follows referrals automatically.  The object provides the client
+     * with a method for getting the distinguished name and password
+     * used to authenticate to another LDAP server during a referral.
+     * (This field is <CODE>null</CODE> by default.)
+     * @param hop_limit maximum number of referrals to follow in a
+     * sequence when attempting to resolve a request
+     * @see netscape.ldap.LDAPConnection#setOption(int, java.lang.Object)
+     */
+    public LDAPConstraints( int msLimit, boolean doReferrals, 
+        LDAPRebind rebind_proc, int hop_limit) {
+        m_time_limit = msLimit;
+        referrals = doReferrals;
+        m_bind_proc = null;
+        m_rebind_proc = rebind_proc;
+        m_hop_limit = hop_limit;
+        m_clientControls = null;
+        m_serverControls = null;
+    }
+    
+    /**
+     * Constructs a new <CODE>LDAPConstraints</CODE> object and allows you
+     * to specify the constraints in that object.
+     * <P>
+     * @param msLimit Mmaximum time in milliseconds to wait for results (0
+     * by default, which means that there is no maximum time limit)
+     * @param doReferrals specify <CODE>true</CODE> to follow referrals
+     * automatically, or <CODE>False</CODE> to throw an
+     * <CODE>LDAPReferralException</CODE> error if the server sends back
+     * a referral (<CODE>False</CODE> by default)
+     * @param bind_proc specifies the object that 
+     * implements the <CODE>LDAPBind</CODE> interface (you need to
+     * define this class).  The object will be used to authenticate to the
+     * server on referrals. (This field is <CODE>null</CODE> by default.)
+     * @param hop_limit maximum number of referrals to follow in a
+     * sequence when attempting to resolve a request
+     * @see netscape.ldap.LDAPConnection#setOption(int, java.lang.Object)
+     */
+    public LDAPConstraints( int msLimit, boolean doReferrals, 
+        LDAPBind bind_proc, int hop_limit) {
+        m_time_limit = msLimit;
+        referrals = doReferrals;
+        m_bind_proc = bind_proc;
+        m_rebind_proc = null;
+        m_hop_limit = hop_limit;
+        m_clientControls = null;
+        m_serverControls = null;
+    }
+
+    /**
+     * Returns the maximum number of milliseconds to wait for any operation
+     * under these constraints. If 0, there is no maximum time limit
+     * on waiting for the operation results.
+     * @return maximum number of milliseconds to wait for operation results.
+     */
+    public int getTimeLimit() {
+        return m_time_limit;
+    }
+
+
+    /**
+     * Specifies whether nor not referrals are followed automatically.
+     * Returns <CODE>true</CODE> if referrals are to be followed automatically,
+     * or <CODE>false</CODE> if referrals throw an 
+     * <CODE>LDAPReferralException</CODE>.
+     * @return <CODE>true</CODE> if referrals are followed automatically, 
+     * <CODE>false</CODE> if referrals throw an 
+     * <CODE>LDAPReferralException</CODE>.
+     */
+    public boolean getReferrals() {
+        return referrals;
+    }
+
+    /**
+     * Returns the object that provides the mechanism for authenticating to the 
+     * server on referrals. This object must implement the <CODE>LDAPBind</CODE>
+     * interface.
+     * @return object to use to authenticate to the server on referrals.
+     * @see netscape.ldap.LDAPBind
+     */
+    public LDAPBind getBindProc() {
+        return m_bind_proc;
+    }
+
+    /**
+     * Returns the object that provides the method for getting
+     * authentication information. This object must 
+     * implement the <CODE>LDAPRebind</CODE> interface.
+     * @return object to use to obtain information for
+     * authenticating to other LDAP servers during referrals.
+     * @see netscape.ldap.LDAPRebind
+     * @see netscape.ldap.LDAPRebindAuth
+     */
+    public LDAPRebind getRebindProc() {
+        return m_rebind_proc;
+    }
+
+    /**
+     * Returns the maximum number of hops to follow during a referral.
+     * @return maximum number of hops to follow during a referral.
+     */
+    public int getHopLimit() {
+        return m_hop_limit;
+    }
+
+    /**
+     * Returns any client controls to be applied by the client
+     * to LDAP operations.
+     * @return client controls for the client to apply to LDAP operations.
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public LDAPControl[] getClientControls() {
+        return m_clientControls;
+    }
+
+    /**
+     * Returns any server controls to be applied by the server
+     * to LDAP operations.
+     * @return server controls for the server to apply to LDAP operations.
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public LDAPControl[] getServerControls() {
+        return m_serverControls;
+    }
+
+    /**
+     * Sets the maximum number of milliseconds to wait for any operation
+     * under these constraints. If 0, there is no maximum time limit
+     * on waiting for the operation results. If the time limit is exceeded,
+     * an LDAPException with the result code <CODE>LDAPException.TIME_LIMIT
+     * </CODE> is thrown.
+     * @param msLimit Maximum number of milliseconds to wait for operation
+     * results (0 by default, which means that there is no maximum time 
+     * limit.)
+     * @see netscape.ldap.LDAPException#LDAP_TIMEOUT
+     */
+    public void setTimeLimit( int msLimit ) {
+        m_time_limit = msLimit;
+    }
+
+
+    /**
+     * Specifies whether or not referrals are followed automatically.
+     * Specify <CODE>true</CODE> if referrals are to be followed automatically,
+     * or <CODE>false</CODE> if referrals are to throw an 
+     * <CODE>LDAPReferralException</CODE>. 
+     * (By default, this is set to <CODE>false</CODE>.)
+     * <P>
+     * If you set this to <CODE>true</CODE>, you need to create an object of 
+     * this class that implements either the <CODE>LDAPRebind</CODE> or 
+     * <CODE>LDAPBind</CODE> interface. The <CODE>LDAPRebind</CODE> object 
+     * identifies the method for retrieving authentication information which
+     * will be used when connecting to other LDAP servers during referrals. 
+     * This object should be passed to the <CODE>setRebindProc</CODE> method.
+     * Alternatively, the <CODE>LDAPBind</CODE> object identifies an 
+     * authentication mechanism to be used instead of the default 
+     * authentication mechanism when following referrals. This 
+     * object should be passed to the <CODE>setBindProc</CODE> method.
+     * @param doReferrals set to <CODE>true</CODE> if referrals should be 
+     * followed automatically, or <CODE>False</CODE> if referrals should throw 
+     * an <CODE>LDAPReferralException</CODE>
+     * @see netscape.ldap.LDAPBind
+     * @see netscape.ldap.LDAPRebind
+     * @see netscape.ldap.LDAPRebindAuth
+     */
+    public void setReferrals( boolean doReferrals ) {
+        referrals = doReferrals;
+    }
+
+    /**
+     * Sets the object that provides the mechanism for authenticating 
+     * to the server on referrals. This object must implement 
+     * the <CODE>LDAPBind</CODE> interface.(By default, this is 
+     * <CODE>null</CODE>.) This method sets the <CODE>LDAPRebind</CODE>
+     * object to null for this constraint.
+     * @param bind_proc object to use to authenticate to the server
+     * on referrals
+     * @see netscape.ldap.LDAPBind
+     */
+    public void setBindProc( LDAPBind bind_proc ) {
+        m_bind_proc = bind_proc;
+        if (bind_proc != null) {
+            m_rebind_proc = null;
+        }
+    }
+
+    /**
+     * Specifies the object that provides the method for getting
+     * authentication information.  This object must belong to a class
+     * that implements the <CODE>LDAPRebind</CODE> interface.
+     * (By default, this is <CODE>null</CODE>.) This method sets the 
+     * <CODE>LDAPBind</CODE> object to null for this constraint. 
+     * @param rebind_proc object to use to obtain information for
+     * authenticating to other LDAP servers during referrals
+     */
+    public void setRebindProc( LDAPRebind rebind_proc ) {
+        m_rebind_proc = rebind_proc;
+        if (rebind_proc != null) {
+            m_bind_proc = null;
+        }
+    }
+
+    /**
+     * Sets maximum number of hops to follow in sequence during a referral.
+     * (By default, this is 5.)
+     * @param hop_limit maximum number of hops to follow during a referral
+     */
+    public void setHopLimit( int hop_limit ) {
+        m_hop_limit = hop_limit;
+    }
+
+    /**
+     * Sets a client control for LDAP operations.
+     * @param control client control for LDAP operations
+     * @see netscape.ldap.LDAPControl
+     */
+    public void setClientControls( LDAPControl control ) {
+        m_clientControls = new LDAPControl[1];
+        m_clientControls[0] = control;
+    }
+
+    /**
+     * Sets an array of client controls for LDAP operations.
+     * @param controls array of client controls for LDAP operations
+     * @see netscape.ldap.LDAPControl
+     */
+    public void setClientControls( LDAPControl[] controls ) {
+        m_clientControls = controls;
+    }
+
+    /**
+     * Sets a server control for LDAP operations.
+     * @param control server control for LDAP operations
+     * @see netscape.ldap.LDAPControl
+     */
+    public void setServerControls( LDAPControl control ) {
+        m_serverControls = new LDAPControl[1];
+        m_serverControls[0] = control;
+    }
+
+    /**
+     * Sets an array of server controls for LDAP operations.
+     * @param controls an array of server controls for LDAP operations
+     * @see netscape.ldap.LDAPControl
+     */
+    public void setServerControls( LDAPControl[] controls ) {
+        m_serverControls = controls;
+    }
+
+    /**
+     * Return a string representation of the object for debugging
+     *
+     * @return A string representation of the object
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer("LDAPConstraints {");
+        sb.append("time limit " + getTimeLimit() + ", ");
+        sb.append("referrals " + getReferrals() + ", ");
+        sb.append("hop limit " + getHopLimit() + ", ");
+        sb.append("bind_proc " + getBindProc() + ", ");
+        sb.append("rebind_proc " + getRebindProc());
+        LDAPControl[] controls = getClientControls();
+        if ( controls != null ) {
+            sb.append(", client controls ");
+            for (int i =0; i < controls.length; i++) {
+                sb.append(controls[i].toString());
+                if ( i < (controls.length - 1) ) {
+                    sb.append(" ");
+                }
+            }
+        }
+        controls = getServerControls();
+        if ( controls != null ) {
+            sb.append(", server controls ");
+            for (int i =0; i < controls.length; i++) {
+                sb.append(controls[i].toString());
+                if ( i < (controls.length - 1) ) {
+                    sb.append(" ");
+                }
+            }
+        }
+        sb.append('}');
+
+        return sb.toString();
+    }
+
+    /**
+     * Makes a copy of an existing set of constraints.
+     * @return a copy of an existing set of constraints
+     */
+    public Object clone() {
+        try {         
+            LDAPConstraints o = (LDAPConstraints) super.clone();
+
+            if ( (this.m_clientControls != null) &&
+                 (this.m_clientControls.length > 0) ) {
+                o.m_clientControls = new LDAPControl[this.m_clientControls.length];
+                for( int i = 0; i < this.m_clientControls.length; i++ )
+                    o.m_clientControls[i] = 
+                        (LDAPControl)this.m_clientControls[i].clone();
+            }
+            if ( (this.m_serverControls != null) && 
+                 (this.m_serverControls.length > 0) ) {
+                o.m_serverControls = new LDAPControl[this.m_serverControls.length];
+                for( int i = 0; i < this.m_serverControls.length; i++ )
+                    o.m_serverControls[i] = 
+                        (LDAPControl)this.m_serverControls[i].clone();
+            }
+            return o;
+        }
+        catch (CloneNotSupportedException ex) {
+            // shold never happen, the class is Cloneable
+            return null;
+        }
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSSLSocketFactory.java
@@ -0,0 +1,330 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.io.*;
+import java.net.*;
+
+/**
+ * Creates an SSL socket connection to an LDAP Server.  This class
+ * implements the <CODE>LDAPSSLSocketFactoryExt</CODE> interface.
+ * <P>
+ *
+ * To construct an object of this class, you need to specify the
+ * name of a class that implements the <CODE>javax.net.ssl.SSLSocket</CODE>
+ * interface.  If you do not specify a class name, the class
+ * <CODE>netscape.net.SSLSocket</CODE> is used by default.  This
+ * class is included with Netscape Communicator 4.05 and up.
+ * <P>
+ *
+ * If you are using a Java VM that provides certificate database
+ * management (such as Netscape Communicator), you can authenticate
+ * your client to a secure LDAP server by using certificates.
+ * <P>
+ *
+ * @version 1.0
+ * @see LDAPSSLSocketFactoryExt
+ * @see LDAPConnection#LDAPConnection(netscape.ldap.LDAPSocketFactory)
+ */
+public class LDAPSSLSocketFactory
+             implements LDAPSSLSocketFactoryExt, java.io.Serializable {
+
+    static final long serialVersionUID = -3331456736649381427L;
+
+    /**
+     * Indicates if client authentication is on.
+     */
+    private boolean m_clientAuth = false;
+    /**
+     * Name of class implementing SSLSocket.
+     */
+    private String m_packageName = "netscape.net.SSLSocket";
+
+    /**
+     * The cipher suites
+     */
+    private Object m_cipherSuites = null;
+
+    /**
+     * Constructs an <CODE>LDAPSSLSocketFactory</CODE> object using
+     * the default SSL socket implementation,
+     * <CODE>netscape.net.SSLSocket</CODE>. (This class is provided
+     * with Netscape Communicator 4.05 and higher.)
+     */
+    public LDAPSSLSocketFactory() {
+    }
+
+    /**
+     * Constructs an <CODE>LDAPSSLSocketFactory</CODE> object using
+     * the default SSL socket implementation,
+     * <CODE>netscape.net.SSLSocket</CODE>. (This class is provided
+     * with Netscape Communicator 4.05 and up.)
+     * @param clientAuth <CODE>true</CODE> if certificate-based client
+     * authentication is desired. By default, client authentication is
+     * not used.
+     */
+    public LDAPSSLSocketFactory(boolean clientAuth) {
+        m_clientAuth = clientAuth;
+    }
+
+    /**
+     * Constructs an <CODE>LDAPSSLSocketFactory</CODE> object using
+     * the specified class. The class must implement the interface
+     * <CODE>javax.net.ssl.SSLSocket</CODE>.
+     * @param className the name of a class implementing
+     * the <CODE>javax.net.ssl.SSLSocket</CODE> interface.
+     * Pass <code>null</code> for this parameter to use the
+     * default SSL socket implementation,
+     * <CODE>netscape.net.SSLSocket</CODE>, which is included with
+     * Netscape Communicator 4.05 and higher.
+     */
+    public LDAPSSLSocketFactory(String className) {
+        m_packageName = new String(className);
+    }
+
+    /**
+     * Constructs an <CODE>LDAPSSLSocketFactory</CODE> object using
+     * the specified class. The class must implement the interface
+     * <CODE>javax.net.ssl.SSLSocket</CODE>.
+     * @param className the name of a class implementing
+     * the <CODE>javax.net.ssl.SSLSocket</CODE> interface.
+     * Pass <code>null</code> for this parameter to use the
+     * default SSL socket implementation,
+     * <CODE>netscape.net.SSLSocket</CODE>, which is included with
+     * Netscape Communicator 4.05 and higher.
+     * @param clientAuth <CODE>true</CODE> if certificate-based client
+     * authentication is desired. By default, client authentication is
+     * not used.
+     */
+    public LDAPSSLSocketFactory(String className, boolean clientAuth) {
+        m_packageName = new String(className);
+        m_clientAuth = clientAuth;
+    }
+
+    /**
+     * The constructor with the specified package for security and the specified
+     * cipher suites.
+     * @param className the name of a class implementing the interface
+     * <CODE>javax.net.ssl.SSLSocket</CODE>.
+     * Pass <code>null</code> for this parameter to use the
+     * default SSL socket implementation,
+     * <CODE>netscape.net.SSLSocket</CODE>, which is included with
+     * Netscape Communicator 4.05 and higher.
+     * @param cipherSuites the cipher suites to use for SSL connections
+     */
+    public LDAPSSLSocketFactory(String className, Object cipherSuites) {
+        m_packageName = new String(className);
+        m_cipherSuites = cipherSuites;
+    }
+
+    /**
+     * The constructor with the specified package for security and the specified
+     * cipher suites.
+     * @param className the name of a class implementing the interface
+     * <CODE>javax.net.ssl.SSLSocket</CODE>.
+     * Pass <code>null</code> for this parameter to use the
+     * default SSL socket implementation,
+     * <CODE>netscape.net.SSLSocket</CODE>, which is included with
+     * Netscape Communicator 4.05 and higher.
+     * @param cipherSuites the cipher suites to use for SSL connections
+     * @param clientAuth <CODE>true</CODE> if certificate-based client
+     * authentication is desired. By default, client authentication is
+     * not used.
+     */
+    public LDAPSSLSocketFactory(String className, Object cipherSuites,
+      boolean clientAuth) {
+        m_packageName = new String(className);
+        m_cipherSuites = cipherSuites;
+        m_clientAuth = clientAuth;
+    }
+
+    /**
+     * Enables certificate-based client authentication for an
+     * application. The application must be running in a Java VM
+     * that provides transparent certificate database management
+     * (for example, Netscape Communicator's Java VM).
+     * Call this method before you call <CODE>makeSocket</CODE>.
+     * @see netscape.ldap.LDAPSSLSocketFactory#isClientAuth
+     * @see netscape.ldap.LDAPSSLSocketFactory#makeSocket
+     * Note: enableClientAuth() is deprecated. This method is replaced
+     * by any one of the following constructors:
+     * <p>
+     * <CODE>LDAPSSLSocketFactory(boolean)</CODE>
+     * <CODE>LDAPSSLSocketFactory(java.lang.String, boolean)</CODE>
+     * <CODE>LDAPSSLSocketFactory(java.lang.String, java.lang.Object, boolean)</CODE>
+     */
+    public void enableClientAuth() {
+        m_clientAuth = true;
+    }
+
+
+    /**
+     * <B>This method is currently not implemented</B>.
+     * Enables client authentication for an application that uses
+     * an external (file-based) certificate database.
+     * Call this method before you call <CODE>makeSocket</CODE>.
+     * @param certdb the pathname for the certificate database
+     * @param keydb the pathname for the private key database
+     * @param keypwd the password for the private key database
+     * @param certnickname the alias for the certificate
+     * @param keynickname the alias for the key
+     * @see netscape.ldap.LDAPSSLSocketFactory#isClientAuth
+     * @see netscape.ldap.LDAPSSLSocketFactory#makeSocket
+     * @exception LDAPException Since this method is not yet implemented,
+     * calling this method throws an exception.
+     * Note: <CODE>enableClientAuth(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)</CODE> is deprecated. 
+     * This method is replaced by any one of the following constructors:
+     * <p>
+     * <CODE>LDAPSSLSocketFactory(boolean)</CODE>
+     * <CODE>LDAPSSLSocketFactory(java.lang.String, boolean)</CODE>
+     * <CODE>LDAPSSLSocketFactory(java.lang.String, java.lang.Object, boolean)</CODE>
+     */
+    public void enableClientAuth(String certdb, String keydb, String keypwd,
+      String certnickname, String keynickname) throws LDAPException {
+        throw new LDAPException("Client auth not supported now");
+    }
+
+    /**
+     * Returns <code>true</code> if client authentication is enabled.
+     * @see netscape.ldap.LDAPSSLSocketFactory
+     */
+    public boolean isClientAuth() {
+        return m_clientAuth;
+    }
+
+    /**
+     * Returns the name of the class that implements SSL sockets for this factory.
+     *
+     * @return the name of the class that implements SSL sockets for this factory.
+     */
+    public String getSSLSocketImpl() {
+        return m_packageName;
+    }
+
+    /**
+     * Returns the suite of ciphers used for SSL connections made through
+     * sockets created by this factory.
+     *
+     * @return the suite of ciphers used.
+     */
+    public Object getCipherSuites() {
+        return m_cipherSuites;
+    }
+
+    /**
+     * Returns a socket to the LDAP server with the specified
+     * host name and port number.
+     * @param host the host to connect to
+     * @param port the port number
+     * @return the socket to the host name and port number.
+     * @exception LDAPException A socket to the specified host and port
+     * could not be created.
+     * @see netscape.ldap.LDAPSSLSocketFactory
+     */
+    public Socket makeSocket(String host, int port)
+      throws LDAPException {
+
+        Socket s = null;
+
+        if (m_clientAuth) {
+            try {
+                /* Check if running in Communicator; if so, enable client
+                   auth */
+                String[] types = { "java.lang.String" };
+                java.lang.reflect.Method m =
+                    DynamicInvoker.getMethod(
+                        "netscape.security.PrivilegeManager",
+                        "enablePrivilege",
+                        types );
+                if (m != null) {
+                    Object[] args = new Object[1];
+                    args[0] = new String("ClientAuth");
+                    m.invoke( null, args);
+                }
+            } catch (Exception e) {
+                String msg = "LDAPSSLSocketFactory.makeSocket: invoking " +
+                    "enablePrivilege: " + e.toString();
+                throw new LDAPException(msg, LDAPException.PARAM_ERROR);
+            }
+        }
+
+        try {
+            String cipherClassName = null;
+            if (m_cipherSuites != null)
+                cipherClassName = m_cipherSuites.getClass().getName();
+
+            /* Instantiate the SSLSocketFactory implementation, and
+               find the right constructor */
+            Class c = Class.forName(m_packageName);
+            java.lang.reflect.Constructor[] m = c.getConstructors();
+            for (int i = 0; i < m.length; i++) {
+                /* Check if the signature is right: String, int */
+                Class[] params = m[i].getParameterTypes();
+                if ( (m_cipherSuites == null) && (params.length == 2) &&
+                     (params[0].getName().equals("java.lang.String")) &&
+                     (params[1].getName().equals("int")) ) {
+                    Object[] args = new Object[2];
+                    args[0] = host;
+                    args[1] = new Integer(port);
+                    s = (Socket)(m[i].newInstance(args));
+                    return s;
+                } else if ( (m_cipherSuites != null) && (params.length == 3) &&
+                     (params[0].getName().equals("java.lang.String")) &&
+                     (params[1].getName().equals("int")) &&
+                     (params[2].getName().equals(cipherClassName)) ) {
+                    Object[] args = new Object[3];
+                    args[0] = host;
+                    args[1] = new Integer(port);
+                    args[2] = m_cipherSuites;
+                    s = (Socket)(m[i].newInstance(args));
+                    return s;
+                }
+            }
+            throw new LDAPException("No appropriate constructor in " +
+                                  m_packageName,
+                                  LDAPException.PARAM_ERROR);
+        } catch (ClassNotFoundException e) {
+            throw new LDAPException("Class " + m_packageName + " not found",
+                                  LDAPException.PARAM_ERROR);
+        } catch (Exception e) {
+            throw new LDAPException("Failed to create SSL socket",
+                                  LDAPException.CONNECT_ERROR);
+        }
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSearchResultReference.java
@@ -0,0 +1,76 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import netscape.ldap.client.opers.JDAPSearchResultReference;
+/**
+ * An LDAPSearchResultReference object encapsulates a continuation
+ * reference from a search operation.
+ * 
+ * @version 1.0
+ */
+public class LDAPSearchResultReference extends LDAPMessage {
+
+    static final long serialVersionUID = -7816778029315223117L;
+
+    /**
+     * A list of LDAP URLs that are referred to.
+     */
+    private String m_URLs[];
+    
+    /**
+     * Constructor
+     * 
+     * @param msgid message identifier
+     * @param resRef search result reference response
+     * @param controls array of controls or null
+     * @see netscape.ldap.LDAPEntry
+     */
+    LDAPSearchResultReference(int msgid, JDAPSearchResultReference resRef, LDAPControl[]controls) {
+        super(msgid, resRef, controls);    
+        m_URLs = resRef.getUrls();
+    }
+    
+    /**
+     * Returns a list of LDAP URLs that are referred to.
+     * @return a list of URLs.
+     */
+    public String[] getUrls() {
+        return m_URLs;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPResponseListener.java
@@ -0,0 +1,114 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+
+/**
+ * Represents the message queue associated with a particular LDAP
+ * operation or operations.
+ * 
+ */
+public class LDAPResponseListener extends LDAPMessageQueue{
+
+    static final long serialVersionUID = 901897097111294329L;
+
+    /**
+     * Constructor
+     * @param asynchOp a boolean flag that is true if the object is used for 
+     * asynchronous LDAP operations
+     * @see netscape.ldap.LDAPAsynchronousConnection
+     */
+    LDAPResponseListener(boolean asynchOp) {
+        super(asynchOp);
+    }
+    
+    /**
+     * Blocks until a response is available, or until all operations
+     * associated with the object have completed or been canceled, and
+     * returns the response.
+     *
+     * @return a response for an LDAP operation or null if there are no
+     * more outstanding requests.
+     * @exception LDAPException Network error exception
+     * @exception LDAPInterruptedException The invoking thread was interrupted
+     */
+    public LDAPResponse getResponse() throws LDAPException {
+        return (LDAPResponse)nextMessage();
+    }
+
+    /**
+     * Merge two response listeners.
+     * Move/append the content from another response listener to this one.
+     * <P>
+     * To be used for synchronization of asynchronous LDAP operations where
+     * requests are sent by one thread but processed by another one.
+     * <P>
+     * A client may be implemented in such a way that one thread makes LDAP
+     * requests and calls l.getMessageIDs(), while another thread
+     * is responsible for processing of responses (call l.getResponse()).
+     * Both threads are using
+     * the same listener objects. In such a case, a race
+     * condition may occur, where a LDAP response message is retrieved and
+     * the request terminated (request ID removed) before the first thread
+     * has a chance to execute l.getMessageIDs().
+     * The proper way to handle this scenario is to create a separate listener
+     * for each new request, and after l.getMessageIDs() has been invoked, merge the
+     * new request with the existing one.
+     * @param listener2 the listener with which to merge
+     */
+    public void merge(LDAPResponseListener listener2) {
+        super.merge(listener2);
+    }
+    
+    /**
+     * Reports true if a response has been received from the server.
+     *
+     * @return a flag indicating whether the response message queue is empty.
+     */
+    public boolean isResponseReceived() {
+        return super.isMessageReceived();
+    }
+
+    /**
+     * Returns message IDs for all outstanding requests
+     * @return message ID array.
+     */
+    public int[] getMessageIDs() {
+        return super.getMessageIDs();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPCompareAttrNames.java
@@ -0,0 +1,361 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.text.*;
+
+/**
+ * Compares LDAP entries based on one or more attribute values.
+ * <P>
+ *
+ * To use this comparison for sorting search results, pass
+ * an object of this class to the <CODE>sort</CODE> method in
+ * <CODE>LDAPSearchResults</CODE>.
+ * <P>
+ *
+ * @version 1.0
+ * @see LDAPEntryComparator
+ * @see LDAPSearchResults#sort
+ */
+
+public class LDAPCompareAttrNames
+             implements LDAPEntryComparator, java.io.Serializable {
+
+    static final long serialVersionUID = -2567450425231175944L;
+    private String m_attrs[];
+    private boolean m_ascending[];
+    private Locale m_locale = null;
+    private Collator m_collator = null;
+    private boolean m_sensitive = true;
+
+    /**
+     * Constructs a comparator that compares the string values of
+     * a named attribute in LDAP entries and sorts the entries in
+     * ascending order.
+     * <P>
+     *
+     * @param attribute name of attribute for comparisons
+     */
+    public LDAPCompareAttrNames (String attribute) {
+        m_attrs = new String[1];
+        m_attrs[0] = attribute;
+        m_ascending = new boolean[1];
+        m_ascending[0] = true;
+    }
+
+    /**
+     * Constructs a comparator that compares the string values of
+     * a named attribute in LDAP entries and that allows you to sort
+     * entries either in ascending or descending order.
+     * <P>
+     *
+     * @param attribute name of attribute for comparisons
+     * @param ascendingFlag if <CODE>true</CODE>, sort in ascending order
+     */
+    public LDAPCompareAttrNames (String attribute,
+                                 boolean ascendingFlag) {
+        m_attrs = new String[1];
+        m_attrs[0] = attribute;
+        m_ascending = new boolean[1];
+        m_ascending[0] = ascendingFlag;
+    }
+
+    /**
+     * Constructs a comparator that compares the string values of
+     * a set of named attributes in LDAP entries and that sort
+     * the entries in ascending order.
+     * <P>
+     *
+     * Use an array of strings to specify the set of attributes
+     * to use for sorting.  If the values of the first attribute 
+     * (the name specified in <CODE>attribute[0]</CODE>) are equal, 
+     * then the values of the next attribute are compared.
+     * <P>
+     *
+     * For example, if <CODE>attributes[0] = "cn"</CODE> and
+     * <CODE>attributes[1]="uid"</CODE>, results are first sorted
+     * by the <CODE>cn</CODE> attribute.  If two entries have the
+     * same value for <CODE>cn</CODE>, then the <CODE>uid</CODE>
+     * attribute is used to sort the entries.
+     * <P>
+     *
+     * @param attributes array of the attribute names used for comparisons
+     */
+    public LDAPCompareAttrNames (String[] attributes) {
+        m_attrs = attributes;
+        m_ascending = new boolean[attributes.length];
+        for( int i = 0; i < attributes.length; i++ )
+            m_ascending[i] = true;
+    }
+
+    /**
+     * Constructs a comparator that compares the string values of
+     * a set of named attributes in LDAP entries and allows you
+     * to sort the entries in ascending or descending order.
+     * <P>
+     *
+     * Use an array of strings to specify the set of attributes
+     * to use for sorting.  If the values of the first attribute 
+     * (the name specified in <CODE>attribute[0]</CODE>)
+     * are equal, then the values of the next attribute are compared.
+     * <P>
+     *
+     * For example, if <CODE>attributes[0] = "cn"</CODE> and
+     * <CODE>attributes[1]="uid"</CODE>, results are first sorted
+     * by the <CODE>cn</CODE> attribute.  If two entries have the
+     * same value for <CODE>cn</CODE>, then the <CODE>uid</CODE>
+     * attribute is used to sort the entries.
+     * <P>
+     *
+     * Use an array of boolean values to specify whether each attribute
+     * should be sorted in ascending or descending order.  For example,
+     * suppose that <CODE>attributes[0] = "cn"</CODE> and
+     * <CODE>attributes[1]="roomNumber"</CODE>.  If
+     * <CODE>ascendingFlags[0]=true</CODE> and
+     * <CODE>ascendingFlags[1]=false</CODE>, attributes are sorted first by
+     * <CODE>cn</CODE> in ascending order, then by <CODE>roomNumber</CODE>
+     * in descending order.
+     * <P>
+     *
+     * If the size of the array of attribute names is not the same as
+     * the size of the array of boolean values, an
+     * <CODE>LDAPException</CODE> is thrown.
+     * <P>
+     *
+     * @param attributes array of the attribute names to use for comparisons
+     * @param ascendingFlags array of boolean values specifying ascending
+     * or descending order to use for each attribute name. If
+     * <CODE>true</CODE>, the attributes are sorted in ascending order.
+     */
+    public LDAPCompareAttrNames (String[] attributes,
+                                 boolean[] ascendingFlags) {
+        m_attrs = attributes;
+        m_ascending = ascendingFlags;
+        if ( m_ascending == null ) {
+            m_ascending = new boolean[attributes.length];
+            for( int i = 0; i < attributes.length; i++ )
+                m_ascending[i] = true;
+        }
+    }
+
+    /**
+     * Gets the locale, if any, used for collation. If the locale is null,
+     * an ordinary string comparison is used for sorting.
+     *
+     * @return the locale used for collation, or null.
+     */
+    public Locale getLocale() {
+        return m_locale;
+    }
+
+    /**
+     * Set the locale, if any, used for collation. If the locale is null,
+     * an ordinary string comparison is used for sorting. If sorting
+     * has been set to case-insensitive, the collation strength is set
+     * to Collator.PRIMARY, otherwise to Collator.IDENTICAL. If a
+     * different collation strength setting is required, use the signature
+     * that takes a collation strength parameter.
+     *
+     * @param locale the locale used for collation, or null.
+     */
+    public void setLocale( Locale locale ) {
+        if ( m_sensitive ) {
+            setLocale( locale, Collator.IDENTICAL );
+        } else {
+            setLocale( locale, Collator.PRIMARY );
+        }
+    }
+
+    /**
+     * Sets the locale, if any, used for collation. If the locale is null,
+     * an ordinary string comparison is used for sorting.
+     *
+     * @param locale the locale used for collation, or null.
+     * @param strength collation strength: Collator.PRIMARY,
+     * Collator.SECONDARY, Collator.TERTIARY, or Collator.IDENTICAL
+     */
+    public void setLocale( Locale locale, int strength ) {
+        m_locale = locale;
+        if ( m_locale == null ) {
+            m_collator = null;
+        } else {
+            m_collator = Collator.getInstance( m_locale );
+            m_collator.setStrength(strength);
+        }
+    }
+
+    /**
+     * Gets the state of the case-sensitivity flag. This only applies to
+     * Unicode sort order; for locale-specific sorting, case-sensitivity
+     * is controlled by the collation strength.
+     *
+     * @return <code>true</code> for case-sensitive sorting; this is
+     * the default
+     */
+    public boolean getCaseSensitive() {
+        return m_sensitive;
+    }
+
+    /**
+     * Sets the state of the case-sensitivity flag. This only applies to
+     * Unicode sort order; for locale-specific sorting, case-sensitivity
+     * is controlled by the collation strength.
+     *
+     * @param sensitive <code>true</code> for case-sensitive sorting;
+     * this is the default
+     */
+    public void setCaseSensitive( boolean sensitive ) {
+        m_sensitive = sensitive;
+    }
+
+    /**
+     * Returns <CODE>true</CODE> if the value of the attribute in the first entry is greater
+     * than the value of the attribute in the second entry.
+     * <P>
+     *
+     * If one of the entries is missing the attribute, the other is
+     * considered greater.  By default, the first entry is greater.
+     * <P>
+     *
+     * If either entry contains multiple values, only the first value
+     * is used for comparisons.
+     * <P>
+     *
+     * @param greater entry against which to test
+     * @param less entry to test
+     * @return <CODE>true</CODE> if (<CODE>greater &gt; less</CODE>).
+     */
+    public boolean isGreater (LDAPEntry greater, LDAPEntry less) {
+        if (greater.equals (less)) return false;
+        return attrGreater (greater, less, 0);
+    }
+
+    /**
+     * Compares a particular attribute in both entries. If equal,
+     * moves on to the next.
+     * @param greater greater arg from isGreater
+     * @param less less arg from isGreater
+     * @param attrPos the index in an array of attributes, indicating
+     * the attribute to compare
+     * @return (greater > less)
+     */
+    boolean attrGreater (LDAPEntry greater, LDAPEntry less,
+                         int attrPos) {
+        Enumeration greaterAttrSet =
+            greater.getAttributeSet().getAttributes();
+        Enumeration lessAttrSet =
+            less.getAttributeSet().getAttributes();
+
+        String greaterValue = null;
+        String lessValue = null;
+        String attrName = m_attrs[attrPos];
+        boolean ascending = m_ascending[attrPos];
+
+        try {
+            while (lessAttrSet.hasMoreElements()) {
+                LDAPAttribute currAttr =
+                    (LDAPAttribute)(lessAttrSet.nextElement());
+                if (!attrName.equalsIgnoreCase (currAttr.getName()))
+                    continue;
+                lessValue =
+                    (String)(currAttr.getStringValues().nextElement());
+                break;
+            }
+
+            while (greaterAttrSet.hasMoreElements()) {
+                LDAPAttribute currAttr =
+                    (LDAPAttribute)(greaterAttrSet.nextElement());
+                if (!attrName.equalsIgnoreCase (currAttr.getName()))
+                    continue;
+                greaterValue =
+                    (String)(currAttr.getStringValues().nextElement());
+                break;
+            }
+        }
+        catch (ClassCastException cce) {
+            // i.e. one of the enumerations did not contain the
+            // right type !?
+            return false;
+        }
+        catch (NoSuchElementException nse) {
+            // i.e. one of the attributes had no values !?
+            return false;
+        }
+
+        if ((lessValue == null) ^ (greaterValue == null))
+            return greaterValue != null;
+
+        // Check for equality
+        if ( (lessValue == null) ||
+             ((m_collator != null) &&
+              (m_collator.compare( greaterValue, lessValue ) == 0) ) ||
+             ((m_collator == null) && m_sensitive &&
+              lessValue.equals(greaterValue)) ||
+             ((m_collator == null) && !m_sensitive &&
+              lessValue.equalsIgnoreCase(greaterValue)) ) {
+
+            if (attrPos == m_attrs.length - 1) {
+                return false;
+            } else {
+                return attrGreater (greater, less, attrPos+1);
+            }
+        }
+
+        // Not equal, check for order
+        if ( ascending ) {
+            if ( m_collator != null ) {
+                return ( m_collator.compare( greaterValue, lessValue ) > 0 );
+            } else if ( m_sensitive ) {
+                return (greaterValue.compareTo (lessValue) > 0);
+            } else {
+                return (greaterValue.toLowerCase().compareTo (
+                    lessValue.toLowerCase()) > 0);
+            }
+        } else {
+            if ( m_collator != null ) {
+                return ( m_collator.compare( greaterValue, lessValue ) < 0 );
+            } else if ( m_sensitive ) {
+                return (greaterValue.compareTo (lessValue) < 0);
+            } else {
+                return (greaterValue.toLowerCase().compareTo (
+                    lessValue.toLowerCase()) < 0);
+            }
+        }
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPMatchingRuleSchema.java
@@ -0,0 +1,404 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ingo Schaefer (ingo.schaefer@fh-brandenburg.de)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * The definition of a matching rule in the schema.
+ * <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+ * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+ * Attribute Syntax Definitions</A> covers the types of information
+ * that need to be specified in the definition of a matching rule.
+ * According to the RFC, the description of a matching rule can
+ * include the following information:
+ * <P>
+ *
+ * <UL>
+ * <LI>an OID identifying the matching rule
+ * <LI>a name identifying the matching rule
+ * <LI>a description of the matching rule
+ * <LI>the syntax of the matching rule
+ * </UL>
+ * <P>
+ *
+ * The <CODE>LDAPMatchingRuleSchema</CODE> class also specifies
+ * the matching rule "use description", which describes the
+ * attributes which can be used with the matching rule.
+ * <P>
+ *
+ * When you construct an <CODE>LDAPMatchingRuleSchema</CODE> object, you can
+ * specify these types of information as arguments to the constructor or
+ * in the MatchingRuleDescription and MatchingRuleUseDescription formats
+ * specified in RFC 2252.
+ * When an LDAP client searches an LDAP server for the schema, the server
+ * returns schema information as an object with attribute values in this
+ * format.
+ * <P>
+ *
+ * You can get the name, OID, and description of this matching rule
+ * definition by using the <CODE>getName</CODE>, <CODE>getOID</CODE>, and
+ * <CODE>getDescription</CODE> methods inherited from the abstract class
+ * <CODE>LDAPSchemaElement</CODE>. Custom qualifiers are
+ * accessed with <CODE>getQualifier</CODE> and <CODE>getQualifierNames</CODE>
+ * from <CODE>LDAPSchemaElement</CODE>.
+  * <P>
+ *
+ * To add or remove this matching rule definition from the
+ * schema, use the <CODE>add</CODE> and <CODE>remove</CODE>
+ * methods, which this class inherits from the <CODE>LDAPSchemaElement</CODE>
+ * abstract class.
+ * <P>
+ * RFC 2252 defines MatchingRuleDescription and MatchingRuleUseDescription
+ * as follows:
+ * <P>
+ * <PRE>
+ *    MatchingRuleDescription = "(" whsp
+ *        numericoid whsp  ; MatchingRule identifier
+ *        [ "NAME" qdescrs ]
+ *        [ "DESC" qdstring ]
+ *        [ "OBSOLETE" whsp ]
+ *        "SYNTAX" numericoid
+ *    whsp ")"
+ *
+ * Values of the matchingRuleUse list the attributes which are suitable
+ * for use with an extensible matching rule.
+ *
+ *    MatchingRuleUseDescription = "(" whsp
+ *        numericoid whsp  ; MatchingRule identifier
+ *        [ "NAME" qdescrs ]
+ *        [ "DESC" qdstring ]
+ *        [ "OBSOLETE" ]
+ *       "APPLIES" oids    ; AttributeType identifiers
+ *    whsp ")"
+ * </PRE>
+ * <P>
+ * <CODE>LDAPMatchingRuleSchema</CODE> abstracts away from the two types and
+ * manages their relationships transparently.
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPSchemaElement
+ **/
+
+public class LDAPMatchingRuleSchema extends LDAPAttributeSchema {
+
+    static final long serialVersionUID = 6466155218986944131L;
+
+    /**
+     * Constructs a matching rule definition, using the specified
+     * information.
+     * @param name name of the matching rule
+     * @param oid object identifier (OID) of the matching rule
+     * in dotted-decimal format (for example, "1.2.3.4")
+     * @param description description of the matching rule
+     * @param attributes array of the OIDs of the attributes for which
+     * the matching rule is applicable
+     * @param syntax syntax of this matching rule. The value of this
+     * argument can be one of the following:
+     * <UL>
+     * <LI><CODE>cis</CODE> (case-insensitive string)
+     * <LI><CODE>ces</CODE> (case-exact string)
+     * <LI><CODE>binary</CODE> (binary data)
+     * <LI><CODE>int</CODE> (integer)
+     * <LI><CODE>telephone</CODE> (telephone number -- identical to cis,
+     * but blanks and dashes are ignored during comparisons)
+     * <LI><CODE>dn</CODE> (distinguished name)
+     * </UL>
+     */
+    public LDAPMatchingRuleSchema( String name, String oid,
+                                   String description,
+                                   String[] attributes, int syntax ) {
+        this( name, oid, description, attributes, cisString );
+        syntaxElement.syntax = syntax;
+        String syntaxType = syntaxElement.internalSyntaxToString( syntax );
+        if ( syntaxType != null ) {
+            syntaxElement.syntaxString = syntaxType;
+        }
+        setQualifier( SYNTAX, syntaxElement.syntaxString );
+    }
+
+    /**
+     * Constructs a matching rule definition, using the specified
+     * information.
+     * @param name name of the matching rule.
+     * @param oid object identifier (OID) of the matching rule
+     * in dotted-decimal format (for example, "1.2.3.4").
+     * @param description description of the matching rule.
+     * @param attributes array of the OIDs of the attributes for which
+     * the matching rule is applicable.
+     * @param syntaxString syntax of this matching rule in dotted-decimal
+     * format
+     */
+    public LDAPMatchingRuleSchema( String name, String oid,
+                                   String description,
+                                   String[] attributes,
+                                   String syntaxString ) {
+        this( name, oid, description, attributes, syntaxString, null );
+    }
+
+    /**
+     * Constructs a matching rule definition, using the specified
+     * information.
+     * @param name name of the matching rule.
+     * @param oid object identifier (OID) of the matching rule
+     * in dotted-decimal format (for example, "1.2.3.4").
+     * @param description description of the matching rule.
+     * @param attributes array of the OIDs of the attributes for which
+     * the matching rule is applicable.
+     * @param syntaxString syntax of this matching rule in dotted-decimal
+     * format
+     * @param aliases names which are to be considered aliases for this
+     * matching rule; <CODE>null</CODE> if there are no aliases
+     */
+    public LDAPMatchingRuleSchema( String name, String oid,
+                                   String description,
+                                   String[] attributes,
+                                   String syntaxString,
+                                   String[] aliases ) {
+        if ( (oid == null) || (oid.trim().length() < 1) ) {
+            throw new IllegalArgumentException( "OID required" );
+        }
+        this.name = name;
+        this.oid = oid;
+        this.description = description;
+        attrName = "matchingrules";
+        syntaxElement.syntax = syntaxElement.syntaxCheck( syntaxString );
+        syntaxElement.syntaxString = syntaxString;
+        setQualifier( SYNTAX, syntaxElement.syntaxString );
+        this.attributes = new String[attributes.length];
+        for( int i = 0; i < attributes.length; i++ ) {
+            this.attributes[i] = attributes[i];
+        }
+        if ( (aliases != null) && (aliases.length > 0) ) {
+            this.aliases = aliases;
+        }
+    }
+
+    /**
+     * Constructs a matching rule definition based on descriptions in
+     * the MatchingRuleDescription format and MatchingRuleUseDescription
+     * format. For information on this format,
+     * (see <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+     * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+     * Attribute Syntax Definitions</A>. This is the format that LDAP servers
+     * and clients use to exchange schema information. For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with attributes that include "matchingrule" and "matchingruleuse".
+     * The values of these attributes are matching rule descriptions
+     * in this format.
+     * <P>
+     *
+     * @param raw definition of the matching rule in the
+     * MatchingRuleDescription format
+     * @param use definition of the use of the matching rule in the
+     * MatchingRuleUseDescription format
+     */
+    public LDAPMatchingRuleSchema( String raw, String use ) {
+        attrName = "matchingrules";
+        if ( raw != null ) {
+            parseValue( raw );
+        }
+        if ( use != null ) {
+            parseValue( use );
+        }
+	Object p = properties.get( "APPLIES" );
+	if ( p instanceof Vector ) {
+		Vector v = (Vector) p;
+		if ( v != null ) {
+			attributes = new String[v.size()];
+			v.copyInto( attributes );
+			v.removeAllElements();
+		}
+        }
+	else if ( p instanceof String ) {
+		attributes = new String[1];
+		attributes[0] = (String) p;
+	}
+        String val = (String)properties.get( "SYNTAX" );
+        if ( val != null ) {
+            syntaxElement.syntaxString = val;
+            syntaxElement.syntax = syntaxElement.syntaxCheck( val );
+        }
+    }
+
+    /**
+     * Gets the list of the OIDs of the attribute types which can be used
+     * with the matching rule.
+     * @return array of the OIDs of the attribute types which can be used
+     * with the matching rule.
+     */
+    public String[] getAttributes() {
+        return attributes;
+    }
+
+    /**
+     * Prepare a value in RFC 2252 format for submitting to a server
+     *
+     * @param quotingBug <CODE>true</CODE> if SUP and SYNTAX values are to
+     * be quoted; that is to satisfy bugs in certain LDAP servers.
+     * @return a String ready to be submitted to an LDAP server
+     */
+    String getValue( boolean quotingBug ) {
+        String s = getValuePrefix();
+        if ( syntaxElement.syntaxString != null ) {
+            s += "SYNTAX ";
+            if ( quotingBug ) {
+                s += '\'';
+            }
+            s += syntaxElement.syntaxString;
+            if ( quotingBug ) {
+                s += '\'';
+            }
+            s += ' ';
+        }
+        String val = getCustomValues();
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        s += ')';
+        return s;
+    }
+
+    /**
+     * Gets the matching rule definition in the string representation
+     * of the MatchingRuleDescription data type defined in X.501 (see
+     * <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+     * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol
+     * (v3): Attribute Syntax Definitions</A>
+     * for a description of these formats).
+     * This is the format that LDAP servers and clients use to exchange
+     * schema information.  (For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the attributes "matchingrules" and "matchingruleuse".  The
+     * values of these attributes are matching rule description and
+     * matching rule use description in these formats.)
+     * <P>
+     *
+     * @return a string in a format that can be used as the value of
+     * the <CODE>matchingrule</CODE> attribute (which describes
+     * a matching rule in the schema) of a <CODE>subschema</CODE> object
+     */
+    public String getValue() {
+        return getValue( false );
+    }
+
+    /**
+     * Gets the matching rule use definition in the string representation
+     * of the MatchingRuleUseDescription data type defined in X.501 (see
+     * <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+     * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol
+     * (v3): Attribute Syntax Definitions</A>
+     * for a description of these formats).
+     * This is the format that LDAP servers and clients use to exchange
+     * schema information.  (For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the attributes "matchingrules" and "matchingruleuse".  The
+     * values of these attributes are matching rule description and
+     * matching rule use description in these formats.)
+     * <P>
+     *
+     * @return a string in a format that can be used as the value of
+     * the <CODE>matchingruleuse</CODE> attribute (which describes the use of
+     * a matching rule in the schema) of a <CODE>subschema</CODE> object
+     */
+    public String getUseValue() {
+        String s = getValuePrefix();
+        if ( (attributes != null) && (attributes.length > 0) ) {
+            s += "APPLIES ( ";
+            for( int i = 0; i < attributes.length; i++ ) {
+                if ( i > 0 )
+                    s += " $ ";
+                s += attributes[i];
+            }
+            s += " ) ";
+        }
+        s += ')';
+        return s;
+    }
+
+    /**
+     * Adds, removes or modifies the definition from a Directory.
+     * @param ld an open connection to a Directory Server. Typically the
+     * connection must have been authenticated to add a definition.
+     * @param op type of modification to make
+     * @param name name of attribute in the schema entry to modify. This
+     * is ignored here.
+     * @param dn the entry at which to update the schema
+     * @exception LDAPException if the definition can't be added/removed
+     */
+    protected void update( LDAPConnection ld, int op, String name, String dn )
+                            throws LDAPException {
+        LDAPAttribute[] attrs = new LDAPAttribute[2];
+        attrs[0] = new LDAPAttribute( "matchingRules",
+                                      getValue() );
+        /* Must update the matchingRuleUse value as well */
+        attrs[1] = new LDAPAttribute( "matchingRuleUse",
+                                      getUseValue() );
+        update( ld, op, attrs, dn );
+    }
+
+    /**
+     * Gets the definition of the matching rule in a user friendly format.
+     * This is the format that the matching rule definition uses when
+     * you print the matching rule or the schema.
+     * @return definition of the matching rule in a user friendly format.
+     */
+    public String toString() {
+        String s = "Name: " + name + "; OID: " + oid + "; Type: ";
+        s += syntaxElement.syntaxToString();
+        s += "; Description: " + description;
+        if ( attributes != null ) {
+            s += "; Applies to: ";
+            for( int i = 0; i < attributes.length; i++ ) {
+                if ( i > 0 )
+                    s += ", ";
+                s += attributes[i];
+            }
+        }
+        s += getQualifierString( EXPLICIT );
+        s += getAliasString();
+        return s;
+    }
+
+    // Qualifiers tracked explicitly
+    static final String[] EXPLICIT = { OBSOLETE,
+                                       SYNTAX };
+    
+    private String[] attributes = null;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPNameFormSchema.java
@@ -0,0 +1,311 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * The definition of a name form in the schema.
+ * <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+ * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+ * Attribute Syntax Definitions</A> covers the types of information
+ * that need to be specified in the definition of a name form.
+ * According to the RFC, the description of a name form can
+ * include the following information:
+ * <P>
+ *
+ * <UL>
+ * <LI>an OID identifying the name form
+ * <LI>a name identifying the name form
+ * <LI>a description of the name form
+ * <LI>the structural object class of this name form
+ * <LI>the list of attribute types that are required in this name form
+ * <LI>the list of attribute types that are allowed (optional) in this
+ * name form
+ * </UL>
+ * <P>
+ *
+ * When you construct an <CODE>LDAPNameFormSchema</CODE> object,
+ * you can specify
+ * these types of information as arguments to the constructor or in the
+ * NameFormDescription format specified in RFC 2252.
+ * When an LDAP client searches an LDAP server for the schema, the server
+ * returns schema information as an object with attribute values in this
+ * format.
+ * <P>
+ *
+ * You can get the name, OID, and description of this name form
+ * definition by using the <CODE>getName</CODE>, <CODE>getOID</CODE>, and
+ * <CODE>getDescription</CODE> methods inherited from the abstract class
+ * <CODE>LDAPSchemaElement</CODE>. Optional and custom qualifiers are
+ * accessed with <CODE>getQualifier</CODE> and <CODE>getQualifierNames</CODE>
+ * from <CODE>LDAPSchemaElement</CODE>.
+ 
+ * <P>
+ *
+ * To add or remove this name form definition from the
+ * schema, use the <CODE>add</CODE> and <CODE>remove</CODE>
+ * methods, which this class inherits from the <CODE>LDAPSchemaElement</CODE>
+ * abstract class.
+ * <P>
+ * RFC 2252 defines NameFormDescription as follows:
+ * <P>
+ * <PRE>
+ *    NameFormDescription = "(" whsp
+ *        numericoid whsp      ; NameForm identifier
+ *        [ "NAME" qdescrs ]
+ *        [ "DESC" qdstring ]
+ *        [ "OBSOLETE" whsp ]
+ *        "OC" woid            ; Structural ObjectClass
+ *        [ "MUST" oids ]      ; AttributeTypes
+ *        [ "MAY" oids ]       ; AttributeTypes
+ *    whsp ")"
+ * </PRE>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPSchemaElement
+ **/
+public class LDAPNameFormSchema extends LDAPSchemaElement {
+
+    static final long serialVersionUID = 1665316286199590403L;
+
+    /**
+     * Constructs a name form definition, using the specified
+     * information.
+     * @param name name of the name form
+     * @param oid object identifier (OID) of the name form
+     * in dotted-string format (for example, "1.2.3.4")
+     * @param description description of the name form
+     * @param obsolete <code>true</code> if the rule is obsolete
+     * @param objectClass the object to which this name form applies.
+     * This may either be specified by name or numeric oid.
+     * @param required array of names of attributes required
+     * in this name form
+     * @param optional array of names of optional attributes
+     * allowed in this name form
+     */
+    public LDAPNameFormSchema( String name, String oid,
+                               String description, boolean obsolete,
+                               String objectClass,
+                               String[] required, String[] optional ) {
+        super( name, oid, description, null );
+        attrName = "nameforms";
+        if ( obsolete ) {
+            setQualifier( OBSOLETE, "" );
+        }
+        this.objectClass = objectClass;
+        if ( required != null ) {
+            for( int i = 0; i < required.length; i++ ) {
+                must.addElement( required[i] );
+            }
+        }
+        if ( optional != null ) {
+            for( int i = 0; i < optional.length; i++ ) {
+                may.addElement( optional[i] );
+            }
+        }
+    }
+
+    /**
+     * Constructs a name form definition based on a description in
+     * the NameFormDescription format.  For information on this format,
+     * (see <A HREF="http://ds.internic.net/rfc/rfc2252.txt"
+     * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+     * Attribute Syntax Definitions</A>.  This is the format that LDAP servers
+     * and clients use to exchange schema information.  (For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the attributes "objectclasses" and "attributetypes".  The
+     * values of the "objectclasses" attribute are name form descriptions
+     * in this format.)
+     * <P>
+     *
+     * @param raw definition of the object in the NameFormDescription
+     * format
+     */
+    public LDAPNameFormSchema( String raw ) {
+        attrName = "objectclasses";
+        parseValue( raw );
+        Object o = properties.get( "MAY" );
+        if ( o != null ) {
+            if ( o instanceof Vector ) {
+                may = (Vector)o;
+            } else {
+                may.addElement( o );
+            }
+        }
+        o = properties.get( "MUST" );
+        if ( o != null ) {
+            if ( o instanceof Vector ) {
+                must = (Vector)o;
+            } else {
+                must.addElement( o );
+            }
+        }
+        o = properties.get( "OC" );
+        if ( o != null ) {
+            objectClass = (String)o;
+        }
+    }
+
+    /**
+     * Gets the names of the required attributes for
+     * this name form.
+     * @return the names of the required attributes
+     * for this name form.
+     */
+    public String[] getRequiredNamingAttributes() {
+        String[] vals = new String[must.size()];
+        must.copyInto( vals );
+        return vals;
+    }
+
+    /**
+     * Gets the names of optional attributes allowed
+     * in this name form.
+     * @return the names of optional attributes
+     * allowed in this name form.
+     */
+    public String[] getOptionalNamingAttributes() {
+        String[] vals = new String[may.size()];
+        may.copyInto( vals );
+        return vals;
+    }
+
+    /**
+     * Returns the name of the object class that this name form applies to.
+     *
+     * @return the name of the object class that this name form applies to.
+     */
+    public String getObjectClass() {
+        return objectClass;
+    }
+
+    /**
+     * Prepares a value in RFC 2252 format for submitting to a server.
+     *
+     * @param quotingBug <CODE>true</CODE> if SUP and SYNTAX values are to
+     * be quoted. That is to satisfy bugs in certain LDAP servers.
+     * @return a String ready for submission to an LDAP server.
+     */
+    String getValue( boolean quotingBug ) {
+        String s = getValuePrefix();
+        String val = getOptionalValues( NOVALS );
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        s += "OC " + objectClass + ' ';
+        if ( must.size() > 0 ) {
+            s += "MUST " + vectorToList( must );
+            s += ' ';
+        }
+        if ( may.size() > 0 ) {
+            s += "MAY " + vectorToList( may );
+            s += ' ';
+        }
+        val = getCustomValues();
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        s += ')';
+        return s;
+    }
+
+    /**
+     * Gets the definition of the name form in a user friendly format.
+     * This is the format that the name form definition uses when
+     * you print the name form or the schema.
+     * @return definition of the name form in a user friendly format.
+     */
+    public String toString() {
+        String s = "Name: " + name + "; OID: " + oid;
+        s += "; Description: " + description + "; Required: ";
+        String[] vals = getRequiredNamingAttributes();
+        for( int i = 0; i < vals.length; i++ ) {
+            if ( i > 0 )
+                s += ", ";
+            s += vals[i];
+        }
+        s += "; Optional: ";
+        vals = getOptionalNamingAttributes();
+        for( int i = 0; i < vals.length; i++ ) {
+            if ( i > 0 )
+                s += ", ";
+            s += vals[i];
+        }
+        if ( isObsolete() ) {
+            s += "; OBSOLETE";
+        }
+        s += getQualifierString( IGNOREVALS );
+        return s;
+    }
+
+    /**
+     * Creates a list within parentheses, with $ as delimiter
+     *
+     * @param vals values for list
+     * @return a String with a list of values.
+     */
+    protected String vectorToList( Vector vals ) {
+        String val = "( ";
+        for( int i = 0; i < vals.size(); i++ ) {
+            val += (String)vals.elementAt(i) + ' ';
+            if ( i < (vals.size() - 1) ) {
+                val += "$ ";
+            }
+        }
+        val += ')';
+        return val;
+    }
+
+    private Vector must = new Vector();
+    private Vector may = new Vector();
+    private String objectClass = null;
+
+    // Qualifiers known to not have values; prepare a Hashtable
+    static final String[] NOVALS = { "OBSOLETE" };
+    static {
+        for( int i = 0; i < NOVALS.length; i++ ) {
+            novalsTable.put( NOVALS[i], NOVALS[i] );
+        }
+    }
+
+    // Qualifiers which we output explicitly in toString()
+    static final String[] IGNOREVALS = { "MUST", "MAY",
+                                         "OBJECTCLASS", "OBSOLETE"};
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSearchConstraints.java
@@ -0,0 +1,451 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+/**
+ * Represents a set of search preferences.
+ * You can set these preferences for a particular search
+ * by creating an <CODE>LDAPSearchConstraints</CODE> object,
+ * specifying your preferences, and passing the object to
+ * the <CODE>LDAPConnection.search</CODE> method.
+ * <P>
+ *
+ * @version 1.0
+ */
+public class LDAPSearchConstraints extends LDAPConstraints 
+                                   implements Cloneable {
+
+
+    // Constants for behavior when a search continuation reference cannot
+    // be followed
+    /**
+     * Continue processing if there is an error following a search continuation
+     * reference
+     */
+    public static final int REFERRAL_ERROR_CONTINUE = 0;
+    /**
+     * Throw exception if there is an error following a search continuation
+     * reference
+     */
+    public static final int REFERRAL_ERROR_EXCEPTION = 1;
+    private int deref;
+    private int maxRes;
+    private int batch;
+    private int serverTimeLimit;
+    private int maxBacklog = 100;
+    private int referralErrors = REFERRAL_ERROR_CONTINUE;
+
+    /**
+     * Constructs an <CODE>LDAPSearchConstraints</CODE> object that specifies
+     * the default set of search constraints.
+     */
+    public LDAPSearchConstraints() {
+        super();
+        deref = 0;
+        maxRes = 1000;
+        batch = 1;
+        serverTimeLimit = 0;
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPSearchConstraints</CODE> object and allows you
+     * to specify the search constraints in that object.
+     * <P>
+     * @param msLimit maximum time in milliseconds to wait for results (0
+     * by default, which means that there is no maximum time limit)
+     * @param dereference either <CODE>LDAPv2.DEREF_NEVER</CODE>,
+     * <CODE>LDAPv2.DEREF_FINDING</CODE>,
+     * <CODE>LDAPv2.DEREF_SEARCHING</CODE>, or
+     * <CODE>LDAPv2.DEREF_ALWAYS</CODE> (see LDAPConnection.setOption).
+     * <CODE>LDAPv2.DEREF_NEVER</CODE> is the default.
+     * @param maxResults maximum number of search results to return
+     * (1000 by default)
+     * @param doReferrals specify <CODE>true</CODE> to follow referrals
+     * automatically, or <CODE>false</CODE> to throw an
+     * <CODE>LDAPReferralException</CODE> error if the server sends back
+     * a referral (<CODE>false</CODE> by default)
+     * @param batchSize specify the number of results to return at a time
+     * (1 by default)
+     * @param rebind_proc specifies the object of the class that
+     * implements the <CODE>LDAPRebind</CODE> interface (you need to
+     * define this class).  The object will be used when the client
+     * follows referrals automatically.  The object provides the client
+     * with a method for getting the distinguished name and password
+     * used to authenticate to another LDAP server during a referral.
+     * (This field is <CODE>null</CODE> by default.)
+     * @param hop_limit maximum number of referrals to follow in a
+     * sequence when attempting to resolve a request
+     * @see netscape.ldap.LDAPConnection#setOption(int, java.lang.Object)
+     * @see netscape.ldap.LDAPConnection#search(netscape.ldap.LDAPUrl,
+netscape.ldap.LDAPSearchConstraints)
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String,
+java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)
+     */
+    public LDAPSearchConstraints( int msLimit, int dereference,
+        int maxResults, boolean doReferrals, int batchSize,
+        LDAPRebind rebind_proc, int hop_limit) {
+        super(msLimit, doReferrals, rebind_proc, hop_limit);
+        deref = dereference;
+        maxRes = maxResults;
+        batch = batchSize;
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPSearchConstraints</CODE> object and allows you
+     * to specify the search constraints in that object.
+     * <P>
+     * @param msLimit maximum time in milliseconds to wait for results (0
+     * by default, which means that there is no maximum time limit)
+     * @param timeLimit maximum time in seconds for the server to spend
+     * processing a search request (the default value is 0, indicating that there
+     * is no limit)
+     * @param dereference either <CODE>LDAPv2.DEREF_NEVER</CODE>,
+     * <CODE>LDAPv2.DEREF_FINDING</CODE>,
+     * <CODE>LDAPv2.DEREF_SEARCHING</CODE>, or
+     * <CODE>LDAPv2.DEREF_ALWAYS</CODE> (see LDAPConnection.setOption).
+     * <CODE>LDAPv2.DEREF_NEVER</CODE> is the default.
+     * @param maxResults maximum number of search results to return
+     * (1000 by default)
+     * @param doReferrals specify <CODE>true</CODE> to follow referrals
+     * automatically, or <CODE>false</CODE> to throw an
+     * <CODE>LDAPReferralException</CODE> error if the server sends back
+     * a referral (<CODE>false</CODE> by default)
+     * @param batchSize specify the number of results to return at a time
+     * (1 by default)
+     * @param rebind_proc specifies the object that
+     * implements the <CODE>LDAPRebind</CODE> interface. 
+     * The object will be used when the client
+     * follows referrals automatically.  The object provides the client
+     * with a method for getting the distinguished name and password
+     * used to authenticate to another LDAP server during a referral.
+     * (This field is <CODE>null</CODE> by default.)
+     * @param hop_limit maximum number of referrals to follow in a
+     * sequence when attempting to resolve a request
+     * @see netscape.ldap.LDAPConnection#setOption(int, java.lang.Object)
+     * @see netscape.ldap.LDAPConnection#search(netscape.ldap.LDAPUrl,
+netscape.ldap.LDAPSearchConstraints)
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String,
+java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)
+     */
+    public LDAPSearchConstraints( int msLimit, int timeLimit,
+                                  int dereference,
+                                  int maxResults, boolean doReferrals,
+                                  int batchSize,
+                                  LDAPRebind rebind_proc,
+                                  int hop_limit) {
+        super(msLimit, doReferrals, rebind_proc, hop_limit);
+        serverTimeLimit = timeLimit;
+        deref = dereference;
+        maxRes = maxResults;
+        batch = batchSize;
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPSearchConstraints</CODE> object and allows you
+     * to specify the search constraints in that object.
+     * <P>
+     * @param msLimit maximum time in milliseconds to wait for results (0
+     * by default, which means that there is no maximum time limit)
+     * @param timeLimit maximum time in seconds for the server to spend
+     * processing a search request (the default value is 0, indicating that there
+     * is no limit)
+     * @param dereference either <CODE>LDAPv2.DEREF_NEVER</CODE>,
+     * <CODE>LDAPv2.DEREF_FINDING</CODE>,
+     * <CODE>LDAPv2.DEREF_SEARCHING</CODE>, or
+     * <CODE>LDAPv2.DEREF_ALWAYS</CODE> (see LDAPConnection.setOption).
+     * <CODE>LDAPv2.DEREF_NEVER</CODE> is the default.
+     * @param maxResults maximum number of search results to return
+     * (1000 by default)
+     * @param doReferrals specify <CODE>true</CODE> to follow referrals
+     * automatically, or <CODE>false</CODE> to throw an
+     * <CODE>LDAPReferralException</CODE> error if the server sends back
+     * a referral (<CODE>false</CODE> by default)
+     * @param batchSize specify the number of results to return at a time
+     * (1 by default)
+     * @param bind_proc specifies the object that
+     * implements the <CODE>LDAPBind</CODE> interface (you need to
+     * define this class).  The object will be used to authenticate
+     * to the server on referrals.
+     * (This field is <CODE>null</CODE> by default.)
+     * @param hop_limit maximum number of referrals to follow in a
+     * sequence when attempting to resolve a request
+     * @see netscape.ldap.LDAPConnection#setOption(int, java.lang.Object)
+     * @see netscape.ldap.LDAPConnection#search(netscape.ldap.LDAPUrl,
+netscape.ldap.LDAPSearchConstraints)
+     * @see netscape.ldap.LDAPConnection#search(java.lang.String, int, java.lang.String,
+java.lang.String[], boolean, netscape.ldap.LDAPSearchConstraints)
+     */
+    public LDAPSearchConstraints( int msLimit, int timeLimit,
+                                  int dereference,
+                                  int maxResults, boolean doReferrals,
+                                  int batchSize,
+                                  LDAPBind bind_proc,
+                                  int hop_limit) {
+        super(msLimit, doReferrals, bind_proc, hop_limit);
+        serverTimeLimit = timeLimit;
+        deref = dereference;
+        maxRes = maxResults;
+        batch = batchSize;
+    }
+
+    /**
+     * Returns the maximum number of seconds to wait for the server to
+     * spend on a search operation.If 0, there is no time limit.
+     * @return maximum number of seconds for the server to spend.
+     */
+    public int getServerTimeLimit() {
+        return serverTimeLimit;
+    }
+
+    /**
+     * Specifies how aliases should be dereferenced.
+     * @return <CODE>LDAPv2.DEREF_NEVER</CODE> to
+     * never follow ("dereference") aliases,
+     * <CODE>LDAPv2.DEREF_FINDING</CODE> to dereference when finding
+     * the starting point for the search (but not when searching
+     * under that starting entry), <CODE>LDAPv2.DEREF_SEARCHING</CODE>
+     * to dereference when searching the entries beneath the
+     * starting point of the search (but not when finding the starting
+     * entry), or <CODE>LDAPv2.DEREF_ALWAYS</CODE> to always
+     * dereference aliases.
+     */
+    public int getDereference() {
+        return deref;
+    }
+
+    /**
+     * Returns the maximum number of search results that are to be returned; 0 means
+     * there is no limit.
+     * @return maximum number of search results to be returned.
+     */
+    public int getMaxResults() {
+        return maxRes;
+    }
+
+    /**
+     * Returns the suggested number of results to return at a time during
+     * search. This should be 0 if intermediate results are not needed, and
+     * 1 if results are to be processed as they come in.
+     * @return number of results to return at a time.
+     */
+    public int getBatchSize() {
+        return batch;
+    }
+
+    /**
+     * Sets the maximum number of seconds for the server to spend
+     * returning search results. If 0, there is no time limit.
+     * @param limit maximum number of seconds for the server to spend.
+     * (0 by default, which means that there is no maximum time limit.)
+     */
+    public void setServerTimeLimit( int limit ) {
+        serverTimeLimit = limit;
+    }
+
+    /**
+     * Sets a preference indicating how aliases should be dereferenced.
+     * @param dereference <CODE>LDAPv2.DEREF_NEVER</CODE> to
+     * never follow ("dereference") aliases,
+     * <CODE>LDAPv2.DEREF_FINDING</CODE> to dereference when finding
+     * the starting point for the search (but not when searching
+     * under that starting entry), <CODE>LDAPv2.DEREF_SEARCHING</CODE>
+     * to dereference when searching the entries beneath the
+     * starting point of the search (but not when finding the starting
+     * entry), or <CODE>LDAPv2.DEREF_ALWAYS</CODE> to always
+     * dereference aliases
+     */
+    public void setDereference( int dereference ) {
+        deref = dereference;
+    }
+
+    /**
+     * Sets the maximum number of search results to return; 0 means
+     * there is no limit. (By default, this is set to 1000.)
+     * @param maxResults maximum number of search results to return
+     */
+    public void setMaxResults( int maxResults ) {
+        maxRes = maxResults;
+    }
+
+    /**
+     * Sets the suggested number of results to return at a time during search.
+     * This should be 0 if intermediate results are not needed, and 1 if
+     * results are to be processed as they come in. (By default, this is 1.)
+     * @param batchSize number of results to return at a time
+     */
+    public void setBatchSize( int batchSize ) {
+        batch = batchSize;
+    }
+
+    /**
+     * Set the maximum number of unread entries any search listener can
+     * have before we stop reading from the server.
+     * @param backlog the maximum number of unread entries per listener
+     * @deprecated Use <CODE>LDAPConnection.setOption()</CODE>
+     */
+    public void setMaxBacklog( int backlog ) {
+        maxBacklog = backlog;
+    }
+
+    /**
+     * Get the maximum number of unread entries any search listener can
+     * have before we stop reading from the server.
+     * @return the maximum number of unread entries per listener.
+     * @deprecated Use <CODE>LDAPConnection.getOption()</CODE>
+     */
+    public int getMaxBacklog() {
+        return maxBacklog;
+    }
+
+    /**
+     * Reports if errors when following search continuation references are
+     * to cause processing of the remaining results to be aborted.
+     * <p>
+     * If an LDAP server does not contain an entry at the base DN for a search,
+     * it may be configured to return a referral. If it contains an entry at
+     * the base DN of a subtree search, one or more of the child entries may
+     * contain search continuation references. The search continuation
+     * references are returned to the client, which may follow them by issuing
+     * a search request to the host indicated in the search reference.
+     * <p>
+     * If the <CODE>LDAPConnection</CODE> object has been configured to follow
+     * referrals automatically, it may fail when issuing a search request to
+     * the host indicated in a search reference, e.g. because there is no
+     * entry there, because it does not have credentials, because it does not
+     * have sufficient permissions, etc. If the client aborts evaluation of the
+     * search results (obtained through <CODE>LDAPSearchResults</CODE>) when a
+     * search reference cannot be followed, any remaining results are discarded.
+     * <p>
+     * Up to version 4.17 of the Java LDAP SDK, the SDK printed an error
+     * message but continued to process the remaining search results and search
+     * continuation references.
+     * <p>
+     * As of SDK version 4.17, the default behavior is still to continue
+     * processing any remaining search results and search continuation
+     * references if there is an error following a referral, but the behavior
+     * may be changed with <CODE>setReferralErrors</CODE> to throw an exception
+     * instead.
+     * 
+     * @return <CODE>REFERRAL_ERROR_CONTINUE</CODE> if remaining results are
+     * to be processed when there is an error following a search continuation
+     * reference, <CODE>REFERRAL_ERROR_EXCEPTION</CODE> if such an error is to
+     * cause an <CODE>LDAPException</CODE>.
+     * 
+     * @see netscape.ldap.LDAPConstraints#setReferrals
+     * @since LDAPJDK 4.17
+     */
+    public int getReferralErrors() {
+        return referralErrors;
+    }
+    
+    /**
+     * Specifies if errors when following search continuation references are
+     * to cause processing of the remaining results to be aborted.
+     * <p>
+     * If an LDAP server does not contain an entry at the base DN for a search,
+     * it may be configured to return a referral. If it contains an entry at
+     * the base DN of a subtree search, one or more of the child entries may
+     * contain search continuation references. The search continuation
+     * references are returned to the client, which may follow them by issuing
+     * a search request to the host indicated in the search reference.
+     * <p>
+     * If the <CODE>LDAPConnection</CODE> object has been configured to follow
+     * referrals automatically, it may fail when issuing a search request to
+     * the host indicated in a search reference, e.g. because there is no
+     * entry there, because it does not have credentials, because it does not
+     * have sufficient permissions, etc. If the client aborts evaluation of the
+     * search results (obtained through <CODE>LDAPSearchResults</CODE>) when a
+     * search reference cannot be followed, any remaining results are discarded.
+     * <p>
+     * Up to version 4.17 of the Java LDAP SDK, the SDK printed an error
+     * message but continued to process the remaining search results and search
+     * continuation references.
+     * <p>
+     * As of SDK version 4.17, the default behavior is still to continue
+     * processing any remaining search results and search continuation
+     * references if there is an error following a referral, but the behavior
+     * may be changed with <CODE>setReferralErrors</CODE> to throw an exception
+     * instead.
+     * 
+     * @param errorBehavior Either <CODE>REFERRAL_ERROR_CONTINUE</CODE> if
+     * remaining results are to be processed when there is an error following a
+     * search continuation reference or <CODE>REFERRAL_ERROR_EXCEPTION</CODE>
+     * if such an error is to cause an <CODE>LDAPException</CODE>.
+     * 
+     * @see netscape.ldap.LDAPSearchConstraints#getReferralErrors
+     * @see netscape.ldap.LDAPSearchResults#next
+     * @see netscape.ldap.LDAPSearchResults#nextElement
+     * @since LDAPJDK 4.17
+     */
+    public void setReferralErrors(int errorBehavior) {
+        if ( (errorBehavior != REFERRAL_ERROR_CONTINUE) &&
+             (errorBehavior != REFERRAL_ERROR_EXCEPTION) ) {
+            throw new IllegalArgumentException( "Invalid error behavior: " +
+                                                errorBehavior );
+        }
+        referralErrors = errorBehavior;
+    }
+
+    /**
+     * Makes a copy of an existing set of search constraints.
+     * @return a copy of an existing set of search constraints.
+     */
+    public Object clone() {
+        LDAPSearchConstraints o = (LDAPSearchConstraints) super.clone();
+        return o;
+    }
+
+    /**
+     * Return a string representation of the object for debugging
+     *
+     * @return A string representation of the object
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer("LDAPSearchConstraints {");
+        sb.append( super.toString() + ' ' );
+        sb.append("size limit " + maxRes + ", ");
+        sb.append("server time limit " + serverTimeLimit + ", ");
+        sb.append("aliases " + deref + ", ");
+        sb.append("batch size " + batch + ", ");
+        sb.append("max backlog " + maxBacklog + ", ");
+        sb.append("referralErrors " + referralErrors);
+        sb.append('}');
+
+        return sb.toString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPAsynchronousConnection.java
@@ -0,0 +1,455 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * Encapsulates a connection to an LDAP server, providing access to the input queue
+ * for messages received. 
+ *
+ * @version 1.0
+ */
+public interface LDAPAsynchronousConnection {
+  
+    /**
+     * Adds an entry to the directory.
+     *
+     * @param entry LDAPEntry object specifying the distinguished name and
+     * attributes of the new entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPSearchListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPEntry
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener add(LDAPEntry entry,
+                                    LDAPResponseListener listener)
+                                    throws LDAPException;
+ 
+    /**
+     * Adds an entry to the directory and allows you to specify constraints
+     * for this LDAP add operation by using an <CODE>LDAPConstraints</CODE>
+     * object. For example, you can specify whether or not to follow referrals.
+     * You can also apply LDAP v3 controls to the operation.
+     * <P>
+     *
+     * @param entry LDAPEntry object specifying the distinguished name and
+     * attributes of the new entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPEntry
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener add(LDAPEntry entry,
+                                    LDAPResponseListener listener,
+                                    LDAPConstraints cons)
+                                    throws LDAPException;
+
+
+    /**
+     * Authenticates to the LDAP server (that the object is currently
+     * connected to) using the specified name and password. If the object
+     * has been disconnected from an LDAP server, this method attempts to
+     * reconnect to the server. If the object had already authenticated, the
+     * old authentication is discarded.
+     * 
+     * @param dn if non-null and non-empty, specifies that the connection
+     * and all operations through it should be authenticated with dn as the
+     * distinguished name
+     * @param passwd if non-null and non-empty, specifies that the connection
+     * and all operations through it should be authenticated with dn as the
+     * distinguished name and passwd as password
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener bind(String dn,
+                                     String passwd,
+                                     LDAPResponseListener listener)
+                                     throws LDAPException;
+
+    /**
+     * Authenticates to the LDAP server (that the object is currently
+     * connected to) using the specified name and password  and allows you
+     * to specify constraints for this LDAP add operation by using an
+     *  <CODE>LDAPConstraints</CODE> object. If the object
+     * has been disconnected from an LDAP server, this method attempts to
+     * reconnect to the server. If the object had already authenticated, the
+     * old authentication is discarded.
+     * 
+     * @param dn if non-null and non-empty, specifies that the connection
+     * and all operations through it should be authenticated with dn as the
+     * distinguished name
+     * @param passwd if non-null and non-empty, specifies that the connection
+     * and all operations through it should be authenticated with dn as the
+     * distinguished name and passwd as password
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener bind(String dn,
+                                     String passwd,
+                                     LDAPResponseListener listener,
+                                     LDAPConstraints cons) 
+                                     throws LDAPException;
+
+
+    
+    /**
+     * Deletes the entry for the specified DN from the directory.
+     * 
+     * @param dn distinguished name of the entry to delete
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener delete(String dn,
+                                       LDAPResponseListener listener)
+                                       throws LDAPException;
+
+    /**
+     * Deletes the entry for the specified DN from the directory.
+     * 
+     * @param dn distinguished name of the entry to delete
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener delete(String dn,
+                                      LDAPResponseListener listener,
+                                      LDAPConstraints cons)
+                                      throws LDAPException;
+
+    
+    /**
+     * Makes a single change to an existing entry in the directory.
+     * For example, changes the value of an attribute, adds a new attribute
+     * value, or removes an existing attribute value.<BR>
+     * The LDAPModification object specifies both the change to be made and
+     * the LDAPAttribute value to be changed.
+     * 
+     * @param dn distinguished name of the entry to modify
+     * @param mod a single change to make to an entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPModification
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener modify(String dn,
+                                       LDAPModification mod,
+                                       LDAPResponseListener listener)
+                                       throws LDAPException;   
+    
+    /**
+     * Makes a single change to an existing entry in the directory.
+     * For example, changes the value of an attribute, adds a new attribute
+     * value, or removes an existing attribute value.<BR>
+     * The LDAPModification object specifies both the change to be made and
+     * the LDAPAttribute value to be changed.
+     * 
+     * @param dn distinguished name of the entry to modify
+     * @param mod a single change to make to an entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPModification
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener modify(String dn,
+                                       LDAPModification mod,
+                                       LDAPResponseListener listener,
+                                       LDAPConstraints cons)
+                                       throws LDAPException;    
+
+    /**
+     * Makes a set of changes to an existing entry in the directory.
+     * For example, changes attribute values, adds new attribute values, or
+     * removes existing attribute values.
+     * <P>
+     * @param dn distinguished name of the entry to modify
+     * @param mods a set of modifications to make to the entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPModificationSet
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener modify(String dn,
+                                       LDAPModificationSet mods,
+                                       LDAPResponseListener listener)
+                                       throws LDAPException;   
+    
+    /**
+     * Makes a set of changes to an existing entry in the directory.
+     * For example, changes attribute values, adds new attribute values, or
+     * removes existing attribute values.
+     * 
+     * @param dn distinguished name of the entry to modify
+     * @param mods a set of modifications to make to the entry
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPModificationSet
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener modify(String dn,
+                                       LDAPModificationSet mods,
+                                       LDAPResponseListener listener,
+                                       LDAPConstraints cons)
+                                       throws LDAPException;    
+    
+
+    /**
+     * Renames an existing entry in the directory.
+     * 
+     * @param dn current distinguished name of the entry
+     * @param newRdn new relative distinguished name for the entry
+     * @param deleteOldRdn if <code>true</code>, the old name is not retained as an
+     * attribute value
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     */
+    public LDAPResponseListener rename(String dn,
+                                       String newRdn,
+                                       boolean deleteOldRdn,
+                                       LDAPResponseListener listener)
+                                       throws LDAPException;
+
+    /**
+     * Renames an existing entry in the directory.
+     * 
+     * @param dn current distinguished name of the entry
+     * @param newRdn new relative distinguished name for the entry
+     * @param deleteOldRdn if <code>true</code>, the old name is not retained as an
+     * attribute value
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to the operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPResponseListener
+     * @see netscape.ldap.LDAPConstraints
+     */
+    public LDAPResponseListener rename(String dn,
+                                       String newRdn,
+                                       boolean deleteOldRdn,
+                                       LDAPResponseListener listener,
+                                       LDAPConstraints cons)
+                                       throws LDAPException;
+    
+    /**
+     * Performs the search specified by the criteria that you enter. <P>
+     * To abandon the search, use the <CODE>abandon</CODE> method.
+     *
+     * @param base the base distinguished name from which to search
+     * @param scope the scope of the entries to search.  You can specify one
+     * of the following: <P>
+     * <UL>
+     * <LI><CODE>LDAPv2.SCOPE_BASE</CODE> (search only the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_ONE</CODE>
+     * (search only those entries that are one level below the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_SUB</CODE>
+     * (search the base DN and all entries within its subtree) <P>
+     * </UL>
+     * <P>
+     * @param filter search filter specifying the search criteria
+     * @param attrs list of attributes to return in the search results
+     * @param typesOnly if <code>true</code>, returns the names but not the values of the
+     * attributes found. If <code>false</code>, returns the names and values of the
+     * attributes found.
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @return LDAPSearchListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPAsynchronousConnection#abandon(netscape.ldap.LDAPSearchListener)
+     */
+    public LDAPSearchListener search(String base,
+                                     int scope,
+                                     String filter,
+                                     String attrs[],
+                                     boolean typesOnly,
+                                     LDAPSearchListener listener)
+                                     throws LDAPException;
+
+    /**
+     * Performs the search specified by the criteria that you enter.
+     * This method also allows you to specify constraints for the search
+     * (such as the maximum number of entries to find or the
+     * maximum time to wait for search results). <P>
+     * To abandon the search, use the <CODE>abandon</CODE> method.
+     *
+     * @param base the base distinguished name from which to search
+     * @param scope the scope of the entries to search.  You can specify one
+     * of the following: <P>
+     * <UL>
+     * <LI><CODE>LDAPv2.SCOPE_BASE</CODE> (search only the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_ONE</CODE>
+     * (search only those entries that are one level below the base DN) <P>
+     * <LI><CODE>LDAPv2.SCOPE_SUB</CODE>
+     * (search the base DN and all entries within its subtree) <P>
+     * </UL>
+     * <P>
+     * @param filter search filter specifying the search criteria
+     * @param attrs list of attributes to return in the search results
+     * @param typesOnly if <code>true</code>, returns the names but not the values of the
+     * attributes found.  If <code>false</code>, returns the names and  values for
+     * attributes found.
+     * @param listener handler for messages returned from a server in response
+     * to this request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to this search (for example, the
+     * maximum number of entries to return)
+     * @return LDAPSearchListener handler for messages returned from a server
+     * in response to this request.
+     * @exception LDAPException Failed to send request.
+     * @see netscape.ldap.LDAPAsynchronousConnection#abandon(netscape.ldap.LDAPSearchListener)
+     */
+    public LDAPSearchListener search(String base,
+                                     int scope,
+                                     String filter,
+                                     String attrs[],
+                                     boolean typesOnly,
+                                     LDAPSearchListener listener,
+                                      LDAPSearchConstraints cons)
+                                     throws LDAPException;
+    
+    /**
+     * Compares an attribute value with one in the directory. The result
+     * is obtained by calling <CODE>getResultCode</CODE> on the 
+     * <CODE>LDAPResponse</CODE> from the <CODE>LDAPResponseListener</CODE>.
+     * The code will be <CODE>LDAPException.COMPARE_TRUE</CODE> or 
+     * <CODE>LDAPException.COMPARE_FALSE</CODE>. 
+     * 
+     * @param dn distinguished name of the entry to compare
+     * @param attr attribute with a value to compare
+     * @param listener handler for messages returned from a server in response
+     * to the specified request. If it is null, a listener object is created internally.
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to the specified request.
+     * @exception LDAPException Failed to send request.
+     */
+    public LDAPResponseListener compare(String dn, 
+                                        LDAPAttribute attr, 
+                                        LDAPResponseListener listener)
+                                        throws LDAPException;
+    
+    /**
+     * Compares an attribute value with one in the directory. The result
+     * is obtained by calling <CODE>getResultCode</CODE> on the 
+     * <CODE>LDAPResponse</CODE> from the <CODE>LDAPResponseListener</CODE>.
+     * The code will be <CODE>LDAPException.COMPARE_TRUE</CODE> or 
+     * <CODE>LDAPException.COMPARE_FALSE</CODE>. 
+     * 
+     * @param dn distinguished name of the entry to compare
+     * @param attr attribute with a value to compare
+     * @param listener handler for messages returned from a server in response
+     * to the specified request. If it is null, a listener object is created internally.
+     * @param cons constraints specific to this operation
+     * @return LDAPResponseListener handler for messages returned from a server
+     * in response to the specified request.
+     * @exception LDAPException Failed to send request.
+     */
+    public LDAPResponseListener compare(String dn, 
+                                        LDAPAttribute attr, 
+                                        LDAPResponseListener listener,
+                                        LDAPConstraints cons) 
+                                        throws LDAPException;
+    
+    /**
+     * Cancels the ldap request with the specified id and discards
+     * any results already received.
+     * 
+     * @param id an LDAP request ID
+     * @exception LDAPException Failed to send request.
+     */
+    public void abandon(int id) throws LDAPException;
+    
+    /**
+     * Cancels all outstanding search requests associated with this
+     * LDAPSearchListener object and discards any results already received.
+     * 
+     * @param searchlistener a search listener returned from a search
+     * @exception LDAPException Failed to send request.
+     */
+    public void abandon(LDAPSearchListener searchlistener)
+                        throws LDAPException;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPModificationSet.java
@@ -0,0 +1,156 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * Represents a set of modifications to be made to attributes in an entry.
+ * A set of modifications is made up of <CODE>LDAPModification</CODE> objects.
+ * <P>
+ *
+ * After you specify a change to an attribute, you can execute the change
+ * by calling the <CODE>LDAPConnection.modify</CODE> method and specifying
+ * the DN of the entry that you want to modify.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPModification
+ * @see netscape.ldap.LDAPConnection#modify(java.lang.String, netscape.ldap.LDAPModificationSet)
+ */
+public class LDAPModificationSet implements java.io.Serializable {
+
+    static final long serialVersionUID = 4650238666753391214L;
+    private int current = 0;
+    private Vector modifications;
+
+    /**
+     * Constructs a new, empty set of modifications.
+     * You can add modifications to this set by calling the
+     * <CODE>LDAPModificationsSet.add</CODE> method.
+     */
+    public LDAPModificationSet() {
+        modifications = new Vector();
+        current = 0;
+    }
+
+    /**
+     * Retrieves the number of <CODE>LDAPModification</CODE>
+     * objects in this set.
+     * @return the number of <CODE>LDAPModification</CODE>
+     * objects in this set.
+     */
+    public int size () {
+        return modifications.size();
+    }
+
+    /**
+     * Retrieves a particular <CODE>LDAPModification</CODE> object at
+     * the position specified by the index.
+     * @param index position of the <CODE>LDAPModification</CODE>
+     * object that you want to retrieve.
+     * @return <CODE>LDAPModification</CODE> object representing
+     * a change to make to an attribute.
+     */
+    public LDAPModification elementAt (int index) {
+        return (LDAPModification)modifications.elementAt(index);
+    }
+
+    /**
+     * Removes a particular <CODE>LDAPModification</CODE> object at
+     * the position specified by the index.
+     * @param index position of the <CODE>LDAPModification</CODE>
+     * object that you want to remove
+     */
+    public void removeElementAt( int index ) {
+        modifications.removeElementAt(index);
+    }
+
+    /**
+     * Specifies another modification to be added to the set of modifications.
+     * @param op the type of modification to make. This can be one of the following:
+     *   <P>
+     *   <UL>
+     *   <LI><CODE>LDAPModification.ADD</CODE> (the value should be added to the attribute)
+     *   <LI><CODE>LDAPModification.DELETE</CODE> (the value should be removed from the attribute)
+     *   <LI><CODE>LDAPModification.REPLACE</CODE> (the value should replace the existing value of the attribute)
+     *   </UL><P>
+     * If you are working with a binary value (not a string value), you need to bitwise OR (|) the
+     * modification type with <CODE>LDAPModification.BVALUES</CODE>.
+     * <P>
+     *
+     * @param attr the attribute (possibly with values) to modify
+     */
+    public synchronized void add( int op, LDAPAttribute attr ) {
+        LDAPModification mod = new LDAPModification( op, attr );
+        modifications.addElement( mod );
+    }
+
+    /**
+     * Removes the first attribute with the specified name in the set of modifications.
+     * @param name name of the attribute to remove
+     */
+    public synchronized void remove( String name ) {
+        for( int i = 0; i < modifications.size(); i++ ) {
+            LDAPModification mod = (LDAPModification)modifications.elementAt( i );
+            LDAPAttribute attr = mod.getAttribute();
+            if ( name.equalsIgnoreCase( attr.getName() ) ) {
+                modifications.removeElementAt( i );
+                break;
+            }
+        }
+    }
+
+    /**
+     * Retrieves the string representation of the
+     * modification set.
+     *
+     * @return string representation of the modification set.
+     */
+    public String toString() {
+        String s = "LDAPModificationSet: {";
+        for( int i = 0; i < modifications.size(); i++ ) {
+            s += (LDAPModification)modifications.elementAt(i);
+            if ( i < modifications.size()-1 ) {
+                s += ", ";
+            }
+        }
+        s += "}";
+        return s;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPResponse.java
@@ -0,0 +1,104 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import netscape.ldap.client.opers.JDAPProtocolOp;
+import netscape.ldap.client.opers.JDAPResult;
+
+/**
+ * Represents the response to a particular LDAP operation.
+ * 
+ * @version 1.0
+ */
+public class LDAPResponse extends LDAPMessage {
+
+    static final long serialVersionUID = 5822205242593427418L;
+
+    /**
+     * Constructor
+     * 
+     * @param msgid message identifier
+     * @param rsp operation response
+     * @param controls array of controls or null
+     */
+    LDAPResponse(int msgid, JDAPProtocolOp rsp, LDAPControl controls[]) {
+        super(msgid, rsp, controls);
+    }
+    
+    /**
+     * Returns any error message in the response.
+     *
+     * @return the error message of the last error (or <CODE>null</CODE>
+     * if no message was set).
+     */
+    public String  getErrorMessage() {
+        JDAPResult result = (JDAPResult) getProtocolOp();
+        return result.getErrorMessage();
+    }
+
+    /**
+     * Returns the partially matched DN field, if any, in a server response.
+     *
+     * @return the maximal subset of a DN to match,
+     * or <CODE>null</CODE>.
+     */
+    public String getMatchedDN() {
+	JDAPResult result = (JDAPResult) getProtocolOp();
+        return result.getMatchedDN();
+    }
+    
+    /**
+     * Returns all referrals, if any, in a server response.
+     *
+     * @return a list of referrals or <CODE>null</CODE>.
+     */
+    public String[] getReferrals() {
+        JDAPResult result = (JDAPResult) getProtocolOp();
+        return result.getReferrals();
+    }    
+
+    /**
+     * Returns the result code in a server response.
+     *
+     * @return the result code.
+     */
+    public int getResultCode() {
+        JDAPResult result = (JDAPResult) getProtocolOp();
+        return result.getResultCode();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/DynamicInvoker.java
@@ -0,0 +1,108 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.lang.reflect.*;
+import java.util.Hashtable;
+
+/**
+ * Utility class to dynamically find methods of a class and to invoke
+ * them
+ */
+class DynamicInvoker {
+    static Object invokeMethod(Object obj, String packageName,
+      String methodName, Object[] args, String[] argNames)
+      throws LDAPException {
+        try {
+            java.lang.reflect.Method m = getMethod(packageName, methodName,
+              argNames);
+            if (m != null) {
+                return (m.invoke(obj, args));
+            }
+        } catch (Exception e) {
+            throw new LDAPException("Invoking "+methodName+": "+
+              e.toString(), LDAPException.PARAM_ERROR);
+        }
+
+        return null;
+    }
+
+    static java.lang.reflect.Method getMethod(String packageName,
+      String methodName, String[] args) throws LDAPException {
+        try {
+            java.lang.reflect.Method method = null;
+            String suffix = "";
+            if (args != null)
+                for (int i=0; i<args.length; i++)
+                    suffix = suffix+args[i].getClass().getName();
+            String key = packageName+"."+methodName+"."+suffix;
+            if ((method = (java.lang.reflect.Method)(m_methodLookup.get(key)))
+              != null)
+                return method;
+
+            Class c = Class.forName(packageName);
+            java.lang.reflect.Method[] m = c.getMethods();
+            for (int i = 0; i < m.length; i++ ) {
+                Class[] params = m[i].getParameterTypes();
+                if ((m[i].getName().equals(methodName)) &&
+                    signatureCorrect(params, args)) {
+                    m_methodLookup.put(key, m[i]);
+                    return m[i];
+                }
+            }
+            throw new LDAPException("Method " + methodName + " not found in " +
+              packageName);
+        } catch (ClassNotFoundException e) {
+            throw new LDAPException("Class "+ packageName + " not found");
+        }
+    }
+
+    static private boolean signatureCorrect(Class params[], String args[]) {
+        if (args == null)
+            return true;
+        if (params.length != args.length)
+            return false;
+        for (int i=0; i<params.length; i++) {
+            if (!params[i].getName().equals(args[i]))
+                return false;
+        }
+        return true;
+    }
+
+    private static Hashtable m_methodLookup = new Hashtable();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPException.java
@@ -0,0 +1,947 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.client.opers.*;
+import java.io.*;
+
+/**
+ * Indicates that an error has occurred.  An <CODE>LDAPException</CODE>
+ * can result from physical problems (such as network errors) as well as
+ * problems with LDAP operations (for example, if the LDAP add operation
+ * fails because of duplicate entry).
+ * <P>
+ *
+ * Most errors that occur throw this type of exception.  In order to determine
+ * the cause of the error, you can call the <CODE>getLDAPResultCode()</CODE>
+ * method to get the specific result code and compare this code against
+ * the result codes defined as fields in this class. (For example, if
+ * the result code matches the value of the field
+ * <CODE>LDAPException.TIME_LIMIT_EXCEEDED</CODE>, the time limit passed
+ * before the search operation could be completed.)
+ * <P>
+ *
+ * This exception includes methods for getting an error message that
+ * corresponds to the LDAP result code (for example, "Timelimit exceeded"
+ * for <CODE>LDAPException.TIME_LIMIT_EXCEEDED</CODE>).  These error
+ * messages are specified in the following files:
+ * <PRE>netscape/ldap/errors/ErrorCodes_<I>locale_string</I>.props</PRE>
+ * where <I>locale_string</I> is the name of the locale that includes
+ * the language and country, but not the variant.
+ * <P>
+ *
+ * For example:
+ * <PRE>netscape/ldap/errors/ErrorCodes_en_US.props</PRE>
+ *
+ * The LDAP Java classes get this locale name by calling the
+ * <CODE>java.util.Locale.toString</CODE> method for the specified
+ * locale and ignoring the variant.  If no locale is specified, the
+ * LDAP Java classes use the <CODE>java.util.Locale.getDefault</CODE>
+ * method to get the locale of the local host system.
+ * <P>
+ *
+ * In order to get error messages for different locales, you need to
+ * provide files containing the error messages for those locales.
+ * The files should be located in the <CODE>netscape/ldap/errors</CODE>
+ * directory and should use the naming convention specified above.
+ * <P>
+ *
+ * The following is a list of LDAP result codes:
+ * <PRE>
+ * Result
+ *  Code   Defined Value
+ * ======  =============
+ *   0     <A HREF="#SUCCESS">SUCCESS</A>
+ *   1     <A HREF="#OPERATION_ERROR">OPERATION_ERROR</A>
+ *   2     <A HREF="#PROTOCOL_ERROR">PROTOCOL_ERROR</A>
+ *   3     <A HREF="#TIME_LIMIT_EXCEEDED">TIME_LIMIT_EXCEEDED</A>
+ *   4     <A HREF="#SIZE_LIMIT_EXCEEDED">SIZE_LIMIT_EXCEEDED</A>
+ *   5     <A HREF="#COMPARE_FALSE">COMPARE_FALSE</A>
+ *   6     <A HREF="#COMPARE_TRUE">COMPARE_TRUE</A>
+ *   7     <A HREF="#AUTH_METHOD_NOT_SUPPORTED">AUTH_METHOD_NOT_SUPPORTED</A>
+ *   8     <A HREF="#STRONG_AUTH_REQUIRED">STRONG_AUTH_REQUIRED</A>
+ *   9     <A HREF="#LDAP_PARTIAL_RESULTS">LDAP_PARTIAL_RESULTS</A>
+ *  10     <A HREF="#REFERRAL">REFERRAL</A> (LDAP v3)
+ *  11     <A HREF="#ADMIN_LIMIT_EXCEEDED">ADMIN_LIMIT_EXCEEDED</A> (LDAP v3)
+ *  12     <A HREF="#UNAVAILABLE_CRITICAL_EXTENSION">UNAVAILABLE_CRITICAL_EXTENSION</A> (LDAP v3)
+ *  13     <A HREF="#CONFIDENTIALITY_REQUIRED">CONFIDENTIALITY_REQUIRED</A> (LDAP v3)
+ *  14     <A HREF="#SASL_BIND_IN_PROGRESS">SASL_BIND_IN_PROGRESS</A> (LDAP v3)
+ *  16     <A HREF="#NO_SUCH_ATTRIBUTE">NO_SUCH_ATTRIBUTE</A>
+ *  17     <A HREF="#UNDEFINED_ATTRIBUTE_TYPE">UNDEFINED_ATTRIBUTE_TYPE</A>
+ *  18     <A HREF="#INAPPROPRIATE_MATCHING">INAPPROPRIATE_MATCHING</A>
+ *  19     <A HREF="#CONSTRAINT_VIOLATION">CONSTRAINT_VIOLATION</A>
+ *  20     <A HREF="#ATTRIBUTE_OR_VALUE_EXISTS">ATTRIBUTE_OR_VALUE_EXISTS</A>
+ *  21     <A HREF="#INVALID_ATTRIBUTE_SYNTAX">INVALID_ATTRIBUTE_SYNTAX</A>
+ *  32     <A HREF="#NO_SUCH_OBJECT">NO_SUCH_OBJECT</A>
+ *  33     <A HREF="#ALIAS_PROBLEM">ALIAS_PROBLEM</A>
+ *  34     <A HREF="#INVALID_DN_SYNTAX">INVALID_DN_SYNTAX</A>
+ *  35     <A HREF="#IS_LEAF">IS_LEAF</A>
+ *  36     <A HREF="#ALIAS_DEREFERENCING_PROBLEM">ALIAS_DEREFERENCING_PROBLEM</A>
+ *  48     <A HREF="#INAPPROPRIATE_AUTHENTICATION">INAPPROPRIATE_AUTHENTICATION</A>
+ *  49     <A HREF="#INVALID_CREDENTIALS">INVALID_CREDENTIALS</A>
+ *  50     <A HREF="#INSUFFICIENT_ACCESS_RIGHTS">INSUFFICIENT_ACCESS_RIGHTS</A>
+ *  51     <A HREF="#BUSY">BUSY</A>
+ *  52     <A HREF="#UNAVAILABLE">UNAVAILABLE</A>
+ *  53     <A HREF="#UNWILLING_TO_PERFORM">UNWILLING_TO_PERFORM</A>
+ *  54     <A HREF="#LOOP_DETECT">LOOP_DETECT</A>
+ *  64     <A HREF="#NAMING_VIOLATION">NAMING_VIOLATION</A>
+ *  65     <A HREF="#OBJECT_CLASS_VIOLATION">OBJECT_CLASS_VIOLATION</A>
+ *  66     <A HREF="#NOT_ALLOWED_ON_NONLEAF">NOT_ALLOWED_ON_NONLEAF</A>
+ *  67     <A HREF="#NOT_ALLOWED_ON_RDN">NOT_ALLOWED_ON_RDN</A>
+ *  68     <A HREF="#ENTRY_ALREADY_EXISTS">ENTRY_ALREADY_EXISTS</A>
+ *  69     <A HREF="#OBJECT_CLASS_MODS_PROHIBITED">OBJECT_CLASS_MODS_PROHIBITED</A>
+ *  71     <A HREF="#AFFECTS_MULTIPLE_DSAS">AFFECTS_MULTIPLE_DSAS</A> (LDAP v3)
+ *  80     <A HREF="#OTHER">OTHER</A>
+ *  81     <A HREF="#SERVER_DOWN">SERVER_DOWN</A>
+ *  85     <A HREF="#LDAP_TIMEOUT">LDAP_TIMEOUT</A>
+ *  89     <A HREF="#PARAM_ERROR">PARAM_ERROR</A>
+ *  91     <A HREF="#CONNECT_ERROR">CONNECT_ERROR</A>
+ *  92     <A HREF="#LDAP_NOT_SUPPORTED">LDAP_NOT_SUPPORTED</A>
+ *  93     <A HREF="#CONTROL_NOT_FOUND">CONTROL_NOT_FOUND</A>
+ *  94     <A HREF="#NO_RESULTS_RETURNED">NO_RESULTS_RETURNED</A>
+ *  95     <A HREF="#MORE_RESULTS_TO_RETURN">MORE_RESULTS_TO_RETURN</A>
+ *  96     <A HREF="#CLIENT_LOOP">CLIENT_LOOP</A>
+ *  97     <A HREF="#REFERRAL_LIMIT_EXCEEDED">REFERRAL_LIMIT_EXCEEDED</A>
+ * 112     <A HREF="#TLS_NOT_SUPPORTED">TLS_NOT_SUPPORTED</A> (LDAP v3) 
+ * </PRE>
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPReferralException
+ */
+public class LDAPException extends java.lang.Exception
+                           implements java.io.Serializable {
+
+    static final long serialVersionUID = -9215007872184847925L;
+
+    /**
+     * (0) The operation completed successfully.
+     */
+    public final static int SUCCESS                      = 0;
+
+    /**
+     * (1) An internal error occurred in the LDAP server.
+     */
+    public final static int OPERATION_ERROR              = 1;
+
+    /**
+     * (2) A LDAP server could not correctly interpret the request
+     * sent by your client because the request does not strictly
+     * comply with the LDAP protocol. (For example, the data
+     * was not correctly BER-encoded, or a specified value -- such
+     * as the search scope or modification type -- does not
+     * comply with the LDAP protocol.  If you invent your own
+     * search scope, for instance, this result code might be returned.<P>
+     */
+    public final static int PROTOCOL_ERROR               = 2;
+
+    /**
+     * (3) The search operation could not be completed within
+     * the maximum time limit.  You can specify the maximum time
+     * limit by calling the <CODE>LDAPConnection.setOption</CODE>
+     * method or the <CODE>LDAPSearchConstraints.setServerTimeLimit</CODE>
+     * method.<P>
+     *
+     * @see netscape.ldap.LDAPConnection#setOption
+     * @see netscape.ldap.LDAPSearchConstraints#setServerTimeLimit
+     */
+    public final static int TIME_LIMIT_EXCEEDED          = 3;
+
+    /**
+     * (4) The search found more than the maximum number of results.
+     * You can specify the maximum number of results by calling the
+     * <CODE>LDAPConnection.setOption</CODE> method or the
+     * <CODE>LDAPSearchConstraints.setSizeLimit</CODE> method.<P>
+     *
+     * @see netscape.ldap.LDAPConnection#setOption
+     * @see netscape.ldap.LDAPSearchConstraints#setMaxResults
+     */
+    public final static int SIZE_LIMIT_EXCEEDED          = 4;
+
+    /**
+     * (5) Value returned by an LDAP compare operation if the
+     * specified attribute and value is not found in the entry
+     * (no matching value found).
+     *
+     * @see netscape.ldap.LDAPConnection#compare
+     */
+    public final static int COMPARE_FALSE                = 5;
+
+    /**
+     * (6) Value returned by an LDAP compare operation if the
+     * specified attribute and value is found in the entry
+     * (matching value found).
+     *
+     * @see netscape.ldap.LDAPConnection#compare
+     */
+    public final static int COMPARE_TRUE                 = 6;
+
+    /**
+     * (7) The specified authentication method is not supported
+     * by the LDAP server that you are connecting to.  The
+     * <CODE>LDAPConnection</CODE> class is implemented so that
+     * <CODE>LDAPConnection.authenticate</CODE> always
+     * uses the LDAP_AUTH_SIMPLE method of authentication.
+     * (<CODE>LDAPConnection.authenticate</CODE> does not
+     * allow you to select the method of authentication.)<P>
+     */
+    public final static int AUTH_METHOD_NOT_SUPPORTED    = 7;
+
+    /**
+     * (8) A stronger authentication method (more than LDAP_AUTH_SIMPLE)
+     * is required by the LDAP server that you are connecting to.
+     * The <CODE>LDAPConnection</CODE> class is implemented so that
+     * <CODE>LDAPConnection.authenticate</CODE> always
+     * uses the LDAP_AUTH_SIMPLE method of authentication.
+     * (<CODE>LDAPConnection.authenticate</CODE> does not
+     * allow you to select the method of authentication.)<P>
+     */
+    public final static int STRONG_AUTH_REQUIRED         = 8;
+
+    /**
+     * (9) The LDAP server is referring your client to another
+     * LDAP server.  If you set up the <CODE>LDAPConnection</CODE>
+     * options or the <CODE>LDAPConstraints</CODE> options
+     * for automatic referral, your client will automatically
+     * connect and authenticate to the other LDAP server.
+     * (This <CODE>LDAPException</CODE> will not be raised.)
+     * <P>
+     *
+     * (To set up automatic referrals in an <CODE>LDAPConnection</CODE>
+     * object, set the <CODE>LDAPConnection.REFERRALS</CODE> option
+     * to <CODE>true</CODE> and the LDAPConnection.REFERRALS_REBIND_PROC</CODE>
+     * option to the object containing the method for retrieving
+     * authentication information (in other words, the distinguished
+     * name and password to use when authenticating to other LDAP servers).
+     * <P>
+     *
+     * If instead you set <CODE>LDAPConnection.REFERRALS</CODE>
+     * to <CODE>false</CODE> (or if you set
+     * <CODE>LDAPConstraints.setReferrals</CODE> to <CODE>false</CODE>,
+     * an <CODE>LDAPReferralException</CODE> is raised.
+     * <P>
+     *
+     * If an error occurs during the referral process, an
+     * <CODE>LDAPException</CODE> with this result code
+     * (<CODE>LDAP_PARTIAL_RESULTS</CODE>) is raised.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPConnection#setOption
+     * @see netscape.ldap.LDAPConstraints#setReferrals
+     * @see netscape.ldap.LDAPConstraints#setRebindProc
+     * @see netscape.ldap.LDAPRebind
+     * @see netscape.ldap.LDAPRebindAuth
+     * @see netscape.ldap.LDAPReferralException
+     */
+    public final static int LDAP_PARTIAL_RESULTS         = 9;
+
+    /**
+     * (10) [LDAP v3] The server does not hold the requested entry.
+     * The referral field of the server's response contains a
+     * reference to another server (or set of servers), which
+     * your client can access through LDAP or other protocols.
+     * Typically, these references are LDAP URLs that identify
+     * the server that may contain the requested entry.
+     * <P>
+     *
+     * When this occurs, a <CODE>LDAPReferralException</CODE>
+     * is thrown. You can catch this exception and call the
+     * <CODE>getURLs</CODE> method to get the list of LDAP
+     * URLs from the exception.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPReferralException
+     */
+    public final static int REFERRAL                     = 10;
+
+    /**
+     * (11) [LDAP v3] The adminstrative limit on the
+     * maximum number of entries to return was exceeded.
+     * In the Netscape Directory Server 3.0, this
+     * corresponds to the "look through limit" for
+     * the server.  This is the maximum number of
+     * entries that the server will check through
+     * when determining which entries match the
+     * search filter and scope.
+     * <P>
+     */
+    public final static int ADMIN_LIMIT_EXCEEDED         = 11;
+
+    /**
+     * (12) [LDAP v3] The server received an LDAP v3 control
+     * that is marked critical and either (1) is not
+     * recognized or supported by the server, or
+     * (2) is inappropriate for the operation requested.
+     * The Netscape Directory Server 3.0 also returns
+     * this result code if the client specifies a
+     * matching rule that is not supported by the server.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPControl
+     */
+    public final static int UNAVAILABLE_CRITICAL_EXTENSION = 12;
+
+    /**
+     * (13) [LDAP v3] A secure connection is required for
+     * this operation.
+     */
+    public final static int CONFIDENTIALITY_REQUIRED         = 13;
+
+    /**
+     * (14) [LDAP v3] While authenticating your client
+     * by using a SASL (Simple Authentication Security Layer)
+     * mechanism, the server requires the client to send
+     * a new SASL bind request (specifying the same SASL
+     * mechanism) to continue the authentication process.
+     */
+    public final static int SASL_BIND_IN_PROGRESS        = 14;
+
+    /**
+     * (16) The specified attribute could not be found.
+     */
+    public final static int NO_SUCH_ATTRIBUTE            = 16;
+
+    /**
+     * (17) The specified attribute is not defined.
+     */
+    public final static int UNDEFINED_ATTRIBUTE_TYPE     = 17;
+
+    /**
+     * (18) An inappropriate type of matching was used.
+     */
+    public final static int INAPPROPRIATE_MATCHING       = 18;
+
+    /**
+     * (19) An internal error occurred in the LDAP server.
+     */
+    public final static int CONSTRAINT_VIOLATION         = 19;
+
+    /**
+     * (20) The value that you are adding to an attribute
+     * already exists in the attribute.
+     */
+    public final static int ATTRIBUTE_OR_VALUE_EXISTS    = 20;
+
+    /**
+     * (21) The request contains invalid syntax.
+     */
+    public final static int INVALID_ATTRIBUTE_SYNTAX     = 21;
+
+    /**
+     * (32) The entry specified in the request does not exist.
+     */
+    public final static int NO_SUCH_OBJECT               = 32;
+
+    /**
+     * (33) An problem occurred with an alias.
+     */
+    public final static int ALIAS_PROBLEM                = 33;
+
+    /**
+     * (34) The specified distinguished name (DN) uses invalid syntax.
+     */
+    public final static int INVALID_DN_SYNTAX            = 34;
+
+    /**
+     * (35) The specified entry is a "leaf" entry (it has no entries
+     * beneath it in the directory tree).
+     */
+    public final static int IS_LEAF                      = 35;
+
+    /**
+     * (36) An error occurred when dereferencing an alias.
+     */
+    public final static int ALIAS_DEREFERENCING_PROBLEM  = 36;
+
+    /**
+     * (48) The authentication presented to the server is inappropriate.
+     * This result code might occur, for example, if your client
+     * presents a password and the corresponding entry has no
+     * userpassword attribute.
+     */
+    public final static int INAPPROPRIATE_AUTHENTICATION = 48;
+
+    /**
+     * (49) The credentials presented to the server for authentication
+     * are not valid.  (For example, the password sent to the server
+     * does not match the user's password in the directory.)
+     */
+    public final static int INVALID_CREDENTIALS          = 49;
+
+    /**
+     * (50) The client is authenticated as a user who does not have the
+     * access privileges to perform this operation.
+     */
+    public final static int INSUFFICIENT_ACCESS_RIGHTS   = 50;
+
+    /**
+     * (51) The LDAP server is busy.
+     */
+    public final static int BUSY                         = 51;
+
+    /**
+     * (52) The LDAP server is unavailable.
+     */
+    public final static int UNAVAILABLE                  = 52;
+
+    /**
+     * (53) The LDAP server is unable to perform the specified operation.
+     */
+    public final static int UNWILLING_TO_PERFORM         = 53;
+
+    /**
+     * (54) A loop has been detected.
+     */
+    public final static int LOOP_DETECT                  = 54;
+
+    /**
+     * (60) The "server-side sorting" control
+     * was not included with the "virtual list view"
+     * control in the search request.
+     */
+    public final static int SORT_CONTROL_MISSING         = 60;
+
+    /**
+     * (61) An index range error occurred.
+     */
+    public final static int INDEX_RANGE_ERROR            = 61;
+
+    /**
+     * (64) A naming violation has occurred.
+     */
+    public final static int NAMING_VIOLATION             = 64;
+
+    /**
+     * (65) The requested operation will add or change
+     * data so that the data no longer complies with
+     * the schema.
+     */
+    public final static int OBJECT_CLASS_VIOLATION       = 65;
+
+    /**
+     * (66) The requested operation can only be performed
+     * on an entry that has no entries beneath it in the
+     * directory tree (in other words, a "leaf" entry).
+     * <P>
+     *
+     * For example, you cannot delete or rename an entry
+     * if the entry has subentries beneath it.
+     * <P>
+     */
+    public final static int NOT_ALLOWED_ON_NONLEAF       = 66;
+
+    /**
+     * (67) The specified operation cannot be performed on
+     * a relative distinguished name (RDN).
+     */
+    public final static int NOT_ALLOWED_ON_RDN           = 67;
+
+    /**
+     * (68) The specified entry already exists.  You might receive
+     * this error if, for example, you attempt to add an entry
+     * that already exists or if you attempt to change the name
+     * of an entry to the name of an entry that already exists.
+     */
+    public final static int ENTRY_ALREADY_EXISTS         = 68;
+
+    /**
+     * (69) You cannot modify the specified object class.
+     */
+    public final static int OBJECT_CLASS_MODS_PROHIBITED = 69;
+
+    /**
+     * (71) [LDAP v3] The client attempted to move an entry
+     * from one LDAP server to another by requesting a "modify
+     * DN" operation.  In general, clients should not be able
+     * to arbitrarily move entries and subtrees between servers.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPConnection#rename(java.lang.String, java.lang.String, java.lang.String, boolean)
+     * @see netscape.ldap.LDAPConnection#rename(java.lang.String, java.lang.String, java.lang.String, boolean, LDAPConstraints)
+     */
+    public final static int AFFECTS_MULTIPLE_DSAS        = 71;
+
+    /**
+     * (80) General result code for other types of errors
+     * that may occur.
+     */
+    public final static int OTHER                        = 80;
+
+    /**
+     * (81) The LDAP server cannot be contacted.
+     */
+    public final static int SERVER_DOWN                  = 0x51;
+
+    /**
+     * (85) The operation could not be completed within the
+     * maximum time limit. You can specify the maximum time limit
+     * by calling the <CODE>LDAPConstraints.setTimeLimit</CODE>
+     * method.<P>
+     *
+     * @see netscape.ldap.LDAPConstraints#setTimeLimit
+     */
+    public final static int LDAP_TIMEOUT                 = 0x55;
+
+
+    /**
+     * (89) When calling a constructor or method from your client,
+     * one or more parameters were incorrectly specified.
+     */
+    public final static int PARAM_ERROR                  = 0x59;
+
+    /**
+     * (91) Your LDAP client failed to connect to the LDAP server.
+     */
+    public final static int CONNECT_ERROR                = 0x5b;
+
+    /**
+     * (92) The request is not supported by this version of the LDAP protocol.
+     */
+    public final static int LDAP_NOT_SUPPORTED           = 0x5c;
+
+    /**
+     * (93) The requested control is not found.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPControl
+     */
+    public final static int CONTROL_NOT_FOUND            = 0x5d;
+
+    /**
+     * (94) No results have been returned from the server.
+     */
+    public final static int NO_RESULTS_RETURNED          = 0x5e;
+
+    /**
+     * (95) More results are being returned from the server.
+     */
+    public final static int MORE_RESULTS_TO_RETURN       = 0x5f;
+
+    /**
+     * (96) Your LDAP client detected a loop in the referral.
+     */
+    public final static int CLIENT_LOOP                  = 0x60;
+
+    /**
+     * (97) The number of sequential referrals (for example,
+     * the client may be referred first from LDAP server A to
+     * LDAP server B, then from LDAP server B to LDAP server C,
+     * and so on) has exceeded the maximum number of referrals
+     * (the <CODE>LDAPv2.REFERRALS_HOP_LIMIT</CODE> option).
+     * <P>
+     *
+     * @see netscape.ldap.LDAPv2#REFERRALS_HOP_LIMIT
+     * @see netscape.ldap.LDAPConnection#getOption
+     * @see netscape.ldap.LDAPConnection#setOption
+     */
+    public final static int REFERRAL_LIMIT_EXCEEDED      = 0x61;
+
+    /**
+     * (112) The socket factory of the connection is not capable
+     * of initiating a TLS session.
+     * <P>
+     *
+     * @see netscape.ldap.LDAPConnection#startTLS
+     */
+    public final static int TLS_NOT_SUPPORTED      = 0x70;
+
+    /**
+     * Internal variables
+     */
+    private int resultCode = -1;
+    private String errorMessage = null;
+    private String extraMessage = null;
+    private String matchedDN = null;
+    private Locale m_locale = Locale.getDefault();
+    private static Hashtable cacheResource = new Hashtable();
+    private static final String baseName = "netscape/ldap/errors/ErrorCodes";
+
+    /**
+     * Constructs a default exception with no specific error information.
+     */
+    public LDAPException() {
+    }
+
+    /**
+     * Constructs a default exception with a specified string of
+     * additional information. This string appears if you call
+     * the <CODE>toString()</CODE> method.
+     * <P>
+     *
+     * This form is used for lower-level errors.
+     * It is recommended that you always use one of the constructors
+     * that takes a result code as a parameter. (If your exception is
+     * thrown, any code that catches the exception may need to extract
+     * the result code from the exception.)
+     * <P>
+     * @param message the additional error information
+     * @see netscape.ldap.LDAPException#toString()
+     */
+    public LDAPException( String message ) {
+        super( message );
+    }
+
+    /**
+     * Constructs a default exception with a result code and
+     * a specified string of additional information.  This string
+     * appears if you call the <CODE>toString()</CODE> method.
+     * The result code that you set is accessible through the
+     * <CODE>getLDAPResultCode()</CODE> method.
+     * <P>
+     *
+     * @param message the additional error information to specify
+     * @param resultCode the result code returned from the
+     * operation that caused this exception
+     * @see netscape.ldap.LDAPException#toString()
+     * @see netscape.ldap.LDAPException#getLDAPResultCode()
+     */
+    public LDAPException( String message, int resultCode ) {
+        super( message );
+        this.resultCode = resultCode;
+    }
+
+    /**
+     * Constructs a default exception with a result code, a specified
+     * string of additional information, and a string containing
+     * information passed back from the server.
+     * <P>
+     *
+     * After you construct the <CODE>LDAPException</CODE> object,
+     * the result code and messages will be accessible through the
+     * following ways:
+     * <P>
+     * <UL>
+     * <LI>The first string of additional information appears if you
+     * call the <CODE>toString()</CODE> method. <P>
+     * <LI>The result code that you set is accessible through the
+     * <CODE>getLDAPResultCode()</CODE> method. <P>
+     * <LI>The string of server error information that you set
+     * is accessible through the <CODE>getLDAPErrorMessage</CODE>
+     * method. <P>
+     * </UL>
+     * <P>
+     *
+     * Use this form of the constructor
+     * for higher-level LDAP operational errors.
+     * @param message the additional error information to specify
+     * @param resultCode the result code returned from the
+     * operation that caused this exception
+     * @param serverErrorMessage error message specifying additional
+     * information returned from the server
+     * @see netscape.ldap.LDAPException#toString()
+     * @see netscape.ldap.LDAPException#getLDAPResultCode()
+     * @see netscape.ldap.LDAPException#getLDAPErrorMessage()
+     */
+    public LDAPException( String message, int resultCode,
+      String serverErrorMessage ) {
+        super( message );
+        this.resultCode = resultCode;
+        this.errorMessage = serverErrorMessage;
+    }
+
+    /**
+     * Constructs a default exception with a result code, a specified
+     * string of additional information, a string containing
+     * information passed back from the server, and the DN of the
+     * closest matching entry, if the exception was thrown because
+     * an entry could not be found (for example, if <CODE>cn=Babs Jensen,
+     * ou=People, c=Airius.com</CODE> could not be found but
+     * <CODE>ou=People, c=Airius.com</CODE> is a valid directory entry,
+     * the &quot;matched DN&quot; is <CODE>ou=People, c=Airius.com</CODE>.
+     * <P>
+     *
+     * After you construct the <CODE>LDAPException</CODE> object,
+     * the result code and messages will be accessible through the
+     * following ways:
+     * <P>
+     * <UL>
+     * <LI>This string of additional information appears if you
+     * call the <CODE>toString()</CODE> method. <P>
+     * <LI>The result code that you set is accessible through the
+     * <CODE>getLDAPResultCode()</CODE> method. <P>
+     * <LI>The string of server error information that you set
+     * is accessible through the <CODE>getLDAPErrorMessage</CODE>
+     * method. <P>
+     * <LI>The matched DN that you set is accessible through the
+     * <CODE>getMatchedDN</CODE> method.<P>
+     * </UL>
+     * <P>
+     *
+     * This form is used for higher-level LDAP operational errors.
+     * @param message the additional error information
+     * @param resultCode the result code returned
+     * @param serverErrorMessage error message specifying additional information
+     * returned from the server
+     * @param matchedDN maximal subset of a specified DN which could be
+     * matched by the server
+     * @see netscape.ldap.LDAPException#toString()
+     * @see netscape.ldap.LDAPException#getLDAPResultCode()
+     * @see netscape.ldap.LDAPException#getLDAPErrorMessage()
+     * @see netscape.ldap.LDAPException#getMatchedDN()
+     */
+    public LDAPException( String message, int resultCode,
+      String serverErrorMessage, String matchedDN ) {
+        super( message );
+        this.resultCode = resultCode;
+        this.errorMessage = serverErrorMessage;
+        this.matchedDN = matchedDN;
+    }
+
+    /**
+     * Returns the result code from the last error that occurred.
+     * This result code is defined as a public final static int member
+     * of this class.  Note that this value is not always valid.
+     * -1 indicates that the result code is invalid.
+     * @return the LDAP result code of the last operation.
+     */
+    public int getLDAPResultCode () {
+        return resultCode;
+    }
+
+    /**
+     * Returns the error message from the last error, if this message
+     * is available (that is, if this message was set).  If the message
+     * was not set, this method returns <CODE>null</CODE>.
+     * <P>
+     *
+     * Note that this message is rarely set.  (In order to set this message,
+     * the code constructing this exception must have called the constructor
+     * <CODE>LDAPException(String, int, String)</CODE>.  The last argument,
+     * which is additional error information returned from the server,
+     * is the string returned by <CODE>getLDAPErrorMessage</CODE>.
+     * <P>
+     *
+     * In most cases, if you want information about
+     * the error generated, you should call the <CODE>toString()</CODE>
+     * method instead.
+     * <P>
+     *
+     * @return the error message of the last error (or <CODE>null</CODE>
+     * if no message was set).
+     * @see netscape.ldap.LDAPException#toString()
+     */
+    public String getLDAPErrorMessage () {
+        return errorMessage;
+    }
+   
+
+    /**
+     * Adds additional explanation to the error message
+     */
+    void setExtraMessage (String msg) {
+        if (extraMessage == null) {
+            extraMessage = msg;
+        }
+        else {
+            extraMessage += "; " + msg;
+        }
+    }
+
+    /**
+     * Returns the maximal subset of a DN which could be matched by the
+     * server.
+     * 
+     * The method should be used if the server returned one of the
+     * following errors:
+     * <UL>
+     * <LI><CODE>NO_SUCH_OBJECT</CODE>
+     * <LI><CODE>ALIAS_PROBLEM</CODE>
+     * <LI><CODE>INVALID_DN_SYNTAX</CODE>
+     * <LI><CODE>ALIAS_DEREFERENCING_PROBLEM</CODE>
+     * </UL>
+     * For example, if the DN <CODE>cn=Babs Jensen, o=People, c=Airius.com</CODE>
+     * could not be found by the DN <CODE>o=People, c=Airius.com</CODE>
+     * could be found, the matched DN is
+     * <CODE>o=People, c=Airius.com</CODE>.
+     * <P>
+     *
+     * If the exception does not specify a matching DN,
+     * this method returns <CODE>null</CODE>.
+     * @return the maximal subset of a DN which could be matched,
+     * or <CODE>null</CODE> if the error is not one of the above.
+     */
+    public String getMatchedDN () {
+        return matchedDN;
+    }
+
+    /**
+     * Gets the string representation of the exception, which
+     * includes the result code, the message sent back from
+     * the LDAP server, the portion of the DN that the server
+     * could find in the directory (if applicable), and the
+     * error message corresponding to this result code.
+     * <P>
+     *
+     * For example:
+     *
+     * <PRE>netscape.ldap.LDAPException: error result (32); server error message; matchedDN = ou=people,o=airius.com; No such object</PRE>
+     *
+     * In this example, <CODE>error result</CODE> is the string of
+     * additional information specified in the exception, <CODE>32</CODE> is
+     * the result code, <CODE>server error message</CODE> is the additional
+     * information from the server specified in the exception, the
+     * matched DN is <CODE>ou=people,o=airius.com</CODE>, and the error message
+     * corresponding to the result code <CODE>32</CODE> is <CODE>No such
+     * object</CODE>.
+     * <P>
+     *
+     * The error message corresponding to the error code can also be
+     * retrieved by using the <CODE>errorCodeToString</CODE> method.
+     * Note that this method can generate error messages specific to
+     * a current locale.
+     * <P>
+     *
+     * @return string representation of exception.
+     * @see netscape.ldap.LDAPException#errorCodeToString(int)
+     */
+    public String toString() {
+        String str = super.toString() + " (" + resultCode + ")" ;
+        if ( (errorMessage != null) && (errorMessage.length() > 0) ) {
+            str += "; " + errorMessage;
+        }
+        if ( (matchedDN != null) && (matchedDN.length() > 0) ) {
+            str += "; matchedDN = " + matchedDN;
+        }
+        String  errorStr = errorCodeToString(m_locale);
+        if ((errorStr != null) && (errorStr.length() > 0)) {
+            str += "; " + errorStr;
+        }
+        if (extraMessage != null) {
+            str += "; " + extraMessage;
+        }
+        return str;
+    }
+
+    /**
+     * Returns the error message describing the error code (for this
+     * exception). The error message is specific to the default locale
+     * for this system.  (The LDAP Java classes determine the default
+     * locale by calling the <CODE>java.util.Locale.getDefault</CODE>
+     * method and retrieve the error messages from the following file:
+     * <PRE>netscape/ldap/error/ErrorCodes_<I>locale_name</I>.props</PRE>
+     * where <I>locale_name</I> is the language and country (concatenated
+     * and delimited by an underscore) of the default locale. For example:
+     * <PRE>netscape/ldap/error/ErrorCodes_en_US.props</PRE>
+     *
+     * @return the error message describing the error code for this
+     * exception in the default locale.
+     */
+    public String errorCodeToString() {
+        return errorCodeToString(resultCode, m_locale);
+    }
+
+   /**
+     * Returns the error message describing the error code for this
+     * exception. The error message for the specified locale is retrieved
+     * from the following file:
+     * <PRE>netscape/ldap/error/ErrorCodes_<I>locale_name</I>.props</PRE>
+     * where <I>locale_name</I> is the language and country (concatenated
+     * and delimited by an underscore) of the default locale. For example:
+     * <PRE>netscape/ldap/error/ErrorCodes_en_US.props</PRE>
+     *
+     * @param l the <CODE>java.util.Locale</CODE> object representing the
+     * locale of the error message to retrieve
+     * @return the error message describing the current error code
+     * in the specified locale.
+     */
+    public String errorCodeToString(Locale l) {
+        return errorCodeToString(resultCode, l);
+    }
+
+    /**
+     * Returns the error message describing the specified error code.
+     * The error message is specific to the default locale
+     * for this system.  (The LDAP Java classes determine the default
+     * locale by calling the <CODE>java.util.Locale.getDefault</CODE>
+     * method and retrieve the error messages from the following file:
+     * <PRE>netscape/ldap/error/ErrorCodes_<I>locale_name</I>.props</PRE>
+     * where <I>locale_name</I> is the language and country (concatenated
+     * and delimited by an underscore) of the default locale. For example:
+     * <PRE>netscape/ldap/error/ErrorCodes_en_US.props</PRE>
+     *
+     * @param code the error code for which to get the
+     * corresponding error message
+     * @return error message describing the specified error code for
+     * the default locale.
+     */
+    public static String errorCodeToString(int code) {
+        return errorCodeToString(code, Locale.getDefault());
+    }
+
+    /**
+     * Returns the error message describing the specified error code.
+     * The error message for the specified locale is retrieved from
+     * the following file:
+     * <PRE>netscape/ldap/error/ErrorCodes_<I>locale_name</I>.props</PRE>
+     * where <I>locale_name</I> is the language and country (concatenated
+     * and delimited by an underscore) of the default locale. For example:
+     * <PRE>netscape/ldap/error/ErrorCodes_en_US.props</PRE>
+     *
+     * @param code the error code for which to get the
+     * corresponding error
+     * @param locale the <CODE>java.util.Locale</CODE> object representing the
+     * locale of the error message that you want to retrieve
+     * @return error message describing the specified error code for
+     * the specified locale.
+     */
+    public synchronized static String errorCodeToString(int code, Locale locale) {
+        try {
+            String localeStr = locale.toString();
+            PropertyResourceBundle p =
+               (PropertyResourceBundle)cacheResource.get(localeStr);
+
+            if (p == null) {
+                p = LDAPResourceBundle.getBundle(baseName);
+
+                if (p != null)
+                    cacheResource.put(localeStr, p);
+            }
+
+            if (p != null) {
+                return (String)p.handleGetObject(Integer.toString(code));
+            }
+        } catch (IOException e) {
+            System.out.println("Cannot open resource file for LDAPException "+
+              baseName);
+        }
+
+        return null;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPAttribute.java
@@ -0,0 +1,565 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.io.*;
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+
+/**
+ * Represents the name and values of an attribute in an entry.
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPAttributeSet
+ */
+public class LDAPAttribute implements java.io.Serializable {
+
+    static final long serialVersionUID = -4594745735452202600L; 
+    private String name = null;
+    private byte[] nameBuf = null;
+    /**
+     * Internally, this is a list of "byte[]"-based attribute values.
+     */
+    private Object values[] = new Object[0];
+
+    /**
+     * Constructs an attribute from another existing attribute.
+     * Effectively, this makes a copy of the existing attribute.
+     * @param attr the attribute to copy
+     */
+    public LDAPAttribute( LDAPAttribute attr ) {
+        name = attr.name;
+        nameBuf = attr.nameBuf;
+        values = new Object[attr.values.length];
+        for (int i = 0; i < attr.values.length; i++) {
+            values[i] = new byte[((byte[])attr.values[i]).length];
+            System.arraycopy((byte[])attr.values[i], 0, (byte[])values[i], 0,
+                ((byte[])attr.values[i]).length);
+        }
+    }
+
+    /**
+     * Constructs an attribute with no values.
+     * @param attrName name of the attribute
+     */
+    public LDAPAttribute( String attrName ) {
+        name = attrName;
+    }
+
+    /**
+     * Constructs an attribute with a byte-formatted value.
+     * @param attrName name of the attribute
+     * @param attrValue value of the attribute in byte format
+     */
+    public LDAPAttribute( String attrName, byte[] attrValue ) {
+        name = attrName;
+        addValue(attrValue);
+    }
+
+    /**
+     * Constructs an attribute that has a single string value.
+     * @param attrName name of the attribute
+     * @param attrValue value of the attribute in String format
+     */
+    public LDAPAttribute( String attrName, String attrValue ) {
+        name = attrName;
+        addValue( attrValue );
+    }
+
+    /**
+     * Constructs an attribute that has an array of string values.
+     * @param attrName name of the attribute
+     * @param attrValues the list of string values for this attribute
+     */
+    public LDAPAttribute( String attrName, String[] attrValues ) {
+        name = attrName;
+        if (attrValues != null) {
+            setValues( attrValues );
+        }
+    }
+
+    /**
+     * Constructs an attribute from a BER (Basic Encoding Rules) element.
+     * (The protocol elements of LDAP are encoded for exchange using the
+     * Basic Encoding Rules.)
+     * @param element element that you want translated into an attribute
+     * @exception IOException The attribute could not be created from
+     * the specified element.
+     */
+    public LDAPAttribute(BERElement element) throws IOException {
+        BERSequence seq = (BERSequence)element;
+        BEROctetString type = (BEROctetString)seq.elementAt(0);
+        nameBuf = type.getValue();
+        BERSet set = (BERSet)seq.elementAt(1);
+        if (set.size() > 0) {
+            Object[] vals = new Object[set.size()];
+            for (int i = 0; i < set.size(); i++) {
+                vals[i] = ((BEROctetString)set.elementAt(i)).getValue();
+                if (vals[i] == null) {
+                    vals[i] = new byte[0];
+                }
+            }
+            setValues( vals );
+        }
+     }
+
+    /**
+     * Returns the number of values of the attribute.
+     * @return number of values for this attribute.
+     */
+    public int size() {
+        return values.length;
+    }
+
+    /**
+     * Returns an enumerator for the string values of an attribute.
+     * @return enumerator for the string values.
+     */
+    public Enumeration getStringValues() {
+        Vector v = new Vector();
+        synchronized(this) {
+            try {
+                for (int i=0; i<values.length; i++) {
+                    if ( values[i] != null ) {
+                        v.addElement(new String ((byte[])values[i], "UTF8"));
+                    } else {
+                        v.addElement( new String( "" ) );
+                    }
+                }
+            } catch ( Exception e ) {
+                return null;
+            }
+        }
+        return v.elements();
+    }
+	
+    /**
+     * Returns the values of the attribute as an array of <CODE>String</CODE> 
+     * objects.
+     * @return array of attribute values. Each element in the array
+     * is a <CODE>String</CODE> object.
+     */
+    public String[] getStringValueArray() {
+    
+    	String s[] = new String[values.length];
+    	synchronized(this) {
+    		try {
+    			for (int i=0; i < values.length; i++) {
+    				if ( values[i] !=null ) {
+    					s[i] = new String((byte[])values[i], "UTF8");
+    				} else {
+    					s[i] = new String("");
+    				}
+    			}
+    		} catch (Exception e) {
+    			return null;
+    		}
+    	}
+    	return s;
+    }
+    
+    /**
+     * Returns an enumerator for the values of the attribute in <CODE>byte[]</CODE>
+     * format.
+     * @return a set of attribute values. Each element in the enumeration
+     * is of type <CODE>byte[]</CODE>.
+     */
+    public Enumeration getByteValues() {
+        Vector v = new Vector();
+        synchronized(this) {
+            for (int i=0; i<values.length; i++) {
+                if ( values[i] != null ) {
+                    v.addElement(values[i]);
+                } else {
+                    v.addElement( new byte[0] );
+                }
+            }
+        }
+        return v.elements();
+    }
+
+    /**
+     * Returns the values of the attribute in an array of <CODE>byte[]</CODE>
+     * format.
+     * @return array of attribute values. Each element in the array
+     * will be of type <CODE>byte[]</CODE>.
+     */
+     public byte[][] getByteValueArray() {
+    	byte b[][] = new byte[values.length][];
+    	synchronized(this) {
+    		try {
+    			for (int i=0; i < values.length; i++) {
+    				b[i] = new byte[((byte[])(values[i])).length];
+	    			System.arraycopy((byte[])values[i], 0, (byte[])b[i], 0, 
+    					((byte[])(values[i])).length);
+    			}
+    		} catch (Exception e) {
+    			return null;
+    		}
+    	}
+    	return b;
+     
+     }
+     
+    /**
+     * Returns the name of the attribute.
+     * @return name of the attribute.
+     */
+    public String getName() {
+        if ((name == null) && (nameBuf != null)) {
+            try{
+                name = new String(nameBuf, "UTF8");
+            } catch(Throwable x) {}
+        }
+        return name;
+    }
+
+    /**
+     * Extracts the subtypes from the specified attribute name.
+     * For example, if the attribute name is <CODE>cn;lang-ja;phonetic</CODE>,
+     * this method returns an array containing <CODE>lang-ja</CODE>
+     * and <CODE>phonetic</CODE>.
+     * <P>
+     *
+     * @param attrName name of the attribute from which to extract the subtypes
+     * @return array of subtypes, or null (if the name has no subtypes).
+     * @see netscape.ldap.LDAPAttribute#getBaseName
+     */
+    public static String[] getSubtypes(String attrName) {
+        StringTokenizer st = new StringTokenizer(attrName, ";");
+        if( st.hasMoreElements() ) {
+            // First element is base name
+            st.nextElement();
+            String[] subtypes = new String[st.countTokens()];
+            int i = 0;
+            // Extract the types
+            while( st.hasMoreElements() )
+                subtypes[i++] = (String)st.nextElement();
+            return subtypes;
+        }
+        return null;
+    }
+
+    /**
+     * Extracts the subtypes from the attribute name of the current
+     * <CODE>LDAPAttribute</CODE> object.  For example, if the attribute
+     * name is <CODE>cn;lang-ja;phonetic</CODE>, this method returns an array
+     * containing <CODE>lang-ja</CODE> and <CODE>phonetic</CODE>.
+     *<P>
+     *
+     * @return array of subtypes, or null (if the name has no subtypes).
+     */
+    public String[] getSubtypes() {
+        return getSubtypes(getName());
+    }
+
+    /**
+     * Extracts the language subtype from the attribute name of the
+     * <CODE>LDAPAttribute</CODE> object, if any.  For example, if the
+     * attribute name is <CODE>cn;lang-ja;phonetic</CODE>, this method
+     * returns the String <CODE>lang-ja</CODE>.
+     *<P>
+     *
+     * @return the language subtype, or null (if the name has no
+     * language subtype).
+     */
+    public String getLangSubtype() {
+        String[] subTypes = getSubtypes();
+        if ( subTypes != null ) {
+            for( int i = 0; i < subTypes.length; i++ ) {
+                if ((subTypes[i].length() >= 5) &&
+                    (subTypes[i].substring(0, 5).equalsIgnoreCase("lang-")))
+                    return subTypes[i];
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Extracts the base name from the specified attribute name.
+     * For example, if the attribute name is <CODE>cn;lang-ja;phonetic</CODE>,
+     * this method returns <CODE>cn</CODE>.
+     * <P>
+     *
+     * @param attrName name of the attribute from which to extract the base name
+     * @return base name (the attribute name without any subtypes).
+     * @see netscape.ldap.LDAPAttribute#getSubtypes
+     */
+    public static String getBaseName(String attrName) {
+        String basename = attrName;
+        StringTokenizer st = new StringTokenizer(attrName, ";");
+        if( st.hasMoreElements() )
+            // First element is base name
+            basename = (String)st.nextElement();
+        return basename;
+    }
+
+    /**
+     * Extracts the base name from the attribute name of the current
+     * <CODE>LDAPAttribute</CODE> object. For example, if the attribute
+     * name is <CODE>cn;lang-ja;phonetic</CODE>, this method returns
+     * <CODE>cn</CODE>.
+     * <P>
+     *
+     * @return base name (the attribute name without any subtypes).
+     * @see netscape.ldap.LDAPAttribute#getSubtypes
+     */
+    public String getBaseName() {
+        return getBaseName(getName());
+    }
+
+    /**
+     * Reports whether the attribute name contains the specified subtype.
+     * For example, if you check for the subtype <CODE>lang-en</CODE>
+     * and the attribute name is <CODE>cn;lang-en</CODE>, this method
+     * returns <CODE>true</CODE>.
+     * <P>
+     *
+     * @param subtype the single subtype for which you want to check
+     * @return true if the attribute name contains the specified subtype.
+     * @see netscape.ldap.LDAPAttribute#getSubtypes
+     */
+    public boolean hasSubtype(String subtype) {
+        String[] mytypes = getSubtypes();
+        for(int i = 0; i < mytypes.length; i++) {
+            if( subtype.equalsIgnoreCase( mytypes[i] ) )
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * Reports if the attribute name contains all specified subtypes
+     * For example, if you check for the subtypes <CODE>lang-en</CODE>
+     * and <CODE>phonetic</CODE> and the attribute name is
+     * <CODE>cn;lang-en;phonetic</CODE>, this method returns <CODE>true</CODE>.
+     * If the attribute name is <CODE>cn;phonetic</CODE> or
+     * <CODE>cn;lang-en</CODE>, this method returns <CODE>false</CODE>.
+     * <P>
+     * @param subtypes an array of subtypes to check
+     * @return true if the attribute name contains all subtypes
+     * @see netscape.ldap.LDAPAttribute#getSubtypes
+     */
+    public boolean hasSubtypes(String[] subtypes) {
+        for(int i = 0; i < subtypes.length; i++) {
+            if( !hasSubtype(subtypes[i]) )
+                return false;
+        }
+        return true;
+    }
+
+    /**
+     * Adds a string value to the attribute.
+     * @param attrValue the string value to add to the attribute
+     */
+    public synchronized void addValue( String attrValue ) {
+        if (attrValue != null) {
+            try {
+                byte[] b = attrValue.getBytes("UTF8");
+                addValue( b );
+            } catch(Throwable x)
+            {}
+        }
+    }
+
+    /**
+     * Sets the string values as the attribute's values.
+     * @param attrValues the string values to use in the attribute
+     */
+    protected void setValues( String[] attrValues ) {
+        Object[] vals;
+        if (attrValues != null) {
+            vals = new Object[attrValues.length];
+            for (int i = 0; i < vals.length; i++) {
+                try {
+                    vals[i] = attrValues[i].getBytes("UTF8");
+                } catch(Throwable x)
+                    { vals[i] = new byte[0]; }
+            }
+        } else {
+            vals = new Object[0];
+        }
+        setValues(vals);
+    }
+
+    /**
+     * Adds a <CODE>byte[]</CODE>-formatted value to the attribute.
+     * @param attrValue the <CODE>byte[]</CODE>-formatted value to
+     * add to the attribute
+     */
+    public synchronized void addValue( byte[] attrValue ) {
+        if (attrValue != null) {
+            Object[] vals = new Object[values.length+1];
+            for (int i = 0; i < values.length; i++)
+                vals[i] = values[i];
+            vals[values.length] = attrValue;
+            values = vals;
+        }
+    }
+
+    /**
+     * Sets the byte[] values as the attribute's values.
+     * @param attrValues the values to use in the attribute
+     */
+    protected synchronized void setValues( Object[] attrValues ) {
+        values = attrValues;
+    }
+
+    /**
+     * Removes a string value from the attribute.
+     * @param attrValue the string value to remove
+     */
+    public synchronized void removeValue( String attrValue) {
+        if (attrValue != null) {
+            try{
+                byte b[] = attrValue.getBytes("UTF8");
+                removeValue ( b );
+            } catch(Throwable x)
+            {}
+        }
+    }
+
+    /**
+     * Removes a <CODE>byte[]</CODE>-formatted value from the attribute.
+     * @param attrValue <CODE>byte[]</CODE>-formatted value to remove
+     */
+    public synchronized void removeValue( byte[] attrValue) {
+        if ((attrValue == null) || (values == null)|| (values.length < 1))
+            return;
+        int ind = -1;
+        for (int i=0; i<values.length; i++) {
+            if (equalValue(attrValue, (byte[])values[i])) {
+                ind = i;
+                 break;
+            }
+        }
+        if (ind >= 0) {
+            Object[] vals = new Object[values.length-1];
+            int j = 0;
+            for (int i = 0; i < values.length; i++) {
+                if (i != ind) {
+                    vals[j++] = values[i];
+                }
+            }
+            values = vals;
+        }
+    }
+
+    private static boolean equalValue(byte[] a, byte[] b) {
+        if (a.length != b.length)
+            return false;
+
+        for (int i=0; i<a.length; i++) {
+            if (a[i] != b[i])
+                return false;
+        }
+        return true;
+    }
+
+    /**
+     * Retrieves the BER (Basic Encoding Rules) representation of an attribute.
+     * (The protocol elements of LDAP are encoded for exchange using the
+     * Basic Encoding Rules.)
+     * @return the BER representation of the attribute.
+     */
+    public BERElement getBERElement() {
+        try {
+            BERSequence seq = new BERSequence();
+            seq.addElement(new BEROctetString(getName()));
+            BERSet set = new BERSet();
+            for (int i = 0; i < values.length; i++) {
+                set.addElement(new BEROctetString((byte[])values[i]));
+            }
+            seq.addElement(set);
+            return seq;
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Retrieves the string representation of attribute parameters.
+     * @return string representation parameters.
+     */
+    private String getParamString() {
+        StringBuffer sb = new StringBuffer();
+        
+        if ( values.length > 0 ) {
+            for (int i = 0; i < values.length; i++) {
+                if (i != 0) {
+                    sb.append(",");
+                }
+                byte[] val = (byte[])values[i];
+                try {
+                    String sval = new String(val, "UTF8");
+                    if (sval.length() == 0 && val.length > 0) {
+                        sb.append("<binary value, length:");
+                        sb.append(val.length);
+                        sb.append(">");
+                    }
+                    else {
+                        sb.append(sval);
+                    }
+                     
+                } catch (Exception e) {
+                    if (val != null) {
+                        sb.append("<binary value, length:");
+                        sb.append(val.length);
+                        sb.append(">");
+                    }
+                    else {
+                        sb.append("null value");
+                    }
+                }
+            }
+        }
+        return "{type='" + getName() + "', values='" + sb.toString() + "'}";
+    }
+
+    /**
+     * Retrieves the string representation of an attribute
+     * in an LDAP entry. For example:
+     *
+     * <PRE>LDAPAttribute {type='cn', values='Barbara Jensen,Babs Jensen'}</PRE>
+     *
+     * @return string representation of the attribute.
+     */
+    public String toString() {
+        return "LDAPAttribute " + getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPDN.java
@@ -0,0 +1,190 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import netscape.ldap.util.*;
+import java.io.*;
+
+/**
+ * Represents a distinguished name in LDAP.
+ * <P>
+ *
+ * You can use objects of this class to split a distinguished name
+ * (DN) into its individual components.  You can also escape the
+ * characters in a DN.
+ * <P>
+ *
+ * @version 1.0
+ */
+public class LDAPDN {
+
+    /**
+     * Returns the individual components of a distinguished name (DN).
+     * @param dn distinguished name of which you want to get the components.
+     * @param noTypes if <CODE>true</CODE>, returns only the values of the
+     * components and not the names (such as 'cn=')
+     * @return an array of strings representing the components of the DN.
+     * @see netscape.ldap.LDAPDN#explodeRDN(java.lang.String, boolean)
+     */
+    public static String[] explodeDN (String dn, boolean noTypes) {
+        DN name = new DN(dn);
+        return name.explodeDN(noTypes);
+    }
+
+    /**
+     * Returns the individual components of a relative distinguished name (RDN).
+     * @param rdn relative distinguished name of which you want to get the components.
+     * @param noTypes if <CODE>true</CODE>, returns only the values of the
+     * components and not the names (such as 'cn=')
+     * @return an array of strings representing the components of the RDN.
+     * @see netscape.ldap.LDAPDN#explodeDN(java.lang.String, boolean)
+     */
+    public static String[] explodeRDN (String rdn, boolean noTypes) {
+        RDN name = new RDN(rdn);
+        if ( noTypes ) {
+            return name.getValues();
+        } else {
+            String[] str = new String[1];
+            str[0] = name.toString();
+            return str;
+        }
+    }
+
+    /**
+     * Returns the RDN after escaping the characters specified
+     * by <CODE>netscape.ldap.util.DN.ESCAPED_CHAR</CODE>.
+     * <P>
+     *
+     * @param rdn the RDN to escape
+     * @return the RDN with the characters escaped.
+     * @see netscape.ldap.util.DN#ESCAPED_CHAR
+     * @see netscape.ldap.LDAPDN#unEscapeRDN(java.lang.String)
+     */
+    public static String escapeRDN(String rdn) {
+
+        RDN name = new RDN(rdn);
+        String[] val = name.getValues();
+        if (val == null)
+            return rdn;
+
+        StringBuffer[] buffer = new StringBuffer[val.length];
+        StringBuffer retbuf = new StringBuffer();
+        String[] types = name.getTypes();
+
+        for (int j = 0; j < val.length; j++ ) {
+            buffer[j] = new StringBuffer(val[j]);
+
+            int i=0;
+            while (i<buffer[j].length()) {
+                if (isEscape(buffer[j].charAt(i))) {
+                    buffer[j].insert(i, '\\');
+                    i++;
+                }
+                
+                i++;
+            }
+
+            retbuf.append( ((retbuf.length() > 0) ? " + " : "") + types[j] + "=" +
+                           ( new String( buffer[j] ) ) );
+        }
+
+        return new String( retbuf );
+    }
+
+    /**
+     * Returns the RDN after unescaping any escaped characters.
+     * For a list of characters that are typically escaped in a
+     * DN, see <CODE>netscape.ldap.LDAPDN.ESCAPED_CHAR</CODE>.
+     * <P>
+     *
+     * @param rdn the RDN to unescape
+     * @return the unescaped RDN.
+     * @see netscape.ldap.util.DN#ESCAPED_CHAR
+     * @see netscape.ldap.LDAPDN#escapeRDN(java.lang.String)
+     */
+    public static String unEscapeRDN(String rdn) {
+        RDN name = new RDN(rdn);
+        String[] vals = name.getValues();
+        if ( (vals == null) || (vals.length < 1) )
+            return rdn;
+
+        StringBuffer buffer = new StringBuffer(vals[0]);
+        StringBuffer copy = new StringBuffer();
+        int i=0;
+        while (i<buffer.length()) {
+            char c = buffer.charAt(i++);
+            if (c != '\\') {
+                copy.append(c);
+            }
+            else { // copy the escaped char following the back slash
+                if (i<buffer.length()) {
+                    copy.append(buffer.charAt(i++));
+                }
+            }
+        }
+
+        return name.getTypes()[0]+"="+(new String(copy));
+    }
+
+    /** 
+     * Normalizes the dn.
+     * @param dn the DN to normalize
+     * @return the normalized DN
+     */
+    public static String normalize(String dn) {
+        return (new DN(dn)).toString();
+    }
+    
+    /** 
+     * Compares two dn's for equality.
+     * @param dn1 the first dn to compare
+     * @param dn2 the second dn to compare
+     * @return true if the two dn's are equal
+     */
+    public static boolean equals(String dn1, String dn2) {
+        return normalize(dn1).equals(normalize(dn2));
+    }
+
+    private static boolean isEscape(char c) {
+        for (int i=0; i<DN.ESCAPED_CHAR.length; i++)
+            if (c == DN.ESCAPED_CHAR[i])
+                return true;
+        return false;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPCache.java
@@ -0,0 +1,853 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+import netscape.ldap.client.*;
+import netscape.ldap.util.*;
+import java.util.zip.CRC32;
+
+/**
+ * <CODE>LDAPCache</CODE> represents an in-memory cache that you can use 
+ * to reduce the number of search requests sent to the LDAP server.
+ * <P>
+ *
+ * Each item in the cache represents a search request and
+ * its results.  Each item is uniquely identified by the
+ * search criteria, which includes:
+ * <P>
+ *
+ * <UL>
+ * <LI>the host name and port number of the LDAP server
+ * <LI>the base DN of the search
+ * <LI>the search filter
+ * <LI>the scope of the search
+ * <LI>the attributes to be returned in the search results
+ * <LI>the DN used to authenticate the client when binding
+ *     to the server
+ * <LI>the LDAP v3 controls specified in the search request
+ * </UL>
+ * <P>
+ *
+ * After a search request is cached, the results of any
+ * subsequent search requests using the same criteria are
+ * read from the cache.  Note that if any part of the
+ * criteria differs (for example, if a different DN is used
+ * when binding to the server or if a different set of
+ * attributes to be returned is specified), the search
+ * request is sent to the server.
+ * <P>
+ *
+ * When you create the cache, you specify the maximum amount
+ * of time that an item can be kept in the cache.  When an
+ * item's age exceeds that time limit, the item is removed
+ * from the cache.
+ * <P>
+ *
+ * The cache also has a maximum size that you specify when
+ * creating the cache.  If adding a new item exceeds the
+ * maximum size of the cache, the first entries in the cache
+ * are removed to make enough space for the new item.
+ * <P>
+ *
+ * Finally, when creating the cache, you can specify a list
+ * of the base DNs in search requests that you want to cache.
+ * For example, if you specify <CODE>o=Airius.com</CODE> as
+ * a base DN to cache, your client caches search requests
+ * where the base DN is <CODE>o=Airius.com</CODE>.
+ * <P>
+ *
+ * To specify that you want to use a cache for a particular
+ * LDAP session, call the <CODE>setCache</CODE> method of
+ * the <CODE>LDAPConnection</CODE> object that you are
+ * working with.
+ * <P>
+ *
+ * All clones of an <CODE>LDAPConnection</CODE> object share
+ * the same <CODE>LDAPCache</CODE> object.
+ * <P>
+ * 
+ * Note that <CODE>LDAPCache</CODE> does not maintain consistency 
+ * with the directory, so that cached search results may no longer be
+ * valid after a directory update. If the same application is performing 
+ * both cached searches and directory updates, then the 
+ * application should flush the corresponding cache entries after an update.
+ * To do this use the <CODE>flushEntries</CODE> method.
+ * <P>
+ *
+ * Also, note that search requests that return referrals are not cached.
+ * <P>
+ *
+ * The <CODE>LDAPCache</CODE> class includes methods for
+ * getting statistics (such as hit rates) from the cache and
+ * for flushing entries from the cache.
+ * <P>
+ *
+ * @see netscape.ldap.LDAPConnection#setCache(netscape.ldap.LDAPCache)
+ * @see netscape.ldap.LDAPConnection#getCache
+ */
+public class LDAPCache implements Serializable {
+    static final long serialVersionUID = 6275167993337814294L;
+    
+    /**
+     * A hashtable of search results. The key is created from the search
+     * request parameters (see createKey() method). The value is a Vector
+     * where the first element is a Long integer representing the size
+     * of all entries, followed by the actual search result entries (of type
+     * LDAPEntry).
+     */    
+    private Hashtable m_cache;
+    
+    /**
+     * A list of cached entries ordered by time (augments m_cache). Each
+     * element in the list is a 2 element Vector where the element at index
+     * 0 is the key in the m_cache table, and the element at index 1 is the
+     * time when the entry was created.
+     * The list is used to track the time-to-live limit and to implement the
+     * FIFO algorithm when adding new entries; if the size of the new entry
+     * exceeds the cache available space, the extra space is made by removing
+     * existing cached results in the order of their entry in the cache.
+     */
+    private Vector m_orderedStruct;
+
+    private long m_timeToLive;
+    private long m_maxSize;
+    private String[] m_dns;
+    private long m_remainingSize = 0;
+
+    // Count of LDAPConnections that share this cache
+    private int m_refCnt = 0;
+
+    /**
+     * Delimiter used internally when creating keys
+     * for the cache.
+     */
+    public static final String DELIM = "#";
+    private TTLTimer m_timer = null;
+    private long m_totalOpers = 0;
+    private long m_hits = 0;
+    private long m_flushes = 0;
+
+    // Debug can be activated by defining debug.cache property    
+    private static boolean m_debug = false;
+    static {
+        try {
+            String traceProp = System.getProperty("debug.cache");
+            m_debug = (traceProp != null);
+        }
+        catch (Exception e) {
+            ;// In browser access to property might not be allowed
+        }
+    }
+    
+    /**
+     * Constructs a new <CODE>LDAPCache</CODE> object, using the
+     * specified maximum size of the cache (in bytes) and the maximum
+     * age of cached items (in seconds).  When items in the cache
+     * exceed this age, they are removed from the cache.
+     * <P>
+     *
+     * @param ttl the maximum amount of time that an item can be cached
+     *  (in seconds)
+     * @param size the maximum size of the cache (in bytes)
+     */
+    public LDAPCache(long ttl, long size)
+    {
+        init(ttl, size);
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPCache</CODE> object, using the
+     * specified maximum size of the cache (in bytes), and the maximum
+     * age of cached items (in seconds), and an array of  the base DNs
+     * of searches that you want to cache.  (For example,
+     * if the array of base DNs includes <CODE>o=Airius.com</CODE>,
+     * the cache stores search results if the base DN in the search
+     * request is <CODE>o=Airius.com</CODE>.)
+     * <P>
+     *
+     * @param ttl the maximum amount of time that an item can be cached
+     *  (in seconds)
+     * @param size the maximum size of the cache (in bytes)
+     * @param dns the list of base DNs of searches that you want to cache.
+     */
+    public LDAPCache(long ttl, long size, String[] dns)
+    {
+        init(ttl, size);
+
+        m_dns = new String[dns.length];
+        if ((dns != null) && (dns.length > 0))
+            for (int i=0; i<dns.length; i++) {
+                m_dns[i] = (new DN(dns[i])).toString();
+        }
+    }
+
+    /**
+     * Gets the maximum size of the cache (in bytes).
+     * <P>
+     *
+     * @return the maximum size of the cache (in bytes).
+     */
+    public long getSize()
+    {
+        return m_maxSize;
+    }
+
+    /**
+     * Gets the maximum age allowed for cached items (in
+     * seconds).  (Items that exceed this age are
+     * removed from the cache.)
+     * <P>
+     *
+     * @return the maximum age of items in the cache (in
+     *  seconds).
+     */
+    public long getTimeToLive()
+    {
+        return m_timeToLive/1000;
+    }
+
+    /**
+     * Gets the array of base DNs of searches to be cached.
+     * (Search requests with these base DNs are cached.)
+     * <P>
+     *
+     * @return the array of base DNs.
+     */
+    public String[] getBaseDNs()
+    {
+        return m_dns;
+    }
+
+    /**
+     * Flush the entries identified by DN and scope from the cache.
+     * <P>
+     *
+     * @param dn the distinguished name (or base DN) of the entries
+     *  to be removed from the cache. Use this parameter in conjunction
+     *  with <CODE>scope</CODE> to identify the entries that you want
+     *  removed from the cache.  If this parameter is <CODE>null</CODE>,
+     *  the entire cache is flushed.
+     * @param scope the scope identifying the entries that you want
+     *  removed from the cache. The value of this parameter can be
+     *  one of the following:
+     *  <UL>
+     *  <LI><CODE>LDAPv2.SCOPE_BASE</CODE> (to remove the entry identified
+     *      by <CODE>dn</CODE>)
+     *  <LI><CODE>LDAPv2.SCOPE_ONE</CODE> (to remove the entries that
+     *      have <CODE>dn</CODE> as their parent entry)
+     *  <LI><CODE>LDAPv2.SCOPE_SUB</CODE> (to remove the entries in the
+     *      subtree under <CODE>dn</CODE> in the directory)
+     *  </UL>
+     * <P>
+     * @return <CODE>true</CODE> if the entry is removed from the cache;
+     * <CODE>false</CODE> if the entry is not removed.
+     */
+    public synchronized boolean flushEntries(String dn, int scope) {
+
+        if (m_debug)
+            System.out.println("DEBUG: User request for flushing entry: dn "+
+            dn+" and scope "+scope);
+        // if the dn is null, invalidate the whole cache
+        if (dn == null)
+        {
+            // reclaim all the cache spaces
+            m_remainingSize = m_maxSize;
+            m_cache.clear();
+            m_orderedStruct.removeAllElements();
+            // reset stats
+            m_totalOpers = m_hits = m_flushes = 0;
+
+            return true;
+        }
+
+        DN dn2 = new DN(dn);
+
+        Enumeration e = m_cache.keys();
+
+        while(e.hasMoreElements()) {
+            Long key = (Long)e.nextElement();
+            Vector val = (Vector)m_cache.get(key);
+
+            // LDAPEntries start at idx 1, at idx 0 is a Long
+            // (size of all LDAPEntries returned by search())
+            int j=1;
+            int size2=val.size();
+
+            for (; j<size2; j++) {
+                String d = ((LDAPEntry)val.elementAt(j)).getDN();
+                DN dn1 = new DN(d);
+
+                if (dn1.equals(dn2))
+                    break;
+                if (scope == LDAPConnection.SCOPE_ONE) {
+                    DN parentDN1 = dn1.getParent();
+                    if (parentDN1.equals(dn2)) {
+                        break;
+                    }
+                }
+                if ((scope == LDAPConnection.SCOPE_SUB) &&
+                    (dn1.isDescendantOf(dn2))) {
+                    break;
+                }
+            }
+
+            if (j < size2) {
+                for (int k=0; k<m_orderedStruct.size(); k++) {
+                    Vector v = (Vector)m_orderedStruct.elementAt(k);
+                    if (key.equals((Long)v.elementAt(0))) {
+                        m_orderedStruct.removeElementAt(k);
+                        break;
+                    }
+                }
+                Vector entry = (Vector)m_cache.remove(key);
+                m_remainingSize += ((Long)entry.firstElement()).longValue();
+                if (m_debug)
+                    System.out.println("DEBUG: Successfully removed entry ->"+key);
+
+                return true;
+            }
+        }
+
+        if (m_debug)
+            System.out.println("DEBUG: The number of keys in the cache is "
+            +m_cache.size());
+
+        return false;
+    }
+
+    /**
+     * Gets the amount of available space (in bytes) left in the cache.
+     * <P>
+     *
+     * @return the available space (in bytes) in the cache.
+     */
+    public long getAvailableSize() {
+        return m_remainingSize;
+    }
+
+    /**
+     * Gets the total number of requests for retrieving items from
+     * the cache.  This includes both items successfully found in
+     * the cache and items not found in the cache.
+     * <P>
+     *
+     * @return the total number of requests for retrieving items from
+     * the cache.
+     */
+    public long getTotalOperations() {
+        return m_totalOpers;
+    }
+
+    /**
+     * Gets the total number of requests which failed to find and
+     * retrieve an item from the cache.
+     * <P>
+     *
+     * @return the number of requests that did not find and retrieve
+     *  an item in the cache.
+     */
+    public long getNumMisses() {
+        return (m_totalOpers - m_hits);
+    }
+
+    /**
+     * Gets the total number of requests which successfully found and
+     * retrieved an item from the cache.
+     * @return the number of requests that successfully found and
+     *  retrieved an item from the cache.
+     */
+    public long getNumHits() {
+        return m_hits;
+    }
+
+    /**
+     * Gets the total number of entries that are flushed when timer expires
+     *  and <CODE>flushEntries</CODE> is called.
+     * <P>
+     *
+     * @return the total number of entries that are flushed when timer
+     *  expires.
+     */
+    public long getNumFlushes() {
+        return m_flushes;
+    }
+
+    /**
+     * Create a key for a cache entry by concatenating all input parameters
+     * @return the key for a cache entry
+     * @exception LDAPException Thrown when failed to create key.
+     */
+    Long createKey(String host, int port, String baseDN, String filter,
+      int scope, String[] attrs, String bindDN, LDAPConstraints cons)
+      throws LDAPException {
+
+        DN dn = new DN(baseDN);
+        baseDN = dn.toString();
+
+        if (m_dns != null) {
+            int i=0;
+            for (; i<m_dns.length; i++) {
+                if (baseDN.equals(m_dns[i]))
+                    break;
+            }
+
+            if (i >= m_dns.length)
+                throw new LDAPException(baseDN+" is not a cached base DN",
+                LDAPException.OTHER);
+        }
+
+        String key = null;
+
+        key = appendString(baseDN);
+        key = key+appendString(scope);
+        key = key+appendString(host);
+        key = key+appendString(port);
+        key = key+appendString(filter);
+        key = key+appendString(attrs);
+        key = key+appendString(bindDN);
+
+        LDAPControl[] serverControls = null;
+        LDAPControl[] clientControls = null;
+
+        // get server and client controls
+        if (cons != null)
+        {
+            serverControls = cons.getServerControls();
+            clientControls = cons.getClientControls();
+        }
+
+        if ((serverControls != null) && (serverControls.length > 0))
+        {
+            String[] objID = new String[serverControls.length];
+
+            for (int i=0; i<serverControls.length; i++) {
+                LDAPControl ctrl = serverControls[i];
+                long val = getCRC32(ctrl.getValue());
+                objID[i] = ctrl.getID() + ctrl.isCritical() + new Long(val).toString();
+            }
+            key = key + appendString(objID);
+        }
+        else
+            key = key+appendString(0);
+
+        if ((clientControls != null) && (clientControls.length > 0))
+        {
+            String[] objID = new String[clientControls.length];
+
+            for (int i=0; i<clientControls.length; i++) {
+                LDAPControl ctrl = clientControls[i];
+                long val = getCRC32(ctrl.getValue());
+                objID[i] = ctrl.getID() + ctrl.isCritical() + new Long(val).toString();
+
+            }
+            key = key + appendString(objID);
+        }
+        else
+            key = key+appendString(0);
+
+        long val = getCRC32(key.getBytes());
+        if(m_debug) {
+            System.out.println("key="+val + " for "+key);
+        }
+        return new Long(val);
+    }
+
+    /**
+     * Gets the cache entry based on the specified key.
+     * @param key the key for the cache entry
+     * @return the cache entry.
+     */
+    synchronized Object getEntry(Long key) {
+        Object obj = null;
+
+        obj = m_cache.get(key);
+        m_totalOpers++;
+
+        if (m_debug) {
+            if (obj == null)
+                System.out.println("DEBUG: Entry whose key -> "+key+
+                    " not found in the cache.");
+            else
+                System.out.println("DEBUG: Entry whose key -> "+key+
+                    " found in the cache.");
+        }
+
+        if (obj != null)
+            m_hits++;
+
+
+        return obj;
+    }
+
+    /**
+     * Flush entries which stay longer or equal to the time-to-live.
+     */
+    synchronized void flushEntries()
+    {
+        Vector v = null;
+        boolean delete = false;
+
+        long currTime = System.currentTimeMillis();
+
+        m_flushes = 0;
+        while(true) {
+            if (m_orderedStruct.size() <= 0)
+                break;
+
+            v = (Vector)m_orderedStruct.firstElement();
+            long diff = currTime-((Long)v.elementAt(1)).longValue();
+            if (diff >= m_timeToLive) {
+                Long key = (Long)v.elementAt(0);
+
+                if (m_debug)
+                    System.out.println("DEBUG: Timer flush entry whose key is "+key);
+                Vector entry = (Vector)m_cache.remove(key);
+                m_remainingSize += ((Long)entry.firstElement()).longValue();
+
+                // always delete the first one
+                m_orderedStruct.removeElementAt(0);
+
+                m_flushes++;
+            }
+            else
+            break;
+        }
+
+        if (m_debug)
+            System.out.println("DEBUG: The number of keys in the cache is "
+                +m_cache.size());
+    }
+
+    /**
+     * Add the entry to the hashtable cache and to the vector respectively.
+     * The vector is used to keep track of the order of the entries being added.
+     * @param key the key for the cache entry
+     * @param value the cache entry being added to the cache for the specified
+     * key
+     * @return a flag indicating whether the entry was added.
+     */
+    synchronized boolean addEntry(Long key, Object value)
+    {
+        // if entry exists, dont perform add operation
+        if (m_cache.get(key) != null)
+            return false;
+
+        Vector v = (Vector)value;
+        long size = ((Long)v.elementAt(0)).longValue();
+
+        if (size > m_maxSize) {
+            if (m_debug) {
+                System.out.println("Failed to add an entry to the cache since the new entry exceeds the cache size");
+            }    
+            return false;
+        }
+
+        // if the size of entry being added is bigger than the spare space in the
+        // cache
+        if (size > m_remainingSize) {
+            while (true) {
+                Vector element = (Vector)m_orderedStruct.firstElement();
+                Long str = (Long)element.elementAt(0);
+                Vector val = (Vector)m_cache.remove(str);
+                if (m_debug)
+                    System.out.println("DEBUG: The spare size of the cache is not big enough "+
+                        "to hold the new entry, deleting the entry whose key -> "+str);
+
+                // always remove the first one
+                m_orderedStruct.removeElementAt(0);
+                m_remainingSize += ((Long)val.elementAt(0)).longValue();
+                if (m_remainingSize >= size)
+                    break;
+            }
+        }
+
+        m_remainingSize -= size;
+        m_cache.put(key, v);
+        Vector element = new Vector(2);
+        element.addElement(key);
+        element.addElement(new Long(System.currentTimeMillis()));
+        m_orderedStruct.addElement(element);
+
+        // Start TTL Timer if first entry is added
+        if (m_orderedStruct.size() == 1) {
+            scheduleTTLTimer();
+        }            
+            
+        if (m_debug)
+        {
+            System.out.println("DEBUG: Adding a new entry whose key -> "+key);
+            System.out.println("DEBUG: The current number of keys in the cache "+
+            m_cache.size());
+        }
+        return true;
+    }
+
+    /**
+     * Flush entries which stayed longer or equal to the time-to-live, and
+     * Set up the TTLTimer for the next flush. Called when first entry is
+     * added to the cache and when the TTLTimer expires.
+     */
+    synchronized void scheduleTTLTimer() {
+        if (m_orderedStruct.size() <= 0) {
+                return;
+        }
+
+        if (m_timer == null) {            
+            m_timer = new TTLTimer(this);
+        }
+
+        Vector v = (Vector)m_orderedStruct.firstElement();        
+        long currTime = System.currentTimeMillis();
+        long creationTime = ((Long)v.elementAt(1)).longValue();
+        long timeout = creationTime + m_timeToLive - currTime;
+        if (timeout > 0) {
+            m_timer.start(timeout);
+        }
+        else {
+            flushEntries();
+            scheduleTTLTimer();
+        }
+    }        
+        
+    
+    /**
+     * Gets the number of entries being cached.
+     * @return the number of entries being cached.
+     */
+    public int getNumEntries()
+    {
+        return m_cache.size();
+    }
+
+    /**
+     * Get number of LDAPConnections that share this cache
+     * @return Reference Count
+     */
+    int getRefCount() {
+        return m_refCnt;
+    }
+
+    /**
+     * Add a new reference to this cache.
+     *
+     */
+    synchronized void addReference() {
+        m_refCnt++;
+        if (m_debug) {
+            System.err.println("Cache refCnt="+ m_refCnt);
+        }
+    }
+
+    /**
+     * Remove a reference to this cache.
+     * If the reference count is 0, cleaup the cache.
+     *
+     */
+    synchronized void removeReference() {
+        if (m_refCnt > 0) {
+            m_refCnt--;
+            if (m_debug) {
+                System.err.println("Cache refCnt="+ m_refCnt);
+            }
+            if (m_refCnt == 0 ) {
+                cleanup();
+            }
+        }
+    }
+
+    /**
+     * Cleans up
+     */
+    synchronized void cleanup() {
+        flushEntries(null, 0);
+        if (m_timer != null) {
+            m_timer.stop();
+            m_timer = null;
+        }
+    }
+
+    /**
+     * Initialize the instance variables.
+     */
+    private void init(long ttl, long size)
+    {
+        m_cache = new Hashtable();
+        m_timeToLive = ttl*1000;
+        m_maxSize = size;
+        m_remainingSize = size;
+        m_dns = null;
+        m_orderedStruct = new Vector();
+    }
+
+    /**
+     * Concatenates the specified integer with the delimiter.
+     * @param str the String to concatenate with the delimiter
+     * @return the concatenated string.
+     */
+    private String appendString(String str) {
+        if (str == null)
+            return "null"+DELIM;
+        else
+            return str.trim()+DELIM;
+    }
+
+    /**
+     * Concatenates the specified integer with the delimiter.
+     * @param num the integer to concatenate with the delimiter
+     * @return the concatenated string.
+     */
+    private String appendString(int num) {
+        return num+DELIM;
+    }
+
+    /**
+     * Concatenate the specified string array with the delimiter.
+     * @param str a string array
+     * @return the concatenated string.
+     */
+    private String appendString(String[] str) {
+
+        if ((str == null) || (str.length < 1))
+            return "0"+DELIM;
+        else {
+            String[] sorted = new String[str.length];
+            System.arraycopy( str, 0, sorted, 0, str.length );
+            sortStrings(sorted);
+
+            String s = sorted.length+DELIM;
+            for (int i=0; i<sorted.length; i++)
+                s = s+sorted[i].trim()+DELIM;
+            return s;
+        }
+    }
+
+    /**
+     * Sorts the array of strings using bubble sort.
+     * @param str the array of strings to sort. The str parameter contains
+     * the sorted result.
+     */
+    private void sortStrings(String[] str) {
+
+        for (int i=0; i<str.length; i++)
+            str[i] = str[i].trim();
+
+        for (int i=0; i<str.length-1; i++)
+            for (int j=i+1; j<str.length; j++)
+            {
+                if (str[i].compareTo(str[j]) > 0)
+                {
+                    String t = str[i];
+                    str[i] = str[j];
+                    str[j] = t;
+                }
+            }
+    }
+
+    /**
+     * Create a 32 bits CRC from the given byte array.
+     */
+    private long getCRC32(byte[] barray) {
+        if (barray==null) {
+            return 0;
+        }
+        CRC32 crcVal = new CRC32();
+        crcVal.update(barray);
+        return crcVal.getValue();
+    }
+}
+
+/**
+ * Represents a timer which will timeout for every certain interval. It
+ * provides methods to start, stop, or restart timer.
+ */
+class TTLTimer implements Runnable{
+
+    private long m_timeout;
+    private LDAPCache m_cache;
+    private Thread t = null;
+
+    /**
+     * Constructor with the specified timout.
+     * @param timeout the timeout value in milliseconds
+     */
+    TTLTimer(LDAPCache cache) {
+        m_cache = cache;
+    }
+
+    /**
+     * (Re)start the timer.
+     */
+    void start(long timeout) {
+        m_timeout = timeout;
+        if (Thread.currentThread() != t) {
+            stop();
+        }            
+        t = new Thread(this, "LDAPCache-TTLTimer");
+        t.setDaemon(true);
+        t.start();
+    }
+
+    /**
+     * Stop the timer.
+     */
+    void stop() {
+        if (t !=null) {
+            t.interrupt();
+        }
+    }
+
+    /**
+     * The runnable waits until the timeout period has elapsed. It then notify
+     * the registered listener who listens for the timeout event.
+     */
+    public void run() {
+
+        synchronized(this) {
+            try {
+                this.wait(m_timeout);
+            } catch (InterruptedException e) {
+                // This happens if the timer is stopped
+                return;
+            }
+        }
+
+        m_cache.scheduleTTLTimer();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPRebindAuth.java
@@ -0,0 +1,112 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * Represents information used to authenticate the client in cases where
+ * the client follows referrals automatically.  If you are defining a class
+ * that implements the <CODE>LDAPRebind</CODE> interface, your implementation
+ * of the <CODE>LDAPRebind.getRebindAuthentication</CODE> method needs to
+ * construct and return an object of this class.
+ * <P>
+ *
+ * For example, the following method sets up authentication information based
+ * on the LDAP server identified in the referral.  Ideally, this method would be
+ * defined as part of a class implementing the <CODE>LDAPRebind</CODE> interface.
+ *
+ * <PRE>
+ * private String myDN = "cn=Directory Manager,o=Ace Industry,c=US";
+ * private String myPW = "alway4444";
+ * private LDAPRebindAuth myRebindInfo;
+ * ...
+ * public LDAPRebindAuth getRebindAuthentication( String host, int port ) {
+ *  if ( host.equalsIgnoreCase( "alway.mcom.com" ) && ( port == 389 ) ) {
+ *      myRebindInfo = new LDAPRebindAuth( myDN, myPW );
+ *  } else {
+ *      myRebindInfo = new LDAPRebindAuth( "", "" );
+ *  }
+ *  return myRebindInfo;
+ * } </PRE>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPRebind
+ */
+public class LDAPRebindAuth implements java.io.Serializable {
+
+    static final long serialVersionUID = 7161655313564756294L;
+    private String m_dn;
+    private String m_password;
+
+    /**
+     * Constructs information that is used by the client
+     * for authentication when following referrals automatically.
+     * @param dn distinguished name to use for authenticating to
+     * the LDAP server during an automatic referral (if the client
+     * is set up to follow referrals automatically)
+     * @param password password to use for authenticating to
+     * the LDAP server during an automatic referral (if the client
+     * is set up to follow referrals automatically)
+     */
+    public LDAPRebindAuth(String dn, String password) {
+        m_dn = dn;
+        m_password = password;
+    }
+
+    /**
+     * Returns the distinguished name to be used for reauthentication,
+     * if the client is set up to follow referrals automatically.
+     * @return distinguished name to use when authenticating to
+     * other LDAP servers during referrals.
+     */
+    public String getDN() {
+        return m_dn;
+    }
+
+    /**
+     * Returns the password to be used for reauthentication,
+     * if the client is set up to follow referrals automatically.
+     * @return password to use when authenticating to other
+     * LDAP servers during referrals.
+     */
+    public String getPassword() {
+        return m_password;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPSyntaxSchemaElement.java
@@ -0,0 +1,169 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * Helper class supporting schema elements that include syntax
+ * definitions - attributes and matching rules
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPAttributeSchema
+ * @see netscape.ldap.LDAPMatchingRuleSchema
+ **/
+
+class LDAPSyntaxSchemaElement extends LDAPSchemaElement {
+
+    static final long serialVersionUID = 6086340702503710702L;
+
+    /**
+     * Construct a blank element.
+     */
+    LDAPSyntaxSchemaElement() {
+        super();
+    }
+
+    /**
+     * Gets the syntax of the schema element
+     * @return One of the following values:
+     * <UL>
+     * <LI><CODE>cis</CODE> (case-insensitive string)
+     * <LI><CODE>ces</CODE> (case-exact string)
+     * <LI><CODE>binary</CODE> (binary data)
+     * <LI><CODE>int</CODE> (integer)
+     * <LI><CODE>telephone</CODE> (telephone number -- identical to cis,
+     * but blanks and dashes are ignored during comparisons)
+     * <LI><CODE>dn</CODE> (distinguished name)
+     * <LI><CODE>unknown</CODE> (not a known syntax)
+     * </UL>
+     */
+    int getSyntax() {
+        return syntax;
+    }
+
+    /**
+     * Gets the syntax of the attribute type in dotted-decimal format,
+     * for example "1.2.3.4.5"
+     * @return The attribute syntax in dotted-decimal format.
+     */
+    String getSyntaxString() {
+        return syntaxString;
+    }
+
+    /**
+     * Convert from enumerated syntax types to an OID
+     * @param syntax One of the enumerated syntax types
+     * @return The OID corresponding to the internal type
+     */
+    static String internalSyntaxToString( int syntax ) {
+        String s;
+        if ( syntax == cis ) {
+            s = cisString;
+        } else if ( syntax == binary ) {
+            s = binaryString;
+        } else if ( syntax == ces ) {
+            s = cesString;
+        } else if ( syntax == telephone ) {
+            s = telephoneString;
+        } else if ( syntax == dn ) {
+            s = dnString;
+        } else if ( syntax == integer ) {
+            s = intString;
+        } else {
+            s = null;
+        }
+        return s;
+    }
+
+    /**
+     * Convert from enumerated syntax type to a user-friendly
+     * string
+     * @param syntax One of the enumerated syntax types
+     * @return A user-friendly syntax description
+     */
+    String syntaxToString() {
+        String s;
+        if ( syntax == cis ) {
+            s = "case-insensitive string";
+        } else if ( syntax == binary ) {
+            s = "binary";
+        } else if ( syntax == integer ) {
+            s = "integer";
+        } else if ( syntax == ces ) {
+            s = "case-exact string";
+        } else if ( syntax == telephone ) {
+            s = "telephone";
+        } else if ( syntax == dn ) {
+            s = "distinguished name";
+        } else {
+            s = syntaxString;
+        }
+        return s;
+    }
+
+    /**
+     * Convert from an OID to one of the enumerated syntax types
+     * @param syntax A dotted-decimal OID
+     * @return The internal enumerated type corresponding to the
+     * OID; <CODE>unknown</CODE> if it is not one of the known
+     * types
+     */
+    int syntaxCheck( String syntax ) {
+        int i = unknown;
+        if ( syntax == null ) {
+        } else if ( syntax.equals( cisString ) ) {
+            i = cis;
+        } else if ( syntax.equals( binaryString ) ) {
+            i = binary;
+        } else if ( syntax.equals( cesString ) ) {
+            i = ces;
+        } else if ( syntax.equals( intString ) ) {
+            i = integer;
+        } else if ( syntax.equals( telephoneString ) ) {
+            i = telephone;
+        } else if ( syntax.equals( dnString ) ) {
+            i = dn;
+        }
+        return i;
+    }
+    
+
+    int syntax = unknown;
+    String syntaxString = null;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/LDAPDITContentRuleSchema.java
@@ -0,0 +1,411 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap;
+
+import java.util.*;
+
+/**
+ * The definition of a DIT content rule in the schema.
+ * <A HREF="http://www.ietf.org/rfc/rfc2252.txt"
+ * TARGET="_blank">RFC 2252, Lightweight Directory Access Protocol (v3):
+ * DIT Content Rule Description</A> covers the types of information
+ * to specify when defining a DIT content rule. According to the RFC, 
+ * the description of a DIT content rule can include the following:
+ * <P>
+ *
+ * <UL>
+ * <LI>an OID identifying the attribute type
+ * <LI>a name identifying the attribute type
+ * <LI>a description of the attribute type
+ * <LI>the name of the parent attribute type
+ * <LI>the syntax used by the attribute (for example,
+ * <CODE>cis</CODE> or <CODE>int</CODE>)
+ * <LI>an indication of whether the attribute type is single-valued
+ * or multi-valued
+ * </UL>
+ * <P>
+ *
+ * When you construct an <CODE>LDAPDITContentRuleSchema</CODE> object, you can
+ * specify these types of information as arguments to the constructor or
+ * in the AttributeTypeDescription format specified in RFC 2252.
+ * When an LDAP client searches an LDAP server for the schema, the server
+ * returns schema information as an object with attribute values in this
+ * format.
+ * <P>
+ *
+ * There are a number of additional optional description fields which
+ * are not explicitly accessible through LDAPDITContentRuleSchema, but which
+ * can be managed with setQualifier, getQualifier, and getQualifierNames:
+ * <P>
+ *
+ * <UL>
+ * <LI>OBSOLETE
+ * </UL>
+ * <P>
+ *
+ * To get the name, OID, and description of this DIT content rule
+ * , use the <CODE>getName</CODE>, <CODE>getOID</CODE>, and
+ * <CODE>getDescription</CODE> methods inherited from the abstract class
+ * <CODE>LDAPSchemaElement</CODE>. Optional and custom qualifiers are
+ * accessed with <CODE>getQualifier</CODE> and <CODE>getQualifierNames</CODE>
+ * from <CODE>LDAPSchemaElement</CODE>.
+ * <P>
+ *
+ * To add or remove this attribute type definition from the
+ * schema, use the <CODE>add</CODE> and <CODE>remove</CODE>
+ * methods, which this class inherits from the <CODE>LDAPSchemaElement</CODE>
+ * abstract class.
+ * <P>
+ * RFC 2252 defines DITContentRuleDescription as follows:
+ * <P>
+ * <PRE>
+ *    DITContentRuleDescription = "("
+ *        numericoid   ; Structural ObjectClass identifier
+ *        [ "NAME" qdescrs ]
+ *        [ "DESC" qdstring ]
+ *        [ "OBSOLETE" ]
+ *        [ "AUX" oids ]    ; Auxiliary ObjectClasses
+ *        [ "MUST" oids ]   ; AttributeType identifiers
+ *        [ "MAY" oids ]    ; AttributeType identifiers
+ *        [ "NOT" oids ]    ; AttributeType identifiers
+ *       ")"
+ * </PRE>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPSchemaElement
+ **/
+
+public class LDAPDITContentRuleSchema extends LDAPSchemaElement {
+
+    static final long serialVersionUID = -8588488481097270056L;
+
+    /**
+     * Constructs a blank element.
+     */
+    protected LDAPDITContentRuleSchema() {
+        super();
+    }
+
+    /**
+     * Constructs a DIT content rule definition, using the specified
+     * information.
+     * @param name name of the attribute type
+     * @param oid object identifier (OID) of the attribute type
+     * in dotted-string format (for example, "1.2.3.4")
+     * @param description description of attribute type
+     * @param obsolete <code>true</code> if the rule is obsolete
+     * @param auxiliary a list of auxiliary object classes
+     * allowed for an entry to which this content rule applies.
+     * These may either be specified by name or numeric oid.
+     * @param required a list of user attribute types that an entry
+     * to which this content rule applies must contain in addition to
+     * its normal set of mandatory attributes. These may either be
+     * specified by name or numeric oid.
+     * @param optional a list of user attribute types that an entry
+     * to which this content rule applies may contain in addition to
+     * its normal set of optional attributes. These may either be
+     * specified by name or numeric oid.
+     * @param precluded a list consisting of a subset of the optional
+     * user attribute types of the structural and auxiliary object
+     * classes which are precluded from an entry to which this content rule
+     * applies. These may either be specified by name or numeric oid.
+     */
+    public LDAPDITContentRuleSchema( String name, String oid,
+                                     String description, boolean obsolete,
+                                     String[] auxiliary,
+                                     String[] required,
+                                     String[] optional,
+                                     String[] precluded ) {
+        super( name, oid, description, null );
+        if ( required != null ) {
+            for( int i = 0; i < required.length; i++ ) {
+                must.addElement( required[i] );
+            }
+        }
+        if ( optional != null ) {
+            for( int i = 0; i < optional.length; i++ ) {
+                may.addElement( optional[i] );
+            }
+        }
+        if ( auxiliary != null ) {
+            for( int i = 0; i < auxiliary.length; i++ ) {
+                aux.addElement( auxiliary[i] );
+            }
+        }
+        if ( precluded != null ) {
+            for( int i = 0; i < precluded.length; i++ ) {
+                not.addElement( precluded[i] );
+            }
+        }
+        if ( obsolete ) {
+            setQualifier( OBSOLETE, "" );
+        }
+    }
+
+    /**
+     * Constructs a DIT content rule definition based on a description in
+     * the DITContentRuleDescription format. For information on this format,
+     * (see <A HREF="http://www.ietf.org/rfc/rfc2252.txt"
+     * >RFC 2252, Lightweight Directory Access Protocol (v3):
+     * DIT Content Rule Description</A>.  This is the format that LDAP servers
+     * and clients use to exchange schema information.  (For example, when
+     * you search an LDAP server for its schema, the server returns an entry
+     * with the attributes "objectclasses" and "attributetypes".  The
+     * values of "attributetypes" are attribute type descriptions
+     * in this format.)
+     * <P>
+     *
+     * @param raw definition of the DIT content rule in the
+     * DITContentRuleDescription format
+     */
+    public LDAPDITContentRuleSchema( String raw ) {
+        attrName = "ditContentRules";
+        parseValue( raw );
+        Object o = properties.get( MAY );
+        if ( o != null ) {
+            if ( o instanceof Vector ) {
+                may = (Vector)o;
+            } else {
+                may.addElement( o );
+            }
+        }
+        o = properties.get( MUST );
+        if ( o != null ) {
+            if ( o instanceof Vector ) {
+                must = (Vector)o;
+            } else {
+                must.addElement( o );
+            }
+        }
+        o = properties.get( NOT );
+        if ( o != null ) {
+            if ( o instanceof Vector ) {
+                not = (Vector)o;
+            } else {
+                not.addElement( o );
+            }
+        }
+        o = properties.get( AUX );
+        if ( o != null ) {
+            if ( o instanceof Vector ) {
+                aux = (Vector)o;
+            } else {
+                aux.addElement( o );
+            }
+        }
+    }
+
+    /**
+     * Gets the names of the required attributes for
+     * this content rule.
+     * @return the names of the required attributes
+     * for this content rule.
+     */
+    public String[] getRequiredAttributes() {
+        String[] vals = new String[must.size()];
+        must.copyInto( vals );
+        return vals;
+    }
+
+    /**
+     * Gets the names of optional attributes allowed
+     * in this content rule.
+     * @return the names of optional attributes
+     * allowed in this content rule.
+     */
+    public String[] getOptionalAttributes() {
+        String[] vals = new String[may.size()];
+        may.copyInto( vals );
+        return vals;
+    }
+
+    /**
+     * Gets the names of the precluded attributes for
+     * this content rule.
+     * @return the names of the precluded attributes
+     * for this content rule.
+     */
+    public String[] getPrecludedAttributes() {
+        String[] vals = new String[not.size()];
+        not.copyInto( vals );
+        return vals;
+    }
+
+    /**
+     * Gets the names of the auxiliary object classes allowed
+     * in this content rule.
+     * @return the names of auxiliary object classes
+     * allowed in this content rule.
+     */
+    public String[] getAuxiliaryClasses() {
+        String[] vals = new String[aux.size()];
+        aux.copyInto( vals );
+        return vals;
+    }
+
+    /**
+     * Prepares a value in RFC 2252 format for submission to a server
+     *
+     * @return a String ready for submission to an LDAP server.
+     */
+    public String getValue() {
+        String s = getValuePrefix();
+        String val;
+        val = getOptionalValues( NOVALS );
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        if ( aux.size() > 0 ) {
+            s += AUX + " " + vectorToList( aux );
+            s += ' ';
+        }
+        if ( must.size() > 0 ) {
+            s += MUST + " " + vectorToList( must );
+            s += ' ';
+        }
+        if ( may.size() > 0 ) {
+            s += MAY + " " + vectorToList( may );
+            s += ' ';
+        }
+        if ( not.size() > 0 ) {
+            s += NOT + " " + vectorToList( not );
+            s += ' ';
+        }
+        val = getCustomValues();
+        if ( val.length() > 0 ) {
+            s += val + ' ';
+        }
+        s += ')';
+        return s;
+    }
+
+    /**
+     * Creates a list within parentheses, with $ as delimiter
+     *
+     * @param vals values for list
+     * @return a String with a list of values.
+     */
+    protected String vectorToList( Vector vals ) {
+        String val = "( ";
+        for( int i = 0; i < vals.size(); i++ ) {
+            val += (String)vals.elementAt(i) + ' ';
+            if ( i < (vals.size() - 1) ) {
+                val += "$ ";
+            }
+        }
+        val += ')';
+        return val;
+    }
+
+    /**
+     * Gets the definition of the rule in a user friendly format.
+     * This is the format that the rule definition uses when
+     * printing the attribute type or the schema.
+     * @return definition of the rule in a user friendly format.
+     */
+    public String toString() {
+        String s = "Name: " + name + "; OID: " + oid;
+        s += "; Description: " + description + "; Required: ";
+        int i = 0;
+        Enumeration e = must.elements();
+        while( e.hasMoreElements() ) {
+            if ( i > 0 )
+                s += ", ";
+            i++;
+            s += (String)e.nextElement();
+        }
+        s += "; Optional: ";
+        e = may.elements();
+        i = 0;
+        while( e.hasMoreElements() ) {
+            if ( i > 0 )
+                s += ", ";
+            i++;
+            s += (String)e.nextElement();
+        }
+        s += "; Auxiliary: ";
+        e = aux.elements();
+        i = 0;
+        while( e.hasMoreElements() ) {
+            if ( i > 0 )
+                s += ", ";
+            i++;
+            s += (String)e.nextElement();
+        }
+        s += "; Precluded: ";
+        e = not.elements();
+        i = 0;
+        while( e.hasMoreElements() ) {
+            if ( i > 0 )
+                s += ", ";
+            i++;
+            s += (String)e.nextElement();
+        }
+        if ( isObsolete() ) {
+            s += "; OBSOLETE";
+        }
+        s += getQualifierString( IGNOREVALS );
+        return s;
+    }
+
+    public final static String AUX = "AUX";
+    public final static String MUST = "MUST";
+    public final static String MAY = "MAY";
+    public final static String NOT = "NOT";
+
+    // Qualifiers known to not have values; prepare a Hashtable
+    static final String[] NOVALS = { "OBSOLETE" };
+    static {
+        for( int i = 0; i < NOVALS.length; i++ ) {
+            novalsTable.put( NOVALS[i], NOVALS[i] );
+        }
+    }
+
+    // Qualifiers which we output explicitly in toString()
+    static final String[] IGNOREVALS = { OBSOLETE,
+                                         AUX,
+                                         MUST,
+                                         MAY,
+                                         NOT
+                                       };
+
+    private Vector must = new Vector();
+    private Vector may = new Vector();
+    private Vector aux = new Vector();
+    private Vector not = new Vector();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/factory/JSSSocketFactory.java
@@ -0,0 +1,214 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.factory;
+
+import java.net.*;
+import java.io.*;
+
+import netscape.ldap.*;
+
+import org.mozilla.jss.ssl.SSLSocket;
+import org.mozilla.jss.ssl.SSLCertificateApprovalCallback.ValidityStatus;
+import org.mozilla.jss.ssl.SSLCertificateApprovalCallback;
+import org.mozilla.jss.crypto.X509Certificate;
+import org.mozilla.jss.crypto.AlreadyInitializedException;
+import org.mozilla.jss.CryptoManager;
+
+/**
+ * Creates an SSL socket connection to a server, using the Netscape/Mozilla
+ * JSS package.
+ * This class implements the <CODE>LDAPSocketFactory</CODE>
+ * interface.
+ * <P>
+ * By default, the factory uses "secmod.db", "key*.db" and "cert*.db"
+ * databases in the current directory. If you need to override this default
+ * setting, then you should use the constructor <CODE>JSSSocketFactory(certdbDir)</CODE>.
+ * 
+ * @version 1.1
+ * @see LDAPSocketFactory
+ * @see LDAPConnection#LDAPConnection(netscape.ldap.LDAPSocketFactory)
+ */
+
+public class JSSSocketFactory implements Serializable,
+                                         LDAPTLSSocketFactory,
+                                         SSLCertificateApprovalCallback
+{
+
+    static final long serialVersionUID = -6926469178017736903L;
+
+    /**
+     * Constructs a new <CODE>JSSSocketFactory</CODE>, initializing the
+     * JSS security system if it has not already been initialized.
+     * <p>
+     * The current directory is assumed to be the certificate database directory.
+     * 
+     * @exception LDAPException on initialization error
+     * @see netscape.ldap.factory.JSSSocketFactory#JSSSocketFactory(java.lang.String)
+     */
+    public JSSSocketFactory() throws LDAPException{
+        initialize(".");
+    }
+
+    /**
+     * Constructs a new <CODE>JSSSocketFactory</CODE>, initializing the
+     * JSS security system if it has not already been initialized.
+     *
+     * @param certdbDir The full path, relative or absolute, of the certificate
+     * database directory
+     * @exception LDAPException on initialization error
+     */
+    public JSSSocketFactory( String certdbDir ) throws LDAPException{
+        initialize( certdbDir );
+    }
+
+    /**
+     * Initialize the JSS security subsystem.
+     * <P>
+     * This method allows you to override the current directory as the
+     * default certificate database directory. The directory is expected
+     * to contain <CODE>secmod.db</CODE>, <CODE>key*.db</CODE> and
+     * <CODE>cert*.db</CODE> files as the security module database, key database
+     * and certificate database respectively.
+     * <P>
+     * The method may be called only once, before the first instance of 
+     * <CODE>JSSSocketFactory</CODE> is created. When creating the first
+     * instance, the constructor will automatically initialize the JSS 
+     * security subsystem using the defaults, unless it is already initialized.
+     * <P>
+     * @param certdbDir The full path, relative or absolute, of the certificate
+     * database directory.
+     * @exception LDAPException on initialization error
+     * @see netscape.ldap.factory.JSSSocketFactory#JSSSocketFactory(String)
+     */
+    public static void initialize( String certdbDir ) throws LDAPException {
+        try {
+            CryptoManager.initialize( certdbDir );
+        } catch (AlreadyInitializedException e) {
+            // This is ok
+        } catch (Exception e) {
+            throw new LDAPException("Failed to initialize JSSSocketFactory: "
+                                    + e.getMessage(), LDAPException.OTHER);
+        }
+    }
+
+    /**
+     * Creates an SSL socket
+     *
+     * @param host Host name or IP address of SSL server
+     * @param port Port numbers of SSL server
+     * @return A socket for an encrypted session
+     * @exception LDAPException on error creating socket
+     */
+    public Socket makeSocket( String host, int port ) throws LDAPException {
+        SSLSocket socket = null;
+        try {
+
+            socket = new SSLSocket( host, // address
+                                    port, // port
+                                    null, // localAddress
+                                    0,    // localPort
+                                    this, // certApprovalCallback
+                                    null  // clientCertSelectionCallback
+            );
+
+            socket.forceHandshake();
+
+        }
+        catch (UnknownHostException e) {
+            throw new LDAPException("JSSSocketFactory.makeSocket - Unknown host: " + host,
+                                    LDAPException.CONNECT_ERROR);
+                    
+        }
+        catch (Exception e) {
+            throw new LDAPException("JSSSocketFactory.makeSocket " +
+                                    host + ":" + port + ", " + e.getMessage(),
+                                    LDAPException.CONNECT_ERROR);
+        }
+
+        return socket;
+    }
+
+    /**
+     * The default implementation of the SSLCertificateApprovalCallback
+     * interface.
+     * <P>
+     * This default implementation always returns true. If you need to
+     * verify the server certificate validity, then you should override
+     * this method.
+     * <P>
+     * @param serverCert X509 Certificate
+     * @param status The validity of the server certificate
+     * @return <CODE>true</CODE>, by default we trust the certificate
+     */
+    public boolean approve(X509Certificate serverCert,
+                           ValidityStatus status) {
+        
+        return true;
+    }
+
+    /**
+     * Creates an SSL socket layered over an existing socket.
+     * 
+     * Used for the startTLS implementation (RFC2830).
+     *
+     * @param s An existing non-SSL socket
+     * @return A SSL socket layered over the input socket
+     * @exception LDAPException on error creating socket
+     * @since LDAPJDK 4.17
+     */    
+    public Socket makeSocket(Socket s) throws LDAPException {
+        SSLSocket socket = null;
+        String host = s.getInetAddress().getHostName();
+        int port = s.getPort();
+        try {
+            socket = new SSLSocket( s,
+                                    host,
+                                    this, // certApprovalCallback
+                                    null  // clientCertSelectionCallback
+            );
+
+            socket.forceHandshake();
+
+        } catch (Exception e) {
+            throw new LDAPException("JSSSocketFactory - start TLS, " + e.getMessage(),
+                                    LDAPException.TLS_NOT_SUPPORTED);
+        }
+
+        return socket;        
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/factory/JSSESocketFactory.java
@@ -0,0 +1,176 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package netscape.ldap.factory;
+
+import java.net.*; 
+import java.io.*; 
+import javax.net.ssl.*; 
+import netscape.ldap.*;
+
+/**
+ * Creates an SSL socket connection to a server, using the JSSE package
+ * from Sun. This class implements the <CODE>LDAPSocketFactory</CODE>
+ * interface.
+ * <P>
+ *
+ * @version 1.0
+ * @see LDAPSocketFactory
+ * @see LDAPConnection#LDAPConnection(netscape.ldap.LDAPSocketFactory)
+ */
+public class JSSESocketFactory implements LDAPTLSSocketFactory,
+                                          java.io.Serializable {
+
+    static final long serialVersionUID = 6834205777733266610L;
+
+    protected SSLSocketFactory factory = null;
+
+    // Optional explicit cipher suites to use
+    protected String[] suites = null;
+
+    /**
+     * Default factory constructor
+     */
+    public JSSESocketFactory() {
+        this.factory = (SSLSocketFactory) SSLSocketFactory.getDefault();
+    }
+  
+    /**
+     * Factory constructor
+     *
+     * @param suites Cipher suites to attempt to use with the server;
+     * if <code>null</code>, use any cipher suites available in the
+     * JSSE package
+     */
+    public JSSESocketFactory( String[] suites ) {
+        this.suites = suites;
+        this.factory = (SSLSocketFactory)SSLSocketFactory.getDefault();
+    }
+  
+    /**
+     * Factory constructor
+     * @param factory the SSL socketfactory to use
+     */
+    public JSSESocketFactory( SSLSocketFactory factory) {
+        this.factory = factory;
+    }
+
+    /**
+     * Factory constructor
+     * @param suites Cipher suites to attempt to use with the server;
+     * if <code>null</code>, use any cipher suites available in the
+     * JSSE package
+     * @param factory the SSL socketfactory to use
+     */
+    public JSSESocketFactory( String[] suites, SSLSocketFactory factory) {
+        this.suites = suites;
+        this.factory = factory;
+    }
+
+    /**
+     * Creates an SSL socket.
+     *
+     * @param host Host name or IP address of SSL server
+     * @param port Port numbers of SSL server
+     * @return A socket for an encrypted session
+     * @exception LDAPException on error creating socket
+     */
+    public Socket makeSocket(String host, int port)
+        throws LDAPException { 
+
+        SSLSocket sock = null;
+
+        try {
+            sock = (SSLSocket)factory.createSocket(host, port);
+
+            if (suites != null) {
+                sock.setEnabledCipherSuites(suites);
+            }
+            
+            // Start handshake manually to immediately expose potential
+            // SSL errors as exceptions. Otherwise, handshake will take
+            // place first time the data are written to the socket.
+            sock.startHandshake();
+
+        } catch (UnknownHostException e) {
+            throw new LDAPException("JSSESocketFactory.makeSocket - Unknown host: " + host,
+                                    LDAPException.CONNECT_ERROR);
+        } catch (IOException f) {
+            throw new LDAPException("JSSESocketFactory.makeSocket " +
+                                    host + ":" + port + ", " + f.getMessage(),
+                                    LDAPException.CONNECT_ERROR);
+        }
+
+        return sock;
+    }
+
+    /**
+     * Creates an SSL socket layered over an existing socket.
+     * 
+     * Used for the startTLS implementation (RFC2830).
+     *
+     * @param s An existing non-SSL socket
+     * @return A SSL socket layered over the input socket
+     * @exception LDAPException on error creating socket
+     * @since LDAPJDK 4.17
+     */
+    public Socket makeSocket(Socket s)
+        throws LDAPException { 
+  
+        SSLSocket sock = null;
+        String host = s.getInetAddress().getHostName();
+        int port = s.getPort();
+
+        try {
+            sock = (SSLSocket)factory.createSocket(s, host, port, /*autoClose=*/ true);
+
+            if (suites != null) {
+                sock.setEnabledCipherSuites(suites);
+            }
+            
+            sock.startHandshake();
+
+        } catch (IOException f) {
+            throw new LDAPException("JSSESocketFactory - start TLS, " + f.getMessage(),
+                                    LDAPException.TLS_NOT_SUPPORTED);
+        }
+
+        return sock;
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/controls/LDAPPersistSearchControl.java
@@ -0,0 +1,523 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.controls;
+
+import java.io.*;
+import netscape.ldap.client.JDAPBERTagDecoder;
+import netscape.ldap.LDAPControl;
+import netscape.ldap.ber.stream.*;
+
+/**
+ * Represents an LDAP v3 server control that specifies a persistent
+ * search (an ongoing search operation), which allows your LDAP client
+ * to get notification of changes to the directory.  (The OID for this
+ * control is 2.16.840.1.113730.3.4.3.)  You can use this control in
+ * conjunction with an "entry change notification" control (represented
+ * by <CODE>LDAPEntryChangeControl</CODE> object.
+ * <P>
+ *
+ * To use persistent searching for change notification, you create a
+ * "persistent search" control that specifies the types of changes that
+ * you want to track.  You include the control in a search request.
+ * If an entry in the directory is changed, the server determines if
+ * the entry matches the search criteria in your request and if the
+ * change is the type of change that you are tracking.  If both of
+ * these are true, the server sends the entry to your client.
+ * <P>
+ *
+ * The server can also include an "entry change notification" control
+ * with the entry.  (The OID for this control is 2.16.840.1.113730.3.4.7.)
+ * This control contains additional information about the
+ * change made to the entry, including the type of change made,
+ * the change number (which corresponds to an item in the server's
+ * change log, if the server supports a change log), and, if the
+ * entry was renamed, the old DN of the entry.
+ * <P>
+ *
+ * When constructing an <CODE>LDAPPersistSearchControl</CODE> object,
+ * you can specify the following information:
+ * <P>
+ *
+ * <UL>
+ * <LI>the type of change you want to track (added, modified, deleted,
+ * or renamed entries)
+ * <LI>a preference indicating whether or not you want the server to
+ * return all entries that initially matched the search criteria
+ * (rather than only the entries that change)
+ * <LI>a preference indicating whether or not you want entry change
+ * notification controls included with every entry returned by the
+ * server
+ * </UL>
+ * <P>
+ *
+ * For example:
+ * <PRE>
+ * ...
+ * LDAPConnection ld = new LDAPConnection();
+ *
+ * try {
+ *     // Connect to server.
+ *     ld.connect( 3, hostname, portnumber, "", "" );
+ *
+ *     // Create a persistent search control.
+ *     int op = LDAPPersistSearchControl.ADD |
+ *         LDAPPersistSearchControl.MODIFY |
+ *         LDAPPersistSearchControl.DELETE |
+ *         LDAPPersistSearchControl.MODDN;
+ *     boolean changesOnly = true;
+ *     boolean returnControls = true;
+ *     boolean isCritical = true;
+ *     LDAPPersistSearchControl persistCtrl = new
+ *         LDAPPersistSearchControl( op, changesOnly,
+ *         returnControls, isCritical );
+ *
+ *     // Set the search constraints to use that control.
+ *     LDAPSearchConstraints cons = ld.getSearchConstraints();
+ *     cons.setBatchSize( 1 );
+ *     cons.setServerControls( persistCtrl );
+ *
+ *     // Start the persistent search.
+ *     LDAPSearchResults res = ld.search( "o=Airius.com",
+ *               LDAPv3.SCOPE_SUB, "(cn=Barbara*)", null, false, cons );
+ *
+ *     // Loop through the incoming results.
+ *     while ( res.hasMoreElements() ) {
+ *     ...
+ *     }
+ * ...
+ * }
+ * </PRE>
+ *
+ * @see netscape.ldap.LDAPControl
+ * @see netscape.ldap.controls.LDAPEntryChangeControl
+ */
+
+public class LDAPPersistSearchControl extends LDAPControl {
+
+    /**
+     * Default constructor
+     */
+    public LDAPPersistSearchControl()
+    {
+        super(PERSISTENTSEARCH, true, null);
+    }
+
+    /**
+     * Constructs an <CODE>LDAPPersistSearchControl</CODE> object
+     * that specifies a persistent search.
+     *
+     * @param changeTypes the change types to monitor. You can perform
+     * a bitwise OR on any of the following values and specify the result as
+     * the change types:
+     * <UL>
+     * <LI><CODE>LDAPPersistSearchControl.ADD</CODE> (to track new entries
+     * added to the directory)
+     * <LI><CODE>LDAPPersistSearchControl.DELETE</CODE> (to track entries
+     * removed from the directory)
+     * <LI><CODE>LDAPPersistSearchControl.MODIFY</CODE> (to track entries
+     * that have been modified)
+     * <LI><CODE>LDAPPersistSearchControl.MODDN</CODE> (to track entries
+     * that have been renamed)
+     * </UL>
+     * @param changesOnly <code>true</code> if you do not want the server
+     * to return all existing entries in the directory that match the
+     * search criteria.  (Use this if you just want the changed entries 
+     * to be returned.)
+     * @param returnControls <code>true</code> if you want the server to return
+     * entry change controls with each entry in the search results
+     * @param isCritical <code>true</code> if this control is critical to
+     * the search operation. (If the server does not support
+     * this control, you may not want the server to perform the search
+     * at all.)
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.controls.LDAPEntryChangeControl
+     */
+    public LDAPPersistSearchControl(int changeTypes, boolean changesOnly,
+        boolean returnControls, boolean isCritical) {
+        super(PERSISTENTSEARCH, isCritical, null);
+        m_value = createPersistSearchSpecification(changeTypes,
+          changesOnly, returnControls);
+        m_changeTypes = changeTypes;
+        m_changesOnly = changesOnly;
+        m_returnECs = returnControls;
+    }
+
+    /**
+     * Gets the change types monitored by this control.
+     * @return integer representing the change types to monitor.
+     * This value can be the bitwise OR of <code>ADD, DELETE, MODIFY,</code>
+     * and/or <code>MODDN</code>. If the change type is unknown,
+     * this method returns -1.
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#setChangeTypes
+     */
+    public int getChangeTypes() {
+        return m_changeTypes;
+    }
+
+    /**
+     * Indicates whether you want the server to send any existing
+     * entries that already match the search criteria or only the
+     * entries that have changed.
+     * @return if <code>true</code>, the server returns only the
+     * entries that have changed.  If <code>false</code>, the server
+     * also returns any existing entries that match the search criteria
+     * but have not changed.
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#setChangesOnly
+     */
+    public boolean getChangesOnly() {
+        return m_changesOnly;
+    }
+
+    /**
+     * Indicates whether or not the server includes an "entry change
+     * notification" control with each entry it sends back to the client
+     * during the persistent search.
+     * @return <code>true</code> if the server includes "entry change
+     * notification" controls with the entries it sends during the
+     * persistent search.
+     * @see netscape.ldap.controls.LDAPEntryChangeControl
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#setReturnControls
+     */
+    public boolean getReturnControls() {
+        return m_returnECs;
+    }
+
+    /**
+     * Sets the change types that you want monitored by this control.
+     * @param types integer representing the change types to monitor
+     * This value can be the bitwise OR of <code>ADD, DELETE, MODIFY,</code>
+     * and/or <code>MODDN</code>.
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#getChangeTypes
+     */
+    public void setChangeTypes(int types) {
+        m_changeTypes = types;
+    }
+
+    /**
+     * Specifies whether you want the server to send any existing
+     * entries that already match the search criteria or only the
+     * entries that have changed.
+     * @param changesOnly if <code>true</code>, the server returns only the
+     * entries that have changed.  If <code>false</code>, the server
+     * also returns any existing entries that match the search criteria
+     * but have not changed.
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#getChangesOnly
+     */
+    public void setChangesOnly(boolean changesOnly) {
+        m_changesOnly = changesOnly;
+    }
+
+    /**
+     * Specifies whether you want the server to include an "entry change
+     * notification" control with each entry it sends back to the client
+     * during the persistent search.
+     * @param returnControls if <code>true</code>, the server includes
+     * "entry change notification" controls with the entries it sends
+     * during the persistent search
+     * @see netscape.ldap.controls.LDAPEntryChangeControl
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#setReturnControls
+     */
+    public void setReturnControls(boolean returnControls) {
+        m_returnECs = returnControls;
+    }
+
+    /**
+     * Takes an input byte array and extracts the ber elements, assigning
+     * them to appropriate fields in the entry change control.
+     *
+     * @param c byte array that contains BER elements
+     * @return the entry change control.
+     * @deprecated LDAPEntryChangeControl controls are now automatically 
+     * instantiated.
+     */
+    public LDAPEntryChangeControl parseResponse(byte[] c) {
+        LDAPEntryChangeControl con = new LDAPEntryChangeControl();
+
+        ByteArrayInputStream inStream = new ByteArrayInputStream(c);
+        BERSequence seq = new BERSequence();
+        JDAPBERTagDecoder decoder = new JDAPBERTagDecoder();
+        int[] numRead = new int[1];
+        numRead[0] = 0;
+
+        try {
+            /* a sequence */
+            BERSequence s = (BERSequence)BERElement.getElement(decoder, inStream,
+              numRead);
+
+            BEREnumerated itr = (BEREnumerated)s.elementAt(0);
+
+            con.setChangeType(itr.getValue());
+
+            if (s.size() > 1) {
+                if (s.elementAt(1) instanceof BEROctetString) {
+                    BEROctetString str = (BEROctetString)s.elementAt(1);
+                    con.setPreviousDN(new String(str.getValue(), "UTF8"));
+                } else if (s.elementAt(1) instanceof BERInteger) {
+                    BERInteger num = (BERInteger)s.elementAt(1);
+                    con.setChangeNumber(num.getValue());
+                }
+            }
+            if (s.size() > 2) {
+                BERInteger num = (BERInteger)s.elementAt(2);
+                con.setChangeNumber(num.getValue());
+            }
+        } catch (Exception e) {
+            return null;
+        }
+
+        return con;
+    }
+
+    /**
+     * Returns an "entry change notification" control if the control is in
+     * the specified array of controls.  Use this method to retrieve an "entry
+     * change notification" control included with an entry sent by the server.
+     * <P>
+     *
+     * You can get the controls returned by the server by using the
+     * <CODE>getResponseControls</CODE> method of the
+     * <CODE>LDAPConnection</CODE> class.
+     * <P>
+     *
+     * For example:
+     * <PRE>
+     * ...
+     * LDAPConnection ld = new LDAPConnection();
+     * try {
+     *     // Connect to the server, set up the persistent search control,
+     *     // and set up the search constraints.
+     *     ...
+     *
+     *     // Search the directory.
+     *     LDAPSearchResults res = ld.search( "o=Airius.com",
+     *         LDAPv3.SCOPE_SUB, "(cn=Barbara*)", attrs, false, cons );
+     *
+     *     // Determine if the server sent a control back to you.
+     *     LDAPControl[] returnedControls = ld.getResponseControls();
+     *     if ( returnedControls != null ) {
+     *
+     *         // Get the entry change control.
+     *         LDAPEntryChangeControl entryCtrl = null;
+     *         for ( int i = 0; i < returnedControls.length; i++ ) {
+     *             if ( returnedControls[i] instanceof LDAPEntryChangeControl ) {
+     *                 entryCtrl = (LDAPEntryChangeControl)returnedControls[i];
+     *                 break;
+     *             }
+     *         }
+     *         if ( entryCtrl != null ) {
+     *
+     *             // Get and print the type of change made to the entry.
+     *             int changeType = entryCtrl.getChangeType();
+     *             if ( changeType != -1 ) {
+     *                 System.out.print( "Change made: " );
+     *                 switch ( changeType ) {
+     *                 case LDAPPersistSearchControl.ADD:
+     *                     System.out.println( "Added new entry." );
+     *             break;
+     *                 case LDAPPersistSearchControl.MODIFY:
+     *                     System.out.println( "Modified entry." );
+     *             break;
+     *                 case LDAPPersistSearchControl.DELETE:
+     *                     System.out.println( "Deleted entry." );
+     *             break;
+     *                 case LDAPPersistSearchControl.MODDN:
+     *                     System.out.println( "Renamed entry." );
+     *             break;
+     *                 }
+     *             }
+     *
+     *             // Get and print the change number corresponding
+     *             // to the change.
+     *             int changeNumber = entryCtrl.getChangeNumber();
+     *             if ( changeNumber != -1 )
+     *                 System.out.println( "Change log number: " + changeNumber);
+     *
+     *             // Get and print the previous DN of the entry,
+     *             // if the entry was renamed.
+     *             LDAPDN oldDN = entryCtrl.getPreviousDN();
+     *             if ( oldDN != null )
+     *                     System.out.println( "Previous DN: " + oldDN );
+     *
+     *         } else {
+     *
+     *             System.out.println( "No entry change control." );
+     *         }
+     *     }
+     *     ...
+     * }
+     * ...
+     *
+     * </PRE>
+     *
+     * @param controls an array of <CODE>LDAPControl</CODE> objects,
+     * representing the controls returned by the server
+     * with an entry. To get these controls, use the
+     * <CODE>getResponseControls</CODE> method of the
+     * <CODE>LDAPConnection</CODE> class.
+     * @return an <CODE>LDAPEntryChangeControl</CODE> object representing
+     * the entry change control sent by the server.  If no entry change
+     * control was sent, this method returns null.
+     * @see netscape.ldap.controls.LDAPEntryChangeControl
+     * @see netscape.ldap.LDAPConnection#getResponseControls
+     * @deprecated LDAPEntryChangeControl controls are now automatically 
+     * instantiated.
+     */
+    public static LDAPEntryChangeControl parseResponse(LDAPControl[] controls) {
+
+        LDAPPersistSearchControl con = new LDAPPersistSearchControl();
+
+        for (int i=0; (controls != null) && (i < controls.length); i++) {
+
+            // get the entry change control
+            if (controls[i].getID().equals(LDAPEntryChangeControl.ENTRYCHANGED)) {
+                return con.parseResponse(controls[i].getValue());
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Creates a "flattened" BER encoding of the persistent search
+     * specifications and returns it as a byte array.
+     * @param changeTypes the change types to monitor on the server
+     * @param changesOnly <code>true</code> to skip the initial search
+     * @param returnECs <code>true</code> if entry change controls are to be
+     * returned with the search results
+     * @return the BER-encoded data.
+     */
+    private byte[] createPersistSearchSpecification(int changeTypes,
+        boolean changesOnly, boolean returnECs) {
+
+        /* A sequence */
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BERInteger(changeTypes));
+        seq.addElement(new BERBoolean(changesOnly));
+        seq.addElement(new BERBoolean(returnECs));
+
+        /* return a byte array */
+        return flattenBER( seq );
+    }
+
+    public String toString() {
+        StringBuffer sb = new StringBuffer("{PersistSearchCtrl:");
+        
+        sb.append(" isCritical=");
+        sb.append(isCritical());
+        
+        sb.append(" returnEntryChangeCtrls=");
+        sb.append(m_returnECs);
+        
+        sb.append(" changesOnly=");
+        sb.append(m_changesOnly);
+
+        sb.append(" changeTypes=");
+        sb.append(typesToString(m_changeTypes));
+        
+        sb.append("}");
+
+        return sb.toString();
+    }
+
+
+    /**
+     * This method is also used by LDAPentryChangeControl.toString()
+     */
+    static String typesToString(int changeTypes) {
+        String types = "";
+
+        if ((changeTypes & ADD) != 0) {
+            types += (types.length() > 0) ? "+ADD" : "ADD";
+        }
+        if ((changeTypes & DELETE) != 0) {
+            types += (types.length() > 0) ? "+DEL" : "DEL";
+        }
+        if ((changeTypes & MODIFY) != 0) {
+            types += (types.length() > 0) ? "+MOD" : "MOD";
+        }
+        if ((changeTypes & MODDN) != 0) {
+            types += (types.length() > 0) ? "+MODDN" : "MODDN";
+        }
+        return types;
+    }        
+
+    private int m_changeTypes = 1;
+    private boolean m_changesOnly = false;
+    private boolean m_returnECs = false;
+
+    /**
+     * Change type specifying that you want to track additions of new
+     * entries to the directory.  You can either specify this change type
+     * when constructing an <CODE>LDAPPersistSearchControl</CODE> or
+     * by using the <CODE>setChangeTypes</CODE> method.
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#getChangeTypes
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#setChangeTypes
+     */
+    public static final int ADD = 1;
+
+    /**
+     * Change type specifying that you want to track removals of
+     * entries from the directory.  You can either specify this change type
+     * when constructing an <CODE>LDAPPersistSearchControl</CODE> or
+     * by using the <CODE>setChangeTypes</CODE> method.
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#getChangeTypes
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#setChangeTypes
+     */
+    public static final int DELETE = 2;
+
+    /**
+     * Change type specifying that you want to track modifications of
+     * entries in the directory.  You can either specify this change type
+     * when constructing an <CODE>LDAPPersistSearchControl</CODE> or
+     * by using the <CODE>setChangeTypes</CODE> method.
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#getChangeTypes
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#setChangeTypes
+     */
+    public static final int MODIFY = 4;
+
+    /**
+     * Change type specifying that you want to track modifications of the
+     * DNs of entries in the directory.  You can either specify this change type
+     * when constructing an <CODE>LDAPPersistSearchControl</CODE> or
+     * by using the <CODE>setChangeTypes</CODE> method.
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#getChangeTypes
+     * @see netscape.ldap.controls.LDAPPersistSearchControl#setChangeTypes
+     */
+    public static final int MODDN = 8;
+    public final static String PERSISTENTSEARCH  = "2.16.840.1.113730.3.4.3";
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/controls/LDAPPasswordExpiredControl.java
@@ -0,0 +1,121 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.controls;
+
+import netscape.ldap.LDAPControl;
+import netscape.ldap.LDAPException;
+
+/**
+ * Represents an LDAP v3 server control that may be returned if a
+ * password has expired, and password policy is enabled on the server.
+ * The OID for this control is 2.16.840.1.113730.3.4.4.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPControl
+ */
+public class LDAPPasswordExpiredControl extends LDAPStringControl {
+    public final static String EXPIRED = "2.16.840.1.113730.3.4.4";
+
+    /**
+     * Contructs an <CODE>LDAPPasswordExpiredControl</CODE> object. 
+     * This constructor is used by <CODE>LDAPControl.register</CODE> to 
+     * instantiate password expired controls.
+     * <P>
+     * To retrieve the message from the server, call <CODE>getMessage</CODE>.
+     * @param oid this parameter must be equal to 
+     * <CODE>LDAPPasswordExpiredControl.EXPIRED</CODE>
+     * or an <CODE>LDAPException</CODE> is thrown
+     * @param critical <code>true</code> if this control is critical
+     * @param value the value associated with this control
+     * @exception netscape.ldap.LDAPException If oid is not 
+     * <CODE>LDAPPasswordExpiredControl.EXPIRED</CODE>.
+     * @see netscape.ldap.LDAPControl#register
+     */
+    public LDAPPasswordExpiredControl( String oid, boolean critical, 
+                                       byte[] value ) throws LDAPException {
+        super( EXPIRED, critical, value );
+	if ( !oid.equals( EXPIRED )) {
+	    throw new LDAPException( "oid must be LDAPPasswordExpiredControl." +
+				     "PWEXPIRED", LDAPException.PARAM_ERROR);
+	}
+
+    }
+
+    /**
+     * @param controls an array of <CODE>LDAPControl</CODE> objects,
+     * representing the controls returned by the server
+     * after a search. To get these controls, use the
+     * <CODE>getResponseControls</CODE> method of the
+     * <CODE>LDAPConnection</CODE> class.
+     * @return an error message string, or null if none is in the control.
+     * @see netscape.ldap.LDAPConnection#getResponseControls
+     * @deprecated LDAPPasswordExpiredControl controls are now automatically
+     * instantiated.
+     */
+    public static String parseResponse( LDAPControl[] controls ) {
+        return LDAPStringControl.parseResponse( controls, EXPIRED );
+    }
+ 
+    /**
+     * Gets the message returned by the server with this control.
+     * @return the message returned by the server.
+     */    
+    public String getMessage() {
+        return m_msg;
+    }
+    
+    public String toString() {
+         StringBuffer sb = new StringBuffer("{PasswordExpiredCtrl:");
+        
+        sb.append(" isCritical=");
+        sb.append(isCritical());
+        
+        sb.append(" msg=");
+        sb.append(m_msg);
+        
+        sb.append("}");
+
+        return sb.toString();
+    }
+
+}
+
+
+
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/controls/LDAPPasswordExpiringControl.java
@@ -0,0 +1,129 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.controls;
+
+import netscape.ldap.LDAPControl;
+import netscape.ldap.LDAPException;
+
+/**
+ * Represents an LDAP v3 server control that may be returned if a
+ * password is about to expire, and password policy is enabled on the server.
+ * The OID for this control is 2.16.840.1.113730.3.4.5.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPControl
+ */
+public class LDAPPasswordExpiringControl extends LDAPStringControl {
+    public final static String EXPIRING = "2.16.840.1.113730.3.4.5";
+
+    /**
+     * Contructs an <CODE>LDAPPasswordExpiringControl</CODE> object.
+     * This constructor is used by <CODE>LDAPControl.register</CODE> to 
+     * instantiate password expiring controls.
+     * <P>
+     * To retrieve the number of seconds until this password expires,
+     * call <CODE>getSecondsToExpiration</CODE>.
+     * @param oid this parameter must be 
+     * <CODE>LDAPPasswordExpiringControl.EXPIRING</CODE>
+     * or an <CODE>LDAPException</CODE> is thrown
+     * @param critical <code>true</code> if this control is critical
+     * @param value the value associated with this control
+     * @exception netscape.ldap.LDAPException If oid is not 
+     * <CODE>LDAPPasswordExpiringControl.EXPIRING.</CODE>
+     * @see netscape.ldap.LDAPControl#register
+     */
+    public LDAPPasswordExpiringControl( String oid, boolean critical, 
+                                       byte[] value ) throws LDAPException {
+        super( EXPIRING, critical, value );
+	if ( !oid.equals( EXPIRING )) {
+	    throw new LDAPException( "oid must be LDAPPasswordExpiringControl" +
+				     ".EXPIRING", LDAPException.PARAM_ERROR );
+	}
+    }
+
+    /**
+     * Gets the number of seconds until the password expires returned by the 
+     * server.
+     * @return int the number of seconds until the password expires.
+     * @exception java.lang.NumberFormatException If the server returned an
+     * undecipherable message. In this case, use <CODE>getMessage</CODE> to 
+     * retrieve the message as a string.
+     */
+    public int getSecondsToExpiration() {
+        return Integer.parseInt( m_msg );
+    }
+
+    /**
+     * Gets the value associated with this control parsed as a string.
+     * @return the value associated with this control parsed as a string.
+     */
+    public String getMessage() {
+        return m_msg;
+    }
+
+    /**
+     * @param controls an array of <CODE>LDAPControl</CODE> objects,
+     * representing the controls returned by the server.
+     * after a search.  To get these controls, use the
+     * <CODE>getResponseControls</CODE> method of the
+     * <CODE>LDAPConnection</CODE> class.
+     * @return an error message string, or null if none is in the control.
+     * @see netscape.ldap.LDAPConnection#getResponseControls
+     * @deprecated LDAPPasswordExpiringControl controls are now automatically
+     * instantiated.
+     */
+    public static String parseResponse( LDAPControl[] controls ) {
+        return LDAPStringControl.parseResponse( controls, EXPIRING );
+    }
+    
+    public String toString() {
+         StringBuffer sb = new StringBuffer("{PasswordExpiringCtrl:");
+        
+        sb.append(" isCritical=");
+        sb.append(isCritical());
+        
+        sb.append(" msg=");
+        sb.append(m_msg);
+        
+        sb.append("}");
+
+        return sb.toString();
+    }
+    
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/controls/LDAPEntryChangeControl.java
@@ -0,0 +1,264 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.controls;
+
+import java.io.*;
+import netscape.ldap.ber.stream.*;
+import netscape.ldap.client.JDAPBERTagDecoder;
+import netscape.ldap.*;
+
+/**
+ * Represents an LDAP v3 server control that specifies information
+ * about a change to an entry in the directory.  (The OID for this
+ * control is 2.16.840.1.113730.3.4.7.)  You need to use this control in
+ * conjunction with a "persistent search" control (represented
+ * by <CODE>LDAPPersistentSearchControl</CODE> object.
+ * <P>
+ *
+ * To use persistent searching for change notification, you create a
+ * "persistent search" control that specifies the types of changes that
+ * you want to track.  When an entry is changed, the server sends that
+ * entry back to your client and may include an "entry change notification"
+ * control that specifies additional information about the change.
+ * <P>
+ *
+ * Typically, you use the <CODE>getResponseControls</CODE> method of
+ * the <CODE>LDAPConnection</CODE> object to get any 
+ * <CODE>LDAPEntryChangeControl</CODE> objects returned by the server.
+ * <P>
+ *
+ * Once you retrieve an <CODE>LDAPEntryChangeControl</CODE> object from
+ * the server, you can get the following additional information about
+ * the change made to the entry:
+ * <P>
+ *
+ * <UL>
+ * <LI>The type of change made (add, modify, delete, or modify DN)
+ * <LI>The change number identifying the record of the change in the
+ * change log (if the server supports change logs)
+ * <LI>If the entry was renamed, the old DN of the entry
+ * </UL>
+ * <P>
+ *
+ * @see netscape.ldap.controls.LDAPPersistSearchControl
+ * @see netscape.ldap.LDAPConnection#getResponseControls
+ */
+
+public class LDAPEntryChangeControl extends LDAPControl {
+
+    /**
+     * Constructs a new <CODE>LDAPEntryChangeControl</CODE> object.
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.controls.LDAPPersistSearchControl
+     */
+    public LDAPEntryChangeControl() {
+        super(ENTRYCHANGED, false, null);
+    }
+
+    /**
+     * Contructs an <CODE>LDAPEntryChangedControl</CODE> object. 
+     * This constructor is used by <CODE>LDAPControl.register</CODE> to 
+     * instantiate entry change controls.
+     * @param oid this parameter must be 
+     * <CODE>LDAPEntryChangeControl.ENTRYCHANGED</CODE>
+     * or an <CODE>LDAPException</CODE> is thrown
+     * @param critical <code>true</code> if this control is critical
+     * @param value the value associated with this control
+     * @exception netscape.ldap.LDAPException If oid is not 
+     * <CODE>LDAPEntryChangeControl.ENTRYCHANGED</CODE>.
+     * @exception java.io.IOException If value is not a valid BER sequence.
+     * @see netscape.ldap.LDAPControl#register
+     */
+    public LDAPEntryChangeControl(String oid, boolean critical, byte[] value) 
+        throws LDAPException, IOException {
+	super(ENTRYCHANGED, false, value);
+	
+	if (!oid.equals( ENTRYCHANGED )) {
+	    throw new LDAPException("oid must be LDAPEntryChangeControl." +
+				    "ENTRYCHANGED", LDAPException.PARAM_ERROR);
+	}
+
+        
+        ByteArrayInputStream inStream = new ByteArrayInputStream(m_value);
+        BERSequence seq = new BERSequence();
+        JDAPBERTagDecoder decoder = new JDAPBERTagDecoder();
+        int[] numRead = new int[1];
+        numRead[0] = 0;
+
+	BERSequence s = (BERSequence)BERElement.getElement(decoder, inStream,
+							   numRead);
+	
+	BEREnumerated itr = (BEREnumerated)s.elementAt(0);
+	    
+	m_changeTypes = itr.getValue();
+
+	if (s.size() > 1) {
+	    if (s.elementAt(1) instanceof BEROctetString) {
+	        BEROctetString str = (BEROctetString)s.elementAt(1);
+		try {
+		    m_previousDN = new String(str.getValue(), "UTF8");
+		} catch (UnsupportedEncodingException e) {
+		}
+	    } else if (s.elementAt(1) instanceof BERInteger) {
+	        BERInteger num = (BERInteger)s.elementAt(1);
+		m_changeNumber = num.getValue();
+	    }
+	}
+	if (s.size() > 2) {
+	    BERInteger num = (BERInteger)s.elementAt(2);
+  	    m_changeNumber = num.getValue();
+	}
+    }
+  
+    /**
+     * Sets the change number (which identifies the record of the change
+     * in the server's change log) in this "entry change notification"
+     * control.
+     * @param num change number to set
+     * @see netscape.ldap.controls.LDAPEntryChangeControl#getChangeNumber
+     */
+    public void setChangeNumber(int num) {
+        m_changeNumber = num;
+    }
+
+    /**
+     * Sets the change type (which identifies the type of change
+     * that occurred) in this "entry change notification" control.
+     * @param num change type to set. This can be one of
+     * the following values:
+     * <P>
+     *
+     * <UL>
+     * <LI><CODE>LDAPPersistSearchControl.ADD</CODE> (a new entry was
+     * added to the directory)
+     * <LI><CODE>LDAPPersistSearchControl.DELETE</CODE> (an entry was
+     * removed from the directory)
+     * <LI><CODE>LDAPPersistSearchControl.MODIFY</CODE> (an entry was
+     * modified)
+     * <LI><CODE>LDAPPersistSearchControl.MODDN</CODE> (an entry was
+     * renamed)
+     * </UL>
+     * <P>
+     *
+     * @see netscape.ldap.controls.LDAPEntryChangeControl#getChangeType
+     */
+    public void setChangeType(int num) {
+        m_changeTypes = num;
+    }
+
+    /**
+     * Sets the previous DN of the entry (if the entry was renamed)
+     * in the "entry change notification control".
+     * @param dn the previous distinguished name of the entry
+     * @see netscape.ldap.controls.LDAPEntryChangeControl#getPreviousDN
+     */
+    public void setPreviousDN(String dn) {
+        m_previousDN = dn;
+    }
+
+    /**
+     * Gets the change number, which identifies the record of the change
+     * in the server's change log.
+     * @return change number identifying the change made.
+     * @see netscape.ldap.controls.LDAPEntryChangeControl#setChangeNumber
+     */
+    public int getChangeNumber() {
+        return m_changeNumber;
+    }
+
+    /**
+     * Gets the change type, which identifies the type of change
+     * that occurred.
+     * @return change type identifying the type of change that
+     * occurred.  This can be one of the following values:
+     * <P>
+     *
+     * <UL>
+     * <LI><CODE>LDAPPersistSearchControl.ADD</CODE> (a new entry was
+     * added to the directory)
+     * <LI><CODE>LDAPPersistSearchControl.DELETE</CODE> (an entry was
+     * removed from the directory)
+     * <LI><CODE>LDAPPersistSearchControl.MODIFY</CODE> (an entry was
+     * modified)
+     * <LI><CODE>LDAPPersistSearchControl.MODDN</CODE> (an entry was
+     * renamed)
+     * </UL>
+     * <P>
+     *
+     * @see netscape.ldap.controls.LDAPEntryChangeControl#setChangeType
+     */
+    public int getChangeType() {
+        return m_changeTypes;
+    }
+
+    /**
+     * Gets the previous DN of the entry (if the entry was renamed).
+     * @return the previous distinguished name of the entry.
+     * @see netscape.ldap.controls.LDAPEntryChangeControl#setPreviousDN
+     */
+    public String getPreviousDN() {
+        return m_previousDN;
+    }
+
+    public String toString() {
+         StringBuffer sb = new StringBuffer("{EntryChangedCtrl:");
+        
+        sb.append(" isCritical=");
+        sb.append(isCritical());
+        
+        sb.append(" changeTypes=");
+        sb.append(LDAPPersistSearchControl.typesToString(m_changeTypes));
+        
+        sb.append(" previousDN=");
+        sb.append(m_previousDN);
+        
+        sb.append(" changeNumber=");
+        sb.append(m_changeNumber);
+
+        sb.append("}");
+
+        return sb.toString();
+    }
+
+    private int m_changeNumber = -1;
+    private int m_changeTypes = -1;
+    private String m_previousDN = null;
+    public final static String ENTRYCHANGED = "2.16.840.1.113730.3.4.7";
+
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/controls/LDAPStringControl.java
@@ -0,0 +1,112 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.controls;
+
+import netscape.ldap.LDAPControl;
+
+/**
+ * Represents an LDAP v3 server control that contains a string as its
+ * only value. This is to be used as a base class by real such controls.
+ */
+abstract class LDAPStringControl extends LDAPControl {
+    protected String m_msg = null;
+
+    LDAPStringControl() {
+      super();
+    }
+
+    /**
+     * Constructs an <CODE>LDAPStringControl</CODE> object, and stores the 
+     * value as a string. To retrieve this string value, use 
+     * <CODE>getMsg()</CODE>.
+     * @param oid the oid of this control
+     * @param critical <code>true</code> if this control is critical to the search
+     * @param value the value associated with this control
+     * @see netscape.ldap.LDAPcontrol
+     */
+    public LDAPStringControl( String oid, boolean critical, byte[] value ) {
+        super( oid, critical, value );
+	
+	if ( value != null ) {
+	    try {  
+	        m_msg = new String( value, "UTF8" );
+	    } catch ( java.io.IOException e ) {
+	    }
+	}
+    }
+
+    /**
+     * Parses a response control sent by the server and
+     * retrieves a string.
+     * <P>
+     *
+     * You can get the controls returned by the server by using the
+     * <CODE>getResponseControls</CODE> method of the
+     * <CODE>LDAPConnection</CODE> class.
+     * <P>
+     *
+     * @param controls an array of <CODE>LDAPControl</CODE> objects,
+     * representing the controls returned by the server
+     * after a search. To get these controls, use the
+     * <CODE>getResponseControls</CODE> method of the
+     * <CODE>LDAPConnection</CODE> class.
+     * @param type the OID of the control to look for
+     * @return a message string, or null if the server did
+     * not return a string.
+     * @see netscape.ldap.LDAPConnection#getResponseControls
+     */
+    public static String parseResponse( LDAPControl[] controls, String type ) {
+        String msg = null;
+        LDAPControl cont = null;
+        /* See if there is a password control in the array */
+        for( int i = 0; (controls != null) && (i < controls.length); i++ ) {
+            if ( controls[i].getID().equals( type ) ) {
+                cont = controls[i];
+                break;
+            }
+        }
+        if ( cont != null ) {
+            /* Suck out the data and return it */
+            try {
+                msg = new String( cont.getValue(), "UTF8" );
+            } catch ( Exception e ) {
+            }
+        }
+        return msg;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/controls/LDAPVirtualListResponse.java
@@ -0,0 +1,238 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.controls;
+
+import java.io.*;
+import netscape.ldap.client.JDAPBERTagDecoder;
+import netscape.ldap.LDAPControl;
+import netscape.ldap.ber.stream.*;
+import netscape.ldap.LDAPException;
+
+/**
+ * Represents control data for returning paged results from a search.
+ *
+ * @version 1.0
+ *
+ *<PRE>
+ *   VirtualListViewResponse ::= SEQUENCE {
+ *       targetPosition   INTEGER (0 .. maxInt),
+ *       contentCount     INTEGER (0 .. maxInt),
+ *       virtualListViewResult ENUMERATED {
+ *           success                  (0),
+ *           operatonsError           (1),
+ *           timeLimitExceeded        (3),
+ *           adminLimitExceeded       (11),
+ *           insufficientAccessRights (50),
+ *           busy                     (51),
+ *           unwillingToPerform       (53),
+ *           sortControlMissing       (60),
+ *           offsetRangeError         (61),
+ *           other                    (80)
+ *       },
+ *       contextID     OCTET STRING OPTIONAL 
+ *  }
+ *</PRE>
+ */
+
+public class LDAPVirtualListResponse extends LDAPControl {
+    public final static String VIRTUALLISTRESPONSE = "2.16.840.1.113730.3.4.10";
+
+    /**
+     * Blank constructor for internal use in <CODE>LDAPVirtualListResponse</CODE>.
+     * @see netscape.ldap.LDAPControl
+     */
+    LDAPVirtualListResponse() {
+        super( VIRTUALLISTRESPONSE, true, null );
+    }
+
+   /**
+     * Contructs an <CODE>LDAPVirtualListResponse</CODE> object.
+     * @param oid this parameter must be equal to
+     * <CODE>LDAPVirtualListResponse.VIRTUALLISTRESPONSE</CODE> or an 
+     * <CODE>LDAPException</CODE>is thrown
+     * @param critical <code>true</code> if this control is critical
+     * @param value the value associated with this control
+     * @exception netscape.ldap.LDAPException If oid is not 
+     * <CODE>LDAPVirtualListResponse.VIRTUALLISTRESPONSE</CODE>.
+     * @see netscape.ldap.LDAPControl#register
+     */ 
+    public LDAPVirtualListResponse( String oid, boolean critical, 
+                                    byte[] value ) throws LDAPException {
+        super( VIRTUALLISTRESPONSE, critical, value );
+        if ( !oid.equals( VIRTUALLISTRESPONSE ) ) {
+             throw new LDAPException( "oid must be LDAPVirtualListResponse." +
+                                      "VIRTUALLISTRESPONSE", 
+                                      LDAPException.PARAM_ERROR);
+        }
+        
+	parseResponse();
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPVirtualListResponse</CODE> object.
+     * @param value a BER encoded byte array
+     * @see netscape.ldap.LDAPControl
+     */
+    public LDAPVirtualListResponse( byte[] value ) {
+        super( VIRTUALLISTRESPONSE, true, null );
+        m_value = value;
+        parseResponse();
+    }
+
+    /**
+     * Gets the size of the virtual result set.
+     * @return the size of the virtual result set, or -1 if not known.
+     */
+    public int getContentCount() {
+        return m_contentCount;
+    }
+
+    /**
+     * Gets the index of the first entry returned.
+     * @return the index of the first entry returned.
+     */
+    public int getFirstPosition() {
+        return m_firstPosition;
+    }
+
+    /**
+     * Gets the result code.
+     * @return the result code.
+     */
+    public int getResultCode() {
+        return m_resultCode;
+    }
+
+    /**
+     * Gets the context cookie, if any.
+     * @return the result context cookie.
+     */
+    public String getContext() {
+        return m_context;
+    }
+
+    /**
+     * Returns a control useful for subsequent paged results searches.
+     * "this" should be a control returned on a previous paged results
+     * search, so it contains information on the virtual result set
+     * size.
+     * @return a control useful for subsequent paged results searches.
+     */
+    private void parseResponse() {
+        /* Suck out the data and parse it */
+        ByteArrayInputStream inStream =
+            new ByteArrayInputStream( getValue() );
+        BERSequence ber = new BERSequence();
+        JDAPBERTagDecoder decoder = new JDAPBERTagDecoder();
+        int[] nRead = new int[1];
+        nRead[0] = 0;
+        try  {
+            /* A sequence */
+            BERSequence seq = (BERSequence)BERElement.getElement(
+                                                      decoder, inStream,
+                                                      nRead );
+            /* First is firstPosition */
+            m_firstPosition = ((BERInteger)seq.elementAt( 0 )).getValue();
+            m_contentCount = ((BERInteger)seq.elementAt( 1 )).getValue();
+            m_resultCode = ((BEREnumerated)seq.elementAt( 2 )).getValue();
+            if( seq.size() > 3 ) {
+                BEROctetString str = (BEROctetString)seq.elementAt( 3 );
+                m_context = new String(str.getValue(), "UTF8");
+            }
+        } catch(Exception x) {
+            m_firstPosition = m_contentCount = m_resultCode = -1;
+            m_context = null;        }
+    }
+
+    /**
+     * Returns a control returned on a VLV search.
+     * @param controls an array of controls that may include a VLV
+     * results control
+     * @return the control, if any; otherwise null.
+     * @deprecated LDAPVirtualListResponse controls are now automatically 
+     * instantiated.
+     */
+    public static LDAPVirtualListResponse parseResponse(
+        LDAPControl[] controls ) {
+        LDAPVirtualListResponse con = null;
+        /* See if there is a VLV response control in the array */
+        for( int i = 0; (controls != null) && (i < controls.length); i++ ) {
+            if ( controls[i].getID().equals( VIRTUALLISTRESPONSE ) ) {
+                con = new LDAPVirtualListResponse( controls[i].getValue() );
+                con.parseResponse();
+                break;
+            }
+        }
+        if ( con != null ) {
+            con.parseResponse();
+        }
+        return con;
+    }
+
+    public String toString() {
+         StringBuffer sb = new StringBuffer("{VirtListResponseCtrl:");
+        
+        sb.append(" isCritical=");
+        sb.append(isCritical());
+        
+        sb.append(" firstPosition=");
+        sb.append(m_firstPosition);
+        
+        sb.append(" contentCount=");
+        sb.append(m_contentCount);
+
+        sb.append(" resultCode=");
+        sb.append(m_resultCode);
+        
+        if (m_context != null) {
+            sb.append(" conext=");
+            sb.append(m_context);
+        }
+
+        sb.append("}");
+
+        return sb.toString();
+    }
+
+    
+    private int m_firstPosition = 0;
+    private int m_contentCount = 0;
+    private int m_resultCode = -1;
+    private String m_context = null;
+
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/controls/LDAPProxiedAuthControl.java
@@ -0,0 +1,143 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.controls;
+
+import java.io.*;
+import netscape.ldap.LDAPControl;
+import netscape.ldap.LDAPSortKey;
+import netscape.ldap.client.JDAPBERTagDecoder;
+import netscape.ldap.ber.stream.*;
+
+/**
+ * Represents an LDAP v3 server control that specifies that you want
+ * the server to use the specified DN's identity for this operation.
+ * (The OID for this control is 2.16.840.1.113730.3.4.12.)
+ * <P>
+ *
+ * You can include the control in any request by constructing
+ * an <CODE>LDAPSearchConstraints</CODE> object and calling the
+ * <CODE>setServerControls</CODE> method.  You can then pass this
+ * <CODE>LDAPSearchConstraints</CODE> object to the <CODE>search</CODE>
+ * or other request method of an <CODE>LDAPConnection</CODE> object.
+ * <P>
+ *
+ * For example:
+ * <PRE>
+ * ...
+ * LDAPConnection ld = new LDAPConnection();
+ * try {
+ *     // Connect to server.
+ *     ld.connect( 3, hostname, portnumber, "", "" );
+ *
+ *     // Create a "critical" proxied auth server control using
+ *     // the DN "uid=charlie,ou=people,o=acme.com".
+ *     LDAPProxiedAuthControl ctrl =
+ *         new LDAPProxiedAuthControl( "uid=charlie,ou=people,o=acme.com",
+ *                                     true );
+ *
+ *     // Create search constraints to use that control.
+ *     LDAPSearchConstraints cons = new LDAPSearchConstraints();
+ *     cons.setServerControls( sortCtrl );
+ *
+ *     // Send the search request.
+ *     LDAPSearchResults res = ld.search( "o=Airius.com",
+ *        LDAPv3.SCOPE_SUB, "(cn=Barbara*)", null, false, cons );
+ *
+ *     ...
+ *
+ * </PRE>
+ *
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPControl
+ * @see netscape.ldap.LDAPConstraints
+ * @see netscape.ldap.LDAPSearchConstraints
+ * @see netscape.ldap.LDAPConstraints#setServerControls(LDAPControl)
+ */
+public class LDAPProxiedAuthControl extends LDAPControl {
+    public final static String PROXIEDAUTHREQUEST  =
+                                            "2.16.840.1.113730.3.4.12";
+
+    private String m_dn;
+    
+    /**
+     * Constructs an <CODE>LDAPProxiedAuthControl</CODE> object with a
+     * DN to use as identity.
+     * @param dn DN to use as identity for execution of a request
+     * @param critical <CODE>true</CODE> if the LDAP operation should be
+     * discarded when the server does not support this control (in other
+     * words, this control is critical to the LDAP operation)
+     * @see netscape.ldap.LDAPControl
+     */
+    public LDAPProxiedAuthControl( String dn,
+                                   boolean critical) {
+        super( PROXIEDAUTHREQUEST, critical, null );
+        m_value = createSpecification( m_dn = dn );
+    }
+
+    /**
+     * Create a "flattened" BER encoding of the requested contents,
+     * and return it as a byte array.
+     * @param dn the DN to use as an identity
+     * @return the byte array of encoded data.
+     */
+    private byte[] createSpecification( String dn ) {
+        /* A sequence */
+        BERSequence ber = new BERSequence();
+        /* Add the DN as a string value */
+        ber.addElement( new BEROctetString( dn ) );
+        /* Suck out the data and return it */
+        return flattenBER( ber );
+    }
+
+    public String toString() {
+         StringBuffer sb = new StringBuffer("{ProxiedAuthCtrl:");
+        
+        sb.append(" isCritical=");
+        sb.append(isCritical());
+        
+        sb.append(" dn=");
+        sb.append(m_dn);
+        
+        sb.append("}");
+
+        return sb.toString();
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/controls/LDAPVirtualListControl.java
@@ -0,0 +1,486 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.controls;
+
+import java.io.*;
+import netscape.ldap.client.JDAPBERTagDecoder;
+import netscape.ldap.LDAPControl;
+import netscape.ldap.ber.stream.*;
+
+/**
+ * Represents control data for returning paged results from a search.
+ *
+ * Example of usage, with JFC:
+ *<PRE><CODE>
+ *  // Call this to initialize the list box, whenever the search
+ *  // conditions change.
+ *  // "filter" may be "objectclass=person", for example
+ *  void initListBox( String host, int port, String base, String filter ) {
+ *
+ *  // Create list box if not already done
+ *   if ( _dataList == null ) {
+ *       _dataList = new JList();
+ *       JScrollPane scrollPane = new JScrollPane(_dataList);
+ *       add( scrollPane );
+ *   }
+ *
+ *   // Create a virtual data model
+ *   vlistModel model = new vlistModel( host, port, base, filter );
+ *   // Keep a buffer of one page before and one after
+ *   model.setPageSize( getScrollVisibleSize() );
+ *   _dataList.setModel( model );
+ *  }
+ *<P>
+ * // Data model to supply buffer list data
+ *class vlistModel extends AbstractListModel {
+ *  vlistModel( String host, int port, String base, String filter ) {
+ *      _base = base;
+ *      _filter = filter;
+ *
+ *      // Connect to the server
+ *      try {
+ *          _ldc = new LDAPConnection();
+ *          System.out.println( "Connecting to " + host +
+ *                              ":" + port );
+ *          _ldc.connect( host, port );
+ *      } catch ( LDAPException e ) {
+ *          System.out.println( e );
+ *          _ldc = null;
+ *      }
+ *  }
+ *
+ *  // Called by JList to get virtual list size
+ *    public int getSize() {
+ *      if ( !_initialized ) {
+ *          _initialized = true;
+ *          _pageControls = new LDAPControl[2];
+ *          // Paged results also require a sort control
+ *          _pageControls[0] =
+ *              new LDAPSortControl( new LDAPSortKey("cn"),
+ *                                   true );
+ *          // Do an initial search to get the virtual list size
+ *          // Keep one page before and one page after the start
+ *          _beforeCount = _pageSize;
+ *          _afterCount = _pageSize;
+ *          // Create the initial paged results control
+ *          LDAPVirtualListControl cont =
+ *              new LDAPVirtualListControl( "A",
+ *                                          _beforeCount,
+ *                                          _afterCount );
+ *          _pageControls[1] = cont;
+ *          _vlc = (LDAPVirtualListControl)_pageControls[1];
+ *          getPage( 0 );
+ *      }
+ *      return _size;
+ *  }
+ *
+ *  // Get a page starting at first (although we may also fetch
+ *  // some preceding entries)
+ *  boolean getPage( int first ) {
+ *      _vlc.setRange( first, _beforeCount, _afterCount );
+ *      return getPage();
+ *  }
+ *
+ *  boolean getEntries() {
+ *      // Specify necessary controls for vlv
+ *      if ( _pageControls != null ) {
+ *          try {
+ *              _ldc.setOption( _ldc.SERVERCONTROLS, _pageControls );
+ *          } catch ( LDAPException e ) {
+ *              System.out.println( e + ", setting vlv control" );
+ *          }
+ *      }
+ *      // Empty the buffer
+ *      _entries.removeAllElements();
+ *      // Do a search
+ *      try {
+ *          String[] attrs = { "cn" };
+ *          LDAPSearchResults result =
+ *              _ldc.search( _base,
+ *                           LDAPConnection.SCOPE_SUB,
+ *                           _filter,
+ *                           attrs, false );
+ *          while ( result.hasMoreElements() ) {
+ *              LDAPEntry entry = (LDAPEntry)result.nextElement();
+ *              LDAPAttribute attr = entry.getAttribute( attrs[0] );
+ *              if ( attr != null ) {
+ *                  Enumeration en = attr.getStringValues();
+ *                  while( en.hasMoreElements() ) {
+ *                      String name = (String)en.nextElement();
+ *                      _entries.addElement( name );
+ *                  }
+ *              }
+ *          }
+ *      } catch ( LDAPException e ) {
+ *          System.out.println( e + ", searching" );
+ *          return false;
+ *      }
+ *      return true;
+ *  }
+ *
+ *  // Fetch a buffer
+ *  boolean getPage() {
+ *      // Get the actual entries
+ *      if ( !getEntries() )
+ *          return false;
+ *
+ *      // Check if we have a control returned
+ *      LDAPControl[] c = _ldc.getResponseControls();
+ *      LDAPVirtualListResponse nextCont = null;
+ *      for ( int i = 0; i < c.length; i++ ) {
+ *          if ( c[i] instanceof LDAPVirtualListResponse ) {
+ *              nextCont = (LDAPVirtualListResponse)c[i];
+ *              break;
+ *          }
+ *      }
+ *      if ( nextCont != null ) {
+ *          _selectedIndex = nextCont.getFirstPosition() - 1;
+ *          _top = Math.max( 0, _selectedIndex - _beforeCount );
+ *          // Now we know the total size of the virtual list box
+ *          _size = nextCont.getContentCount();
+ *          _vlc.setListSize( _size );
+ *      } else {
+ *          System.out.println( "Null response control" );
+ *      }
+ *      return true;
+ *  }
+ *
+ *  // Called by JList to fetch data to paint a single list item
+ *    public Object getElementAt(int index) {
+ *      if ( (index < _top) || (index >= _top + _entries.size()) ) {
+ *          getPage( index );
+ *      }
+ *      int offset = index - _top;
+ *      if ( (offset < 0) || (offset >= _entries.size()) )
+ *          return new String( "No entry at " + index );
+ *      else
+ *          return _entries.elementAt( offset );
+ *  }
+ *
+ *  // Called by application to find out the virutal selected index
+ *    public int getSelectedIndex() {
+ *      return _selectedIndex;
+ *  }
+ *
+ *  // Called by application to find out the top of the buffer
+ *    public int getFirstIndex() {
+ *      return _top;
+ *  }
+ *
+ *  public void setPageSize( int size ) {
+ *      _pageSize = size;
+ *  }
+ *
+ *  Vector _entries = new Vector();
+ *  protected boolean _initialized = false;
+ *  private int _top = 0;
+ *  protected int _beforeCount;
+ *  protected int _afterCount;
+ *  private int _pageSize = 10;
+ *  private int _selectedIndex = 0;
+ *  protected LDAPControl[] _pageControls = null;
+ *  protected LDAPVirtualListControl _vlc = null;
+ *  protected int _size = -1;
+ *  private String _base;
+ *  private String _filter;
+ *  private LDAPConnection _ldc;
+ *}
+ *</CODE></PRE>
+ * <PRE>
+ *   VirtualListViewRequest ::= SEQUENCE {
+ *            beforeCount    INTEGER (0 .. maxInt),
+ *            afterCount     INTEGER (0 .. maxInt),
+ *            CHOICE {
+ *                byIndex [0] SEQUENCE {
+ *                    index           INTEGER,
+ *                    contentCount    INTEGER
+ *                }
+ *                byFilter [1] jumpTo    Substring
+ *            },
+ *            contextID     OCTET STRING OPTIONAL
+ *  }
+ * </PRE>
+ *
+ * @version 1.0
+ */
+
+public class LDAPVirtualListControl extends LDAPControl {
+    public final static String VIRTUALLIST = "2.16.840.1.113730.3.4.9";
+
+    /**
+     * Blank constructor for internal use in <CODE>LDAPVirtualListControl</CODE>.
+     * @see netscape.ldap.LDAPControl
+     */
+    LDAPVirtualListControl() {
+        super( VIRTUALLIST, true, null );
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPVirtualListControl</CODE> object. Use this
+     * constructor on an initial search operation, specifying the first
+     * entry to be matched, or the initial part of it.
+     * @param jumpTo an LDAP search expression defining the result set
+     * @param beforeCount the number of results before the top/center to
+     * return per page
+     * @param afterCount the number of results after the top/center to
+     * return per page
+     * @see netscape.ldap.LDAPControl
+     */
+    public LDAPVirtualListControl( String jumpTo, int beforeCount,
+                                   int afterCount  ) {
+        super( VIRTUALLIST, true, null );
+        setRange( jumpTo, beforeCount, afterCount );
+    }
+
+    public LDAPVirtualListControl( String jumpTo, int beforeCount,
+                                   int afterCount, String context  ) {
+        this( jumpTo, beforeCount, afterCount );
+        m_context = context;
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPVirtualListControl</CODE> object. Use this
+     * constructor on a subsquent search operation, after we know the
+     * size of the virtual list, to fetch a subset.
+     * @param startIndex the index into the virtual list of an entry to
+     * return
+     * @param beforeCount the number of results before the top/center to
+     * return per page
+     * @param afterCount the number of results after the top/center to
+     * return per page
+     * @see netscape.ldap.LDAPControl
+     */
+    public LDAPVirtualListControl( int startIndex, int beforeCount,
+                                   int afterCount, int contentCount  ) {
+        super( VIRTUALLIST, true, null );
+        m_listSize = contentCount;
+        setRange( startIndex, beforeCount, afterCount );
+    }
+
+    public LDAPVirtualListControl( int startIndex, int beforeCount,
+                                   int afterCount, int contentCount,
+                                   String context ) {
+        this( startIndex, beforeCount, afterCount, contentCount );
+        m_context = context;
+    }
+
+    /**
+     * Sets the starting index, and the number of entries before and after
+     * to return. Apply this method to a control returned from a previous
+     * search, to specify what result range to return on the next search.
+     * @param startIndex the index into the virtual list of an entry to
+     * return
+     * @param beforeCount the number of results before startIndex to
+     * return per page
+     * @param afterCount the number of results after startIndex to
+     * return per page
+     * @see netscape.ldap.LDAPControl
+     */
+    public void setRange( int startIndex, int beforeCount, int afterCount  ) {
+        m_beforeCount = beforeCount;
+        m_afterCount = afterCount;
+        m_listIndex = startIndex;
+        m_value = createPageSpecification( m_listIndex, m_listSize,
+                                           m_beforeCount, m_afterCount );
+    }
+
+    /**
+     * Sets the search expression, and the number of entries before and after
+     * to return.
+     * @param jumpTo an LDAP search expression defining the result set
+     * return.
+     * @param beforeCount the number of results before startIndex to
+     * return per page
+     * @param afterCount the number of results after startIndex to
+     * return per page
+     * @see netscape.ldap.LDAPControl
+     */
+    public void setRange( String jumpTo, int beforeCount, int afterCount  ) {
+        m_beforeCount = beforeCount;
+        m_afterCount = afterCount;
+        m_value = createPageSpecification( jumpTo, m_beforeCount, m_afterCount );
+    }
+
+    /**
+     * Gets the size of the virtual result set.
+     * @return the size of the virtual result set, or -1 if not known.
+     */
+    public int getIndex() {
+        return m_listIndex;
+    }
+
+    /**
+     * Gets the size of the virtual result set.
+     * @return the size of the virtual result set, or -1 if not known.
+     */
+    public int getListSize() {
+        return m_listSize;
+    }
+
+    /**
+     * Sets the size of the virtual result set.
+     * @param listSize the virtual result set size
+     */
+    public void setListSize( int listSize ) {
+        m_listSize = listSize;
+    }
+
+    /**
+     * Gets the number of results before the top/center to return per page.
+     * @return the number of results before the top/center to return per page.
+     */
+    public int getBeforeCount() {
+        return m_beforeCount;
+    }
+
+    /**
+     * Gets the number of results after the top/center to return per page.
+     * @return the number of results after the top/center to return per page.
+     */
+    public int getAfterCount() {
+        return m_afterCount;
+    }
+
+    /**
+     * Gets the optional context cookie.
+     * @return the optional context cookie.
+     */
+    public String getContext() {
+        return m_context;
+    }
+
+    /**
+     * Sets the optional context cookie.
+     * @param context the optional context cookie
+     */
+    public void setContext( String context ) {
+        m_context = context;
+    }
+
+    /**
+     * Creates a "flattened" BER encoding of the requested page
+     * specifications and return it as a byte array.
+     * @param subFilter filter expression for generating the results
+     * @param beforeCount number of entries before first match to return
+     * @param afterCount number of entries after first match to return
+     * @return the byte array of encoded data.
+     */
+    private byte[] createPageSpecification( String subFilter,
+                                            int beforeCount,
+                                            int afterCount ) {
+        /* A sequence */
+        BERSequence seq = new BERSequence();
+        seq.addElement( new BERInteger( beforeCount ) );
+        seq.addElement( new BERInteger( afterCount ) );
+        seq.addElement( new BERTag(BERTag.CONTEXT|TAG_BYFILTER,
+                                   new BEROctetString(subFilter), true) );
+        if ( m_context != null ) {
+            seq.addElement( new BEROctetString(m_context) );
+        }
+        /* Suck out the data and return it */
+        return flattenBER( seq );
+    }
+
+    /**
+     * Creates a "flattened" BER encoding of the requested page
+     * specifications and return it as a byte array.
+     * @param listIndex the center or starting entry to return
+     * @param listSize the virtual list size
+     * @param beforeCount number of entries before the first match to return
+     * @param afterCount number of entries after the first match to return
+     * @return the byte array of encoded data.
+     */
+    private byte[] createPageSpecification( int listIndex,
+                                            int listSize,
+                                            int beforeCount,
+                                            int afterCount ) {
+        /* A sequence */
+        BERSequence seq = new BERSequence();
+        seq.addElement( new BERInteger( beforeCount ) );
+        seq.addElement( new BERInteger( afterCount ) );
+        /* A sequence of list index and list size */
+        BERSequence indexSeq = new BERSequence();
+        indexSeq.addElement( new BERInteger(listIndex) );
+        indexSeq.addElement( new BERInteger(listSize) );
+        seq.addElement(
+            new BERTag(BERTag.CONTEXT|BERTag.CONSTRUCTED|TAG_BYINDEX,
+                       indexSeq,true) );
+        if ( m_context != null ) {
+            seq.addElement( new BEROctetString(m_context) );
+        }
+
+        /* Suck out the data and return it */
+        return flattenBER( seq );
+    }
+
+    public String toString() {
+         StringBuffer sb = new StringBuffer("{VirtListCtrl:");
+        
+        sb.append(" isCritical=");
+        sb.append(isCritical());
+        
+        sb.append(" beforeCount=");
+        sb.append(m_beforeCount);
+        
+        sb.append(" afterCount=");
+        sb.append(m_afterCount);
+        
+        sb.append(" listIndex=");
+        sb.append(m_listIndex);
+
+        sb.append(" listSize=");
+        sb.append(m_listSize);
+
+        if (m_context != null) {
+            sb.append(" conext=");
+            sb.append(m_context);
+        }
+
+        sb.append("}");
+
+        return sb.toString();
+    }
+    
+    private final static int TAG_BYINDEX = 0;
+    private final static int TAG_BYFILTER = 1;
+    private int m_beforeCount = 0;
+    private int m_afterCount = 0;
+    private int m_listIndex = -1;
+    private int m_listSize = 0;
+    private String m_context = null;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/controls/LDAPSortControl.java
@@ -0,0 +1,630 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.controls;
+
+import java.io.*;
+import netscape.ldap.LDAPControl;
+import netscape.ldap.LDAPSortKey;
+import netscape.ldap.client.JDAPBERTagDecoder;
+import netscape.ldap.LDAPException;
+import netscape.ldap.ber.stream.*;
+
+/**
+ * Represents an LDAP v3 server control that specifies that you want
+ * the server to return sorted search results.  (The OID for this
+ * control is 1.2.840.113556.1.4.473.)
+ * <P>
+ *
+ * When constructing an <CODE>LDAPSortControl</CODE> object, you can
+ * specify the order in which you want the results sorted.
+ * You can also specify whether or not this control is critical
+ * to the search operation.
+ * <P>
+ *
+ * To specify the sort order, you construct an <CODE>LDAPSortKey</CODE>
+ * object and pass it to the <CODE>LDAPSortControl</CODE> constructor.
+ * The <CODE>LDAPSortKey</CODE> object represents a list of the attribute
+ * types used for sorting (a "sort key list").
+ * <P>
+ *
+ * You can include the control in a search request by constructing
+ * an <CODE>LDAPSearchConstraints</CODE> object and calling the
+ * <CODE>setServerControls</CODE> method.  You can then pass this
+ * <CODE>LDAPSearchConstraints</CODE> object to the <CODE>search</CODE>
+ * method of an <CODE>LDAPConnection</CODE> object.
+ * <P>
+ *
+ * For example:
+ * <PRE>
+ * ...
+ * LDAPConnection ld = new LDAPConnection();
+ * try {
+ *     // Connect to server.
+ *     ld.connect( 3, hostname, portnumber, "", "" );
+ *
+ *     // Create a sort key that specifies the sort order.
+ *     LDAPSortKey sortOrder = new LDAPSortKey( attrname );
+ *
+ *     // Create a "critical" server control using that sort key.
+ *     LDAPSortControl sortCtrl = new LDAPSortControl(sortOrder,true);
+ *
+ *     // Create search constraints to use that control.
+ *     LDAPSearchConstraints cons = new LDAPSearchConstraints();
+ *     cons.setServerControls( sortCtrl );
+ *
+ *     // Send the search request.
+ *     LDAPSearchResults res = ld.search( "o=Airius.com",
+ *        LDAPv3.SCOPE_SUB, "(cn=Barbara*)", null, false, cons );
+ *
+ *     ...
+ *
+ * </PRE>
+ *
+ * The LDAP server sends back a sort response control to indicate
+ * the result of the sorting operation. (The OID for this control
+ * is 1.2.840.113556.1.4.474.)
+ * <P>
+ *
+ * This control contains:
+ * <P>
+ *
+ * <UL>
+ * <LI>the result code from the sorting operation
+ * <LI>optionally, the first attribute type in the sort key list
+ * that resulted in an error (for example, if the attribute does
+ * not exist)
+ * </UL>
+ * <P>
+ *
+ * To retrieve the data from this control, use the <CODE>getResultCode</CODE>
+ * and <CODE>getFailedAttribute</CODE> methods.
+ * <P>
+ *
+ * The following table lists what kinds of results to expect from the
+ * LDAP server under different situations:
+ * <P>
+ *
+ * <TABLE BORDER=1 COLS=4>
+ * <TR VALIGN=BASELINE>
+ *     <TH>Does the Server Support the Sorting Control?</TH>
+ *     <TH>Is the Sorting Control Marked As Critical?</TH>
+ *     <TH>Other Conditions</TH>
+ *     <TH>Results from LDAP Server</TH>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD ROWSPAN=2>
+ *     No
+ *     </TD>
+ *     <TD>
+ *     Yes
+ *     </TD>
+ *     <TD>
+ *     None
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server does not send back any entries.
+ *     <LI>An LDAPException.UNAVAILABLE_CRITICAL_EXTENSION
+ *     exception is thrown.
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD>
+ *     No
+ *     </TD>
+ *     <TD>
+ *     None
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server ignores the sorting control and
+ *     returns the entries unsorted.
+ *     </UL>
+ *     <P>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD ROWSPAN=4>
+ *     Yes
+ *     </TD>
+ *     <TD>
+ *     Yes
+ *     </TD>
+ *     <TD ROWSPAN=2>
+ *     The server cannot sort the results using the specified
+ *     sort key list.
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server does not send back any entries.
+ *     <LI>An LDAPException.UNAVAILABLE_CRITICAL_EXTENSION
+ *     exception is thrown.
+ *     <LI>The server sends back the sorting response control, which
+ *     specifies the result code of the sort attempt and (optionally)
+ *     the attribute type that caused the error.
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD>
+ *     No
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server returns the entries unsorted.
+ *     <LI>The server sends back the sorting response control, which
+ *     specifies the result code of the sort attempt and (optionally)
+ *     the attribute type that caused the error.
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD ROWSPAN=2>
+ *     N/A (could either be marked as critical or not)
+ *     </TD>
+ *     <TD>
+ *     The server successfully sorted the entries.
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server sends back the sorted entries.
+ *     <LI>The server sends back the sorting response control, which
+ *     specifies the result code of the sort attempt
+ *     (LDAPException.SUCCESS).
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD>
+ *     The search itself failed (for any reason).
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server sends back a result code for the search
+ *     operation.
+ *     <LI>The server does not send back the sorting response control.
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * </TABLE>
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPSortKey
+ * @see netscape.ldap.LDAPControl
+ * @see netscape.ldap.LDAPConstraints
+ * @see netscape.ldap.LDAPSearchConstraints
+ * @see netscape.ldap.LDAPConstraints#setServerControls(LDAPControl)
+ */
+public class LDAPSortControl extends LDAPControl {
+    public final static String SORTREQUEST  = "1.2.840.113556.1.4.473";
+    public final static String SORTRESPONSE = "1.2.840.113556.1.4.474";
+
+    // Response varibales
+    private String m_failedAttribute = null;
+    private int m_resultCode = 0;
+    
+    // Request variables
+    private LDAPSortKey[] m_keys;
+
+    /**
+     * Constructs a sort response <CODE>LDAPSortControl</CODE> object.
+     * This constructor is used by <CODE>LDAPControl.register</CODE> to 
+     * instantiate sort response controls.
+     * <P>
+     * To retrieve the result code of the sort operation, call 
+     * <CODE>getResultCode</CODE>.
+     * <P> 
+     * To retrieve the attribute that caused the sort operation to fail, call
+     * <CODE>getFailedAttribute</CODE>.
+     * @param oid the oid for this control. This must be 
+     * <CODE>LDAPSortControl.SORTRESPONSE</CODE> or an <CODE>LDAPException</CODE> 
+     * is thrown.
+     * @param critical <code>true</code> if this control is critical to the operation
+     * @param value the value associated with this control
+     * @exception netscape.ldap.LDAPException If oid is not 
+     * <CODE>LDAPSortControl.SORTRESPONSE</CODE>.
+     * @exception java.io.IOException If value contains an invalid BER sequence.
+     * @see netscape.ldap.LDAPControl#register
+     */
+    public LDAPSortControl( String oid, boolean critical, byte[] value ) 
+        throws LDAPException, IOException {
+	super( oid, critical, value );
+
+	if ( !oid.equals( SORTRESPONSE )) {
+	    throw new LDAPException( "oid must be LDAPSortControl.SORTRESPONSE",
+				     LDAPException.PARAM_ERROR);
+	}
+
+        ByteArrayInputStream inStream = new ByteArrayInputStream( value );
+        BERSequence ber = new BERSequence();
+        JDAPBERTagDecoder decoder = new JDAPBERTagDecoder();
+        int[] nRead = { 0 };
+
+	/* A sequence */
+	BERSequence seq = (BERSequence)BERElement.getElement(decoder, inStream,
+							     nRead );
+	/* First is result code */
+	m_resultCode = ((BEREnumerated)seq.elementAt( 0 )).getValue();
+	/* Then, possibly an attribute that failed sorting */
+	if(seq.size() == 1) {
+	    return;
+	}
+	/* If this is not an octet string, let there be an exception */
+	BEROctetString t = (BEROctetString)seq.elementAt(1);
+	try {
+	    m_failedAttribute = new String(t.getValue(), "UTF8");
+	} catch (UnsupportedEncodingException e) {
+	}
+
+    }
+
+    /**
+     * @return the attribute that caused the sort operation to fail.
+     */
+    public String getFailedAttribute() {
+	return m_failedAttribute;
+    }
+
+    /**
+     * @return the result code from the search operation.
+     */
+    public int getResultCode() {
+	return m_resultCode;
+    }
+    
+    /**
+     * Constructs an <CODE>LDAPSortControl</CODE> object with a single
+     * sorting key.
+     * @param key a single attribute by which to sort
+     * @param critical <CODE>true</CODE> if the LDAP operation should be
+     * discarded when the server does not support this control (in other
+     * words, this control is critical to the LDAP operation)
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.LDAPSortKey
+     */
+    public LDAPSortControl(LDAPSortKey key,
+                           boolean critical) {
+        super( SORTREQUEST, critical, null );
+        LDAPSortKey[] keys = new LDAPSortKey[1];
+        keys[0] = key;
+        m_value = createSortSpecification( m_keys = keys );
+        
+    }
+
+    /**
+     * Constructs an <CODE>LDAPSortControl</CODE> object with an array of
+     * sorting keys.
+     * @param keys the attributes by which to sort
+     * @param critical <CODE>true</CODE> if the LDAP operation should be
+     * discarded when the server does not support this control (in other
+     * words, this control is critical to the LDAP operation)
+     * @see netscape.ldap.LDAPControl
+     * @see netscape.ldap.LDAPSortKey
+     */
+    public LDAPSortControl(LDAPSortKey[] keys,
+                           boolean critical) {
+        super( SORTREQUEST, critical, null );
+        m_value = createSortSpecification( m_keys = keys );
+    }
+
+    /**
+     * Parses the sorting response control sent by the server and
+     * retrieves the result code from the sorting operation and
+     * the attribute that caused sorting to fail (if specified by
+     * the server).
+     * <P>
+     *
+     * You can get the controls returned by the server by using the
+     * <CODE>getResponseControls</CODE> method of the
+     * <CODE>LDAPConnection</CODE> class.
+     * <P>
+     *
+     * This method returns the attribute that caused the sort operation
+     * to fail (or null, if the server did not specify any attribute).
+     * The result code of the sorting operation is returned in the
+     * <CODE>results</CODE> argument.  This argument is an array of
+     * integers; the result code is specified in the first element of
+     * this array.
+     * <P>
+     *
+     * For example:
+     * <PRE>
+     * ...
+     * LDAPConnection ld = new LDAPConnection();
+     * try {
+     *     // Connect to the server, set up the sorting control,
+     *     // and set up the search constraints.
+     *     ...
+     *
+     *     // Search the directory.
+     *     LDAPSearchResults res = ld.search( "o=Airius.com",
+     *         LDAPv3.SCOPE_SUB, "(cn=Barbara*)", attrs, false, cons );
+     *
+     *     // Determine if the server sent a control back to you.
+     *     LDAPControl[] returnedControls = ld.getResponseControls();
+     *     if ( returnedControls != null ) {
+     *         int[] resultCodes = new int[1];
+     *         String failedAttr = LDAPSortControl.parseResponse(
+     *             returnedControls, resultCodes );
+     *
+     *         // Check if the result code indicated an error occurred.
+     *         if ( resultCodes[0] != 0 ) {
+     *             System.out.println( "Result code: " + resultCodes[0] );
+     *             if ( failedAttr != null ) {
+     *                 System.out.println( "Sorting operation failed on " +
+     *                     failedAttr );
+     *             } else {
+     *                 System.out.println( "Server did not indicate which " +
+     *                     "attribute caused sorting to fail." );
+     *             }
+     *         }
+     *     }
+     *     ...
+     * }
+     * ...
+     *
+     * </PRE>
+     *
+     * The following table lists some of the possible result codes
+     * for the sorting operation.
+     * <P>
+     *
+     * <TABLE BORDER=1 COLS=2>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.SUCCESS</CODE>
+     *     </TD>
+     *     <TD>
+     *     The server successfully sorted the results.
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.OPERATION_ERROR</CODE>
+     *     </TD>
+     *     <TD>
+     *     An internal server error occurred.
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.TIME_LIMIT_EXCEEDED</CODE>
+     *     </TD>
+     *     <TD>
+     *     The maximum time allowed for a search was exceeded
+     *     before the server finished sorting the results.
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.STRONG_AUTH_REQUIRED</CODE>
+     *     </TD>
+     *     <TD>
+     *     The server refused to send back the sorted search
+     *     results because it requires you to use a stronger
+     *     authentication method.
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.ADMIN_LIMIT_EXCEEDED</CODE>
+     *     </TD>
+     *     <TD>
+     *     There are too many entries for the server to sort.
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.NO_SUCH_ATTRIBUTE</CODE>
+     *     </TD>
+     *     <TD>
+     *     The sort key list specifies an attribute that does not exist.
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.INAPPROPRIATE_MATCHING</CODE>
+     *     </TD>
+     *     <TD>
+     *     The sort key list specifies a matching rule that is
+     *     not recognized or appropriate
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.INSUFFICIENT_ACCESS_RIGHTS</CODE>
+     *     </TD>
+     *     <TD>
+     *     The server did not send the sorted results because the
+     *     client has insufficient access rights.
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.BUSY</CODE>
+     *     </TD>
+     *     <TD>
+     *     The server is too busy to sort the results.
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.UNWILLING_TO_PERFORM</CODE>
+     *     </TD>
+     *     <TD>
+     *     The server is unable to sort the results.
+     *     </TD>
+     * </TR>
+     * <TR VALIGN=BASELINE>
+     *     <TD>
+     *     <CODE>LDAPException.OTHER</CODE>
+     *     </TD>
+     *     <TD>
+     *     This general result code indicates that the server
+     *     failed to sort the results for a reason other than
+     *     the ones listed above.
+     *     </TD>
+     * </TR>
+     * </TABLE>
+     * <P>
+     *
+     * @param controls an array of <CODE>LDAPControl</CODE> objects,
+     * representing the controls returned by the server
+     * after a search. To get these controls, use the
+     * <CODE>getResponseControls</CODE> method of the
+     * <CODE>LDAPConnection</CODE> class.
+     * @param results an array of integers.  The first element of this array
+     * specifies the result code of the sorting operation.
+     * @return the attribute that caused the error, or null if the server did
+     * not specify which attribute caused the error.
+     * @see netscape.ldap.LDAPConnection#getResponseControls
+     * @deprecated LDAPSortControl response controls are now automatically 
+     * instantiated.
+     */
+    public static String parseResponse( LDAPControl[] controls, int[] results ) {
+        String attr = null;
+        LDAPControl sort = null;
+        /* See if there is a sort control in the array */
+        for( int i = 0; (controls != null) && (i < controls.length); i++ ) {
+            if ( controls[i].getID().equals( SORTRESPONSE ) ) {
+                sort = controls[i];
+                break;
+            }
+        }
+        if ( sort != null ) {
+            /* Suck out the data and return it */
+            ByteArrayInputStream inStream =
+                new ByteArrayInputStream( sort.getValue() );
+            BERSequence ber = new BERSequence();
+            JDAPBERTagDecoder decoder = new JDAPBERTagDecoder();
+            int[] nRead = new int[1];
+            nRead[0] = 0;
+            try  {
+                /* A sequence */
+                BERSequence seq = (BERSequence)BERElement.getElement(
+                                                     decoder, inStream,
+                                                     nRead );
+                /* First is result code */
+                int result = ((BEREnumerated)seq.elementAt( 0 )).getValue();
+                if ( (results != null) && (results.length > 0) )
+                    results[0] = result;
+                /* Then, possibly an attribute that failed sorting */
+                /* If this is not an octet string, let there be an exception */
+                BEROctetString t = (BEROctetString)seq.elementAt(1);
+                attr = new String(t.getValue(), "UTF8");
+            } catch(Exception x) {
+            }
+        }
+        return attr;
+    }
+
+    /**
+     * Create a "flattened" BER encoding of the requested sort keys,
+     * and return it as a byte array.
+     * @param keys the attributes by which to sort
+     * @return the byte array of encoded data.
+     */
+    private byte[] createSortSpecification( LDAPSortKey[] keys ) {
+        /* A sequence of sequences */
+        BERSequence ber = new BERSequence();
+        /* Add each sort key as a sequence */
+        for( int i = 0; i < keys.length; i++ ) {
+            BERSequence seq = new BERSequence();
+            /* The attribute name */
+            seq.addElement(new BEROctetString(keys[i].getKey()));
+            /* Optional matching rule */
+            if ( keys[i].getMatchRule() != null )
+                seq.addElement(new BERTag(
+                    BERTag.CONTEXT|0,
+                    new BEROctetString(keys[i].getMatchRule()),
+                    true));
+            /* Optional reverse-order sort */
+            if ( keys[i].getReverse() )
+                seq.addElement(new BERTag(
+                    BERTag.CONTEXT|1,
+                    new BEREnumerated(LDAPSortKey.REVERSE),
+                    true));
+            ber.addElement( seq );
+        }
+        /* Suck out the data and return it */
+        return flattenBER( ber );
+    }
+    
+    public String toString() {
+        return (getID() == SORTREQUEST) ? reqToString() : rspToString();
+    }
+    
+    String reqToString() {
+        
+        StringBuffer sb = new StringBuffer("{SortCtrl:");
+        
+        sb.append(" isCritical=");
+        sb.append(isCritical());
+        
+        sb.append(" ");
+        for (int i=0; i < m_keys.length; i++) {
+            sb.append(m_keys[i]);
+        }            
+        
+        sb.append("}");
+
+        return sb.toString();
+    }
+
+    String rspToString() {
+        
+        StringBuffer sb = new StringBuffer("{SortResponseCtrl:");
+        
+        sb.append(" isCritical=");
+        sb.append(isCritical());
+        
+        if (m_failedAttribute != null) {
+            sb.append(" failedAttr=");
+            sb.append(m_failedAttribute);
+        }
+        
+        sb.append(" resultCode=");
+        sb.append(m_resultCode);
+
+        sb.append("}");
+
+        return sb.toString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPGetEntriesBeanInfo.java
@@ -0,0 +1,149 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import java.beans.SimpleBeanInfo;
+import java.beans.BeanDescriptor;
+import java.beans.EventSetDescriptor;
+import java.beans.MethodDescriptor;
+import java.beans.PropertyDescriptor;
+import java.beans.ParameterDescriptor;
+import java.beans.BeanInfo;
+
+/**
+ * BeanInfo for LDAPGetEntries
+ */
+
+public class LDAPGetEntriesBeanInfo extends SimpleBeanInfo {
+
+    public LDAPGetEntriesBeanInfo() throws Exception {
+
+    beanClass = Class.forName( "netscape.ldap.beans.LDAPGetEntries" );
+
+        try {
+            PropertyDescriptor host =
+                new PropertyDescriptor("host", beanClass);
+            PropertyDescriptor port =
+                new PropertyDescriptor("port", beanClass);
+            PropertyDescriptor authDN =
+                new PropertyDescriptor("authDN", beanClass);
+            PropertyDescriptor authPassword =
+                new PropertyDescriptor("authPassword", beanClass);
+            PropertyDescriptor base =
+                new PropertyDescriptor("base", beanClass);
+            PropertyDescriptor userName =
+                new PropertyDescriptor("userName", beanClass);
+            PropertyDescriptor userID =
+                new PropertyDescriptor("userID", beanClass);
+            PropertyDescriptor filter =
+                new PropertyDescriptor("filter", beanClass);
+            PropertyDescriptor scope =
+                new PropertyDescriptor("scope", beanClass);
+            PropertyDescriptor debug =
+                new PropertyDescriptor("debug", beanClass);
+
+            PropertyDescriptor rv[] =
+                {host, port, authDN, authPassword, base, filter,
+                 scope, userName, userID, debug};
+            _propertyDescriptor = new PropertyDescriptor[rv.length];
+            for( int i = 0; i < rv.length; i++ )
+                _propertyDescriptor[i] = rv[i];
+        } catch (Exception e) {
+            throw new Error(e.toString());
+        }
+
+        // Publish events --------------------------------------------------
+        try {
+            _eventSetDescriptor = new EventSetDescriptor[1];
+
+            _eventSetDescriptor[0] = new EventSetDescriptor(beanClass,
+                    "propertyChange",
+                    Class.forName("java.beans.PropertyChangeListener"),
+                    "propertyChange");
+        } catch (Exception e) {
+            throw new Error(e.toString());
+        }
+
+        // Publish descriptor ---------------------------------------------
+        try {
+            _beanDescriptor = new BeanDescriptor(beanClass);
+            _beanDescriptor.setDisplayName( "LDAP entry retrieval" );
+            _beanDescriptor.setShortDescription(
+                "LDAP property retrieval -"
+                + " provided a host, port, base, search filter,"
+                + " and optionally a username and password,"
+                + " return an array of string values both as a"
+                + " function return and as a Property change event." );
+        } catch (Exception e) {
+        }
+    }
+
+    /**
+     * @return the public properties
+     */
+    public PropertyDescriptor[] getPropertyDescriptors() {
+        return _propertyDescriptor;
+    }
+
+    public EventSetDescriptor[] getEventSetDescriptors() {
+        return _eventSetDescriptor;
+    }
+
+    public BeanInfo[] getAdditionalBeanInfo() {
+        return null;
+    }
+
+    public int getDefaultEventIndex() {
+        return -1;
+    }
+
+    public int getDefaultPropertyIndex() {
+        return -1;
+    }
+
+    public BeanDescriptor getBeanDescriptor() {
+        return _beanDescriptor;
+    }
+
+    private static Class beanClass;
+    private BeanDescriptor _beanDescriptor;
+    private EventSetDescriptor[] _eventSetDescriptor;
+    private PropertyDescriptor[] _propertyDescriptor;
+}
+
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPIsMember.mf
@@ -0,0 +1,6 @@
+Name: netscape/ldap/beans/LDAPIsMember.class
+Java-Bean: True
+
+Name: netscape/ldap/beans/LDAPBasePropertySupport.class
+
+Name: netscape/ldap/beans/LDAPIsMemberBeanInfo.class
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/DisplayStringBeanInfo.java
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import java.beans.SimpleBeanInfo;
+import java.beans.BeanDescriptor;
+import java.beans.EventSetDescriptor;
+import java.beans.MethodDescriptor;
+import java.beans.PropertyDescriptor;
+import java.beans.ParameterDescriptor;
+import java.beans.BeanInfo;
+
+/**
+ * BeanInfo for displaying string
+ *
+ */
+
+public class DisplayStringBeanInfo extends SimpleBeanInfo {
+
+    public DisplayStringBeanInfo() throws Exception {
+
+    beanClass = Class.forName( "netscape.ldap.beans.DisplayString" );
+
+        // Publish descriptor ---------------------------------------------
+        try {
+            _beanDescriptor = new BeanDescriptor(beanClass);
+			_beanDescriptor.setDisplayName( "Text Field" );
+			_beanDescriptor.setShortDescription(
+				"LDAP property retrieval -"
+				+ " provided a host, port, base, search filter,"
+				+ " and optionally a username and password,"
+				+ " return an array of string values both as a"
+				+ " function return and as a Property change event." );
+        } catch (Exception e) {
+        }
+    }
+
+    public BeanDescriptor getBeanDescriptor() {
+		return _beanDescriptor;
+	}
+
+    private static Class beanClass;
+	private BeanDescriptor _beanDescriptor;
+    private EventSetDescriptor[] _eventSetDescriptor;
+    private PropertyDescriptor[] _propertyDescriptor;
+}
+
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPSimpleAuth.mf
@@ -0,0 +1,6 @@
+Name: netscape/ldap/beans/LDAPSimpleAuth.class
+Java-Bean: True
+
+Name: netscape/ldap/beans/LDAPBasePropertySupport.class
+
+Name: netscape/ldap/beans/LDAPSimpleAuthBeanInfo.class
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPGetEntries.java
@@ -0,0 +1,377 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import netscape.ldap.*;
+import netscape.ldap.beans.LDAPBasePropertySupport;
+import java.util.Enumeration;
+import java.util.Vector;
+import java.io.Serializable;
+import java.awt.event.*;
+
+
+/**
+ * Invisible Bean that just takes a host, port, directory base,
+ * search string, and optional authentication name and password,
+ * and returns a list of all matching DNs. The search has the scope
+ * "SUB", which means that it will find an entry anywhere at or
+ * below the directory base, unless a different scope is specified.
+ * <BR><BR>
+ * Optionally, a client can register as a PropertyChangeListener
+ * and will be notified when the values are available.
+ *<BR><BR>
+ * A null result means no matching DNs were found. The reason is
+ * available through getErrorCode(), which returns one of
+ * the following:
+ *<PRE>
+ *     OK
+ *     INVALID_PARAMETER
+ *     CONNECT_ERROR
+ *     AUTHENTICATION_ERROR
+ *     PROPERTY_NOT_FOUND
+ *     AMBIGUOUS_RESULTS
+ *</PRE>
+ *
+ */
+public class LDAPGetEntries extends LDAPBasePropertySupport implements Serializable {
+
+    /**
+     * Constructor with no parameters
+     */
+    public LDAPGetEntries() {
+        super();
+    }
+
+    /**
+    * Constructor with host, port, and base initializers
+    * @param theHost host string
+    * @param thePort port number
+    * @param theBase directory base string
+    */
+    public LDAPGetEntries( String theHost, int thePort, String theBase ) {
+        setHost( theHost );
+        setPort( thePort );
+        setBase( theBase );
+    }
+
+    /**
+    * Constructor with host, port, base, and scope initializers
+    * @param theHost host string
+    * @param thePort port number
+    * @param theBase directory base string
+    * @param theScope one of LDAPConnection.SCOPE_BASE,
+    * LDAPConnection.SCOPE_SUB, LDAPConnection.SCOPE_ONE
+    */
+    public LDAPGetEntries( String theHost,
+                           int thePort,
+                           String theBase,
+                           int theScope ) {
+        setHost( theHost );
+        setPort( thePort );
+        setBase( theBase );
+        setScope( theScope );
+    }
+
+    private void notifyResult( String error ) {
+        firePropertyChange( "error", _errorMsg, error );
+        _errorMsg = error;
+    }
+
+    private void notifyResult( String[] newResult ) {
+        String sNewResult = convertToString( newResult );
+        firePropertyChange( "result", _result, newResult );
+        _sResult = sNewResult;
+        _result = newResult;
+    }
+
+    /**
+     * Returns the name of the attribute to retrieve
+     * @return attribute name to retrieve
+     */
+    public String getAttribute() {
+        return _attribute;
+    }
+
+    /**
+     * Sets the attribute to retrieve
+     */
+    public void setAttribute( String attr ) {
+        _attribute = attr;
+    }
+
+    public void setResultString( String sNewValue ) {
+        _sResult = sNewValue;
+    }
+
+    public String getResultString() {
+        return _sResult;
+    }
+
+    /**
+     * Searches and returns values for a specified attribute
+     * @param host host string
+     * @param port port number
+     * @param base directory base string
+     * @param scope one of LDAPConnection.SCOPE_BASE,
+     * LDAPConnection.SCOPE_SUB, LDAPConnection.SCOPE_ONE
+     * @param filter search filter
+     * @return Array of values for the property
+     */
+    public String[] getEntries( String host,
+                                int port,
+                                String base,
+                                int scope,
+                                String filter) {
+        setHost( host );
+        setPort( port );
+        setBase( base );
+        setScope( scope );
+        setFilter( filter );
+        return getEntries();
+    }
+
+    /**
+     * Searches and returns values for a specified attribute
+     * @param host host string
+     * @param port port number
+     * @param base directory base string
+     * @param scope one of LDAPConnection.SCOPE_BASE,
+     * LDAPConnection.SCOPE_SUB, LDAPConnection.SCOPE_ONE
+     * @param userName The user name
+     * @param userid The user id
+     * @return Array of DNs
+     */
+    public String[] getEntries( String host,
+                                int port,
+                                String base,
+                                int scope,
+                                String userid,
+                                String userName) {
+        setHost( host );
+        setPort( port );
+        setBase( base );
+        setScope( scope );
+        if (userName == null)
+            userName = new String("");
+        setUserName( userName );
+        if (userid == null)
+            userid = new String("");
+        setUserID( userid );
+        return getEntries();
+    }
+
+    // Added this method in order to get exposed in BDK
+    public void getEntries(ActionEvent x) {
+        getEntries();
+    }
+
+    /**
+     * Searches and returns values of a previously registered property,
+     * using previously set parameters
+     * @return Array of values for the property
+     */
+    public String[] getEntries() {
+        boolean invalid = false;
+        if ((getUserName().length() < 1) && (getUserID().length() < 1) &&
+          (getFilter().length() < 1)) {
+            printDebug("No user name or user ID");
+            invalid = true;
+        } else if ( (getHost().length() < 1) || (getBase().length() < 1) ) {
+            printDebug( "Invalid host name or search base" );
+            invalid = true;
+        }
+        if ( invalid ) {
+            setErrorCode( INVALID_PARAMETER );
+            notifyResult( (String)null);
+            return null;
+        }
+
+        if (getFilter().length() < 1) {
+            String filter = new String("");
+            if ((getUserName().length() > 1) && (getUserID().length() > 1)) {
+                filter = "(|(cn="+getUserName()+")(uid="+getUserID()+"))";
+            } else if (getUserName().length() > 1) {
+                filter = "cn="+getUserName();
+            } else if (getUserID().length() > 1) {
+                filter = "uid="+getUserID();
+            }
+            setFilter(filter);
+        }
+
+        String[] res = null;
+        LDAPConnection m_ldc = new LDAPConnection();
+        try {
+            try {
+                printDebug("Connecting to " + getHost() +
+                           " " + getPort());
+                connect( m_ldc, getHost(), getPort());
+            } catch (Exception e) {
+                printDebug( "Failed to connect to " + getHost() + ": " +
+                            e.toString() );
+                setErrorCode( CONNECT_ERROR );
+                notifyResult( (String)null );
+                m_ldc = null;
+                throw( new Exception() );
+            }
+
+            // Authenticate?
+            if ( (!getAuthDN().equals("")) &&
+                 (!getAuthPassword().equals("")) ) {
+
+                printDebug( "Authenticating " + getAuthDN() );
+                try {
+                    m_ldc.authenticate( getAuthDN(), getAuthPassword() );
+                } catch (Exception e) {
+                    printDebug( "Failed to authenticate: " + e.toString() );
+                    setErrorCode( AUTHENTICATION_ERROR );
+                    notifyResult( (String)null );
+                    throw( new Exception() );
+                }
+            }
+
+            // Search
+            try {
+                printDebug("Searching " + getBase() +
+                           " for " + getFilter() + ", scope = " + getScope());
+                String[] attrs = { _attribute };
+                LDAPSearchResults results = m_ldc.search( getBase(),
+                                                          getScope(),
+                                                          getFilter(),
+                                                          attrs,
+                                                          false);
+
+                // Create a vector for the results
+                Vector v = new Vector();
+                LDAPEntry entry = null;
+                while ( results.hasMoreElements() ) {
+                    try {
+                        entry = results.next();
+                    } catch (LDAPException e) {
+                        if (getDebug())
+                            notifyResult(e.toString());
+                        continue;
+                    }
+                    // Add the DN to the list
+                    String value = "";
+                    if ( _attribute.equals("dn") ) {
+                        value = entry.getDN();
+                    } else {
+                        LDAPAttribute attr = entry.getAttribute( _attribute );
+                        if ( attr != null ) {
+                            Enumeration vals = attr.getStringValues();
+                            if ( (vals != null) && (vals.hasMoreElements()) ) {
+                                value = (String)vals.nextElement();
+                            }
+                        }
+                    }
+                    v.addElement( value );
+                    printDebug( "... " + value );
+                }
+                // Pull out the DNs and create a string array
+                if ( v.size() > 0 ) {
+                    res = new String[v.size()];
+                    v.copyInto( res );
+                    v.removeAllElements();
+                    setErrorCode( OK );
+                } else {
+                    printDebug( "No entries found for " + getFilter() );
+                    setErrorCode( PROPERTY_NOT_FOUND );
+                }
+            } catch (Exception e) {
+                if (getDebug()) {
+                    printDebug( "Failed to search for " + getFilter() + ": " +
+                                e.toString() );
+                }
+                setErrorCode( PROPERTY_NOT_FOUND );
+            }
+        } catch (Exception e) {
+        }
+
+        // Disconnect
+        try {
+            if ( (m_ldc != null) && m_ldc.isConnected() )
+                m_ldc.disconnect();
+        } catch ( Exception e ) {
+        }
+
+        // Notify any clients with a PropertyChangeEvent
+        notifyResult( res );
+        return res;
+    }
+
+  /**
+   * The main body if we run it as application instead of applet.
+   * @param args list of arguments
+   */
+    public static void main(String args[]) {
+        String[] scope = { "base", "one", "sub" };
+        int scopeIndex = -1;
+        for( int i = 0; (i < scope.length) && (args.length == 5); i++ ) {
+            if ( args[3].equalsIgnoreCase(scope[i]) ) {
+                scopeIndex = i;
+                break;
+            }
+        }
+            
+        if ( scopeIndex < 0 ) {
+            System.out.println( "Usage: LDAPGetEntries host port base" +
+                                " scope filter" );
+            System.exit(1);
+        }
+        LDAPGetEntries app = new LDAPGetEntries();
+        app.setHost( args[0] );
+        app.setPort( java.lang.Integer.parseInt( args[1] ) );
+        app.setBase( args[2] );
+        app.setScope( scopeIndex );
+        app.setFilter( args[4] );
+        String[] response = app.getEntries();
+        if ( response != null ) {
+            for( int i = 0; i < response.length; i++ )
+                System.out.println( "\t" + response[i] );
+        }
+        System.exit(0);
+    }
+
+    /*
+     * Variables
+     */
+    private String _attribute = "dn";
+    private String[] _result;
+    private String _sResult = null;
+    private String _errorMsg = null;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPSimpleAuthBeanInfo.java
@@ -0,0 +1,138 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import java.beans.SimpleBeanInfo;
+import java.beans.BeanDescriptor;
+import java.beans.EventSetDescriptor;
+import java.beans.MethodDescriptor;
+import java.beans.PropertyDescriptor;
+import java.beans.ParameterDescriptor;
+import java.beans.BeanInfo;
+
+/**
+ * BeanInfo for LDAPSimpleAuth
+ */
+
+public class LDAPSimpleAuthBeanInfo extends SimpleBeanInfo {
+
+    public LDAPSimpleAuthBeanInfo() throws Exception {
+
+    beanClass = Class.forName( "netscape.ldap.beans.LDAPSimpleAuth" );
+
+        try {
+            PropertyDescriptor host =
+                new PropertyDescriptor("host", beanClass);
+            PropertyDescriptor port =
+                new PropertyDescriptor("port", beanClass);
+            PropertyDescriptor authDN =
+                new PropertyDescriptor("authDN", beanClass);
+            PropertyDescriptor authPassword =
+                new PropertyDescriptor("authPassword", beanClass);
+            PropertyDescriptor debug =
+                new PropertyDescriptor("debug", beanClass);
+
+            PropertyDescriptor rv[] =
+                {host, port, authDN, authPassword, debug};
+            _propertyDescriptor = new PropertyDescriptor[rv.length];
+            for( int i = 0; i < rv.length; i++ )
+                _propertyDescriptor[i] = rv[i];
+        } catch (Exception e) {
+            throw new Error(e.toString());
+        }
+
+        // Publish events --------------------------------------------------
+        try {
+            _eventSetDescriptor = new EventSetDescriptor[1];
+
+            _eventSetDescriptor[0] = new EventSetDescriptor(beanClass,
+                    "propertyChange",
+                    Class.forName("java.beans.PropertyChangeListener"),
+                    "propertyChange");
+
+        } catch (Exception e) {
+            throw new Error(e.toString());
+        }
+
+        // Publish descriptor ---------------------------------------------
+        try {
+            _beanDescriptor = new BeanDescriptor(beanClass);
+            _beanDescriptor.setDisplayName( "LDAP user authentication" );
+            _beanDescriptor.setShortDescription(
+                "LDAP user authentication -"
+                + " provided a host, port, base, username, and password,"
+                + " report if the user can be authenticated both as a"
+                + " function return and as a Property change event." );
+        } catch (Exception e) {
+        }
+    }
+
+    /**
+     * @return the public properties
+     */
+    public PropertyDescriptor[] getPropertyDescriptors() {
+        return _propertyDescriptor;
+    }
+
+    public EventSetDescriptor[] getEventSetDescriptors() {
+        return _eventSetDescriptor;
+    }
+
+    public BeanInfo[] getAdditionalBeanInfo() {
+        return null;
+    }
+
+    public int getDefaultEventIndex() {
+        return -1;
+    }
+
+    public int getDefaultPropertyIndex() {
+        return -1;
+    }
+
+    public BeanDescriptor getBeanDescriptor() {
+        return _beanDescriptor;
+    }
+
+    private static Class beanClass;
+    private BeanDescriptor _beanDescriptor;
+    private EventSetDescriptor[] _eventSetDescriptor;
+    private PropertyDescriptor[] _propertyDescriptor;
+}
+
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPSimpleAuth.java
@@ -0,0 +1,198 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import netscape.ldap.*;
+import netscape.ldap.beans.LDAPBasePropertySupport;
+import java.io.Serializable;
+import java.awt.event.*;
+
+/**
+ * Invisible Bean that just authenticates a user with a Directory
+ * Server and returns Y or N. It takes a host and port, and then either
+ * a full distinguished name and password, an RDN and directory base, or
+ * a cn value and directory base.
+ * <BR><BR>
+ * Optionally, a client can register as
+ * a PropertyChangeListener and will be notified when an authentication
+ * completes.
+ * <BR><BR>
+ * The Bean can be used from JavaScript, as in the following example
+ * where the parameters are taken from HTML text fields in an HTML
+ * form called "input":
+ * <PRE>
+ * <XMP>
+ * <SCRIPT LANGUAGE="JavaScript">
+ * function checkAuthentication() {
+ *     auth = new Packages.netscape.ldap.beans.LDAPSimpleAuth();
+ *     auth.setHost( document.input.host.value );
+ *     auth.setPort( parseInt(document.input.port.value) );
+ *     auth.setAuthDN( document.input.username.value );
+ *     auth.setAuthPassword( document.input.password.value );
+ *     result = auth.authenticate();
+ *     alert( "The response is: " + result );
+ * }
+ * </SCRIPT>
+ * </XMP>
+ *</PRE>
+ */
+
+public class LDAPSimpleAuth extends LDAPBasePropertySupport implements
+  Serializable {
+
+    /**
+     * Constructor with no parameters
+     */
+    public LDAPSimpleAuth() {}
+
+    /**
+    * Constructor with host and port initializers
+    * @param theHost host string
+    * @param thePort port number
+    */
+    public LDAPSimpleAuth( String theHost,
+                           int thePort ) {
+        setHost( theHost );
+        setPort( thePort );
+    }
+
+    /**
+    * Constructor with all required authentication parameters
+    * @param theHost host string
+    * @param thePort port number
+    * @param dn fully qualified distinguished name to authenticate
+    * @param password password for authenticating the dn
+    */
+    public LDAPSimpleAuth( String theHost,
+                           int thePort,
+                           String dn,
+                           String password ) {
+        setHost( theHost );
+        setPort( thePort );
+        setAuthDN( dn );
+        setAuthPassword( password );
+    }
+
+    private void notifyResult( String newResult ) {
+        firePropertyChange( "result", result, newResult );
+        result = newResult;
+    }
+
+    /**
+     * Connect to LDAP server using parameters specified in
+     * constructor and/or by setting properties and attempt to
+     * authenticate.
+     * @return "Y" on successful authentication, "N" otherwise
+     */
+    public String authenticate() {
+        LDAPConnection m_ldc = null;
+        String result = "N";
+        try {
+            m_ldc = new LDAPConnection();
+            System.out.println("Connecting to " + getHost() +
+                               " " + getPort());
+            connect( m_ldc, getHost(), getPort());
+        } catch (Exception e) {
+            System.out.println( "Failed to connect to " + getHost() +
+                                ": " + e.toString() );
+        }
+        if ( m_ldc.isConnected() ) {
+            System.out.println( "Authenticating " + getAuthDN() );
+            try {
+                m_ldc.authenticate( getAuthDN(), getAuthPassword() );
+                result = "Y";
+            } catch (Exception e) {
+                System.out.println( "Failed to authenticate to " +
+                                    getHost() + ": " + e.toString() );
+            }
+        }
+
+        try {
+            if ( (m_ldc != null) && m_ldc.isConnected() )
+                m_ldc.disconnect();
+        } catch ( Exception e ) {
+        }
+
+        notifyResult( result );
+        return result;
+    }
+
+    /**
+     * Connect to LDAP server using parameters specified in
+     * constructor and/or by setting properties and attempt to
+     * authenticate.
+     * @param dn fully qualified distinguished name to authenticate
+     * @param password password for authenticating the dn
+     * @return "Y" on successful authentication, "N" otherwise
+     */
+    public String authenticate( String dn,
+                                String password ) {
+        setAuthDN( dn );
+        setAuthPassword( password );
+        return authenticate();
+    }
+
+    public void authenticate( ActionEvent x) {
+        authenticate();
+    }
+
+    /**
+     * The main body if we run it as stand-alone application.
+     * @param args list of arguments
+     */
+    public static void main(String args[]) {
+        if (args.length != 4) {
+            System.out.println( "       LDAPSimpleAuth " +
+                                "host port DN password" );
+            System.exit(1);
+        }
+        LDAPSimpleAuth app = new LDAPSimpleAuth();
+        app.setHost( args[0] );
+        app.setPort( java.lang.Integer.parseInt( args[1] ) );
+        app.setAuthDN( args[2] );
+        app.setAuthPassword( args[3] );
+        String response = app.authenticate();
+        System.out.println( "Response: " + response );
+        System.exit(0);
+    }
+
+    /*
+     * Variables
+     */
+    transient private String result = new String("");
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPGetProperty.mf
@@ -0,0 +1,6 @@
+Name: netscape/ldap/beans/LDAPGetProperty.class
+Java-Bean: True
+
+Name: netscape/ldap/beans/LDAPBasePropertySupport.class
+
+Name: netscape/ldap/beans/LDAPGetPropertyBeanInfo.class
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/DisplayString.mf
@@ -0,0 +1,4 @@
+Name: netscape/ldap/beans/DisplayString.class
+Java-Bean: True
+
+Name: netscape/ldap/beans/DisplayStringBeanInfo.class
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPIsMemberBeanInfo.java
@@ -0,0 +1,130 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import java.beans.SimpleBeanInfo;
+import java.beans.BeanDescriptor;
+import java.beans.EventSetDescriptor;
+import java.beans.MethodDescriptor;
+import java.beans.PropertyDescriptor;
+import java.beans.ParameterDescriptor;
+import java.beans.BeanInfo;
+
+/**
+ * BeanInfo for LDAPIsMember
+ */
+
+public class LDAPIsMemberBeanInfo extends SimpleBeanInfo {
+
+    public LDAPIsMemberBeanInfo() throws Exception {
+
+    beanClass = Class.forName( "netscape.ldap.beans.LDAPIsMember" );
+        // Publish properties -------------------------------------------------
+
+        try {
+            PropertyDescriptor host =
+                new PropertyDescriptor("host", beanClass);
+            PropertyDescriptor port =
+                new PropertyDescriptor("port", beanClass);
+            PropertyDescriptor authDN =
+                new PropertyDescriptor("authDN", beanClass);
+            PropertyDescriptor authPassword =
+                new PropertyDescriptor("authPassword", beanClass);
+            PropertyDescriptor group =
+                new PropertyDescriptor("group", beanClass);
+            PropertyDescriptor member =
+                new PropertyDescriptor("member", beanClass);
+            PropertyDescriptor debug =
+                new PropertyDescriptor("debug", beanClass);
+
+            PropertyDescriptor rv[] =
+                {host, port, authDN, authPassword, group, member, debug};
+            _propertyDescriptor = new PropertyDescriptor[rv.length];
+            for( int i = 0; i < rv.length; i++ )
+                _propertyDescriptor[i] = rv[i];
+        } catch (Exception e) {
+            throw new Error(e.toString());
+        }
+
+        // Publish descriptor ---------------------------------------------
+        try {
+            _beanDescriptor = new BeanDescriptor(beanClass);
+            _beanDescriptor.setDisplayName( "LDAP IsMember" );
+            _beanDescriptor.setShortDescription(
+                "LDAP IsMember -"
+                + " provided a host, port, group name and member name,"
+                + " and optionally an authentication name and password,"
+                + " return true if the member belongs to the group." );
+        } catch (Exception e) {
+        }
+    }
+
+    /**
+     * @return the public properties
+     */
+    public PropertyDescriptor[] getPropertyDescriptors() {
+        return _propertyDescriptor;
+    }
+
+    public EventSetDescriptor[] getEventSetDescriptors() {
+        return _eventSetDescriptor;
+    }
+
+    public BeanInfo[] getAdditionalBeanInfo() {
+        return null;
+    }
+
+    public int getDefaultEventIndex() {
+        return -1;
+    }
+
+    public int getDefaultPropertyIndex() {
+        return -1;
+    }
+
+    public BeanDescriptor getBeanDescriptor() {
+        return _beanDescriptor;
+    }
+
+    private static Class beanClass;
+    private BeanDescriptor _beanDescriptor;
+    private EventSetDescriptor[] _eventSetDescriptor;
+    private PropertyDescriptor[] _propertyDescriptor;
+}
+
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPIsMember.java
@@ -0,0 +1,452 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import netscape.ldap.*;
+import netscape.ldap.util.*;
+import java.util.Enumeration;
+import java.util.StringTokenizer;
+import java.io.Serializable;
+import java.awt.event.*;
+
+/**
+ * Invisible Bean that just takes a host and port, optional
+ * authentication name and password, and DN of a group and another DN
+ * which might be a member of the group, and returns true or
+ * false, depending on whether the second DN is a member of the first.
+ * <BR>
+ * Also handles the case of dynamic groups by derefencing the URL
+ * and searching for membership based on the url search.
+ * <BR>
+ * It doesn't handle nested groups.
+ * <BR><BR>
+ * A false result means the member could not be identified as
+ * belonging to the group. The exact reason is
+ * available through getErrorCode(), which returns one of
+ * the following:
+ *<PRE>
+ *     OK
+ *     INVALID_PARAMETER
+ *     CONNECT_ERROR
+ *     AUTHENTICATION_ERROR
+ *     PROPERTY_NOT_FOUND
+ *     AMBIGUOUS_RESULTS
+ *     NO_SUCH_OBJECT
+ *</PRE>
+ */
+public class LDAPIsMember extends LDAPBasePropertySupport
+                          implements Serializable {
+
+    /**
+     * Constructor with no parameters
+     */
+    public LDAPIsMember() {}
+
+    /**
+    * Constructor with host, port, and group DN initializers
+    * @param host host string
+    * @param port port number
+    * @param group distinguished name of the group
+    */
+    public LDAPIsMember( String host, int port, String group ) {
+        setHost( host );
+        setPort( port );
+        setGroup( group );
+    }
+
+    /**
+    * Constructor with host, port, authentication DN and password
+    * and group DN initializers
+    * @param host host string
+    * @param port port number
+    * @param dn fully qualified distinguished name to authenticate
+    * @param password password for authenticating the dn
+    * @param theGroup distinguished name of the group
+    */
+    public LDAPIsMember( String host, int port,
+                         String dn, String password, String theGroup ) {
+        setHost( host );
+        setPort( port );
+        setGroup( theGroup );
+        setAuthDN( dn );
+        setAuthPassword( password );
+    }
+
+    private void notifyResult( String newResult ) {
+        firePropertyChange( "result", _result, newResult );
+        _result = newResult;
+    }
+
+    /**
+     * Checks if an entity (specified by distinguished name) is a
+     * member of a particular group (specified by distinguished name)
+     * @return true if the specified member belongs to the group
+     */
+    public boolean isMember() {
+        String host = getHost();
+        int port = getPort();
+        String dn = getAuthDN();
+        String password = getAuthPassword();
+        String group = getGroup();
+        String member = getMember();
+        _result = new String("");
+
+        if ( (host == null) || (host.length() < 1)  ) {
+            printDebug( "Invalid host name" );
+            setErrorCode( INVALID_PARAMETER );
+            notifyResult(null);
+            return false;
+        }
+
+        if ( (member == null) || (group == null) ||
+             (member.length() < 1) || (group.length() < 1) ) {
+            printDebug( "Invalid member or group name" );
+            setErrorCode( INVALID_PARAMETER );
+            notifyResult(null);
+            return false;
+        }
+
+        LDAPConnection m_ldc;
+        boolean isMember = false;
+        try {
+            m_ldc = new LDAPConnection();
+            printDebug("Connecting to " + host +
+                               " " + port);
+            connect( m_ldc, getHost(), getPort());
+        } catch (Exception e) {
+            printDebug( "Failed to connect to " + host + ": "
+                        + e.toString() );
+            setErrorCode( CONNECT_ERROR );
+            notifyResult(null);
+            return false;
+        }
+
+        // Authenticate?
+        if ( (dn != null) && (password != null) &&
+             (dn.length() > 0) && (password.length() > 0) ) {
+            printDebug( "Authenticating " + dn + " - " + password );
+            try {
+                m_ldc.authenticate( dn, password );
+            } catch (Exception e) {
+                printDebug( "Failed to authenticate to " +
+                                    host + ": " + e.toString() );
+                setErrorCode( AUTHENTICATION_ERROR );
+                notifyResult(null);
+                return false;
+            }
+        }
+
+        int numDataEntries = 0;
+        // Search
+        try {
+            String[] attrs = new String[4];
+            attrs[0] = "member";
+            attrs[1] = "uniqueMember";
+            attrs[2] = "memberOfGroup";
+            attrs[3] = "memberurl";
+            LDAPSearchResults results =
+                m_ldc.search( group,
+                              LDAPConnection.SCOPE_BASE,
+                              "objectclass=*",
+                              attrs, false);
+
+            // Should be only one result, at most
+            LDAPEntry entry = null;
+            LDAPEntry currEntry = null;
+            while ( results.hasMoreElements() ) {
+                try {
+                    currEntry = (LDAPEntry)results.next();
+                    if (numDataEntries == 0)
+                        entry = currEntry;
+                    if (++numDataEntries > 1) {
+                        printDebug( "More than one entry found for " +
+                                getFilter() );
+                        setErrorCode( AMBIGUOUS_RESULTS );
+                        break;
+                    }
+                } catch (LDAPReferralException e) {
+                    if (getDebug()) {
+                        notifyResult("Referral URLs: ");
+                        LDAPUrl refUrls[] = e.getURLs();
+                        for (int i = 0; i < refUrls.length; i++)
+                            notifyResult(refUrls[i].getUrl());
+                    }
+                    continue;
+                } catch (LDAPException e) {
+                    if (getDebug())
+                        notifyResult(e.toString());
+                    continue;
+                }
+            }
+            if (numDataEntries == 1) {
+                printDebug( "... " + entry.getDN() );
+                String normMember = normalizeDN( member );
+                // Good - exactly one entry found; get the attributes
+                LDAPAttributeSet attrset = entry.getAttributeSet();
+                Enumeration attrsenum = attrset.getAttributes();
+                while ( attrsenum.hasMoreElements() && !isMember ) {
+                    LDAPAttribute attr =
+                        (LDAPAttribute)attrsenum.nextElement();
+                    printDebug( attr.getName() + " = " );
+                    boolean urlHandler =
+                        attr.getName().equalsIgnoreCase("memberurl");
+                    /* Get the values as strings.
+                       The following code also handles dynamic
+                       groups by calling URLMatch to see if an entry
+                       DN is found via a URL search.
+                       This is transparent to the caller of the bean.
+                    */
+                    Enumeration valuesenum = attr.getStringValues();
+                    if (valuesenum != null) {
+                        while (valuesenum.hasMoreElements()) {
+                            String val = (String)valuesenum.nextElement();
+                            if (urlHandler) {
+                                if ( URLMatch(m_ldc, val, normMember) ) {
+                                    isMember = true;
+                                    setErrorCode( OK );
+                                    break;
+                                }
+                            } 
+                            printDebug( "\t\t" + val );
+                            String normFound = normalizeDN( val );
+                            if ( normMember.equals( normFound ) ) {
+                                isMember = true;
+                              setErrorCode( OK );
+                              break;
+                            }
+                        }
+                    } else {
+                        setErrorCode(PROPERTY_NOT_FOUND);
+                        printDebug("Failed to do string conversion for "+
+                                   attr.getName());
+                    }
+                }
+                if ( !isMember )
+                    setErrorCode( PROPERTY_NOT_FOUND );
+            }
+        } catch (Exception e) {
+            printDebug( "Failed to search for " + group + ": "
+                                    + e.toString() );
+            setErrorCode( NO_SUCH_OBJECT );
+        }
+
+        if (numDataEntries == 0) {
+            printDebug( "No entries found for " + group );
+            setErrorCode( NO_SUCH_OBJECT );
+        }
+
+        try {
+            if ( (m_ldc != null) && m_ldc.isConnected() )
+                m_ldc.disconnect();
+        } catch ( Exception e ) {
+        }
+
+        if (isMember)
+            notifyResult("Y");
+        else
+            notifyResult("N");
+
+        return isMember;
+    }
+
+    /**
+     * Checks if an entity (specified by distinguished name) is a
+     * member of a particular group (specified by distinguished name)
+     * @param host host string
+     * @param port port number
+     * @param dn fully qualified distinguished name to authenticate;
+     * can be null or ""
+     * @param password password for authenticating the dn; can be null
+     * or ""
+     * @param group distinguished name of the group
+     * @param member distinguished name of member to be checked
+     * @return true if the specified member belongs to the group
+     */
+    public boolean isMember( String host, int port,
+                             String dn, String password,
+                             String group, String member ) {
+        setHost(host);
+        setPort(port);
+        setAuthDN(dn);
+        setAuthPassword(password);
+        setGroup(group);
+        setMember(member);
+        return isMember();
+    }
+
+    /**
+     * Checks if an entity (specified by distinguished name) is a
+     * member of a particular group (specified by distinguished name)
+     */
+    public void isMember(ActionEvent e) {
+        isMember();
+    }
+
+    /**
+     * Returns the distinguished name of the group
+     * @return group name
+     */
+    public String getGroup() {
+        return _group;
+    }
+
+    /**
+     * Sets the distinguished name of the group
+     * @param group group name
+     */
+    public void setGroup( String group ) {
+        _group = group;
+    }
+
+    /**
+     * Returns the distinguished name of the member
+     * @return member name
+     */
+    public String getMember() {
+        return _member;
+    }
+
+    /**
+     * Sets the distinguished name of the member
+     * @param member member name
+     */
+    public void setMember( String member ) {
+        _member = member;
+    }
+
+    private String normalizeDN( String dn ) {
+        return new DN( dn ).toRFCString().toUpperCase();
+    }
+
+    /**
+     * Return true if normMember is result of url search.
+     * Urls from dynamic groups do not typically contain
+     * the host and port so we need to fix them before
+     * constructing an LDAP URL.  
+     * current ldap:///.... make ldap://host:port/...
+     **/
+     private boolean URLMatch(LDAPConnection ld, String URL,
+                              String normMemberDN) {
+        String cURL = URL;
+        boolean isMember = false;
+        int loc = URL.indexOf(":///");
+        if ( loc > 0) {
+            cURL = URL.substring(0,loc) + "://" + ld.getHost() + 
+                ":" + ld.getPort() + URL.substring(loc+3);
+        }
+        printDebug("URLMatch: url = " + cURL +
+                   ", member DN = " + normMemberDN);
+        LDAPUrl ldapurl;
+        try {
+            ldapurl = new LDAPUrl(cURL);
+            printDebug("URL ->"+ldapurl.getUrl());
+        } catch (java.net.MalformedURLException murl) {
+            printDebug("bad URL");
+            return isMember;
+        }
+        
+        try {
+            LDAPSearchResults results = ld.search(ldapurl);
+            String entry = "";
+            while ( results.hasMoreElements() && !isMember ) {
+                try {
+                    entry = ((LDAPEntry)results.next()).getDN();
+                    String normEntry = normalizeDN( entry );
+                    if (normEntry.equals(normMemberDN)) {
+                        isMember = true;
+                        break;
+                    }
+                } catch (LDAPReferralException e) {
+                    if (getDebug()) {
+                        notifyResult("Referral URLs: ");
+                        LDAPUrl refUrls[] = e.getURLs();
+                        for (int i = 0; i < refUrls.length; i++)
+                            notifyResult(refUrls[i].getUrl());
+                    }
+                    continue;
+                } catch (LDAPException e) {
+                    if (getDebug())
+                        notifyResult(e.toString());
+                    continue;
+                }
+            }
+        } catch (LDAPException lde) {
+            printDebug("Failed search for url " + ldapurl.getUrl());
+            setErrorCode(NO_SUCH_OBJECT);
+        }
+        
+        return isMember;
+     }
+
+  /**
+   * The main body if we run it as application instead of applet.
+   * @param args list of arguments
+   */
+    public static void main(String args[]) {
+        if (args.length != 4) {
+            System.out.println( "Usage: LDAPIsMember host port group" +
+                                " member" );
+            System.exit(1);
+        }
+        LDAPIsMember app = new LDAPIsMember();
+        app.setHost( args[0] );
+        app.setPort( java.lang.Integer.parseInt( args[1] ) );
+        app.setGroup( args[2] );
+        app.setMember( args[3] );
+        boolean response = app.isMember();
+        if ( response == false )
+            System.out.println( "Not a member" );
+        else
+            System.out.println( "Is a member" );
+        System.exit(0);
+    }
+
+    /*
+     * Variables
+     */
+    public static final int OK = 0;
+    public static final int INVALID_PARAMETER = 1;
+    public static final int CONNECT_ERROR = 2;
+    public static final int AUTHENTICATION_ERROR = 3;
+    public static final int PROPERTY_NOT_FOUND = 4;
+    public static final int AMBIGUOUS_RESULTS = 5;
+    public static final int NO_SUCH_OBJECT = 5;
+    private String _group = new String("");
+    private String _member = new String("");
+    private String _result = new String("");
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPBasePropertySupport.java
@@ -0,0 +1,411 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import netscape.ldap.*;
+import java.util.StringTokenizer;
+
+// This class has a bound property
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeSupport;
+import java.io.Serializable;
+
+/**
+ * This is a base class that is extended by various specialized LDAP
+ * Beans. It provides the common properties and accessors used by
+ * them.
+ */
+
+public class LDAPBasePropertySupport implements Serializable {
+
+    /**
+     * Constructor with no parameters
+     */
+    public LDAPBasePropertySupport() {}
+
+    /**
+     * Returns the host to search at.
+     * @return DNS name or dotted IP name of host to search at
+     */
+    public String getHost() {
+        return _host;
+    }
+
+    /**
+    * Sets host string.
+    * @param theHost host name
+    */
+    public void setHost( String theHost ) {
+        _host = theHost;
+    }
+
+    /**
+     * Returns the port to search at.
+     * @return Port to search at
+     */
+    public int getPort() {
+        return _port;
+    }
+
+    /**
+    * Sets port number.
+    * @param thePort port
+    */
+    public void setPort( int thePort ) {
+        _port = thePort;
+    }
+
+    /**
+     * Returns the directory base to search at.
+     * @return directory base to search
+     */
+    public String getBase() {
+        return _base;
+    }
+
+    /**
+    * Sets the starting base
+    * @param theBase starting base
+    */
+    public void setBase( String theBase ) {
+        _base = theBase;
+    }
+
+    /**
+     * Returns the DN to authenticate as; null or empty for anonymous.
+     * @return DN to authenticate as
+     */
+    public String getAuthDN() {
+        return _authDN;
+    }
+
+    /**
+     * Sets the DN to authenticate as; null or empty for anonymous.
+     * @param authDN the DN to authenticate as
+     */
+    public void setAuthDN( String authDN ) {
+        this._authDN =  authDN;
+    }
+
+    /**
+     * Returns the password for the DN to authenticate as
+     * @return Password of DN to authenticate as
+     */
+    public String getAuthPassword() {
+        return _authPassword;
+    }
+
+    /**
+     * Sets the password for the DN to authenticate as
+     * @param authPassword the password to use in authentication
+     */
+    public void setAuthPassword( String authPassword ) {
+        this._authPassword = authPassword;
+    }
+
+    /**
+     * Returns the user name
+     * @return The user name
+     */
+    public String getUserName() {
+        return _userName;
+    }
+
+    /**
+     * Set the user name. The name should be of the form "Polly Plum".
+     * @param name The user name
+     */
+    public void setUserName( String name ) {
+        _userName = name;
+    }
+
+    /**
+     * Return the user ID.
+     * @return name the user id
+     */
+    public String getUserID() {
+        return _userID;
+    }
+
+    /**
+     * Set the user ID.
+     * @param name the value of the user id
+     */
+    public void setUserID( String name ) {
+        _userID = name;
+    }
+
+    /**
+     * Get the current search scope
+     * @return the current search scope as integer
+     */
+    public int getScope() {
+        return _scope;
+    }
+
+    /**
+     * Set the search scope using an integer
+     * @param scope one of LDAPConnection.SCOPE_BASE,
+     * LDAPConnection.SCOPE_SUB, LDAPConnection.SCOPE_ONE
+     */
+    public void setScope( int scope ) {
+        _scope = scope;
+    }
+
+    /**
+     * Returns the search filter
+     * @return search filter
+     */
+    public String getFilter() {
+        return _filter;
+    }
+
+    /**
+     * Sets the search filter
+     * @param filter search filter
+     */
+    public void setFilter( String filter ) {
+        _filter = filter;
+    }
+
+    /**
+     * Returns true if debug output is on
+     * @return true if debug output is on
+     */
+    public boolean getDebug() {
+        return _debug;
+    }
+
+    /**
+     * Turns debug output on or off
+     * @param on true for debug output
+     */
+    public void setDebug( boolean on ) {
+        _debug = on;
+    }
+
+    /**
+     * Returns the latest error code
+     * @return The latest error code
+     */
+    public int getErrorCode() {
+        return _errCode;
+    }
+
+    /**
+     * Sets an error code for retrieval by a client
+     * @param code An error code
+     */
+    public void setErrorCode( int code ) {
+        _errCode = code;
+    }
+
+    /**
+     * Add a client to be notified when an authentication result is in
+     * @param listener a client to be notified of changes
+     */
+    public void addPropertyChangeListener( PropertyChangeListener listener ) {
+        printDebug( "Adding listener " + listener );
+        m_propSupport.addPropertyChangeListener( listener );
+    }
+
+    /**
+     * Remove a client which had requested notification on authentication
+     * @param listener a client to not be notified of changes
+     */
+    public void removePropertyChangeListener(
+                              PropertyChangeListener listener ) {
+        m_propSupport.removePropertyChangeListener( listener );
+    }
+
+    /**
+     * Support for bound property notification
+     * @param propName Name of changed property
+     * @param oldValue Previous value of property
+     * @param newValue New value of property
+     */
+    public void firePropertyChange(
+                              String propName,
+                              Object oldValue,
+                              Object newValue ) {
+
+        if (m_propSupport == null)
+            m_propSupport = new PropertyChangeSupport( this );
+
+        m_propSupport.firePropertyChange( propName, oldValue, newValue );
+    }
+
+    protected void printDebug( String s ) {
+        if ( _debug )
+            System.out.println( s );
+    }
+
+    /**
+     * Sets up basic connection privileges for Communicator if necessary,
+     * and connects
+     * @param host Host to connect to.
+     * @param port Port number.
+     * @exception LDAPException from connect()
+     */
+    protected void connect( LDAPConnection conn, String host, int port )
+        throws LDAPException {
+        boolean needsPrivileges = true;
+        /* Running standalone? */
+        SecurityManager sec = System.getSecurityManager();
+        printDebug( "Security manager = " + sec );
+        if ( sec == null ) {
+            printDebug( "No security manager" );
+            /* Not an applet, we can do what we want to */
+            needsPrivileges = false;
+        /* Can't do instanceof on an abstract class */
+        } else if ( sec.toString().startsWith("java.lang.NullSecurityManager") ) {
+            printDebug( "No security manager" );
+            /* Not an applet, we can do what we want to */
+            needsPrivileges = false;
+        } else if ( sec.toString().startsWith(
+            "netscape.security.AppletSecurity" ) ) {
+
+            /* Connecting to the local host? */
+            try {
+                if ( host.equalsIgnoreCase(
+                    java.net.InetAddress.getLocalHost().getHostName() ) )
+                    needsPrivileges = false;
+            } catch ( java.net.UnknownHostException e ) {
+            }
+        }
+
+        if ( needsPrivileges ) {
+            /* Running as applet. Is PrivilegeManager around? */
+            String mgr = "netscape.security.PrivilegeManager";
+            try {
+                Class c = Class.forName( mgr );
+                java.lang.reflect.Method[] m = c.getMethods();
+                if ( m != null ) {
+                    for( int i = 0; i < m.length; i++ ) {
+                        if ( m[i].getName().equals( "enablePrivilege" ) ) {
+                            try {
+                                Object[] args = new Object[1];
+                                args[0] = new String( "UniversalConnect" );
+                                m[i].invoke( null, args );
+                                printDebug( "UniversalConnect enabled" );
+                                args[0] = new String( "UniversalPropertyRead" );
+                                m[i].invoke( null, args );
+                                printDebug( "UniversalPropertyRead enabled" );
+                            } catch ( Exception e ) {
+                                printDebug( "Exception on invoking " +
+                                            "enablePrivilege: " +
+                                            e.toString() );
+                                break;
+                            }
+                            break;
+                        }
+                    }
+                }
+            } catch ( ClassNotFoundException e ) {
+                printDebug( "no " + mgr );
+            }
+        }
+
+        conn.connect( host, port );
+        setDefaultReferralCredentials( conn );
+    }
+
+    protected void setDefaultReferralCredentials(
+        LDAPConnection conn ) {
+        final LDAPConnection m_conn = conn;
+        LDAPRebind rebind = new LDAPRebind() {
+            public LDAPRebindAuth getRebindAuthentication(
+                String host,
+                int port ) {
+                    return new LDAPRebindAuth( 
+                        m_conn.getAuthenticationDN(),
+                        m_conn.getAuthenticationPassword() );
+                }
+        };
+        try {
+            conn.setOption(LDAPConnection.REFERRALS, Boolean.TRUE);
+            conn.setOption(LDAPConnection.REFERRALS_REBIND_PROC, rebind);
+        } catch (LDAPException e) {
+            //will never happen
+        }
+    }
+
+    /**
+     * Utility method to convert an array of Strings to a single String
+     * with line feeds between elements.
+     * @param aResult The array of Strings to convert
+     * @return A String with the elements separated by line feeds
+     */
+    public String convertToString( String[] aResult ) {
+        String sResult = "";
+        if ( null != aResult ) {
+            for ( int i = 0; i < aResult.length; i++ ) {
+                sResult += aResult[i] + "\n";
+            }
+        }
+        return sResult;
+    }
+
+    /*
+     * Variables
+     */
+    /* Error codes from search operations, etc */
+    public static final int OK = 0;
+    public static final int INVALID_PARAMETER = 1;
+    public static final int CONNECT_ERROR = 2;
+    public static final int AUTHENTICATION_ERROR = 3;
+    public static final int PROPERTY_NOT_FOUND = 4;
+    public static final int AMBIGUOUS_RESULTS = 5;
+    public static final int NO_SUCH_OBJECT = 6;
+
+    private boolean _debug = false;
+    private int _errCode = 0;
+    private String _host = new String("localhost");
+    private int _port = 389;
+    private int _scope = LDAPConnection.SCOPE_SUB;
+    private String _base = new String("");
+    private String _filter = new String("");
+    private String _authDN = new String("");
+    private String _authPassword = new String("");
+    private String _userName = new String("");
+    private String _userID = new String("");
+    transient private PropertyChangeSupport m_propSupport =
+              new PropertyChangeSupport( this );
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPGetProperty.java
@@ -0,0 +1,352 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import netscape.ldap.*;
+import netscape.ldap.beans.LDAPBasePropertySupport;
+import java.util.Enumeration;
+import java.util.Vector;
+import java.io.Serializable;
+import java.beans.*;
+import java.awt.event.*;
+
+
+/**
+ * Invisible Bean that just takes a name and password, host and
+ * port, and directory base and attribute name, and returns an
+ * attribute's values from a Directory Server. The values are
+ * assumed to be strings, and are returned as an array. The
+ * search has the scope "SUB", which means that it will find
+ * an entry anywhere at or below the directory base.
+ * <BR><BR>
+ * Optionally, a client can register as a PropertyChangeListener
+ * and will be notified when the values are available.
+ *<BR><BR>
+ * A null result means the property fetch failed. The reason is
+ * available through getErrorCode(), which returns one of
+ * the following:
+ *<PRE>
+ *     OK
+ *     INVALID_PARAMETER
+ *     CONNECT_ERROR
+ *     AUTHENTICATION_ERROR
+ *     PROPERTY_NOT_FOUND
+ *     AMBIGUOUS_RESULTS
+ *</PRE>
+ */
+public class LDAPGetProperty extends LDAPBasePropertySupport implements
+  Serializable {
+
+    /**
+     * Constructor with no parameters
+     */
+    public LDAPGetProperty() {}
+
+    /**
+    * Constructor with host, port, and base initializers
+    * @param theHost host string
+    * @param thePort port number
+    * @param theBase directory base string
+    */
+    public LDAPGetProperty( String theHost, int thePort, String theBase ) {
+        setHost( theHost );
+        setPort( thePort );
+        setBase( theBase );
+    }
+
+    /**
+     * Returns the name of the attribute to retrieve
+     * @return attribute name to retrieve
+     */
+    public String getAttribute() {
+        return _attribute;
+    }
+
+    /**
+     * Sets the attribute to retrieve
+     */
+    public void setAttribute( String attr ) {
+        _attribute = attr;
+    }
+
+    private void notifyResult( String[] newResult ) {
+        String sNewResult = convertToString( newResult );
+        firePropertyChange( "result", _result, newResult );
+        _sResult = sNewResult;
+        _result = newResult;
+    }
+
+    private void notifyResult( Vector newResult ) {
+        firePropertyChange( "result", _resultV, newResult );
+        _resultV = (Vector)newResult.clone();
+    }
+
+    private void notifyResult( String error ) {
+        firePropertyChange( "error", _errorMsg, error );
+        _errorMsg = error;
+    }
+
+    public void setDNs(PropertyChangeEvent evt) {
+        Object obj = (Object)evt.getNewValue();
+        if ((obj != null) && (obj instanceof String[])) {
+            String[] strings = (String[])obj;
+            if (strings.length == 0)
+                return;
+            _dns = new String[strings.length];
+            System.arraycopy(obj, 0, _dns, 0, strings.length);
+            System.out.println("length of dns -> "+_dns.length);
+        }
+    }
+
+    /**
+     * Searches and returns values for a specified attribute
+     * @param host host string
+     * @param port port number
+     * @param base directory base string
+     * @param filter search filter
+     * @param attribute name of property to return values for
+     * @return Array of values for the property
+     */
+    public String[] getProperty( String host, int port, String base,
+                                 String filter, String attribute) {
+        setHost( host );
+        setPort( port );
+        setBase( base );
+        setFilter( filter );
+        setAttribute( attribute );
+        return getProperty();
+    }
+
+    // Added this method in order to get exposed in BDK
+    public void getProperty(ActionEvent x) {
+        getProperty();
+    }
+
+    /**
+     * Searches and returns values of a previously registered property,
+     * using previously set parameters
+     * @return Array of values for the property
+     */
+    public String[] getProperty() {
+        if ( (_attribute.length() < 1) || (getFilter().length() < 1) ) {
+            printDebug( "Invalid attribute name or filter" );
+            setErrorCode( INVALID_PARAMETER );
+            notifyResult( (String[])null );
+            return null;
+        }
+
+        String[] res = null;
+        LDAPConnection m_ldc;
+        try {
+            m_ldc = new LDAPConnection();
+            printDebug("Connecting to " + getHost() +
+                               " " + getPort());
+            connect( m_ldc, getHost(), getPort());
+        } catch (Exception e) {
+            printDebug( "Failed to connect to " + getHost() + ": "
+                        + e.toString() );
+            setErrorCode( CONNECT_ERROR );
+            notifyResult( (String[])null );
+            return null;
+        }
+
+        // Authenticate?
+        if (_dns != null) {
+            for (int i=0; i<_dns.length; i++) {
+                try {
+                    m_ldc.authenticate(_dns[i], getAuthPassword());
+                    break;
+                } catch (Exception e) {
+                    if (i == _dns.length-1) {
+                        printDebug( "Failed to authenticate to " +
+                                    getHost() + ": " + e.toString() );
+                        setErrorCode( AUTHENTICATION_ERROR );
+                        notifyResult( (String[])null );
+                        return null;
+                    }
+                }
+            }
+        } else if ( (!getAuthDN().equals("")) && (!getAuthPassword().equals("")) ) {
+            printDebug( "Authenticating " + getAuthDN() + " - " +
+                                getAuthPassword() );
+            try {
+                m_ldc.authenticate( getAuthDN(), getAuthPassword() );
+            } catch (Exception e) {
+                printDebug( "Failed to authenticate to " +
+                                    getHost() + ": " + e.toString() );
+                setErrorCode( AUTHENTICATION_ERROR );
+                notifyResult( (String[])null );
+                return null;
+            }
+        }
+
+        int numDataEntries = 0;
+        // Search
+        try {
+            String[] attrs = new String[1];
+            attrs[0] = _attribute;
+            LDAPSearchResults results = m_ldc.search(getBase(),
+                                                     getScope(),
+                                                     getFilter(),
+                                                     attrs, false);
+
+            // Should be only one result, at most
+            LDAPEntry currEntry = null;
+            LDAPEntry entry = null;
+            while ( results.hasMoreElements() ) {
+                try {
+                    currEntry = results.next();
+                    if (numDataEntries == 0)
+                        entry = currEntry;
+                    if (++numDataEntries > 1) {
+                        printDebug( "More than one entry found for " +
+                                getFilter() );
+                        setErrorCode( AMBIGUOUS_RESULTS );
+                        break;
+                    }
+                } catch (LDAPException e) {
+                    if (getDebug())
+                        notifyResult(e.toString());
+                    continue;
+                }
+            }
+            if (numDataEntries == 1) {
+                printDebug( "... " + entry.getDN() );
+                // Good - exactly one entry found; get the attribute
+                // Treat DN as a special case
+                if ( _attribute.equalsIgnoreCase( "dn" ) ) {
+                    res = new String[1];
+                    res[0] = entry.getDN();
+                    setErrorCode( OK );
+                } else {
+                    LDAPAttributeSet attrset = entry.getAttributeSet();
+                    Enumeration attrsenum = attrset.getAttributes();
+                    if (attrsenum.hasMoreElements()) {
+                        LDAPAttribute attr =
+                            (LDAPAttribute)attrsenum.nextElement();
+                        printDebug( attr.getName() + " = " );
+                        // Get the values as strings
+                        Enumeration valuesenum = attr.getStringValues();
+                        if (valuesenum != null) {
+                          // Create a string array for the results
+                            Vector v = new Vector();
+                            while (valuesenum.hasMoreElements()) {
+                                String val = (String)valuesenum.nextElement();
+                                v.addElement( val );
+                                printDebug( "\t\t" + val );
+                            }
+                            res = new String[v.size()];
+                            v.copyInto( res );
+                            setErrorCode( OK );
+                        } else {
+                            Enumeration byteEnum = attr.getByteValues();
+                            Vector v = new Vector();
+                            while (byteEnum.hasMoreElements()) {
+                                byte[] val = (byte[])byteEnum.nextElement();
+                                v.addElement( val );
+                                printDebug( "\t\t" + val );
+                            }
+                            setErrorCode( OK );
+                            notifyResult(v);
+                            return (res = null);
+                        }
+                    } else {
+                        printDebug( "No properties found for " +
+                                    _attribute );
+                        setErrorCode( PROPERTY_NOT_FOUND );
+                    }
+                }
+            }
+        } catch (Exception e) {
+            if (getDebug()) {
+                printDebug( "Failed to search for " + getFilter() + ": "
+                            + e.toString() );
+            }
+            setErrorCode( PROPERTY_NOT_FOUND );
+        }
+
+        if (numDataEntries == 0) {
+            printDebug( "No entries found for " + getFilter() );
+            setErrorCode( PROPERTY_NOT_FOUND );
+        }
+
+        // Disconnect
+        try {
+            if ( (m_ldc != null) && m_ldc.isConnected() )
+                m_ldc.disconnect();
+        } catch ( Exception e ) {
+        }
+
+        notifyResult( res );
+        return res;
+    }
+
+  /**
+   * The main body if we run it as application instead of applet.
+   * @param args list of arguments
+   */
+    public static void main(String args[]) {
+        if (args.length != 5) {
+            System.out.println( "Usage: LDAPGetProperty host port base" +
+                                " filter attribute" );
+            System.exit(1);
+        }
+        LDAPGetProperty app = new LDAPGetProperty();
+        app.setHost( args[0] );
+        app.setPort( java.lang.Integer.parseInt( args[1] ) );
+        app.setBase( args[2] );
+        app.setFilter( args[3] );
+        app.setAttribute( args[4] );
+        String[] response = app.getProperty();
+        if ( response != null ) {
+            for( int i = 0; i < response.length; i++ )
+                System.out.println( "\t" + response[i] );
+        }
+        System.exit(0);
+    }
+
+    /*
+     * Variables
+     */
+    private String[] _dns = null;
+    private String _attribute = new String("cn");
+    transient private String[] _result;
+    private Vector _resultV = null;
+    private String _sResult = null;
+    private String _errorMsg = null;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPGetEntries.mf
@@ -0,0 +1,7 @@
+Name: netscape/ldap/beans/LDAPGetEntries.class
+Java-Bean: True
+
+Name: netscape/ldap/beans/LDAPBasePropertySupport.class
+
+Name: netscape/ldap/beans/LDAPGetEntriesBeanInfo.class
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/DisplayString.java
@@ -0,0 +1,87 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import java.awt.*;
+import java.awt.event.*;
+import java.beans.*;
+import java.io.Serializable;
+
+public class DisplayString extends TextArea implements Serializable {
+
+    public DisplayString() {
+        super();
+        setEditable(false);
+    }
+
+    public void reportChange(PropertyChangeEvent evt) {
+        Object obj = (Object)evt.getNewValue();
+        if (obj == null) {
+            append("null\n");
+            return;
+        }
+
+        String[] values = null;
+        if (obj instanceof String) {
+            values = new String[1];
+            values[0] = (String)obj;
+        }
+        else
+            values = (String[])obj;
+
+        int width = getSize().width - 10;
+        Font f = getFont();
+        for (int i=0; i<values.length; i++) {
+            String text = values[i];
+            if (f != null) {
+                // Trim the text to fit.
+                FontMetrics fm = getFontMetrics(f);
+                while (fm.stringWidth(text) > width) {
+                    text = text.substring(0, text.length()-1);
+                }
+            }
+            append(text+'\n');
+        }
+    }
+
+    public void clear (ActionEvent e) {
+        setText("");
+        invalidate();
+        repaint();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/beans/LDAPGetPropertyBeanInfo.java
@@ -0,0 +1,158 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.beans;
+
+import java.beans.SimpleBeanInfo;
+import java.beans.BeanDescriptor;
+import java.beans.EventSetDescriptor;
+import java.beans.MethodDescriptor;
+import java.beans.PropertyDescriptor;
+import java.beans.ParameterDescriptor;
+import java.beans.BeanInfo;
+
+
+/**
+ * BeanInfo for LDAPGetProperty
+ */
+
+public class LDAPGetPropertyBeanInfo extends SimpleBeanInfo {
+
+    public LDAPGetPropertyBeanInfo() throws Exception {
+
+    beanClass = Class.forName( "netscape.ldap.beans.LDAPGetProperty" );
+
+        try {
+            PropertyDescriptor host =
+                new PropertyDescriptor("host", beanClass);
+            PropertyDescriptor port =
+                new PropertyDescriptor("port", beanClass);
+            PropertyDescriptor authDN =
+                new PropertyDescriptor("authDN", beanClass);
+            PropertyDescriptor authPassword =
+                new PropertyDescriptor("authPassword", beanClass);
+            PropertyDescriptor base =
+                new PropertyDescriptor("base", beanClass);
+            PropertyDescriptor filter =
+                new PropertyDescriptor("filter", beanClass);
+            PropertyDescriptor scope =
+                new PropertyDescriptor("scope", beanClass);
+            PropertyDescriptor attribute =
+                new PropertyDescriptor("attribute", beanClass);
+            PropertyDescriptor debug =
+                new PropertyDescriptor("debug", beanClass);
+
+            PropertyDescriptor rv[] =
+                {host, port, authDN, authPassword, base, scope, attribute,
+                 filter, debug};
+            _propertyDescriptor = new PropertyDescriptor[rv.length];
+            for( int i = 0; i < rv.length; i++ )
+                _propertyDescriptor[i] = rv[i];
+        } catch (Exception e) {
+            throw new Error(e.toString());
+        }
+
+        // Publish events --------------------------------------------------
+        try {
+            _eventSetDescriptor = new EventSetDescriptor[1];
+
+            _eventSetDescriptor[0] = new EventSetDescriptor(beanClass,
+                    "propertyChange",
+                    Class.forName("java.beans.PropertyChangeListener"),
+                    "propertyChange");
+
+
+        } catch (Exception e) {
+            throw new Error(e.toString());
+        }
+
+        // Publish descriptor ---------------------------------------------
+        try {
+            _beanDescriptor = new BeanDescriptor(beanClass);
+            _beanDescriptor.setDisplayName( "LDAP property retrieval" );
+            _beanDescriptor.setShortDescription(
+                "LDAP property retrieval -"
+                + " provided a host, port, base, search filter,"
+                + " and optionally a username and password,"
+                + " return an array of string values both as a"
+                + " function return and as a Property change event." );
+        } catch (Exception e) {
+        }
+    }
+
+    /**
+     * @return the public properties
+     */
+    public PropertyDescriptor[] getPropertyDescriptors() {
+        return _propertyDescriptor;
+    }
+
+    /**
+     * @return the public methods
+     */
+    public MethodDescriptor[] getMethodDescriptors() {
+        return _methodDescriptor;
+    }
+
+    public EventSetDescriptor[] getEventSetDescriptors() {
+        return _eventSetDescriptor;
+    }
+
+    public BeanInfo[] getAdditionalBeanInfo() {
+        return null;
+    }
+
+    public int getDefaultEventIndex() {
+        return -1;
+    }
+
+    public int getDefaultPropertyIndex() {
+        return -1;
+    }
+
+    public BeanDescriptor getBeanDescriptor() {
+        return _beanDescriptor;
+    }
+
+    private static Class beanClass;
+    private BeanDescriptor _beanDescriptor;
+    private EventSetDescriptor[] _eventSetDescriptor;
+    private MethodDescriptor[]   _methodDescriptor;
+    private PropertyDescriptor[] _propertyDescriptor;
+}
+
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDAPFilterList.java
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+
+/**
+ * The list of LDAPFilter objects returned from a LDAPFilterDescriptor
+ * Object.  Note that this is an enumeration, so if multiple iterations
+ * are needed, save the results.
+ *
+ * @see LDAPFilterDescriptor
+ * @see LDAPFilter
+ * @version 1.0
+ */
+
+public class LDAPFilterList implements Enumeration {
+    private Vector m_vFilterList;
+    private static int DEFAULT_LIST_SIZE = 2;
+
+    /**
+     * Constructs an LDAPFilterList object.  This methos shouldn't need to
+     * be called by the developer directly.  Construction of the
+     * LDAPFilterList object should take place when the Prepare function
+     * of LDAPFilterDescriptor is called.
+     *
+     */
+    public LDAPFilterList () {
+        m_vFilterList = new Vector ( DEFAULT_LIST_SIZE );
+    }
+
+
+    /**
+     *  Add an LDAPFilter to the private vector.  Since the filter we're
+     *  being passed has already been cloned from the master
+     *  LDAPFilterDescriptor set, all we have to do is add it to the list.
+     */
+    void add ( LDAPFilter filter ) {
+        m_vFilterList.addElement ( filter );
+    }
+
+    /**
+     * Returns true if there are any LDAPFilter objects to returned.
+     */
+    public boolean hasMoreElements() {
+        return ( ! m_vFilterList.isEmpty() );
+    }
+
+    /**
+     * Returns the next LDAPFilter as an Object.  Note: the preferred way
+     * to return the next LDAPFilter is to call next()
+     *
+     * @see LDAPFilterList#next()
+     * @return The next LDAPFilter object (as an instance of Object)
+     */
+    public Object nextElement() {
+        Object o = m_vFilterList.firstElement();
+        m_vFilterList.removeElementAt ( 0 );
+        return o;
+    }
+
+    /**
+     * Returns the next LDAPFilter
+     *
+     * @return The next LDAPFilter
+     */
+    public LDAPFilter next() {
+        Object o = m_vFilterList.firstElement();
+        m_vFilterList.removeElementAt ( 0 );
+        return (LDAPFilter)o;
+    }
+
+    /**
+     * Return the number of filters in the filter list.
+     * Note that this number decreases every time next() or nextElement() is
+     * called because the elements are removed as they're returned.
+     */
+    public int numFilters (){
+        return m_vFilterList.size();
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/DSMLWriter.java
@@ -0,0 +1,282 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+import netscape.ldap.*;
+import java.io.*;
+
+/**
+ * Class for outputting LDAP entries to a stream as DSML.
+ *
+ * @version 1.0
+ */
+public class DSMLWriter extends LDAPWriter {
+
+//    static final long serialVersionUID = -2710382547996750924L;
+
+    /**
+     * Constructs a <CODE>DSMLWriter</CODE> object to output entries
+     * to a stream as DSML.
+     *
+     * @param pw output stream
+     */
+    public DSMLWriter( PrintWriter pw ) {
+        super( pw );
+    }
+
+    /**
+     * Prints the schema from an entry containing subschema
+     *
+     * entry entry containing schema definitions
+     */
+    public void printSchema( LDAPEntry entry ) {
+        LDAPSchema schema = new LDAPSchema( entry );
+        printString( "  <dsml:directory-schema>" );
+        printObjectClassSchema( schema );
+        printAttributeSchema( schema );
+        printString( "  </dsml:directory-schema>" );
+    }
+
+
+    /**
+     * Prints the object class schema from a schema object
+     *
+     * schema schema elements
+     */
+    protected void printObjectClassSchema( LDAPSchema schema ) {
+        Enumeration en = schema.getObjectClasses();
+        while( en.hasMoreElements() ) {
+            LDAPObjectClassSchema s = (LDAPObjectClassSchema)en.nextElement();
+            printString( "    <dsml:class" );
+            printString( "      id=\"" + s.getName() + "\"" );
+            printString( "      oid=\"" + s.getID() + "\"" );
+            String[] superiors = s.getSuperiors();
+            if ( superiors != null ) {
+                for( int i = 0; i < superiors.length; i++ ) {
+                    printString( "      superior=\"#" + superiors[i] + "\"" );
+                }
+            }
+            String classType = "structural";
+            switch( s.getType() ) {
+            case LDAPObjectClassSchema.ABSTRACT: classType = "abstract";
+                break;
+            case LDAPObjectClassSchema.AUXILIARY: classType = "auxiliary";
+                break;
+            }
+            printString( "      type=\"" + classType + "\">" );
+            if ( s.isObsolete() ) {
+                printString( "      obsolete=true" );
+            }
+            printString( "      <dsml:name>" + s.getName() + "</dsml:name>" );
+            printString( "      <dsml:description>" + s.getDescription() +
+                         "</dsml:description>" );
+            Enumeration attrs = s.getRequiredAttributes();
+            while( attrs.hasMoreElements() ) {
+                printString( "      <dsml:attribute ref=\"#" +
+                             (String)attrs.nextElement() +
+                             "\" required=\"true\"/>" );
+            }
+            attrs = s.getOptionalAttributes();
+            while( attrs.hasMoreElements() ) {
+                printString( "      <dsml:attribute ref=\"#" +
+                             (String)attrs.nextElement() +
+                             "\" required=\"false\"/>" );
+            }
+            printString( "    </dsml:class>" );
+        }
+    }
+
+
+    /**
+     * Prints the attribute schema from a schema object
+     *
+     * schema schema elements
+     */
+    protected void printAttributeSchema( LDAPSchema schema ) {
+        Enumeration en = schema.getAttributes();
+        while( en.hasMoreElements() ) {
+            LDAPAttributeSchema s = (LDAPAttributeSchema)en.nextElement();
+            printString( "    <dsml:attribute-type" );
+            printString( "      id=\"" + s.getName() + "\"" );
+            printString( "      oid=\"" + s.getID() + "\"" );
+            String superior = s.getSuperior();
+            if ( superior != null ) {
+                printString( "      superior=\"#" + superior + "\"" );
+            }
+            if ( s.isSingleValued() ) {
+                printString( "      single-value=true" );
+            }
+            if ( s.isObsolete() ) {
+                printString( "      obsolete=true" );
+            }
+            if ( s.getQualifier( s.NO_USER_MODIFICATION ) != null ) {
+                printString( "      user-modification=false" );
+            }
+            String[] vals = s.getQualifier( s.EQUALITY );
+            if ( (vals != null) && (vals.length > 0) ) {
+                printString( "      equality=" + vals[0] );
+            }
+            vals = s.getQualifier( s.ORDERING );
+            if ( (vals != null) && (vals.length > 0) ) {
+                printString( "      ordering=" + vals[0] );
+            }
+            vals = s.getQualifier( s.SUBSTR );
+            if ( (vals != null) && (vals.length > 0) ) {
+                printString( "      substring=" + vals[0] );
+            }
+            printString( "      <dsml:name>" + s.getName() + "</dsml:name>" );
+            printString( "      <dsml:description>" + s.getDescription() +
+                         "</dsml:description>" );
+            printString( "      <dsml:syntax>" + s.getSyntaxString() +
+                         "</dsml:syntax>" );
+            printString( "    </dsml:attribute-type>" );
+        }
+    }
+
+
+    /**
+     * Print an attribute of an entry
+     *
+     * @param attr the attribute to format to the output stream
+     */
+    protected void printAttribute( LDAPAttribute attr ) {
+		String attrName = attr.getName();
+
+		// Object classes are treated differently in DSML. Also, they
+		// are always String-valued
+		if ( attrName.equalsIgnoreCase( "objectclass" ) ) {
+			Enumeration enumVals = attr.getStringValues();
+			if ( enumVals != null ) {
+				while ( enumVals.hasMoreElements() ) {
+					String s = (String)enumVals.nextElement();
+					printString( "    <dsml:objectclass>" + s +
+								 "</dsml:objectclass>" );
+				}
+			}
+			return;
+		}
+
+		printString( "    <dsml:attr name=\"" + attrName + "\">" );
+
+		/* Loop on values for this attribute */
+		Enumeration enumVals = attr.getByteValues();
+
+		if ( enumVals != null ) {
+			while ( enumVals.hasMoreElements() ) {
+				byte[] b = (byte[])enumVals.nextElement();
+				String s;
+				if ( LDIF.isPrintable(b) ) {
+					try {
+						s = new String( b, "UTF8" );
+					} catch ( UnsupportedEncodingException e ) {
+						s = "";
+					}
+					printEscapedValue( "      <dsml:value>", s,
+                                       "</dsml:value>" );
+				} else {
+					s = getPrintableValue( b );
+					if ( s.length() > 0 ) {
+						printString( "      " +
+									 "<dsml:value encoding=\"base64\">" );
+						printString( "       " + s );
+						printString( "      </dsml:value>" );
+					}
+				}
+			}
+		}
+		printString( "    </dsml:attr>" );
+	}
+
+    /**
+     * Print prologue to entry
+     *
+     * @param dn the DN of the entry
+     */
+    protected void printEntryStart( String dn ) {
+		if ( dn == null ) {
+			dn = "";
+		}
+		printString( "  <dsml:entry dn=\"" + dn + "\">" );
+	}
+
+    /**
+     * Print epilogue to entry
+     *
+     * @param dn the DN of the entry
+     */
+    protected void printEntryEnd( String dn ) {
+		printString( "  </dsml:entry>" );
+    }
+
+    /**
+     * Print the element start, the value with escaping of special
+     * characters, and the element end
+     *
+     * @param prolog element start
+     * @param value value to be escaped
+     * @param epilog element end
+     */
+    protected void printEscapedValue( String prolog, String value,
+                                      String epilog ) {
+		m_pw.print( prolog );
+	    int l = value.length();
+        char[] text = new char[l];
+        value.getChars( 0, l, text, 0 );
+	    for ( int i = 0; i < l; i++ ) {
+	        char c = text[i];
+	        switch (c) {
+	        case '<' : 
+	            m_pw.print( "&lt;" );
+	            break;
+	        case '&' : 
+	            m_pw.print( "&amp;" );
+	            break;
+	        default : 
+	            m_pw.print( c );
+	        }
+	    }
+		m_pw.print( epilog);
+		m_pw.print( '\n' );
+    }
+
+    protected void printString( String value ) {
+		m_pw.print( value );
+		m_pw.print( '\n' );
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIFBaseContent.java
@@ -0,0 +1,109 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import netscape.ldap.LDAPControl;
+
+/**
+ *
+ * An object of this class represents the content of an LDIF record.
+ * This class implements the <CODE>LDIFContent</CODE> interface, but
+ * it is abstract and must be extended for the various record types.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.LDIFRecord#getContent
+ */
+public abstract class LDIFBaseContent
+                      implements LDIFContent, java.io.Serializable {
+
+    static final long serialVersionUID = -8542611537447295949L;
+
+    /**
+     * Internal variables
+     */
+    private LDAPControl[] m_controls = null;
+
+    /**
+     * Blank constructor for deserialization
+     */
+    public LDIFBaseContent() {
+    }
+
+    /**
+     * Retrieves the list of controls specified in the content
+     * of the LDIF record, if any
+     * @return an array of <CODE>LDAPControl</CODE> objects that
+     * represent any controls specified in the the LDIF record,
+     * or <CODE>null</CODE> if none were specified.
+     */
+    public LDAPControl[] getControls() {
+        return m_controls;
+    }
+
+    /**
+     * Sets the list of controls
+     * @param controls an array of <CODE>LDAPControl</CODE> objects
+     * or <CODE>null</CODE> if none are to be specified
+     */
+    public void setControls( LDAPControl[] controls ) {
+        m_controls = controls;
+    }
+
+    /**
+     * Get the OIDs of all controls, if any, as a string
+     *
+     * @return the OIDs of all controls, if any, as a string,
+     * or an empty string if there are no controls.
+     */
+    protected String getControlString() {
+        String s = "";
+        if ( getControls() != null ) {
+            s += ' ';
+            LDAPControl[] controls = getControls();
+            int len = controls.length;
+            for( int i = 0; i < len; i++ ) {
+                s += controls[i].toString();
+                if ( i < (len-1) ) {
+                    s += ' ';
+                }
+            }
+        }
+        return s;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/MimeBase64Encoder.java
@@ -0,0 +1,149 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+
+/** Implements a plaintext -> Base64 encoder.
+ */
+public final class MimeBase64Encoder extends MimeEncoder {
+
+    static final long serialVersionUID = 8781620079813078315L;
+    private int buf = 0;                     // a 24-bit quantity
+    private int buf_bytes = 0;               // how many octets are set in it
+    private byte line[] = new byte[74];      // output buffer
+    private int line_length = 0;             // output buffer fill pointer
+
+    static private final byte crlf[] = "\r\n".getBytes();
+
+    static private final char map[] = {
+      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',     // 0-7
+      'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',     // 8-15
+      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',     // 16-23
+      'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',     // 24-31
+      'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',     // 32-39
+      'o', 'p', 'q', 'r', 's', 't', 'u', 'v',     // 40-47
+      'w', 'x', 'y', 'z', '0', '1', '2', '3',     // 48-55
+      '4', '5', '6', '7', '8', '9', '+', '/',     // 56-63
+    };
+
+    private final void encode_token() {
+        int i = line_length;
+        line[i]   = (byte)map[0x3F & (buf >> 18)];   // sextet 1 (octet 1)
+        line[i+1] = (byte)map[0x3F & (buf >> 12)];   // sextet 2 (octet 1 and 2)
+        line[i+2] = (byte)map[0x3F & (buf >> 6)];    // sextet 3 (octet 2 and 3)
+        line[i+3] = (byte)map[0x3F & buf];           // sextet 4 (octet 3)
+        line_length += 4;
+        buf = 0;
+        buf_bytes = 0;
+    }
+
+    private final void encode_partial_token() {
+        int i = line_length;
+        line[i]   = (byte)map[0x3F & (buf >> 18)];   // sextet 1 (octet 1)
+        line[i+1] = (byte)map[0x3F & (buf >> 12)];   // sextet 2 (octet 1 and 2)
+
+        if (buf_bytes == 1)
+            line[i+2] = (byte)'=';
+        else
+            line[i+2] = (byte)map[0x3F & (buf >> 6)];  // sextet 3 (octet 2 and 3)
+
+        if (buf_bytes <= 2)
+            line[i+3] = (byte)'=';
+        else
+            line[i+3] = (byte)map[0x3F & buf];         // sextet 4 (octet 3)
+        line_length += 4;
+        buf = 0;
+        buf_bytes = 0;
+    }
+
+    private final void flush_line(ByteBuf out) {
+        out.append(line, 0, line_length);
+        line_length = 0;
+    }
+
+    /** Given a sequence of input bytes, produces a sequence of output bytes
+        using the base64 encoding.  If there are bytes in `out' already, the
+        new bytes are appended, so the caller should do `out.setLength(0)'
+        first if that's desired.
+     */
+    public final void translate(ByteBuf in, ByteBuf out) {
+
+        byte inb[] = in.toBytes();
+        int in_length = in.length();
+
+        for (int i = 0; i < in_length; i++) {
+            if (buf_bytes == 0)
+                buf = (buf & 0x00FFFF) | (inb[i] << 16);
+            else if (buf_bytes == 1)
+                buf = (buf & 0xFF00FF) | ((inb[i] << 8) & 0x00FFFF);
+            else
+                buf = (buf & 0xFFFF00) | (inb[i] & 0x0000FF);
+
+            if ((++buf_bytes) == 3) {
+                encode_token();
+                if (line_length >= 72) {
+                    flush_line(out);
+                }
+            }
+
+            if (i == (in_length-1)) {
+                if ((buf_bytes > 0) && (buf_bytes < 3))
+                    encode_partial_token();
+                if (line_length > 0)
+                    flush_line(out);
+            }
+        }
+
+        for (int i=0; i<line.length; i++)
+            line[i] = 0;
+    }
+
+    /** Tell the base64 encoder that no more input data will be forthcoming.
+        This may result in output, as a result of flushing the internal buffer.
+        This object must not be used again after calling eof().  If there are
+        bytes in `out' already, the new bytes are appended, so the caller should
+        do `out.setLength(0)' first if that's desired.
+     */
+    public final void eof(ByteBuf out) {
+        if (buf_bytes != 0)
+            encode_partial_token();
+        flush_line(out);
+        for (int i=0; i<line.length; i++)
+            line[i] = 0;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIFAttributeContent.java
@@ -0,0 +1,122 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.Vector;
+import netscape.ldap.LDAPAttribute;
+
+/**
+ * An object of this class represents the content of an LDIF record that
+ * specifies an entry and its attributes.  This class implements the
+ * <CODE>LDIFContent</CODE> interface.
+ * <P>
+ *
+ * To get this object from an <CODE>LDIFRecord</CODE> object,
+ * use the <CODE>getContent</CODE> method and cast the return value as
+ * <CODE>LDIFAttributeContent</CODE>.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.LDIFRecord#getContent
+ */
+public class LDIFAttributeContent extends LDIFBaseContent {
+
+    /**
+     * Internal variables
+     */
+    private Vector m_attrs = new Vector();
+    static final long serialVersionUID = -2912294697848028220L;
+
+    /**
+     * Constructs an empty <CODE>LDIFAttributeContent</CODE> object with
+     * no attributes specified.  You can use the <CODE>addElement</CODE>
+     * method to add attributes to this object.
+     * @see netscape.ldap.util.LDIFAttributeContent#addElement
+     */
+    public LDIFAttributeContent() {
+    }
+
+    /**
+     * Returns the content type. You can use this with the
+     * <CODE>getContent</CODE> method of the <CODE>LDIFRecord</CODE>
+     * object to determine the type of content specified in the record.
+     * @return the content type (which is
+     * <CODE>LDIFContent.ATTRIBUTE_CONTENT</CODE>).
+     * @see netscape.ldap.util.LDIFRecord#getContent
+     */
+    public int getType() {
+        return ATTRIBUTE_CONTENT;
+    }
+
+    /**
+     * Adds an attribute to the content of the LDIF record.
+     * @param attr the attribute to add
+     */
+    public void addElement(LDAPAttribute attr) {
+        m_attrs.addElement(attr);
+    }
+
+    /**
+     * Retrieves the list of the attributes specified in the content
+     * of the LDIF record.
+     * @return an array of <CODE>LDAPAttribute</CODE> objects that
+     * represent the attributes specified in the content of the LDIF record.
+     */
+    public LDAPAttribute[] getAttributes() {
+        LDAPAttribute attrs[] = new LDAPAttribute[m_attrs.size()];
+        for (int i = 0; i < m_attrs.size(); i++) {
+            attrs[i] = (LDAPAttribute)m_attrs.elementAt(i);
+        }
+        return attrs;
+    }
+
+    /**
+     * Returns the string representation of the content of the LDIF record.
+     * @return the string representation of the content of the LDIF record.
+     */
+    public String toString() {
+        String s = "";
+        for (int i = 0; i < m_attrs.size(); i++) {
+            s = s + ((LDAPAttribute)m_attrs.elementAt(i)).toString();
+        }
+        if ( getControls() != null ) {
+            s += getControlString();
+        }
+        return "LDIFAttributeContent {" + s + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIFModDNContent.java
@@ -0,0 +1,172 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+/**
+ * An object of this class represents the content of an LDIF record that
+ * specifies changes to an RDN or the DN of an entry.  This class
+ * implements the <CODE>LDIFContent</CODE> interface.
+ * <P>
+ *
+ * To get this object from an <CODE>LDIFRecord</CODE> object,
+ * use the <CODE>getContent</CODE> method and cast the return value as
+ * <CODE>LDIFModDNContent</CODE>.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.LDIFRecord#getContent
+ */
+public class LDIFModDNContent extends LDIFBaseContent {
+    /**
+     * Internal variables
+     */
+    private String m_newParent = null;
+    private String m_rdn = null;
+    private boolean m_deleteOldRDN = false;
+    static final long serialVersionUID = 1352504898614557791L;
+
+    /**
+     * Constructs an empty <CODE>LDIFModDNContent</CODE> object.
+     * To specify the modifications to be made to the entry, use
+     * the <CODE>setRDN</CODE>, <CODE>setNewParent</CODE>,
+     * and <CODE>setDeleteOldRDN</CODE> methods.
+     * @see netscape.ldap.util.LDIFModDNContent#setRDN
+     * @see netscape.ldap.util.LDIFModDNContent#setNewParent
+     * @see netscape.ldap.util.LDIFModDNContent#setDeleteOldRDN
+     */
+    public LDIFModDNContent() {
+    }
+
+    /**
+     * Returns the content type. You can use this with the
+     * <CODE>getContent</CODE> method of the <CODE>LDIFRecord</CODE>
+     * object to determine the type of content specified in the record.
+     * @return the content type (which is
+     * <CODE>LDIFContent.MODDN_CONTENT</CODE>).
+     * @see netscape.ldap.util.LDIFRecord#getContent
+     */
+    public int getType() {
+        return MODDN_CONTENT;
+    }
+
+    /**
+     * Sets the new RDN that should be assigned to the entry.
+     * @param rdn the new RDN
+     * @see netscape.ldap.util.LDIFModDNContent#getRDN
+     */
+    public void setRDN(String rdn) {
+        m_rdn = rdn;
+    }
+
+    /**
+     * Returns the new RDN specified in the content of the LDIF record.
+     * @return the new RDN.
+     * @see netscape.ldap.util.LDIFModDNContent#setRDN
+     */
+    public String getRDN() {
+        return m_rdn;
+    }
+
+    /**
+     * Sets the new parent DN that should be assigned to the entry.
+     * @param parent the new parent DN for the entry
+     * @see netscape.ldap.util.LDIFModDNContent#getNewParent
+     */
+    public void setNewParent(String parent) {
+        m_newParent = parent;
+    }
+
+    /**
+     * Returns the entry's new parent DN, if specified in the content
+     * of the LDIF record.
+     * @return the new parent of the entry.
+     * @see netscape.ldap.util.LDIFModDNContent#setNewParent
+     */
+    public String getNewParent() {
+        return m_newParent;
+    }
+
+    /**
+     * Sets whether or not the old RDN should be removed as an
+     * attribute in the entry.
+     * @param bool if <CODE>true</CODE>, remove the attribute representing
+     * the RDN.  If <CODE>false</CODE>, leave the attribute in the entry.
+     * @see netscape.ldap.util.LDIFModDNContent#getDeleteOldRDN
+     */
+    public void setDeleteOldRDN(boolean bool) {
+        m_deleteOldRDN = bool;
+    }
+
+    /**
+     * Determines if the content of the LDIF record specifies that
+     * the old RDN should be removed as an attribute in the entry.
+     * @return <CODE>true</CODE> if the change specifies that the
+     * the attribute representing the RDN should be removed,
+     * <CODE>false</CODE> if the change specifies that the attribute
+     * should be left in the entry.
+     * @see netscape.ldap.util.LDIFModDNContent#setDeleteOldRDN
+     */
+    public boolean getDeleteOldRDN() {
+        return m_deleteOldRDN;
+    }
+
+    /**
+     * Returns string representation of the content of the LDIF record.
+     * @return the string representation of the content of the LDIF record.
+     */
+    public String toString() {
+        String s = "";
+        if (m_newParent == null)
+            s = s + "new parent() ";
+        else
+            s = s + "new parent( "+m_newParent+" ), ";
+        if (m_deleteOldRDN)
+            s = s + "deleteOldRDN( true ), ";
+        else
+            s = s + "deleteOldRDN( false ), ";
+        if (m_rdn == null)
+            s = s + "new rdn()";
+        else
+            s = s + "new rdn( "+m_rdn+" )";
+
+        if ( getControls() != null ) {
+            s += getControlString();
+        }
+        return "LDIFModDNContent {" + s + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIFDeleteContent.java
@@ -0,0 +1,90 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+/**
+ * An object of this class represents the content of an LDIF record that
+ * specifies the deletion of an entry.  This class implements the
+ * <CODE>LDIFContent</CODE> interface.
+ * <P>
+ *
+ * To get this object from an <CODE>LDIFRecord</CODE> object,
+ * use the <CODE>getContent</CODE> method and cast the return value as
+ * <CODE>LDIFDeleteContent</CODE>.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.LDIFRecord#getContent
+ */
+public class LDIFDeleteContent extends LDIFBaseContent {
+
+    static final long serialVersionUID = -6581979396116035503L;
+
+    /**
+     * Constructs an <CODE>LDIFDeleteContent</CODE> object
+     * to specify that an entry should be deleted.  (The DN
+     * identifying the entry is part of the <CODE>LDIFRecord</CODE>
+     * object.
+     */
+    public LDIFDeleteContent() {
+    }
+
+    /**
+     * Returns the content type. You can use this with the
+     * <CODE>getContent</CODE> method of the <CODE>LDIFRecord</CODE>
+     * object to determine the type of content specified in the record.
+     * @return the content type (which is
+     * <CODE>LDIFContent.DELETE_CONTENT</CODE>).
+     * @see netscape.ldap.util.LDIFRecord#getContent
+     */
+    public int getType() {
+        return DELETE_CONTENT;
+    }
+
+    /**
+     * Returns the string representation of the content of the LDIF record.
+     * @return the string representation of the content of the LDIF record.
+     */
+    public String toString() {
+        String s = "";
+        if ( getControls() != null ) {
+            s += getControlString();
+        }
+        return "LDIFDeleteContent {" + s + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDAPWriter.java
@@ -0,0 +1,130 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+import netscape.ldap.*;
+import java.io.*;
+
+/**
+ * Abstract class for outputting LDAP entries to a stream.
+ *
+ * @version 1.0
+ */
+public abstract class LDAPWriter implements Serializable {
+
+//    static final long serialVersionUID = -2710382547996750924L;
+    protected PrintWriter m_pw;
+    private static MimeBase64Encoder m_encoder = new MimeBase64Encoder();
+
+    /**
+     * Constructs an <CODE>LDAPWriter</CODE> object to output entries
+     * to a stream.
+     *
+     * @param pw output stream
+     */
+    public LDAPWriter( PrintWriter pw ) {
+        m_pw = pw;
+    }
+
+    /**
+     * The main method of LDAPWriter. It calls printEntryIntro,
+     * printAttribute, and printEntryEnd of derived classes.
+     *
+     * @param entry an LDAPEntry to be formatted to the output
+     * stream
+     */
+	public void printEntry( LDAPEntry entry ) throws IOException {
+        printEntryStart( entry.getDN() );
+		/* Get the attributes of the entry */
+		LDAPAttributeSet attrs = entry.getAttributeSet();
+		Enumeration enumAttrs = attrs.getAttributes();
+		/* Loop on attributes */
+		while ( enumAttrs.hasMoreElements() ) {
+			LDAPAttribute anAttr =
+				(LDAPAttribute)enumAttrs.nextElement();
+            printAttribute( anAttr );
+		}
+        printEntryEnd( entry.getDN() );
+    }
+
+    /**
+     * Default schema writer - assumes an ordinary entry
+     *
+     * @param entry an LDAPEntry containing schema to be formatted
+     * to the output stream
+     */
+	public void printSchema( LDAPEntry entry ) throws IOException {
+        printEntry( entry );
+    }
+
+    /**
+     * Print an attribute of an entry
+     *
+     * @param attr the attribute to format to the output stream
+     */
+    protected abstract void printAttribute( LDAPAttribute attr );
+
+    /**
+     * Print prologue to entry
+     *
+     * @param dn the DN of the entry
+     */
+    protected abstract void printEntryStart( String dn );
+
+    /**
+     * Print epilogue to entry
+     *
+     * @param dn the DN of the entry
+     */
+    protected abstract void printEntryEnd( String dn );
+
+	protected String getPrintableValue( byte[] b ) {
+		String s = "";
+		ByteBuf inBuf = new ByteBuf( b, 0, b.length );
+		ByteBuf encodedBuf = new ByteBuf();
+		// Translate to base 64 
+		m_encoder.translate( inBuf, encodedBuf );
+		int nBytes = encodedBuf.length();
+		if ( nBytes > 0 ) {
+			s = new String(encodedBuf.toBytes(),
+						   0, nBytes);
+		}
+		return s;
+	}
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIFWriter.java
@@ -0,0 +1,211 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+import netscape.ldap.*;
+import java.io.*;
+
+/**
+ * Class for outputting LDAP entries to a stream as LDIF.
+ *
+ * @version 1.0
+ */
+public class LDIFWriter extends LDAPWriter {
+
+//    static final long serialVersionUID = -2710382547996750924L;
+	private String m_sep;
+	private boolean m_foldLines;
+	private boolean m_attrsOnly;
+	private boolean m_toFiles;
+	private static final String DEFAULT_SEPARATOR = ":";
+	private static final int MAX_LINE = 77;
+
+
+    /**
+     * Constructs an <CODE>LDIFWriter</CODE> object to output entries
+     * to a stream as LDIF.
+     *
+     * @param pw output stream
+     */
+    public LDIFWriter( PrintWriter pw ) {
+        this( pw, false, DEFAULT_SEPARATOR, true, false );
+    }
+
+    /**
+     * Constructs an <CODE>LDIFWriter</CODE> object to output entries
+     * to a stream as LDIF.
+     *
+     * @param pw output stream
+	 * @param attrsOnly <code>true</code> if only attribute names, not
+	 * values, are to be printed
+	 * @param separator String to use between attribute names and values;
+	 * the default is ":"
+	 * @param foldLines <code>true</code> to fold lines at 77 characters,
+	 * <code>false</code> to not fold them; the default is <code>true</code>.
+	 * @param toFiles <code>true</code> to write each attribute value to a
+	 * file in the temp folder, <code>false</code> to write them to the
+	 * output stream in printable format; the default is <code>false</code>.
+     */
+    public LDIFWriter( PrintWriter pw, boolean attrsOnly,
+					   String separator, boolean foldLines,
+					   boolean toFiles ) {
+		super( pw );
+		m_attrsOnly = attrsOnly;
+		m_sep = separator;
+		m_foldLines = foldLines;
+		m_toFiles = toFiles;
+    }
+
+    /**
+     * Print an attribute of an entry
+     *
+     * @param attr the attribute to format to the output stream
+     */
+    protected void printAttribute( LDAPAttribute attr ) {
+		String attrName = attr.getName();
+
+		if ( m_attrsOnly ) {
+			printString( attrName + m_sep );
+			return;
+		}
+
+		/* Loop on values for this attribute */
+		Enumeration enumVals = attr.getByteValues();
+
+		if ( enumVals != null ) {
+			while (enumVals.hasMoreElements()) {
+				if ( m_toFiles ) {
+					try {
+						FileOutputStream f = getTempFile( attrName );
+						f.write( (byte[])enumVals.nextElement() );
+					} catch ( Exception e ) {
+						System.err.println( "Error writing values " +
+								"of " + attrName + ", " +
+								e.toString() );
+						System.exit(1);
+					}
+				} else {
+					byte[] b = (byte[])enumVals.nextElement();
+					String s;
+					if ( LDIF.isPrintable(b) ) {
+						try {
+							s = new String( b, "UTF8" );
+						} catch ( UnsupportedEncodingException e ) {
+							s = "";
+						}
+						printString( attrName + m_sep + " " + s );
+					} else {
+						s = getPrintableValue( b );
+						if ( s.length() > 0 ) {
+							printString( attrName + ":: " + s );
+						} else {
+							printString( attrName + m_sep + ' ' );
+						}
+					}
+				}
+			}
+		} else {
+			printString( attrName + m_sep + ' ' );
+		}
+	}
+
+    /**
+     * Print prologue to entry
+     *
+     * @param dn the DN of the entry
+     */
+    protected void printEntryStart( String dn ) {
+		if ( dn == null ) {
+			printString( "dn" + m_sep + " ");
+		} else {
+            byte[] b = null;
+            try {
+                b = dn.getBytes( "UTF8" );
+            } catch ( UnsupportedEncodingException ex ) {
+            }
+            if ( LDIF.isPrintable(b) ) {
+                printString( "dn" + m_sep + " " + dn );
+            } else {
+                dn = getPrintableValue( b );
+                printString( "dn" + m_sep + m_sep + " " + dn );
+            }
+        }
+	}
+
+    /**
+     * Print epilogue to entry
+     *
+     * @param dn the DN of the entry
+     */
+    protected void printEntryEnd( String dn ) {
+        m_pw.println();
+    }
+
+    protected void printString( String value ) {
+        if ( m_foldLines ) {
+            LDIF.breakString( m_pw, value, MAX_LINE );
+        } else {
+            m_pw.print( value );
+            m_pw.print( '\n' );
+        }
+    }
+
+	/**
+	 * Create a unique file name in the temp folder and open an
+	 * output stream to the file
+	 *
+	 * @param name base name of file; an extension is appended which
+	 * consists of a number that makes the name unique
+	 * @return an open output stream to the file
+	 * @exception IOException if the file couldn't be opened for output
+	 */
+    protected FileOutputStream getTempFile( String name )
+               throws IOException {
+	    int num = 0;
+		File f;
+		String filename;
+		do {
+		    filename = name + '.' + num;
+		    f = new File( filename );
+			num++;
+		} while ( f.exists() );
+		printString(name + m_sep + " " + filename);
+		return new FileOutputStream( f );
+	}
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDAPIntFilterList.java
@@ -0,0 +1,125 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
+
+/**
+ *  Represents an Internal LDAPFilterList object.  This is an internal object
+ *  that  should never be instantiated directly by the developer.  We
+ *  store all filters that have the same match pattern here.
+ */
+
+public class LDAPIntFilterList {
+    private Vector m_vFilter;
+    private String m_strMatchPattern;
+        // a regexp pattern of m_strMatchPattern
+    private Pattern m_patMatch = null;
+
+    LDAPIntFilterList ( LDAPFilter filter ) throws
+            BadFilterException {
+        m_strMatchPattern = filter.getMatchPattern();
+
+        try {
+            m_patMatch = Pattern.compile( m_strMatchPattern );
+        } catch ( PatternSyntaxException e ) {
+
+            throw new BadFilterException (
+            "The Regular Expression for this filter is bad. " +
+            "Line number: " + filter.getLineNumber() );
+        }
+
+        m_vFilter = new Vector();
+        m_vFilter.addElement ( filter );
+    }
+
+    /**
+     * Add a "relative" filter to an existing filter list.  We do this
+     * becuse the ldapfilter file defines that we can have multiple
+     * filters per match pattern (and delimiter).  This method is
+     * called by the parent LDAPIntFilterSet because the file specified
+     * a "relative" filter (a filter in the ldapfilter.conf file that
+     * only has 2 or 3 tokens).
+     */
+    void AddFilter ( LDAPFilter filter ) {
+        m_vFilter.addElement ( filter );
+    }
+
+
+    /**
+     * Return the number of Filters this InternalFilterList contains.
+     */
+    // Since we're storing the filters as a vector, just return
+    // Vector.size().
+    int numFilters () {
+        return m_vFilter.size();
+    }
+
+
+    public String toString() {
+        StringBuffer strBuf = new StringBuffer ( 100 );
+        strBuf.append ( "    Match Pattern: \"" + m_strMatchPattern + "\"\n" );
+
+        for ( int i = 0; i < m_vFilter.size(); i++ ) {
+            strBuf.append ( ((LDAPFilter)m_vFilter.elementAt(i)).toString() );
+            strBuf.append ( "\n" );
+        }
+        return strBuf.toString();
+    }
+
+    /**
+     * Return the requested filter.
+     */
+    LDAPFilter getFilter ( int nFilter ) {
+        return (LDAPFilter)m_vFilter.elementAt ( nFilter );
+    }
+
+    /**
+     * Try to match the filter to the given string.  This method is called
+     * when the user types in data.  We match the expression (stored in
+     * m_strMatchPattern) to the value that the user typed in (the
+     * parameter to this method).
+     */
+    boolean MatchFilter ( String matcherValue ) {
+    	return m_patMatch.matcher(matcherValue).matches();
+    }
+}
+
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/GetOpt.java
@@ -0,0 +1,255 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+import java.util.*;
+
+/**
+ * This class is similar to the <CODE>getopt()</CODE> function in
+ * UNIX System V. You can use this class to parse command-line
+ * arguments.
+ * <P>
+ *
+ * When you create an object of this class, you specify a string
+ * containing the command-line options that you want to check for.
+ * The string should contain the letters of these options. If an
+ * option requires an argument (for example, "-h <hostname>"),
+ * you should add a colon after the letter in this string.
+ * <P>
+ *
+ * For example, in the following string, the <CODE>-h</CODE>,
+ * <CODE>-p</CODE>, <CODE>-D,</CODE>, and <CODE>-w</CODE> options
+ * all require arguments.  The <CODE>-H</CODE> option does not
+ * require any arguments.
+ * <PRE>
+ * "h:p:D:w:H"
+ * </PRE>
+ *
+ * You can use the <CODE>hasOption</CODE> method to determine if
+ * an option has been specified and the <CODE>getOptionParam</CODE>
+ * method to get the argument specified after a particular option.
+ * <P>
+ *
+ * If an option not specified in the string is passed in as an
+ * argument, the <CODE>GetOpt</CODE> object prints out an error
+ * message.  Note that the object does not throw an exception or
+ * exit the application if an invalid option is specified.
+ * <P>
+ *
+ * Note that you are still responsible for verifying that any
+ * required arguments have been specified.
+ * <P>
+ *
+ * The following example parses the command-line arguments for
+ * the hostname, port number, DN, and password to use when
+ * connecting and authenticating to an LDAP server.
+ * <PRE>
+ * import netscape.ldap.*;
+ * import netscape.ldap.controls.*;
+ * import netscape.ldap.util.*;
+ * import java.util.*;
+ *
+ * public class SearchDirectory {
+ *
+ *     public static void main( String[] args )
+ *     {
+ *
+ *         String usage = "Usage: java SearchDirectory -h <host> -p <port> "
+ *                      + "[-D <bind dn>] [-w <password>]"
+ *
+ *         int portnumber = LDAPv2.DEFAULT_PORT;
+ *
+ *         // Check for these options. -H means to print out a usage message.
+ *         GetOpt options = new GetOpt( "h:p:D:w:H", args );
+ *
+ *         // Get the arguments specified for each option.
+ *         String hostname = options.getOptionParam( 'h' );
+ *         String port = options.getOptionParam( 'p' );
+ *         String bindDN = options.getOptionParam( 'D' );
+ *         String bindPW = options.getOptionParam( 'w' );
+ *
+ *         // Check to see if the hostname (which is mandatory)
+ *         // is not specified or if the user simply wants to
+ *         // see the usage message (-H).
+ *         if ( hostname == null || options.hasOption( 'H' ) ) {
+ *             System.out.println( usage );
+ *             System.exit( 1 );
+ *         }
+ *
+ *         // If a port number was specified, convert the port value
+ *         //  to an integer.
+ *         if ( port != null ) {
+ *             try {
+ *                 portnumber = java.lang.Integer.parseInt( port );
+ *             } catch ( java.lang.Exception e ) {
+ *                 System.out.println( "Invalid port number: " + port );
+ *                 System.out.println( usage );
+ *                 System.exit( 1 );
+ *             }
+ *         }
+ *
+ *         // Create a new connection.
+ *         LDAPConnection ld = new LDAPConnection();
+ *
+ *         try {
+ *             // Connect and authenticate to server.
+ *             ld.connect( 3, hostname, portnumber, bindDN, bindPW );
+ *             ...
+ *         } catch ( LDAPException e ) {
+ *             System.out.println( "Error: " + e.toString() );
+ *         }
+ *         ...
+ *     }
+ * }
+ * </PRE>
+ *
+ * @version 1.0
+ */
+public class GetOpt implements java.io.Serializable {
+    /**
+     * Internal variables
+     */
+    private int m_pos;
+    private String optarg;
+    private String m_control;
+    private Vector m_option;
+    private Vector m_ParameterList;
+    private Hashtable m_optionHashTable;
+    private Hashtable m_optionParamHashTable;
+    static final long serialVersionUID = -2570196909939660248L;
+
+    /**
+     * Constructs a <CODE>GetOpt</CODE> object.
+     * @param strControl a string specifying the letters of
+     * all available options. If an option requires an argument
+     * (for example, "-h <hostname>"), use a colon after the
+     * letter for that option (for example, "h:p:D:w:H").
+     * @param args an array of strings representing the list
+     * of arguments to parse (for example, the
+     * array passed into Main).
+     */
+    public GetOpt(String strControl, String args[]) {
+        m_option = new Vector();
+        m_control = strControl;
+        m_optionHashTable = new Hashtable();
+        m_optionParamHashTable = new Hashtable();
+        m_ParameterList = new Vector();
+
+        for (int i=0;i<args.length ;i++ ) {
+            String sOpt = args[i];
+                if (sOpt.length()>0) {
+                    if ((sOpt.charAt(0)=='-') ||
+                        (sOpt.charAt(0)=='/')) {
+                        if (sOpt.length()>1) {
+                            int nIndex = m_control.indexOf(sOpt.charAt(1));
+                            if (nIndex == (-1)) {
+                                System.err.println("Invalid usage. No option -" +
+                                    sOpt.charAt(1));
+                            } else {
+                                char cOpt[]= new char[1];
+                                cOpt[0]= sOpt.charAt(1);
+                                String sName = new String(cOpt);
+                                m_optionHashTable.put(sName,"1");
+                                if ((m_control != null) && (m_control.length() > (nIndex+1))) {
+                                    if (m_control.charAt(nIndex+1)==':') {
+                                        i++;
+                                        if (i < args.length)
+                                            m_optionParamHashTable.put(sName,args[i]);
+                                        else
+                                            System.err.println("Missing argument for option "+
+                                                sOpt);
+                                    }
+                                }
+                            }
+                        } else {
+                        System.err.println("Invalid usage.");
+                    }
+                } else {
+                    // probably parameters
+                    m_ParameterList.addElement(args[i]);
+                }
+            }
+        }
+    }
+
+    /**
+     * Determines if an option was specified. For example,
+     * <CODE>hasOption( 'H' )</CODE> checks if the -H option
+     * was specified.
+     * <P>
+     *
+     * @param c letter of the option to check
+     * @return <code>true</code> if the option was specified.
+     */
+    public boolean hasOption(char c) {
+        boolean fReturn = false;
+        char cOption[]=new char[1];
+        cOption[0]=c;
+        String s = new String(cOption);
+        if (m_optionHashTable.get(s)=="1") {
+            fReturn = true;
+        }
+        return(fReturn);
+    }
+
+    /**
+     * Gets the argument specified with an option.
+     * For example, <CODE>getOptionParameter( 'h' )</CODE>
+     * gets the value of the argument specified with
+     * the -h option (such as "localhost" in "-h localhost").
+     * <P>
+     *
+     * @param c the letter of the option to check
+     * @return the argument specified for this option.
+     */
+    public String getOptionParam(char c) {
+        char cOption[] = new char[1];
+        cOption[0]=c;
+        String s = new String(cOption);
+        String sReturn=(String)m_optionParamHashTable.get(s);
+        return(sReturn);
+    }
+
+    /**
+     * Gets a list of any additional parameters specified
+     * (not including the arguments for any options).
+     * @return a list of the additional parameters.
+     */
+    public Vector getParameters() {
+        return(m_ParameterList);
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIFContent.java
@@ -0,0 +1,134 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import netscape.ldap.LDAPControl;
+
+/**
+ * This interface represents the content of an LDIF record.
+ * An LDIF record can specify an entry or modifications to be
+ * made to an entry.
+ * <P>
+ *
+ * The following classes implement this interface:
+ * <P>
+ *
+ * <UL>
+ * <LI><CODE>LDIFAttributeContent</CODE> (represents the content
+ * of an LDIF record that specifies an entry)
+ * <LI><CODE>LDIFAddContent</CODE> (represents the content
+ * of an LDIF record that adds a new entry)
+ * <LI><CODE>LDIFModifyContent</CODE> (represents the content
+ * of an LDIF record that modifies an entry)
+ * <LI><CODE>LDIFDeleteContent</CODE> (represents the content
+ * of an LDIF record that deletes an entry)
+ * <LI><CODE>LDIFModDNContent</CODE> (represents the content
+ * of an LDIF record that changes the RDN or DN of an entry)
+ * </UL>
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.LDIFRecord
+ * @see netscape.ldap.util.LDIFAttributeContent
+ * @see netscape.ldap.util.LDIFAddContent
+ * @see netscape.ldap.util.LDIFModifyContent
+ * @see netscape.ldap.util.LDIFDeleteContent
+ * @see netscape.ldap.util.LDIFModDNContent
+ */
+public interface LDIFContent {
+
+   /**
+    * The LDIF record specifies an entry and its attributes.
+    */
+    public final static int ATTRIBUTE_CONTENT = 0;
+
+   /**
+    * The LDIF record specifies a new entry to be added.
+    */
+    public final static int ADD_CONTENT = 1;
+
+   /**
+    * The LDIF record specifies an entry to be deleted.
+    */
+    public final static int DELETE_CONTENT = 2;
+
+   /**
+    * The LDIF record specifies modifications to an entry.
+    */
+    public final static int MODIFICATION_CONTENT = 3;
+
+   /**
+    * The LDIF record specifies changes to the DN or RDN of an entry.
+    */
+    public final static int MODDN_CONTENT = 4;
+
+    /**
+     * Determines the content type.
+     * @return the content type, identified by one of the following values:
+     * <UL>
+     * <LI>ATTRIBUTE_CONTENT (specifies an entry and its attributes)
+     * <LI>ADD_CONTENT (specifies a new entry to be added)
+     * <LI>DELETE_CONTENT (specifies an entry to be deleted)
+     * <LI>MODIFICATION_CONTENT (specifies an entry to be modified)
+     * <LI>MODDN_CONTENT (specifies a change to the RDN or DN of an entry)
+     * </UL>
+     */
+    public int getType();
+
+    /**
+     * Retrieves the list of controls specified in the content
+     * of the LDIF record, if any
+     * @return an array of <CODE>LDAPControl</CODE> objects that
+     * represent any controls specified in the the LDIF record,
+     * or <CODE>null</CODE> if none were specified.
+     */
+    public LDAPControl[] getControls();
+
+    /**
+     * Sets the list of controls
+     * @param controls an array of <CODE>LDAPControl</CODE> objects
+     * or <CODE>null</CODE> if none are to be specified
+     */
+    public void setControls( LDAPControl[] controls );
+
+    /**
+     * Returns the string representation of the content of the LDIF record.
+     * @return string representation of the content of the LDIF record.
+     */
+    public String toString();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/MimeEncoder.java
@@ -0,0 +1,65 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+/** This abstract class is the parent of those classes which implement
+    MIME encoding and decoding: base64.
+    @see netscape.ldap.util.MimeBase64Encoder
+    @see netscape.ldap.util.MimeBase64Decoder
+ */
+
+public abstract class MimeEncoder implements java.io.Serializable {
+
+    static final long serialVersionUID = 5179250095383961512L;
+
+    /** Given a sequence of input bytes, produces a sequence of output bytes.
+        Note that some (small) amount of buffering may be necessary, if the
+        input byte stream didn't fall on an appropriate boundary.  If there
+        are bytes in `out' already, the new bytes are appended, so the
+        caller should do `out.setLength(0)' first if that's desired.
+     */
+    abstract public void translate(ByteBuf in, ByteBuf out);
+
+    /** Tell the decoder that no more input data will be forthcoming.
+        This may result in output, as a result of flushing the internal
+        buffer.  This object must not be used again after calling eof().
+        If there are bytes in `out' already, the new bytes are appended,
+        so the caller should do `out.setLength(0)' first if that's desired.
+     */
+    abstract public void eof(ByteBuf out);
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIF.java
@@ -0,0 +1,808 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+import netscape.ldap.*;
+import netscape.ldap.client.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * LDAP Data Interchange Format (LDIF) is a file format used to
+ * import and export directory data from an LDAP server and to
+ * describe a set of changes to be applied to data in a directory.
+ * This format is described in the Internet draft
+ * <A HREF="ftp://ftp.ietf.org/internet-drafts/draft-good-ldap-ldif-00.txt"
+ * TARGET="_blank">The LDAP Data Interchange Format (LDIF) -
+ * Technical Specification</A>.
+ * <P>
+ *
+ * This class implements an LDIF file parser.  You can construct
+ * an object of this class to parse data in LDIF format and
+ * manipulate the data as individual <CODE>LDIFRecord</CODE> objects.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.LDIFRecord
+ */
+public class LDIF implements Serializable {
+
+    /**
+     * Internal constants
+     */
+    private final static char COMMENT = '#';
+    static final long serialVersionUID = -2710382547996750924L;
+
+    /**
+     * Constructs an <CODE>LDIF</CODE> object to parse the
+     * LDAP data read from stdin.
+     * @exception IOException An I/O error has occurred.
+     */
+    public LDIF() throws IOException {
+        DataInputStream ds = new DataInputStream(System.in);
+        BufferedReader d = new BufferedReader(new InputStreamReader(ds, "UTF8"));
+        m_reader = new LineReader(d);
+        m_source = "System.in";
+        m_decoder = new MimeBase64Decoder();
+    }
+
+    /**
+     * Constructs an <CODE>LDIF</CODE> object to parse the
+     * LDIF data read from a specified file.
+     * @param file the name of the LDIF file to parse
+     * @exception IOException An I/O error has occurred.
+     */
+    public LDIF(String file) throws IOException {
+        FileInputStream fs = new FileInputStream(file);
+        DataInputStream ds = new DataInputStream(fs);
+        BufferedReader d = new BufferedReader(new InputStreamReader(ds, "UTF8"));
+        m_reader = new LineReader(d);
+        m_source = file;
+        m_decoder = new MimeBase64Decoder();
+    }
+
+    /**
+     * Constructs an <CODE>LDIF</CODE> object to parse the
+     * LDIF data read from an input stream.
+     * @param ds The input stream providing the LDIF data
+     * @exception IOException An I/O error has occurred.
+     */
+    public LDIF(DataInputStream ds) throws IOException {
+        BufferedReader d = new BufferedReader(new InputStreamReader(ds, "UTF8"));
+        m_reader = new LineReader(d);
+        m_source = ds.toString();
+        m_decoder = new MimeBase64Decoder();
+    }
+
+    /**
+     * Returns the next record in the LDIF data. You can call this
+     * method repeatedly to iterate through all records in the LDIF data.
+     * <P>
+     *
+     * @return the next record as an <CODE>LDIFRecord</CODE>
+     * object or null if there are no more records.
+     * @exception IOException An I/O error has occurred.
+     * @see netscape.ldap.util.LDIFRecord
+     */
+    public LDIFRecord nextRecord() throws IOException {
+        if ( m_done )
+            return null;
+        else
+            return parse_ldif_record( m_reader );
+    }
+
+    /**
+     * Parses ldif content. The list of attributes is
+     * terminated by \r\n or '-'. This function is
+     * also used to parse the attributes in modifications.
+     * @param ds data input stream
+     */
+    private LDIFRecord parse_ldif_record(LineReader d)
+          throws IOException {
+        String line = null;
+        String dn = null;
+        Vector attrs = new Vector();
+        LDIFRecord rec = null;
+
+        // Skip past any blank lines
+        while( ((line = d.readLine()) != null) &&
+               (line.length() < 1) ) {
+        }
+        if (line == null) {
+            return null;
+        }
+
+        if (line.startsWith("version:")) {
+            m_version = Integer.parseInt(
+                line.substring("version:".length()).trim() );
+            if ( m_version != 1 ) {
+                throwLDIFException( "Unexpected " + line );
+            }
+            // Do the next record
+            line = d.readLine();
+            if ( (line != null) && (line.length() == 0) ) {
+                // Skip the newline
+                line = d.readLine();
+            }
+            if (line == null) {
+                return null;
+            }
+        }
+
+        if (!line.startsWith("dn:"))
+            throwLDIFException("expecting dn:");
+        dn = line.substring(3).trim();
+        if (dn.startsWith(":") && (dn.length() > 1)) {
+            String substr = dn.substring(1).trim();
+            dn = new String(getDecodedBytes(substr), "UTF8");
+        }
+
+        LDIFContent content = parse_ldif_content(d);
+        rec = new LDIFRecord(dn, content);
+        return rec;
+    }
+
+    /**
+     * Parses ldif content. The list of attributes is
+     * terminated by \r\n or '-'. This function is
+     * also used to parse the attributes in modifications.
+     * @param ds data input stream
+     */
+    private LDIFContent parse_ldif_content(LineReader d)
+          throws IOException {
+        String line = d.readLine();
+        if ((line == null) || (line.length() < 1) || (line.equals("-"))) {
+            // if this is empty line, then we're finished reading all
+            // the info for the current entry
+            if ((line != null) && (line.length() < 1)) {
+                m_currEntryDone = true;
+            }
+            return null;
+        }
+
+        if (line.startsWith("changetype:")) {
+            /* handles (changerecord) */
+            LDIFContent lc = null;
+            String changetype = line.substring(11).trim();
+            if (changetype.equals("modify")) {
+                lc = parse_mod_spec(d);
+            } else if (changetype.equals("add")) {
+                lc = parse_add_spec(d);
+            } else if (changetype.equals("delete")) {
+                lc = parse_delete_spec(d);
+            } else if (changetype.equals("moddn") ||
+                       changetype.equals("modrdn")) {
+                lc = parse_moddn_spec(d);
+            } else {
+                throwLDIFException("change type not supported");
+            }
+            return lc;
+        }
+
+        /* handles 1*(attrval-spec) */
+        Hashtable ht = new Hashtable();
+        String newtype = null;
+        Object val = null;
+        LDAPAttribute newAttr = null;
+        Vector controlVector = null;
+
+        /* Read lines until we're past the record */
+        while( true ) {
+            if (line.startsWith("control:")) {
+                if ( controlVector == null ) {
+                    controlVector = new Vector();
+                }
+                controlVector.addElement( parse_control_spec( line ) );
+            } else {
+                /* An attribute */
+                int len = line.length();
+                if ( len < 1 ) {
+                    break;
+                }
+                int idx = line.indexOf(':');
+                /* Must have a colon */
+                if (idx == -1)
+                    throwLDIFException("no ':' found");
+                /* attribute type */
+                newtype = line.substring(0,idx).toLowerCase();
+                val = "";
+                /* Could be :: for binary */
+                idx++;
+                if ( len > idx ) {
+                    if ( line.charAt(idx) == ':' ) {
+                        idx++;
+                        String substr = line.substring(idx).trim();
+                        val = getDecodedBytes(substr);
+                    } else if (line.charAt(idx) == '<') {
+                        try {
+                            URL url =
+                                new URL(line.substring(idx+1).trim());
+                            String filename = url.getFile();
+                            val = getFileContent(filename);
+                        } catch (MalformedURLException ex) {
+                            throwLDIFException(
+                                ex +
+                                ": cannot construct url "+
+                                line.substring(idx+1).trim());
+                        }
+                    } else {
+                        val = line.substring(idx).trim();
+                    }
+                }
+                /* Is there a previous value for this attribute? */
+                newAttr = (LDAPAttribute)ht.get( newtype );
+                if ( newAttr == null ) {
+                    newAttr = new LDAPAttribute( newtype );
+                }
+                if ( val instanceof String ) {
+                    newAttr.addValue( (String)val );
+                } else {
+                    newAttr.addValue( (byte[])val );
+                }
+                ht.put( newtype, newAttr );
+            }
+            line = d.readLine();
+            if (line == null || (line.length() < 1) ||
+                (line.equals("-"))) {
+                if ((line != null) && (line.length() < 1)) {
+                    m_currEntryDone = true;
+                }
+                break;
+            }
+        }
+        LDIFAttributeContent ac = new LDIFAttributeContent();
+        // Copy over the attributes to the record
+        Enumeration en = ht.elements();
+        while( en.hasMoreElements() ) {
+            ac.addElement( (LDAPAttribute)en.nextElement() );
+        }
+        ht.clear();
+        if( controlVector != null ) {
+            LDAPControl[] controls =
+                new LDAPControl[controlVector.size()];
+            controlVector.copyInto( controls );
+            ac.setControls( controls );
+            controlVector.removeAllElements();
+        }
+        return ac;
+    }
+
+    private byte[] getDecodedBytes(String line) {
+        ByteBuf inBuf = new ByteBuf(line);
+        ByteBuf decodedBuf = new ByteBuf();
+        /* Translate from base 64 */
+        m_decoder.translate( inBuf, decodedBuf );
+        return decodedBuf.toBytes();
+    }
+
+    private byte[] getFileContent(String url) throws IOException {
+        StringTokenizer tokenizer = new StringTokenizer(url, "|");
+        String filename = url;
+        int num = tokenizer.countTokens();
+        if (num == 2) {
+            String token = (String)tokenizer.nextElement();
+            int index = token.lastIndexOf("/");
+            String drive = token.substring(index+1);
+            token = (String)tokenizer.nextElement();
+            token = token.replace('/', '\\');
+            filename = drive+":"+token;
+        }
+
+        File file = new File(filename);
+        byte[] b = new byte[(int)file.length()];
+        FileInputStream fi = new FileInputStream(filename);
+        fi.read(b);
+        return b;
+    }
+
+    /**
+     * Parses add content
+     * @param ds data input stream
+     */
+    private LDIFAddContent parse_add_spec(LineReader d)
+          throws IOException {
+        LDIFAttributeContent ac = (LDIFAttributeContent)parse_ldif_content(d);
+        if (m_currEntryDone)
+          m_currEntryDone = false;
+        LDAPAttribute attrs[] = ac.getAttributes();
+        LDIFAddContent rc = new LDIFAddContent(attrs);
+        LDAPControl[] controls = ac.getControls();
+        if ( controls != null ) {
+            rc.setControls( controls );
+        }
+        return rc;
+    }
+
+    /**
+     * Parses delete content
+     * @param ds data input stream
+     */
+    private LDIFDeleteContent parse_delete_spec(LineReader d)
+          throws IOException {
+        Vector controlVector = null;
+        LDIFDeleteContent dc = new LDIFDeleteContent();
+        String line = d.readLine();
+        while( line != null && !line.equals("") ) {
+            if (line.startsWith("control:")) {
+                if ( controlVector == null ) {
+                    controlVector = new Vector();
+                }
+                controlVector.addElement( parse_control_spec( line ) );
+            } else {
+                throwLDIFException("invalid SEP" );
+            }
+            line = d.readLine();
+        } 
+        if( controlVector != null ) {
+            LDAPControl[] controls = new LDAPControl[controlVector.size()];
+            controlVector.copyInto( controls );
+            dc.setControls( controls );
+            controlVector.removeAllElements();
+        }
+
+        return dc;
+    }
+
+    /**
+     * Parses change modification.
+     * @param ds data input stream
+     */
+    private LDIFModifyContent parse_mod_spec(LineReader d)
+          throws IOException {
+
+        Vector controlVector = null;
+        String line = null;
+        line = d.readLine();
+        LDIFModifyContent mc = new LDIFModifyContent();
+        do {
+            int oper = -1;
+            if (line.startsWith("add:")) {
+                oper = LDAPModification.ADD;
+            } else if (line.startsWith("delete:")) {
+                oper = LDAPModification.DELETE;
+            } else if (line.startsWith("replace:")) {
+                oper = LDAPModification.REPLACE;
+            } else
+                throwLDIFException("unknown modify type");
+
+            LDIFAttributeContent ac =
+                (LDIFAttributeContent)parse_ldif_content(d);
+            if (ac != null) {
+                LDAPAttribute attrs[] = ac.getAttributes();
+                for (int i = 0; i < attrs.length; i++) {
+                    LDAPModification mod = new LDAPModification(oper, attrs[i]);
+                    mc.addElement( mod );
+                }
+                LDAPControl[] controls = ac.getControls();
+                if ( controls != null ) {
+                    if ( controlVector == null ) {
+                        controlVector = new Vector();
+                    }
+                    for( int i = 0; i < controls.length; i++ ) {
+                        controlVector.addElement( controls[i] );
+                    }
+                }
+            // if there is no attrval-spec, go into the else statement
+            } else {
+                int index = line.indexOf(":");
+                if (index == -1)
+                    throwLDIFException("colon missing in "+line);
+
+                String attrName = line.substring(index+1).trim();
+
+                if (oper == LDAPModification.ADD)
+                    throwLDIFException("add operation needs the value for attribute "+attrName);
+                LDAPAttribute attr = new LDAPAttribute(attrName);
+                LDAPModification mod = new LDAPModification(oper, attr);
+                mc.addElement(mod);
+            }
+            if (m_currEntryDone) {
+                m_currEntryDone = false;
+                break;
+            }
+            line = d.readLine();
+        } while (line != null && !line.equals(""));
+
+        if( controlVector != null ) {
+            LDAPControl[] controls = new LDAPControl[controlVector.size()];
+            controlVector.copyInto( controls );
+            mc.setControls( controls );
+            controlVector.removeAllElements();
+        }
+        return mc;
+    }
+
+    /**
+     * Parses moddn/modrdn modification.
+     * @param d data input stream
+     */
+    private LDIFModDNContent parse_moddn_spec(LineReader d)
+                  throws IOException {
+        Vector controlVector = null;
+        String line = null;
+        line = d.readLine();
+        LDIFModDNContent mc = new LDIFModDNContent();
+        String val = null;
+        do {
+            if (line.startsWith("newrdn:") &&
+              (line.length() > ("newrdn:".length()+1))) {
+                mc.setRDN(line.substring("newrdn:".length()).trim());
+            } else if (line.startsWith("deleteoldrdn:") &&
+              (line.length() > ("deleteoldrdn:".length()+1))) {
+                String str = line.substring("deleteoldrdn:".length()).trim();
+                if (str.equals("0"))
+                    mc.setDeleteOldRDN(false);
+                else if (str.equals("1"))
+                    mc.setDeleteOldRDN(true);
+                else
+                    throwLDIFException("Incorrect input for deleteOldRdn ");
+            } else if (line.startsWith("newsuperior:") &&
+                       (line.length() > ("newsuperior:".length()+1))) {
+                mc.setNewParent(line.substring(
+                    "newsuperior:".length()).trim());
+            } else if (line.startsWith("newparent:") &&
+                       (line.length() > ("newparent:".length()+1))) {
+                mc.setNewParent(line.substring(
+                    "newparent:".length()).trim());
+            } else if (line.startsWith("control:")) {
+                if ( controlVector == null ) {
+                    controlVector = new Vector();
+                }
+                controlVector.addElement( parse_control_spec( line ) );
+            }
+            line = d.readLine();
+        } while (line != null && !line.equals(""));
+
+        if( controlVector != null ) {
+            LDAPControl[] controls = new LDAPControl[controlVector.size()];
+            controlVector.copyInto( controls );
+            mc.setControls( controls );
+            controlVector.removeAllElements();
+        }
+
+        return mc;
+    }
+
+    /**
+     * Parses the specification of a control<BR>
+     *
+     * A control looks line one of the following:
+     *<BR>
+     * control: 1.2.3.4.10.210
+     *<BR>
+     * control: 1.2.3.4.10.210 true
+     *<BR>
+     * control: 1.2.3.4.10.210 true: someASCIIvalue
+     *<BR>
+     * control: 1.2.3.4.10.210: someASCIIvalue
+     *<BR>
+     * control: 1.2.3.4.10.210 true:: 44GK44GM44GV44KP44KJ
+     *<BR>
+     * control: 1.2.3.4.10.210:: 44GK44GM44GV44KP44KJ
+     *<BR>
+     * control: 1.2.3.4.10.210 true:< file:///usr/local/directory/cont.dta
+     *<BR>
+     * control: 1.2.3.4.10.210:< file:///usr/local/directory/cont.dta
+     *
+     * @param line a line containing a control spec
+     * @return a parsed control.
+     * @exception IOException if the line could not be parsed
+     */
+    protected LDAPControl parse_control_spec( String line )
+        throws IOException {
+        boolean criticality = true;
+        String OID;
+        byte[] val = null;
+        int len = line.length();
+        int idx = line.indexOf(':') + 2;
+        /* OID, must be present */
+        if ( idx >= len ) {
+            throwLDIFException("OID required for control");
+        }
+        line = line.substring(idx).trim();
+        idx = line.indexOf(' ');
+        if ( idx < 0 ) {
+            OID = line;
+        } else {
+            /* Optional criticality */
+            OID = line.substring(0, idx);
+            line = line.substring(idx+1);
+            idx = line.indexOf(':');
+            String criticalVal;
+            if (idx > 0) {
+                criticalVal = line.substring(0, idx);
+            } else {
+                criticalVal = line;
+            }
+            if ( criticalVal.compareTo("true") == 0 ) {
+                criticality = true;
+            } else if ( criticalVal.compareTo("false") == 0 ) {
+                criticality = false;
+            } else {
+                throwLDIFException(
+                    "Criticality for control must be true" +
+                    " or false, not " + criticalVal);
+            }
+            /* Optional value */
+            if ( idx > 0 ) {
+                /* Could be :: for binary */
+                idx++;
+                if ( line.length() > idx ) {
+                    if ( line.charAt(idx) == ':' ) {
+                        idx++;
+                        line = line.substring(idx).trim();
+                        val = getDecodedBytes(line);
+                    } else if (line.charAt(idx) == '<') {
+                        String urlString = line.substring(idx+1).trim();
+                        try {
+                            URL url = new URL(urlString);
+                            String filename = url.getFile();
+                            val = getFileContent(filename);
+                        } catch (MalformedURLException ex) {
+                            throwLDIFException(
+                                ex + ": cannot construct url "+
+                                urlString);
+                        }
+                    } else {
+                        try {
+                            val = line.substring(idx).trim().getBytes("UTF8");
+                        } catch(Exception x) {
+                        }
+                    }
+                }
+            }
+        }
+        return new LDAPControl( OID, criticality, val );
+    }
+
+    /**
+     * Returns true if all the bytes in the given array are valid for output as a
+     * String according to the LDIF specification. If not, the array should
+     * output base64-encoded.
+     * @return <code>true</code> if all the bytes in the given array are valid for 
+     * output as a String according to the LDIF specification; otherwise, 
+     * <code>false</code>.
+     */
+    public static boolean isPrintable(byte[] b) {
+        for( int i = b.length - 1; i >= 0; i-- ) {
+            if ( (b[i] < ' ') || (b[i] > 127) ) {
+                if ( b[i] != '\t' )
+                    return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Outputs the String in LDIF line-continuation format. No line will be longer
+     * than the given max. A continuation line starts with a single blank space.
+     * @param pw the printer writer
+     * @param value the given string being printed out
+     * @param max the maximum characters allowed in the line
+     */
+    public static void breakString( PrintWriter pw, String value, int max) {
+        int leftToGo = value.length();
+        int written = 0;
+        int maxChars = max;
+        /* Limit to 77 characters per line */
+        while( leftToGo > 0 ) {
+            int toWrite = Math.min( maxChars, leftToGo );
+            String s = value.substring( written, written+toWrite);
+            if ( written != 0 ) {
+                pw.print( " " + s );
+            } else {
+                pw.print( s );
+                maxChars -= 1;
+            }
+            written += toWrite;
+            leftToGo -= toWrite;
+            /* Don't use pw.println, because it outputs an extra CR
+               in Win32 */
+            pw.print( '\n' );
+        }
+    }
+
+    /**
+     * Gets the version of LDIF used in the data.
+     * @return version of LDIF used in the data.
+     */
+    public int getVersion() {
+        return m_version;
+    }
+
+    /**
+     * Gets the string representation of the
+     * entire LDIF file.
+     * @return the string representation of the entire LDIF data file.
+     */
+    public String toString() {
+        return "LDIF {" + m_source + "}";
+    }
+
+    /**
+     * Throws a LDIF file exception including the current line number.
+     * @param msg Error message
+     */
+    protected void throwLDIFException(String msg)throws IOException {
+        throw new IOException ("line " +
+            (m_currLineNum-m_continuationLength) + ": " + msg);
+    }      
+    
+    /**
+     * Internal variables
+     */
+    private int m_version = 1;
+    private boolean m_done = false;
+    private LineReader m_reader = null;
+    private String m_source = null;
+    private MimeBase64Decoder m_decoder = null;
+    private boolean m_currEntryDone = false;
+    private int m_currLineNum;
+    private int m_continuationLength;
+
+    /* Concatenate continuation lines, if present */
+    class LineReader {
+        LineReader( BufferedReader d ) {
+            _d = d;
+        }
+        /**
+         * Reads a non-comment line.
+         * @return a string or null.
+         */
+        String readLine() throws IOException {
+            String line = null;
+            String result = null;
+            int readCnt = 0, continuationLength = 0;
+            do {
+                /* Leftover line from last time? */
+                if ( _next != null ) {
+                    line = _next;
+                    _next = null;
+                } else {
+                    line = _d.readLine();
+                }
+                if (line != null) {
+                    readCnt++;
+                    /* Empty line means end of record */
+                    if( line.length() < 1 ) {
+                        if ( result == null )
+                            result = line;
+                        else {
+                            _next = line;
+                            break;
+                        }
+                    } else if( line.charAt(0) == COMMENT ) {
+                        /* Ignore comment lines */
+                    } else if( line.charAt(0) != ' ' ) {
+                        /* Not a continuation line */
+                        if( result == null ) {
+                            result = line;
+                        } else {
+                            _next = line;
+                            break;
+                        }
+                    } else {
+                        /* Continuation line */
+                        if ( result == null ) {
+                            m_currLineNum += readCnt;
+                            throwLDIFException("continuation out of nowhere");
+                        }
+                        result += line.substring(1);
+                        continuationLength++;
+                    }
+                } else {
+                    /* End of file */
+                    break;
+                }
+            } while ( true );
+
+            m_done = ( line == null );
+            
+            m_currLineNum += readCnt;
+            if (_next != null) {
+                // read one line ahead
+                m_currLineNum--;
+            }            
+            m_continuationLength = continuationLength;
+            
+            return result;
+        }
+        private BufferedReader _d;
+        String _next = null;
+    }
+
+    /**
+     * Converts a byte array to a printable string following
+     * the LDIF rules (encode in base64 if necessary)
+     *
+     * @param b the byte array to convert
+     * @return a converted string which is printable.
+     */
+    public static String toPrintableString( byte[] b ) {
+        String s = "";
+        if (isPrintable(b)) {
+            try {
+                s = new String(b, "UTF8");
+            } catch ( java.io.UnsupportedEncodingException e ) {
+            }
+        } else {
+            ByteBuf inBuf = new ByteBuf( b, 0, b.length );
+            ByteBuf encodedBuf = new ByteBuf();
+            // Translate to base 64 
+            MimeBase64Encoder encoder = new MimeBase64Encoder();
+            encoder.translate( inBuf, encodedBuf );
+            int nBytes = encodedBuf.length();
+            if ( nBytes > 0 ) {
+                s = new String(encodedBuf.toBytes(), 0, nBytes);
+            }
+        }
+        return s;
+    }
+
+    /**
+     * Test driver - just reads and parses an LDIF file, printing
+     * each record as interpreted
+     *
+     * @param args name of the LDIF file to parse
+     */
+    public static void main( String[] args ) {
+        if ( args.length != 1 ) {
+            System.out.println( "Usage: java LDIF <FILENAME>" );
+            System.exit( 1 );
+        }
+        LDIF ldif = null;
+        try {
+            ldif = new LDIF( args[0] );
+        } catch (Exception e) {
+            System.err.println("Failed to read LDIF file " + args[0] +
+                               ", " + e.toString());
+            System.exit(1);
+        }
+        try {
+            for( LDIFRecord rec = ldif.nextRecord();
+                 rec != null; rec = ldif.nextRecord() ) {
+                System.out.println( rec.toString() + '\n' );
+            }
+        } catch ( IOException ex ) {
+            System.out.println( ex );
+            System.exit( 1 );
+        }
+        System.exit( 0 );
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/ConnectionPool.java
@@ -0,0 +1,574 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+import netscape.ldap.*;
+
+/**
+ * Class to maintain a pool of individual connections to the
+ * same server. Specify the initial size and the max size
+ * when constructing a pool. Call getConnection() to obtain
+ * a connection from the pool and close() to return it. If
+ * the pool is fully extended and there are no free connections,
+ * getConnection() blocks until a connection has been returned
+ * to the pool.<BR>
+ * Call destroy() to release all connections.
+ *<BR><BR>Example:<BR>
+ *<PRE>
+ * ConnectionPool pool = null;
+ * try {
+ *     pool = new ConnectionPool( 10, 30,
+ *                                "foo.acme.com",389,
+ *                                "uid=me, o=acme.com",
+ *                                "password" );
+ * } catch ( LDAPException e ) {
+ *    System.err.println( "Unable to create connection pool" );
+ *    System.exit( 1 );
+ * }
+ * while ( clientsKnocking ) {
+ *     String filter = getSearchFilter();
+ *     LDAPConnection ld = pool.getConnection();
+ *     try {
+ *         LDAPSearchResults res = ld.search( BASE, ld.SCOPE_SUB,
+ *                                            filter, attrs,
+ *                                            false );
+ *         pool.close( ld );
+ *         while( res.hasMoreElements() ) {
+ *             ...
+ *</PRE>
+ */
+
+/**
+ * Connection pool, typically used by a server to avoid creating
+ * a new connection for each client
+ *
+ * @version 1.2
+ **/
+public class ConnectionPool {
+ 
+    /**
+     * Constructor for specifying all parameters
+     *
+     * @param min initial number of connections
+     * @param max maximum number of connections
+     * @param host hostname of LDAP server
+     * @param port port number of LDAP server
+     * @param authdn DN to authenticate as
+     * @param authpw password for authentication
+     * @exception LDAPException on failure to create connections
+     */
+    public ConnectionPool( int min, int max,
+                           String host, int port,
+                           String authdn, String authpw )
+        throws LDAPException {
+        this( min, max, host, port, authdn, authpw, null );
+    }
+
+    /**
+     * Constructor for specifying all parameters, anonymous
+     * identity
+     *
+     * @param min initial number of connections
+     * @param max maximum number of connections
+     * @param host hostname of LDAP server
+     * @param port port number of LDAP server
+     * @exception LDAPException on failure to create connections
+     */
+    public ConnectionPool( int min, int max,
+                           String host, int port)
+        throws LDAPException {
+        this( min, max, host, port, "", ""); 
+    }
+
+    /**
+     * Constructor for using default parameters, anonymous identity
+     *
+     * @param host hostname of LDAP server
+     * @param port port number of LDAP server
+     * @exception LDAPException on failure to create connections
+     */
+    public ConnectionPool( String host, int port ) 
+        throws LDAPException {
+        // poolsize=10,max=20,host,port,
+        // noauth,nopswd
+        this( 10, 20, host, port, "", "" );
+    }
+
+    /** 
+     * Constructor for using an existing connection to clone
+     * from.
+     * <P>
+     * The connection to clone must be already established and
+     * the user authenticated.
+     * 
+     * @param min initial number of connections
+     * @param max maximum number of connections
+     * @param ldc connection to clone 
+     * @exception LDAPException on failure to create connections 
+     */ 
+    public ConnectionPool( int min, int max, LDAPConnection ldc )
+        throws LDAPException {
+        this( min, max, ldc.getHost(), ldc.getPort(),
+              ldc.getAuthenticationDN(), ldc.getAuthenticationPassword(),
+              (LDAPConnection)ldc.clone() );
+    } 
+
+    /* 
+     * Constructor for using an existing connection to clone
+     * from
+     * 
+     * @param min initial number of connections
+     * @param max maximum number of connections
+     * @param host hostname of LDAP server
+     * @param port port number of LDAP server
+     * @param authdn DN to authenticate as
+     * @param authpw password for authentication
+     * @param ldc connection to clone 
+     * @exception LDAPException on failure to create connections 
+     */ 
+    private ConnectionPool( int min, int max,
+                            String host, int port,
+                            String authdn, String authpw,
+                            LDAPConnection ldc )
+        throws LDAPException {
+        this.poolSize = min;
+        this.poolMax  = max;
+        this.host = host;
+        this.port = port;
+        this.authdn = authdn;
+        this.authpw = authpw;
+        this.ldc = ldc;
+        this.debugMode = false;
+        createPool();
+    }
+
+    /**
+     * Destroy the whole pool - called during a shutdown
+     */
+    public void destroy() {
+        for ( int i = 0; i < pool.size(); i++ ) {
+            disconnect(
+                (LDAPConnectionObject)pool.elementAt(i) );
+        }
+        pool.removeAllElements();
+    }
+
+    /**
+     * Gets a connection from the pool
+     *
+     * If no connections are available, the pool will be
+     * extended if the number of connections is less than
+     * the maximum; if the pool cannot be extended, the method
+     * blocks until a free connection becomes available.
+     *
+     * @return an active connection.
+     */
+    public LDAPConnection getConnection() {
+        LDAPConnection con;
+
+        while( (con = getConnFromPool()) == null ) {
+            synchronized( pool ) {
+                try {
+                    pool.wait();
+                } catch ( InterruptedException e ) {
+                }
+            }
+        }
+        return con;
+    }
+
+    /**
+     * Gets a connection from the pool within a time limit.
+     *
+     * If no connections are available, the pool will be
+     * extended if the number of connections is less than
+     * the maximum; if the pool cannot be extended, the method
+     * blocks until a free connection becomes available or the
+     * time limit is exceeded. 
+     *
+     * @param timeout timeout in milliseconds
+     * @return an active connection or <CODE>null</CODE> if timed out. 
+     */
+    public LDAPConnection getConnection(int timeout) {
+        LDAPConnection con;
+
+        while( (con = getConnFromPool()) == null ) {
+            long t1, t0 = System.currentTimeMillis();
+
+            if (timeout <= 0) {
+                return con;
+            }
+
+            synchronized( pool ) {
+                try {
+                    pool.wait(timeout);
+                } catch ( InterruptedException e ) {
+                    return null;
+                }
+            }
+
+            t1 = System.currentTimeMillis();
+            timeout -= (t1 - t0);
+        }
+        return con;
+    }
+
+    /**
+     * Gets a connection from the pool
+     *
+     * If no connections are available, the pool will be
+     * extended if the number of connections is less than
+     * the maximum; if the pool cannot be extended, the method
+     * returns null.
+     *
+     * @return an active connection or null.
+     */
+    protected synchronized LDAPConnection getConnFromPool() {
+        LDAPConnection con = null;
+        LDAPConnectionObject ldapconnobj = null;
+
+        int pSize = pool.size();
+
+        // Get an available connection
+        for ( int i = 0; i < pSize; i++ ) {
+
+            // Get the ConnectionObject from the pool
+            LDAPConnectionObject co = 
+                (LDAPConnectionObject)pool.elementAt(i);
+
+            if ( co.isAvailable() ) {  // Conn available?
+                ldapconnobj = co;
+                break;
+            }
+        }
+
+        if ( ldapconnobj == null ) {
+            // If there there were no conns in pool, can we grow
+            // the pool?
+            if ( (poolMax < 0) ||
+                 ( (poolMax > 0) &&
+                   (pSize < poolMax)) ) {
+
+                // Yes we can grow it
+                int i = addConnection();
+
+                // If a new connection was created, use it
+                if ( i >= 0 ) {
+                    ldapconnobj = 
+                        (LDAPConnectionObject)pool.elementAt(i);
+                }
+            } else {
+                debug("All pool connections in use");
+            }
+        }
+
+        if ( ldapconnobj != null ) {
+            ldapconnobj.setInUse( true );  // Mark as in use
+            con = ldapconnobj.getLDAPConn();
+        }
+        return con;
+    }
+
+    /**
+     * This is our soft close - all we do is mark
+     * the connection as available for others to use.
+     * We also reset the auth credentials in case
+     * they were changed by the caller.
+     *
+     * @param ld a connection to return to the pool
+     */
+    public synchronized void close( LDAPConnection ld ) {
+
+        int index = find( ld );
+        if ( index != -1 ) {
+            LDAPConnectionObject co = 
+                (LDAPConnectionObject)pool.elementAt(index);
+
+            // Reset the auth if necessary
+            if (ldc == null || !ldc.getAuthenticationMethod().equals("sasl")) {
+
+                boolean reauth = false;
+                //if user bound anon then getAuthenticationDN is null
+                if ( ld.getAuthenticationDN() == null ) {
+                      reauth = (authdn != null); 
+                }
+                else if ( !ld.getAuthenticationDN().equalsIgnoreCase(authdn) ) {
+                    reauth = true;
+                }
+                if (reauth) {
+                    try {
+                        debug("user changed credentials-resetting");
+                        ld.bind(authdn,authpw);  //reauth as proper user
+                    } catch (LDAPException e) {
+                        debug("unable to reauth during close as "+authdn);
+                        debug(e.toString());
+                    }
+                }
+            }
+
+            co.setInUse( false );  // Mark as available
+            synchronized( pool ) {
+                pool.notifyAll();
+            }
+        }
+    }
+  
+    /**
+     * Debug method to print the contents of the pool
+     */
+    public void printPool(){
+        System.out.println("--ConnectionPool--");
+        for ( int i = 0; i < pool.size(); i++ ) {
+            LDAPConnectionObject co =
+                (LDAPConnectionObject)pool.elementAt(i);
+            System.out.println( "" + i + "=" + co );
+        }
+    }
+
+    private void disconnect(
+        LDAPConnectionObject ldapconnObject ) {
+        if ( ldapconnObject != null ) {
+            if (ldapconnObject.isAvailable()) {  
+                LDAPConnection ld = ldapconnObject.getLDAPConn();
+                if ( (ld != null) && (ld.isConnected()) ) {
+                    try {
+                        ld.disconnect();
+                    } catch (LDAPException e) {
+                        debug("disconnect: "+e.toString());
+                    }
+                 }
+                 ldapconnObject.setLDAPConn(null); // Clear conn
+            }
+        }
+    }
+ 
+    private void createPool() throws LDAPException {
+        // Called by the constructors
+        if ( poolSize <= 0 ) {
+            throw new LDAPException("ConnectionPoolSize invalid");
+        }
+        if ( poolMax < poolSize ) {
+            debug("ConnectionPoolMax is invalid, set to " +
+                  poolSize);
+            poolMax = poolSize;
+        }
+
+        debug("****Initializing LDAP Pool****");
+        debug("LDAP host = "+host+" on port "+port);
+        debug("Number of connections="+poolSize);
+        debug("Maximum number of connections="+poolMax);
+        debug("******");
+
+        pool = new java.util.Vector(); // Create pool vector
+        setUpPool( poolSize ); // Initialize it
+    }
+
+    private int addConnection() {
+        int index = -1;
+
+        debug("adding a connection to pool...");
+        try {
+            int size = pool.size() + 1; // Add one connection
+            setUpPool( size );
+
+            if ( size == pool.size() ) {
+                // New size is size requested?
+                index = size - 1;
+            }
+        } catch (Exception ex) {
+            debug("Adding a connection: "+ex.toString());
+        }
+        return index;
+    }
+  
+    private synchronized void setUpPool( int size )
+        throws LDAPException {
+        // Loop on creating connections
+        while( pool.size() < size ) {
+            LDAPConnectionObject co =
+                new LDAPConnectionObject();
+            // Make LDAP connection, using template if available
+            LDAPConnection newConn =
+                (ldc != null) ? (LDAPConnection)ldc.clone() :
+                new LDAPConnection();
+            co.setLDAPConn(newConn);
+            try {
+                if ( newConn.isConnected() ) {
+                    // If using a template, then reconnect
+                    // to create a separate physical connection
+                    newConn.reconnect();
+                } else {
+                    // Not using a template, so connect with
+                    // simple authentication using ldap v3
+                    try { 
+                        newConn.connect( 3, host, port, authdn, authpw); 
+                    }
+                    catch (LDAPException connEx) {
+                        // fallback to ldap v2 if v3 is not supported
+                        if (connEx.getLDAPResultCode() == connEx.PROTOCOL_ERROR) {
+                            newConn.connect( 2, host, port, authdn, authpw); 
+                        }
+                        else {
+                            throw connEx;
+                        }
+                    }
+                }
+            } catch ( LDAPException le ) {
+                debug("Creating pool:"+le.toString());
+                debug("aborting....");
+                throw le;
+            }
+            co.setInUse( false ); // Mark not in use
+            pool.addElement( co );
+        }
+    }
+
+    private int find( LDAPConnection con ) {
+        // Find the matching Connection in the pool
+        if ( con != null ) {
+            for ( int i = 0; i < pool.size(); i++ ) {
+                LDAPConnectionObject co = 
+                    (LDAPConnectionObject)pool.elementAt(i);
+                if ( co.getLDAPConn() == con ) {
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    /**
+      * Sets the debug printout mode.
+      *
+      * @param mode debug mode to use
+      */
+    public synchronized void setDebug( boolean mode ) {
+        debugMode = mode;
+    }
+
+    /**
+      * Reports the debug printout mode.
+      *
+      * @return debug mode in use.
+      */
+    public boolean getDebug() {
+        return debugMode;
+    }
+
+    private void debug( String s ) {
+        if ( debugMode )
+            System.out.println("ConnectionPool ("+
+                               new Date()+") : " + s);
+    }
+
+    private void debug(String s, boolean severe) {
+        if ( debugMode || severe ) {
+            System.out.println("ConnectionPool ("+
+                               new Date()+") : " + s);
+        }
+    }
+
+    /**
+     * Wrapper for LDAPConnection object in pool
+     */
+    class LDAPConnectionObject{
+
+        /**
+         * Returns the associated LDAPConnection.
+         *
+         * @return the LDAPConnection.
+         * 
+         */
+        LDAPConnection getLDAPConn() {
+            return this.ld;
+        }
+
+        /**
+         * Sets the associated LDAPConnection
+         *
+         * @param ld the LDAPConnection
+         * 
+         */
+        void setLDAPConn( LDAPConnection ld ) {
+            this.ld = ld;
+        }
+
+        /**
+         * Marks a connection in use or available
+         *
+         * @param inUse <code>true</code> to mark in use, <code>false</code> if available
+         * 
+         */
+        void setInUse( boolean inUse ) {
+            this.inUse = inUse;
+        }
+
+        /**
+         * Returns whether the connection is available
+         * for use by another user.
+         *
+         * @return <code>true</code> if available.
+         */
+        boolean isAvailable() {
+            return !inUse;
+        }
+  
+        /**
+         * Debug method
+         *
+         * @return s user-friendly rendering of the object.
+         */
+        public String toString() {
+            return "LDAPConnection=" + ld + ",inUse=" + inUse;
+        }
+
+        private LDAPConnection ld; // LDAP Connection
+        private boolean inUse; // In use? (true = yes)
+    }
+
+    private int poolSize; // Min pool size
+    private int poolMax; // Max pool size
+    private String host; // LDAP host
+    private int port;    // Port to connect at
+    private String authdn;  // Identity of connections
+    private String authpw;  // Password for authdn
+    private LDAPConnection ldc = null; // Connection to clone
+    private java.util.Vector pool;  // the actual pool
+    private boolean debugMode;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/DN.java
@@ -0,0 +1,479 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+import java.io.*;
+import java.util.StringTokenizer;
+
+/**
+ * Objects of this class represent distinguished names (DN). A
+ * distinguished name is used to identify an entry in a directory.
+ * <P>
+ *
+ * The <CODE>netscape.ldap.LDAPDN</CODE> class uses this class
+ * internally.  In most cases, when working with DNs in the
+ * LDAP Java classes, you should use the
+ * <CODE>netscape.ldap.LDAPDN</CODE> class.
+ * <P>
+ *
+ * The following DNs are examples of the different formats
+ * for DNs that may appear:
+ * <UL>
+ * <LI>uid=bjensen, ou=People, o=Airius.com
+ * (<A HREF="http://ds.internic.net/rfc/rfc1485.txt"
+ * TARGET="_blank">RFC 1485</A> format)
+ * <LI>o=Airius.com/ou=People/uid=bjensen (OSF format)
+ * </UL>
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.LDAPDN
+ */
+public final class DN implements Serializable {
+
+    /**
+     * List of RDNs. DN consists of one or more RDNs.
+     * RDNs follow RFC1485 order.
+     */
+    private Vector m_rdns = new Vector();
+
+    /**
+     * Type specifying a DN in the RFC format.
+     * <P>
+     *
+     * @see netscape.ldap.util.DN#getDNType
+     * @see netscape.ldap.util.DN#setDNType
+     */
+    public static int RFC = 0;
+
+    /**
+     * Type specifying a DN in the OSF format.
+     * <P>
+     *
+     * @see netscape.ldap.util.DN#getDNType
+     * @see netscape.ldap.util.DN#setDNType
+     */
+    public static int OSF = 1;
+
+    private int m_dnType = RFC;
+    static final long serialVersionUID = -8867457218975952548L;
+
+    /**
+     * Constructs an empty <CODE>DN</CODE> object.
+     */
+    public DN() {
+    }
+
+    /**
+     * Constructs a <CODE>DN</CODE> object from the specified
+     * distinguished name.  The string representation of the DN
+     * can be in RFC 1485 or OSF format.
+     * <P>
+     *
+     * @param dn string representation of the distinguished name
+     */
+    public DN(String dn) {
+
+        String neutralDN = neutralizeEscapes(dn);
+        if (neutralDN == null) {
+            return; // malformed
+        }
+        
+        // RFC1485
+        if (neutralDN.indexOf(',') != -1 || neutralDN.indexOf(';') != -1) {
+            parseRDNs(neutralDN, dn, ",;");
+        }
+        else if (dn.indexOf('/') != -1) { /* OSF */
+            m_dnType = OSF;
+            StringTokenizer st = new StringTokenizer(dn, "/");
+            Vector rdns = new Vector();
+            while (st.hasMoreTokens()) {
+                String rdn = st.nextToken();
+                if (RDN.isRDN(rdn))
+                    rdns.addElement(new RDN(rdn));
+                else
+                    return;
+            }
+            /* reverse the RDNs order */
+            for (int i = rdns.size() - 1; i >= 0; i--) {
+                m_rdns.addElement(rdns.elementAt(i));
+            }        
+        }        
+        else if (RDN.isRDN(dn)) {
+            m_rdns.addElement(new RDN(dn));
+        }
+    }
+
+    /**
+     * Neutralize backslash escapes and quoted sequences for easy parsing.
+     * @return dn string with disabled escapes or null if malformed dn
+     */    
+    private String neutralizeEscapes(String dn) {
+        String neutralDN = RDN.neutralizeEscapes(dn);
+        if (neutralDN == null) {
+            return null; // malformed
+        }
+        
+        String dn2 = neutralDN.trim();
+        if (dn2.length() == 0) {
+            return neutralDN;
+        }
+        if (dn2.charAt(0) == ';' || dn2.charAt(0)  == ',') {
+            return null; // malformed
+        }
+        int lastIdx = dn2.length() -1;
+        if (dn2.charAt(lastIdx) == ';' || dn2.charAt(lastIdx) == ',') {
+            return null; // malformed
+        }
+        return neutralDN;
+    }
+    
+    /**
+     * Parse RDNs in the DN
+     */
+    private void parseRDNs(String neutralDN, String dn, String sep) {
+        int startIdx=0, endIdx=0;
+        RDN rdn = null;
+        StringTokenizer tok = new StringTokenizer(neutralDN, sep);
+        while (tok.hasMoreElements()) {
+            String neutralRDN = tok.nextToken();
+            endIdx = startIdx + neutralRDN.length();
+            rdn = new RDN (dn.substring(startIdx, endIdx));
+            if (rdn.getTypes() != null) {
+                m_rdns.addElement(rdn);
+            }
+            else { // malformed rdn
+                m_rdns.removeAllElements();
+                return;
+            }
+            startIdx = endIdx + 1;
+        }        
+    }
+
+    /**
+     * Adds the specified relative distinguished name (RDN) to the
+     * beginning of the current DN.
+     * <P>
+     *
+     * @param rdn the relative distinguished name to add to the 
+     * beginning of the current DN
+     * @see netscape.ldap.util.RDN
+     */
+    public void addRDNToFront(RDN rdn) {
+        m_rdns.insertElementAt(rdn, 0);
+    }
+
+    /**
+     * Adds the specified relative distinguished name (RDN) to the
+     * end of the current DN.
+     * <P>
+     *
+     * @param rdn the relative distinguished name to append to the current DN
+     * @see netscape.ldap.util.RDN
+     */
+    public void addRDNToBack(RDN rdn) {
+        m_rdns.addElement(rdn);
+    }
+
+    /**
+     * Adds the specified relative distinguished name (RDN) to the current DN.
+     * If the DN is in RFC 1485 format, the RDN is added to the beginning
+     * of the DN.  If the DN is in OSF format, the RDN is appended to the
+     * end of the DN.
+     * <P>
+     *
+     * @param rdn the relative distinguished name to add to the current DN
+     * @see netscape.ldap.util.RDN
+     */
+    public void addRDN(RDN rdn) {
+        if (m_dnType == RFC) {
+            addRDNToFront(rdn);
+        } else {
+            addRDNToBack(rdn);
+        }
+    }
+
+    /**
+     * Sets the type of format used for the DN (RFC format or OSF format).
+     * <P>
+     *
+     * @param type one of the following constants: <CODE>DN.RFC</CODE>
+     * (to use the RFC format) or <CODE>DN.OSF</CODE> (to use the OSF format)
+     * @see netscape.ldap.util.DN#getDNType
+     * @see netscape.ldap.util.DN#RFC
+     * @see netscape.ldap.util.DN#OSF
+     */
+    public void setDNType(int type) {
+        m_dnType = type;
+    }
+
+    /**
+     * Gets the type of format used for the DN (RFC format or OSF format).
+     * <P>
+     *
+     * @return one of the following constants: <CODE>DN.RFC</CODE>
+     * (if the DN is in RFC format) or <CODE>DN.OSF</CODE>
+     * (if the DN is in OSF format).
+     * @see netscape.ldap.util.DN#setDNType
+     * @see netscape.ldap.util.DN#RFC
+     * @see netscape.ldap.util.DN#OSF
+     */
+    public int getDNType() {
+        return m_dnType;
+    }
+
+    /**
+     * Returns the number of components that make up the current DN.
+     * @return the number of components in this DN.
+     */
+    public int countRDNs() {
+        return m_rdns.size();
+    }
+
+    /**
+     * Returns a list of the components (<CODE>RDN</CODE> objects)
+     * that make up the current DN.
+     * @return a list of the components of this DN.
+     * @see netscape.ldap.util.RDN
+     */
+    public Vector getRDNs() {
+        return m_rdns;
+    }
+
+    /**
+     * Returns an array of the individual components that make up
+     * the current distinguished name.
+     * @param noTypes specify <code>true</code> to remove the attribute type
+     * and equals sign (for example, "cn=") from each component
+     */
+    public String[] explodeDN(boolean noTypes) {
+        if (m_rdns.size() == 0)
+            return null;
+        String str[] = new String[m_rdns.size()];
+        for (int i = 0; i < m_rdns.size(); i++) {
+            if (noTypes)
+                str[i] = ((RDN)m_rdns.elementAt(i)).getValue();
+            else
+                str[i] = ((RDN)m_rdns.elementAt(i)).toString();
+        }
+        return str;
+    }
+
+    /**
+     * Determines if the DN is in RFC 1485 format.
+     * @return <code>true</code> if the DN is in RFC 1485 format.
+     */
+    public boolean isRFC() {
+        return (m_dnType == RFC);
+    }
+
+    /**
+     * Returns the DN in RFC 1485 format.
+     * @return the DN in RFC 1485 format.
+     */
+    public String toRFCString() {
+        String dn = "";
+        for (int i = 0; i < m_rdns.size(); i++) {
+            if (i != 0)
+                dn += ",";
+            dn = dn + ((RDN)m_rdns.elementAt(i)).toString();
+        }
+        return dn;
+    }
+
+    /**
+     * Returns the DN in OSF format.
+     * @return the DN in OSF format.
+     */
+    public String toOSFString() {
+        String dn = "";
+        for (int i = 0; i < m_rdns.size(); i++) {
+            if (i != 0) {
+                dn = "/" + dn;
+            }
+            RDN rdn = (RDN)m_rdns.elementAt(i);
+            dn = rdn.toString() + dn;
+        }
+        return dn;
+    }
+
+    /**
+     * Returns the string representation of the DN
+     * in its original format. (For example, if the
+     * <CODE>DN</CODE> object was constructed from a DN
+     * in RFC 1485 format, this method returns the DN
+     * in RFC 1485 format.
+     * @return the string representation of the DN.
+     */
+    public String toString() {
+        if (m_dnType == RFC)
+            return toRFCString();
+        else
+            return toOSFString();
+    }
+
+    /**
+     * Determines if the given string is an distinguished name or
+     * not.
+     * @param dn distinguished name
+     * @return <code>true</code> or <code>false</code>.
+     */
+    public static boolean isDN(String dn) {
+        if ( dn.equals( "" ) ) {
+            return true;
+        }
+        DN newdn = new DN(dn);
+        return (newdn.countRDNs() > 0);
+    }
+
+    /**
+     * Determines if the current DN is equal to the specified DN.
+     * @param dn DN to compare against the current DN
+     * @return <code>true</code> if the two DNs are the same.
+     */
+    public boolean equals(DN dn) {
+        return (dn.toRFCString().toUpperCase().equals(toRFCString().toUpperCase()));
+    }
+
+    /**
+     * Gets the parent DN for this DN.
+     * <P>
+     *
+     * For example, the following section of code gets the
+     * parent DN of "uid=bjensen, ou=People, o=Airius.com."
+     * <PRE>
+     *    DN dn = new DN("uid=bjensen, ou=People, o=Airius.com");
+     *    DN parent = dn.getParent();
+     * </PRE>
+     * The parent DN in this example is "ou=People, o=Airius.com".
+     * <P>
+     *
+     * @return DN of the parent of this DN.
+     */
+    public DN getParent() {
+        DN newdn = new DN();
+        for (int i = m_rdns.size() - 1; i > 0; i--) {
+            newdn.addRDN((RDN)m_rdns.elementAt(i));
+        }
+        return newdn;
+    }
+
+    /**
+     * Determines if the given DN is under the subtree defined by this DN.
+     * <P>
+     *
+     * For example, the following section of code determines if the
+     * DN specified by <CODE>dn1</CODE> is under the subtree specified
+     * by <CODE>dn2</CODE>.
+     * <PRE>
+     *    DN dn1 = new DN("uid=bjensen, ou=People, o=Airius.com");
+     *    DN dn2 = new DN("ou=People, o=Airius.com");
+     *
+     *    boolean isContain = dn1.contains(dn2)
+     * </PRE>
+     * In this case, since "uid=bjensen, ou=People, o=Airius.com"
+     * is an entry under the subtree "ou=People, o=Airius.com",
+     * the value of <CODE>isContain</CODE> is true.
+     * <P>
+     *
+     * @param dn the DN of a subtree to check
+     * @return <code>true</code> if the current DN belongs to the subtree
+     * specified by <CODE>dn</CODE>.
+     * @deprecated Please use isDescendantOf() instead.
+     */
+
+    public boolean contains(DN dn) {
+        
+        return isDescendantOf(dn);
+    }
+    
+    /**
+     * Determines if this DN is a descendant of the given DN.
+     * <P>
+     *
+     * For example, the following section of code determines if the
+     * DN specified by <CODE>dn1</CODE> is a descendant of the DN specified
+     * by <CODE>dn2</CODE>.
+     * <PRE>
+     *    DN dn1 = new DN("uid=bjensen, ou=People, o=Airius.com");
+     *    DN dn2 = new DN("ou=People, o=Airius.com");
+     *
+     *    boolean isDescendant = dn1.isDescendantOf(dn2)
+     * </PRE>
+     * In this case, since "uid=bjensen, ou=People, o=Airius.com"
+     * is an entry under the subtree "ou=People, o=Airius.com",
+     * the value of <CODE>isDescendant</CODE> is true.
+     * <P>
+     *
+     * In the case where the given DN is equal to this DN
+     * it returns false.
+     *
+     * @param dn the DN of a subtree to check
+     * @return <code>true</code> if the current DN is a descendant of the DN
+     * specified by <CODE>dn</CODE>.
+     */
+
+    public boolean isDescendantOf(DN dn) {
+
+        Vector rdns1 = dn.m_rdns;
+
+        Vector rdns2 = this.m_rdns;
+
+        int i = rdns1.size() - 1;
+        int j = rdns2.size() - 1;
+        
+        if ((j < i) || (equals(dn) == true)) 
+          return false;
+
+        for (; i>=0 && j>=0; i--, j--) {
+            RDN rdn1 = (RDN)rdns1.elementAt(i);
+            RDN rdn2 = (RDN)rdns2.elementAt(j);
+            if (!rdn2.equals(rdn1)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Array of the characters that may be escaped in a DN.
+     */
+    public static final char[] ESCAPED_CHAR = {',', '+', '"', '\\', '<', '>', ';'};
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDAPFilter.java
@@ -0,0 +1,549 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import netscape.ldap.*;
+import java.util.*;
+
+/**
+ * Represents an LDAP search filter, which includes the string-based
+ * representation of the filter and other information retrieved from the
+ * LDAP filter configuration file (or from a buffer in memory or from a URL).
+ * <P>
+ *
+ * Although this class provides methods to create and modify LDAP
+ * filters, in most cases, you do not need to use these methods.
+ * In most situations, these classes are used to access individual
+ * filters from filter configuration files.
+ * <P>
+ *
+ * For example, you might do the following:
+ * <P>
+ *
+ * <OL>
+ * <LI>Connect to the LDAP server and accept a set of search criteria.
+ * <LI>Create an LDAP filter configuration file.
+ * <LI>Call the <CODE>LDAPFilterDescriptor</CODE> constructor to
+ * read the filter configuration file into memory.
+ * <LI>Call the <CODE>getFilters</CODE> method to get a list of
+ * filters that match the search criteria.  This list of filters
+ * is represented by an <CODE>LDAPFilterList</CODE> object.
+ * <LI>Iterate through the list of filters (each filter is represented
+ * by an <CODE>LDAPFilter</CODE> object), and apply the filter to
+ * a search.
+ * </OL>
+ * <P>
+ *
+ * For an example of using an object of this class and for more information on
+ * the filter configuration file syntax, see the documentation for <a
+ * href="n.l.u.LDAPFilterDescriptor.html">LDAPFilterDescriptor</a>.
+ * <P>
+ *
+ * @see LDAPFilterDescriptor
+ * @see LDAPFilterList
+ * @version 1.0
+ */
+
+public class LDAPFilter implements Cloneable {
+
+    private static final int DEFAULT_FILTER_LENGTH = 256;
+
+    private String m_strFilter = null;
+    private String m_strDescription;        // token 4 from filter configuration file
+    private int m_nScope;           // token 5 from filter configuration file
+    private boolean m_bIsExact;
+
+    private String m_strMatchPattern;       // token 1 from filter configuration file
+    private String m_strDelimiter;      // token 2 from filter configuration file
+    private String m_strFilterTemplate;     // token 3 from filter configuration file
+
+    private int m_nLine;
+    private String m_strSuffix;
+    private String m_strPrefix;
+
+    /**
+     * Constructs an <CODE>LDAPFilter</CODE> object.  In most situations,
+     * you do not need to construct an LDAPFilter object.  Instead, you
+     * work with <CODE>LDAPFilter</CODE> objects created from the
+     * <CODE>LDAPFilter</CODE> objects and <CODE>LDAPFilterDescriptor</CODE>
+     * objects.
+     * <P>
+     *
+     * This constructor uses the integer value for a search scope in
+     * addition to other information to construct an <CODE>LDAPFilter</CODE>
+     * object.  The integer value of the search scope can be one of the
+     * following:
+     *   <ul>
+     *     <li><CODE>LDAPConnection.SCOPE_BASE</CODE>
+     *     <li><CODE>LDAPConnection.SCOPE_ONE</CODE>
+     *     <li><CODE>LDAPConnection.SCOPE_SUB</CODE>
+     *   </ul>
+     *
+     * If an invalid scope is specified, the constructor throws an
+     * <CODE>illegalArgumentException</CODE>.
+     */
+    public LDAPFilter ( String strMatchPattern,
+            String strDelimiter,
+            String strFilterTemplate,
+            String strDescription,
+                int nScope ) throws IllegalArgumentException{
+
+        m_strMatchPattern = convertMatchPattern ( strMatchPattern );
+        m_strDelimiter = strDelimiter;
+        m_strFilterTemplate = strFilterTemplate;
+        m_strDescription = strDescription;
+        m_nScope = nScope;
+
+    }
+
+    /**
+     * Constructs an <CODE>LDAPFilter</CODE> object.  In most situations,
+     * you do not need to construct an LDAPFilter object.  Instead, you
+     * work with <CODE>LDAPFilter</CODE> objects created from the
+     * <CODE>LDAPFilter</CODE> objects and <CODE>LDAPFilterDescriptor</CODE>
+     * objects.
+     * <P>
+     *
+     * This constructor uses the string value for a search scope in
+     * addition to other information to construct an <CODE>LDAPFilter</CODE>
+     * object.  The string value of the search scope can be one of the
+     * following:
+     *   <ul>
+     *     <li><CODE>&quot;base&quot;</CODE>
+     *     <li><CODE>&quot;onelevel&quot;</CODE>
+     *     <li><CODE>&quot;subtree&quot;</CODE>
+     *   </ul>
+     *
+     * If an invalid scope is specified, the constructor throws an
+     * <CODE>illegalArgumentException</CODE>.
+     */
+    public LDAPFilter ( String strMatchPattern,
+            String strDelimiter,
+            String strFilterTemplate,
+            String strDescription,
+                String strScope )
+            throws IllegalArgumentException {
+        if ( strScope.equals ( "base" ) ) {
+            m_nScope = LDAPConnection.SCOPE_BASE;
+
+        } else if ( strScope.equals ( "onelevel" ) ) {
+            m_nScope = LDAPConnection.SCOPE_ONE;
+
+        } else if ( strScope.equals ( "subtree" ) ) {
+            m_nScope = LDAPConnection.SCOPE_SUB;
+        }
+
+        m_strMatchPattern = strMatchPattern;
+        m_strDelimiter = strDelimiter;
+        m_strFilterTemplate = strFilterTemplate;
+        m_strDescription = strDescription;
+    }
+
+    /**
+     * Print out a string representation of the LDAPFilter.
+     * Basically, it prints out the appropriate fields.
+     * <P>
+     *
+     * For example, suppose you called the method in this way:
+     * <P>
+     *
+     * <PRE>System.out.println(filter.toString());</PRE>
+     *
+     * The resulting output might look like this:
+     * <P>
+     *
+     * <PRE>
+     *      matchPtn: "@"
+     *      delim:    " "
+     *      filttmpl: "(mail=%v*)"
+     *      descript: "start of email address"
+     *      scope: "LDAPConnection.SCOPE_SUB"
+     *      line:     "32"
+     *      FILTER:   "(mail=babs@aceindustry.com*)"
+     * </PRE>
+     */
+    public String toString() {
+        StringBuffer strBuf = new StringBuffer ( 300 );
+        strBuf.append ( "      matchPtn: \"" + m_strMatchPattern+"\"\n" );
+        strBuf.append ( "      delim:    \"" + m_strDelimiter+"\"\n" );
+        strBuf.append ( "      filttmpl: \"" + m_strFilterTemplate+"\"\n" );
+        strBuf.append ( "      descript: \"" + m_strDescription+"\"\n" );
+        switch ( m_nScope ) {
+            case LDAPConnection.SCOPE_BASE:
+                strBuf.append ( "      scope: \"LDAPConnection.SCOPE_BASE\"\n" );
+            break;
+            case LDAPConnection.SCOPE_ONE:
+                strBuf.append ( "      scope: \"LDAPConnection.SCOPE_ONE\"\n" );
+            break;
+            case LDAPConnection.SCOPE_SUB:
+                strBuf.append ( "      scope: \"LDAPConnection.SCOPE_SUB\"\n" );
+            break;
+        }
+        strBuf.append ( "      line:     \"" + m_nLine+"\"\n" );
+        strBuf.append ( "      FILTER:   \"" + m_strFilter+"\"\n" );
+
+        return strBuf.toString();
+    }
+
+    /**
+     * Sets up the filter string, given the string <CODE>strValue</CODE>.
+     * If the <CODE>strPrefix</CODE> and <CODE>strSuffix</CODE> arguments
+     * are non-null strings, they are prepended and appended
+     * to the filter string (respectively).
+     * <P>
+     *
+     * This string, which is available through the <CODE>getFilter()</CODE>
+     * method, should be suitable for use as search criteria when
+     * calling the <CODE>LDAPConnection.search()</CODE> method.
+     * <P>
+     *
+     * <b>Notes:</b>
+     * <P>
+     *
+     * <UL>
+     * <LI>This method <i>does not</i> maintain the affixes
+     * set with the <CODE>LDAPFilterDescriptor.setFilterAffixes</CODE>
+     * method, so you
+     * need to explicitly define any filter prefixes or suffixes here.<p>
+     *
+     * <LI> This method only uses the
+     * strPrefix and strSuffix for this invocation of setupFilter.  It
+     * does not redefine strPrefix and strSuffix for later
+     * invocations. <p>
+     * </UL>
+     * <P>
+     *
+     * @see netscape.ldap.util.LDAPFilterDescriptor#setFilterAffixes
+     * @see #setFilterAffixes
+     */
+    public void setupFilter ( String strValue, String strPrefix,
+                String strSuffix ) {
+        createFilterString ( strValue, strPrefix, strSuffix );
+    }
+
+    /**
+     * Sets up the filter string, given the string <CODE>strValue</CODE>.
+     * This string, which is available through the <CODE>getFilter()</CODE>
+     * method, should be suitable for use as search criteria when
+     * calling the <CODE>LDAPConnection.search()</CODE> method.
+     * <P>
+     *
+     * <b>Note:</b> If you want to specify a filter prefix and suffix,
+     * you need to explicitly define them by calling the
+     * <CODE>setFilterAffixes()</CODE> method.
+     *
+     * @see netscape.ldap.util.LDAPFilterDescriptor#setFilterAffixes
+     * @see #setFilterAffixes
+     *
+     */
+    public void setupFilter ( String strValue ) {
+        createFilterString ( strValue, null, null );
+    }
+
+    /**
+     * Create the filter string which can be used in
+     * LDAPConnection.search() and others given the parameter
+     * strValue.  If strPrefix and strSuffix are non-null strings,
+     * prepend strPrefix and append strSuffix.
+     */
+    void createFilterString ( String strValue, String strPrefix,
+                 String strSuffix ) {
+        StringTokenizer strTok =
+            new StringTokenizer ( strValue, m_strDelimiter );
+
+        // Initialize an array of broken up values so that we
+        // can reference  them directly.
+        String[] aValues = new String[strTok.countTokens()];
+        int nTokens = strTok.countTokens();
+        for ( int i = 0; i < nTokens; i++ ) {
+            aValues[i] = strTok.nextToken();
+        }
+
+        StringBuffer sbFilter = new StringBuffer ( DEFAULT_FILTER_LENGTH);
+        if ( strPrefix != null ) {
+            sbFilter.append ( strPrefix );
+        }
+        char[] cFilterTemplate = m_strFilterTemplate.toCharArray();
+        int i = 0;
+        while ( i < cFilterTemplate.length ) {
+            if ( cFilterTemplate[i] == '%' ) {
+                i++;
+                if ( cFilterTemplate[i] == 'v' ) {
+                    if ( i == (cFilterTemplate.length-1) ) {
+                        sbFilter.append ( strValue );
+                        break;
+                    }
+                    i++;
+                    switch ( cFilterTemplate[i] ) {
+                        case '$':
+                            sbFilter.append ( aValues[aValues.length] );
+                        break;
+
+                        case '1':
+                        case '2':
+                        case '3':
+                        case '4':
+                        case '5':
+                        case '6':
+                        case '7':
+                        case '8':
+                        case '9':
+                            int nValue = Integer.parseInt
+                                ( new Character
+                                  (cFilterTemplate[i]).toString() );
+                            nValue--;
+                            i++;
+                            if ( cFilterTemplate[i] == '-' ) {
+                                i++;
+                                if ( Character.isDigit ( cFilterTemplate[i] )) {
+                                int nValue2 = Integer.parseInt
+                                    ( new Character
+                                    (cFilterTemplate[i]).toString() );
+                                nValue2--;
+                                for ( int j = nValue; j <= nValue2; j++ ) {
+                                    sbFilter.append ( aValues[j] );
+                                    sbFilter.append
+                                    ( ( j == nValue2 ) ? "" : " " );
+                                }
+                                } else {
+                                for ( int j = nValue; j < aValues.length;j++ ) {
+                                    sbFilter.append ( aValues[j] );
+                                    sbFilter.append
+                                        ( ( j == aValues.length - 1 ) ? "" : " " );
+                                }
+                                sbFilter.append ( cFilterTemplate[i]);
+                                }
+
+                            } else {
+                                sbFilter.append ( aValues[nValue] );
+                                sbFilter.append ( cFilterTemplate[i] );
+                            }
+                        break;
+
+                        // We just got a plain old %v, so insert the
+                        // strValue
+                        default:
+                            sbFilter.append ( strValue );
+                            sbFilter.append ( cFilterTemplate[i] );
+                        break;
+                    }
+
+                } else {
+                    sbFilter.append ( "%" );
+                    sbFilter.append ( cFilterTemplate[i] );
+                }
+            } else {
+                sbFilter.append ( cFilterTemplate[i] );
+            }
+            i++;
+        }
+        if ( strSuffix != null ) {
+            sbFilter.append ( strSuffix );
+        }
+        m_strFilter = sbFilter.toString();
+    }
+
+
+    /**
+     * Makes a copy of this <CODE>LDAPFilter</CODE> object.
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch ( CloneNotSupportedException e ) {
+            // this shouldn't happen, since we are Cloneable
+            throw new InternalError();
+        }
+    }
+
+    /**
+     * Set the line number from which this filter was created.  This
+     * is used only when the LDAPFilter is created when an
+     * LDAPFilterDescriptor is initialized from a file/URL/buffer.
+     */
+    void setLine ( int nLine ) {
+        m_nLine = nLine;
+    }
+
+    /**
+     * The ldapfilter.conf specifies match patterns in a funny way.
+     * A "." means "any character" except when used inside of a set of
+     * square brackets "[]", in which case, the "." means just a
+     * plain old period (not a * special character).
+     *
+     * This function converts periods inside of a set of square
+     * brackets into a "\." as per normal regexp code.
+     */
+    String convertMatchPattern ( String strMatchPattern ) {
+        StringBuffer sb = new StringBuffer ( strMatchPattern.length() + 1);
+        char[] a_cMatchPattern = strMatchPattern.toCharArray();
+        boolean bInBrackets = false;
+        for ( int i = 0; i < a_cMatchPattern.length; i++ ) {
+            if ( a_cMatchPattern[i] == '.' ) {
+                if ( bInBrackets ) {
+                    sb.append ( "\\" );
+                }
+            } else if ( a_cMatchPattern[i] == '[' ) {
+                bInBrackets = true;
+            } else if ( a_cMatchPattern[i] == ']' ) {
+                bInBrackets = false;
+            }
+            sb.append ( a_cMatchPattern[i] );
+        }
+        return sb.toString();
+    }
+
+
+    /**
+     * Returns the filter string.   This method will return null if the
+     * filter string has not been calculated by the <CODE>setupFilter()</CODE>,
+     * <CODE>getFilter (strValue)</CODE>, or <CODE>getFilter (strValue,
+     * strPrefix, strSuffix )</CODE> methods.
+     *
+     * @see #setupFilter
+     * @see #getFilter
+     */
+    public String getFilter () {
+        return m_strFilter;
+    }
+
+    /**
+     * Create a filter string given a string value.  This method uses
+     * any Prefixes or Suffixes that have been set by the
+     * setFilterAffixes() method.<p>
+     *
+     * This is the same as doing:
+     * <pre>
+     *   setupFilter ( strValue );
+     *   getFilter();
+     * </pre>
+     */
+    public String getFilter ( String strValue ) {
+        createFilterString ( strValue, m_strPrefix, m_strSuffix );
+        return m_strFilter;
+    }
+
+
+    /**
+     * Create a filter string given a string value.  If strPrefix
+     * and/or strSuffix is non-null, these values are prepended and
+     * appended to the returned string.<p>
+     *
+     * This is the same as doing:
+     * <pre>
+     *   setupFilter ( strValue, strPrefix, strSuffix );
+     *   getFilter();
+     * </pre>
+     */
+    public String getFilter ( String strValue, String strPrefix,
+                        String strSuffix ) {
+        createFilterString ( strValue, strPrefix, strSuffix );
+        return m_strFilter;
+    }
+
+    /**
+     * Return this filter's match pattern.  The match pattern is
+     * found as the first token in a filter configuration line in the
+     * ldapfilter.conf file.
+     */
+    public String getMatchPattern() {
+        return m_strMatchPattern;
+    }
+
+    /**
+     * Return this filter's delimiter.  The delmimeter is
+     * found as the second token in a filter configuration line in the
+     * ldapfilter.conf file.
+     */
+    public String getDelimiter() {
+        return m_strDelimiter;
+    }
+
+    /**
+     * Return this filter's filter template.  The filter template is
+     * found as the third token in a filter configuration line in the
+     * ldapfilter.conf file.
+     */
+    public String getFilterTemplate() {
+        return m_strFilterTemplate;
+    }
+
+    /**
+     * Return this filter's description.  The description is
+     * found as the fourth token in a filter configuration line in the
+     * ldapfilter.conf file.
+     */
+    public String getDescription() {
+        return m_strDescription;
+    }
+
+    /**
+     * Return this filter's scope.  The scope is
+     * found as the fifth (optional) token in a filter configuration
+     * line in the ldapfilter.conf file.
+     */
+    public String getScope() {
+        switch ( m_nScope ) {
+            case LDAPConnection.SCOPE_BASE:
+                return "base";
+
+            case LDAPConnection.SCOPE_ONE:
+                return "onelevel";
+
+            case LDAPConnection.SCOPE_SUB:
+                return "subtree";
+
+            default:
+                return "UNKNOWN!";
+        }
+    }
+
+    /**
+     * Return this filter's line number.  The line number is
+     * mostly a debugging variable to let the developer know which
+     * filter from the filter configuration file is being used.
+     */
+    public String getLineNumber() {
+        return Integer.toString ( m_nLine );
+    }
+
+    public void setFilterAffixes ( String strPrefix, String strSuffix ) {
+        m_strPrefix = strPrefix;
+        m_strSuffix = strSuffix;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIFModifyContent.java
@@ -0,0 +1,125 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.Vector;
+import netscape.ldap.LDAPModification;
+
+/**
+ * An object of this class represents the content of an LDIF record that
+ * specifies modifications to an entry.  This class implements the
+ * <CODE>LDIFContent</CODE> interface.
+ * <P>
+ *
+ * To get this object from an <CODE>LDIFRecord</CODE> object,
+ * use the <CODE>getContent</CODE> method and cast the return value as
+ * <CODE>LDIFModifyContent</CODE>.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.LDIFRecord#getContent
+ */
+public class LDIFModifyContent extends LDIFBaseContent {
+    /**
+     * Internal variables
+     */
+    private Vector m_mods = new Vector();
+    static final long serialVersionUID = -710573832339780084L;
+
+    /**
+     * Constructs an empty <CODE>LDIFModifyContent</CODE> object.
+     * To specify the modifications to be made to the entry, use
+     * the <CODE>addElement</CODE> method.
+     * @see netscape.ldap.util.LDIFModifyContent#addElement
+     */
+    public LDIFModifyContent() {
+    }
+
+    /**
+     * Returns the content type. You can use this with the
+     * <CODE>getContent</CODE> method of the <CODE>LDIFRecord</CODE>
+     * object to determine the type of content specified in the record.
+     * @return the content type (which is
+     * <CODE>LDIFContent.MODIFICATION_CONTENT</CODE>).
+     * @see netscape.ldap.util.LDIFRecord#getContent
+     */
+    public int getType() {
+        return MODIFICATION_CONTENT;
+    }
+
+    /**
+     * Specifies an additional modification that should be made to
+     * the entry.
+     * @param mod <CODE>LDAPModification</CODE> object representing
+     * the change to make to the entry
+     * @see netscape.ldap.LDAPModification
+     */
+    public void addElement(LDAPModification mod) {
+        m_mods.addElement(mod);
+    }
+
+    /**
+     * Retrieves the list of the modifications specified in the content
+     * of the LDIF record.
+     * @return an array of <CODE>LDAPModification</CODE> objects that
+     * represent the modifications specified in the content of the LDIF record.
+     * @see netscape.ldap.LDAPModification
+     */
+    public LDAPModification[] getModifications() {
+        LDAPModification mods[] = new LDAPModification[m_mods.size()];
+        for (int i = 0; i < m_mods.size(); i++) {
+            mods[i] = (LDAPModification)m_mods.elementAt(i);
+        }
+        return mods;
+    }
+
+    /**
+     * Returns the string representation of the content of the LDIF record.
+     * @return the string representation of the content of the LDIF record.
+     */
+    public String toString() {
+        String s = "";
+        for (int i = 0; i < m_mods.size(); i++) {
+            s = s + ((LDAPModification)m_mods.elementAt(i)).toString();
+        }
+        if ( getControls() != null ) {
+            s += getControlString();
+        }
+        return "LDIFModifyContent {" + s + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/MimeBase64Decoder.java
@@ -0,0 +1,194 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+/** Implements a plaintext -> Base64 encoder.
+ */
+public final class MimeBase64Decoder extends MimeEncoder {
+
+    static final long serialVersionUID = 797397585345375903L;
+    private byte token[] = new byte[4];      // input buffer
+    private byte bytes[] = new byte[3];      // output buffer
+    private int token_length = 0;            // input buffer length
+
+    static private final byte NUL = 127;     // must be out of range 0-64
+    static private final byte EOF = 126;     // must be out of range 0-64
+
+    static private final byte map[] = {
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   000-007
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   010-017
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   020-027
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   030-037
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   040-047   !"#$%&'
+      NUL, NUL, NUL,  62, NUL, NUL, NUL,  63,      //   050-057  ()*+,-./
+       52,  53,  54,  55,  56,  57,  58,  59,      //   060-067  01234567
+       60,  61, NUL, NUL, NUL, EOF, NUL, NUL,      //   070-077  89:;<=>?
+
+      NUL,   0,   1,   2,   3,   4,   5,   6,      //   100-107  @ABCDEFG
+        7,   8,   9,  10,  11,  12,  13,  14,      //   110-117  HIJKLMNO
+       15,  16,  17,  18,  19,  20,  21,  22,      //   120-127  PQRSTUVW
+       23,  24,  25, NUL, NUL, NUL, NUL, NUL,      //   130-137  XYZ[\]^_
+      NUL,  26,  27,  28,  29,  30,  31,  32,      //   140-147  `abcdefg
+       33,  34,  35,  36,  37,  38,  39,  40,      //   150-157  hijklmno
+       41,  42,  43,  44,  45,  46,  47,  48,      //   160-167  pqrstuvw
+       49,  50,  51, NUL, NUL, NUL, NUL, NUL,      //   170-177  xyz{|}~
+
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   200-207
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   210-217
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   220-227
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   230-237
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   240-247
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   250-257
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   260-267
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   270-277
+
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   300-307
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   310-317
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   320-327
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   330-337
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   340-347
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   350-357
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   360-367
+      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,      //   370-377
+    };
+
+
+    // Fast routine that assumes full 4-char tokens with no '=' in them.
+    //
+    private final void decode_token(ByteBuf out) {
+        int num = ((map[token[0]] << 18) |
+                   (map[token[1]] << 12) |
+                   (map[token[2]] << 6) |
+                   (map[token[3]]));
+
+        bytes[0] = (byte) (0xFF & (num >> 16));
+        bytes[1] = (byte) (0xFF & (num >> 8));
+        bytes[2] = (byte) (0xFF & num);
+
+        out.append(bytes);
+    }
+
+
+    // Hairier routine that deals with the final token, which can have fewer
+    // than four characters, and that might be padded with '='.
+    //
+    private final void decode_final_token(ByteBuf out) {
+
+        byte b0 = map[token[0]];
+        byte b1 = map[token[1]];
+        byte b2 = map[token[2]];
+        byte b3 = map[token[3]];
+
+        int eq_count = 0;
+
+        if (b0 == EOF) { b0 = 0; eq_count++; }
+        if (b1 == EOF) { b1 = 0; eq_count++; }
+        if (b2 == EOF) { b2 = 0; eq_count++; }
+        if (b3 == EOF) { b3 = 0; eq_count++; }
+
+        int num = ((b0 << 18) | (b1 << 12) | (b2 << 6) | (b3));
+
+        // eq_count will be 0, 1, or 2.
+        // No "=" padding means 4 bytes mapped to 3, the normal case,
+        //        not handled in this routine.
+        // "xxx=" means 3 bytes mapped to 2.
+        // "xx==" means 2 bytes mapped to 1.
+        // "x===" can't happen, because "x" would then be encoding
+        //        only 6 bits, not 8, the minimum possible.
+
+        out.append((byte) (num >> 16));             // byte 1, count = 0 or 1 or 2
+        if (eq_count <= 1) {
+            out.append((byte) ((num >> 8) & 0xFF)); // byte 2, count = 0 or 1
+            if (eq_count == 0) {
+                out.append((byte) (num & 0xFF));    // byte 3, count = 0
+            }
+        }
+    }
+
+
+    /** Given a sequence of input bytes using the Base64 encoding, produces a
+        sequence of unencoded output bytes.  Note that some (small) amount of
+        buffering may be necessary, if the input byte stream didn't fall on an
+        appropriate boundary.  If there are bytes in `out' already, the new
+        bytes are appended, so the caller should do `out.setLength(0)' first
+        if that's desired.
+     */
+    public final void translate(ByteBuf in, ByteBuf out) {
+
+        if (token == null) // already saw eof marker?
+            return;
+
+        byte inb[] = in.toBytes();
+        int in_length = in.length();
+
+        for (int i = 0; i < in_length; i++) {
+            byte b = inb[i];
+                  int x=(b&0xff);
+            byte t = map[x];
+
+            if (t != NUL)
+                token[token_length++] = b;
+
+            if (t == EOF) {
+                eof(out);
+                return;
+            } else if (token_length == 4) {
+                decode_token(out);
+                token_length = 0;
+            }
+        }
+    }
+
+
+    /** Tell the Base64 decoder that no more input data will be forthcoming.
+        This may result in output, as a result of flushing the internal buffer.
+        This object must not be used again after calling eof().  If there are
+        bytes in `out' already, the new bytes are appended, so the caller should
+        do `out.setLength(0)' first if that's desired.
+     */
+    public final void eof(ByteBuf out) {
+        if (token != null && token_length != 0) {
+            while (token_length < 4)
+                token[token_length++] = (byte)'=';
+            decode_final_token(out);
+        }
+        token_length = 0;
+        token = new byte[4];
+        bytes = new byte[3];
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/RDN.java
@@ -0,0 +1,491 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+
+/**
+ * Objects of this class represent the components of a distinguished
+ * name (DN).  (In some situations, these components are referred to
+ * as relative distinguished names, or RDNs.)  For example, the
+ * DN "uid=bjensen, ou=People, o=Airius.com" has three components:
+ * "uid=bjensen", "ou=People", and "o=Airius.com".
+ * <P>
+ *
+ * Each DN component consists of an attribute type and a value.
+ * For example, in "o=Airius.com", the attribute type is "o"
+ * and the value is "Airius.com".
+ * <P>
+ *
+ * You can use objects of this class to add components to an
+ * existing <CODE>DN</CODE> object.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.DN
+ */
+public final class RDN implements java.io.Serializable {
+
+    static final long serialVersionUID = 7895454691174650321L;
+
+    /**
+     * List of RDNs. DN consists of one or more RDNs.
+     */
+    private String[] m_type = null;
+    private String[] m_value = null;
+    private boolean m_ismultivalued = false;
+
+    /**
+     * Hash table of case sensitive attributes
+     */
+    private static Hashtable m_attributehash = new Hashtable();    
+        
+    /**
+     * Constructs a new <CODE>RDN</CODE> object from the specified
+     * DN component.
+     * @param rdn DN component
+     */
+    public RDN( String rdn ) {
+        String neutralRDN = neutralizeEscapes(rdn);
+        if (neutralRDN == null) {
+            return; // malformed RDN
+        }
+        int index = neutralRDN.indexOf( "=" );
+        int next_plus;
+
+        // if the rdn doesnt have = or = positions right at the beginning of the rdn
+        if (index <= 0)
+            return;
+
+        Vector values = new Vector();
+        Vector types = new Vector();
+
+        types.addElement( rdn.substring( 0, index ).trim() );
+        next_plus = neutralRDN.indexOf( '+', index ); 
+        while ( next_plus != -1 ) {
+            m_ismultivalued = true;
+            values.addElement( rdn.substring( index + 1, next_plus).trim() );
+            index = neutralRDN.indexOf( "=", next_plus + 1 );
+            if ( index == -1 ) {
+                // malformed RDN?
+                return;
+            }
+            types.addElement( rdn.substring( next_plus + 1, index ).trim() );
+            next_plus = neutralRDN.indexOf('+', index );
+        }    
+        values.addElement( rdn.substring( index + 1 ).trim() );
+        
+        m_type = new String[types.size()];
+        m_value = new String[values.size()];
+
+        for( int i = 0; i < types.size(); i++ ) {
+            m_type[i] = (String)types.elementAt( i );
+            if (!isValidType(m_type[i])) {
+                m_type = m_value = null;
+                return; // malformed
+            }
+            m_value[i] = (String)values.elementAt( i );
+            if (!isValidValue(m_value[i])) {
+                m_type = m_value = null;
+                return; // malformed
+            }
+        }
+    }
+    
+    /**
+     * Neutralize backslash escapes and quoted sequences for easy parsing.
+     * @return rdn string with disabled escapes or null if malformed rdn
+     */
+     static String neutralizeEscapes(String rdn) {
+        if (rdn == null) {
+            return null;
+        }        
+        StringBuffer sb = new StringBuffer(rdn);
+        boolean quoteOn = false;
+        // first pass, disable backslash escapes
+        for (int i=0; i < sb.length(); i++) {
+            if (sb.charAt(i) =='\\') {
+                sb.setCharAt(i, 'x');
+                if (i < sb.length()-1) {
+                    sb.setCharAt(i+1, 'x');
+                }
+                else {
+                    return null;
+                }
+            }
+        }
+        // second pass, disable quoted sequences
+        for (int i=0; i < sb.length(); i++) {
+            if (sb.charAt(i) == '"') {
+                quoteOn = !quoteOn;
+                continue;
+            }
+            if (quoteOn) {
+                sb.setCharAt(i, 'x');
+            }
+        }        
+        return quoteOn ? null : sb.toString();
+    }
+
+    /**
+     * Type names can not contain any DN special characters
+     */
+    private boolean isValidType(String type) {
+        if (type == null || type.length() < 1) {
+            return false;
+        }
+        for (int i=0; i< type.length(); i++) {
+            for (int j=0; j < DN.ESCAPED_CHAR.length; j++) {
+                if (type.charAt(i) == DN.ESCAPED_CHAR[j]) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+    
+    /**
+     * Values can contain only single quote sequence, where quotes are
+     * at the beginning and the end of the sequence
+     */
+    private boolean isValidValue(String val) {
+        if (val == null || val.length() < 1) {
+            return false;
+        }
+        // count unescaped '"'
+        int cnt=0, i=0;
+        while (i >=0 && i < val.length()) {
+            i = val.indexOf('"', i);
+            if (i >= 0) {
+                if (i==0 || (val.charAt(i-1) != '\\')) {
+                    cnt++;
+                }
+                i++;
+            }
+        }
+        if (cnt == 0) {
+            return true;
+        }
+        else if (cnt != 2) { // can have only two of them surrounding the value
+            return false;
+        }
+        else if (val.charAt(0) != '"' || val.charAt(val.length()-1) != '"') {
+            return false;
+        }
+    
+        return true;
+    }
+    
+    /**
+     * Returns the DN component as the first element in an
+     * array of strings.
+     * @param noType specify <code>true</code> to ignore the attribute type and
+     * equals sign (for example, "cn=") and return only the value
+     * @return an array of strings representing the DN component.
+     * @deprecated use <code>toString</code> or <code>getValues</code> instead.
+     */
+    public String[] explodeRDN(boolean noType) {
+        if (m_type == null)
+            return null;
+        String str[] = new String[1];
+        if (noType) {
+            str[0] = getValue();
+        } else {
+            str[0] = toString();
+        }
+        return str;
+    }
+
+    /**
+     * Returns the attribute type of the DN component.
+     * @return rdn the attribute type of the DN component.
+     * @deprecated use <code>getTypes()</code> instead.
+     */
+    public String getType() {
+        if (m_type != null && m_type.length > 0) {
+            return m_type[0];
+        }
+        return null;
+    }
+
+    /**
+     * Returns the attribute types of the DN component.
+     * @return rdn the attribute types of the DN component.
+     */
+    public String[] getTypes() {
+        return m_type;
+    }
+
+    /**
+     * Returns the value of the DN component.
+     * @return rdn the value of the DN component.
+     * @deprecated use <code>getValues()</code> instead.
+     */
+    public String getValue() {
+        if (m_value != null && m_value.length > 0) {
+            return m_value[0];
+        }
+        return null;
+    }
+
+    /**
+     * Returns the values of the DN component.
+     * @return rdn the values of the DN component.
+     */
+    public String[] getValues() {
+        return m_value;
+    }
+
+    /** 
+     * Returns <code>true</code> if the RDN is multi-valued.
+     * @return <code>true</code> if the RDN is multi-valued.
+     */
+    public boolean isMultivalued() {
+        return m_ismultivalued;
+    }
+    
+    /**
+     * Returns the string representation of the DN component.
+     * @return the string representation of the DN component.
+     */
+    public String toString() {
+        StringBuffer buf = new StringBuffer();
+                
+        for ( int i = 0; m_type != null  && i < m_type.length; i++ ) {
+            if ( i != 0) {
+                buf.append(" + ");
+            }
+            buf.append( m_type[i] + "=" + m_value[i]);
+        }
+
+        return buf.toString();
+    }
+
+    /**
+     * Determines if the specified string is a distinguished name component.
+     * @param rdn the string to check
+     * @return <code>true</code> if the string is a distinguished name component.
+     */
+    public static boolean isRDN(String rdn) {
+        RDN newrdn = new RDN(rdn);
+        return ((newrdn.getTypes() != null) && (newrdn.getValues() != null));
+    }
+
+    /**
+     * Determines if the current DN component is equal to the specified
+     * DN component. Uses an internal table of ces (case exact string) 
+     * attributes to determine how the attributes should be compared.
+     * @param rdn the DN component to compare against the
+     * current DN component.
+     * @return <code>true</code> if the two DN components are equal.
+     * @see netscape.ldap.util.RDN#registerAttributeSyntax
+     * @see netscape.ldap.util.RDN#getAttributeSyntax
+     */
+    public boolean equals(RDN rdn) {
+        String[] this_types = (String[])getTypes().clone(); 
+        String[] this_values = (String[])getValues().clone();
+        String[] rdn_types = (String[])rdn.getTypes().clone();
+        String[] rdn_values = (String[])rdn.getValues().clone();
+
+        if ( this_types.length != rdn_types.length ) {
+            return false;
+        }
+
+        sortTypesAndValues( this_types, this_values );
+        sortTypesAndValues( rdn_types, rdn_values );
+        
+        for (int i = 0; i < this_types.length; i++ ) { 
+            
+            if ( !this_types[i].equalsIgnoreCase( rdn_types[i] ) ) {
+                return false;
+            }
+
+            if ( CES_SYNTAX.equals( getAttributeSyntax( this_types[i] ) ) ) {
+                if ( !this_values[i].equals( rdn_values[i] ) ) {
+                    return false;
+                }
+            } else { 
+                if ( !this_values[i].equalsIgnoreCase( rdn_values[i] ) ) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+
+    /* sorts the rdn components by attribute to make comparison easier */
+    void sortTypesAndValues( String[] types, String[] values ) {
+        boolean no_changes;
+        do {
+            no_changes = true;
+            for ( int i = 0; i < types.length - 1; i++ ) {
+                if ( types[i].toLowerCase().compareTo( types[i + 1].toLowerCase() ) > 0 ) {
+                    String tmp_type = types[i];
+                    String tmp_value = values[i];
+                    types[i] = types[i + 1];
+                    values[i] = values[i + 1];
+                    types[i + 1] = tmp_type;
+                    values[i + 1] = tmp_value;
+                    no_changes = false;
+                }
+            }
+        } while ( no_changes = false );   
+    }
+
+    /**
+     * Registers the the given attribute for the given syntax in an
+     * internal table. This table is used for attribute comparison in the 
+     * <code>equals()</code> method.
+     * @param attr the attribute to register.
+     * @param oid the syntax to register with the attribute.
+     * @see netscape.ldap.util.RDN#equals
+     * @see netscape.ldap.util.RDN#unregisterAttributeSyntax
+     * @see netscape.ldap.util.RDN#getAttributeSyntax
+     * @see netscape.ldap.util.RDN#getAttributesForSyntax
+     */
+    public static void registerAttributeSyntax( String attr, String oid ) {
+        m_attributehash.put( attr.toLowerCase(), oid );
+    }
+    
+    /**
+     * Removes the the given attribute from the attribute syntax table. 
+     * @param attr the attribute to remove.
+     * @see netscape.ldap.util.RDN#registerAttributeSyntax
+     * @see netscape.ldap.util.RDN#getAttributeSyntax
+     * @see netscape.ldap.util.RDN#getAttributesForSyntax
+     */
+    public static void unregisterAttributeSyntax( String attr ) {
+        m_attributehash.remove( attr.toLowerCase() );
+    }
+
+    /**
+     * Returns the syntax for the attribute if the given attribute is registered 
+     * in the internal attribute table.
+     * @param attr the attribute to lookup in the table.
+     * @return the syntax of the attribute if found, null otherwise.
+     * @see netscape.ldap.util.RDN#unregisterAttributeSyntax
+     * @see netscape.ldap.util.RDN#registerAttributeSyntax
+     * @see netscape.ldap.util.RDN#getAttributesForSyntax
+     */
+    public static String getAttributeSyntax( String attr ) {
+        return (String)m_attributehash.get( attr.toLowerCase() );
+    }
+
+    /**
+     * Returns all attributes registered for the given syntax as a 
+     * <code>String</code> Array.
+     * @param oid the syntax to look up in the table.
+     * @return all attributes for the given syntax as a <code>String[]</code>
+     * @see netscape.ldap.util.RDN#unregisterAttributeSyntax
+     * @see netscape.ldap.util.RDN#registerAttributeSyntax
+     * @see netscape.ldap.util.RDN#getAttributeSyntax
+     */
+    public static String[] getAttributesForSyntax( String oid ) {
+        Enumeration itr = m_attributehash.keys();
+        Vector key_v = new Vector();
+        String tmp_str = null;
+
+        while ( itr.hasMoreElements() ) {
+            tmp_str = (String)itr.nextElement();
+            if ( oid.equals( (String)m_attributehash.get( tmp_str ) ) ) {
+                key_v.addElement( tmp_str );
+            }
+        }
+
+        String[]  str = new String[key_v.size()];
+        for ( int i = 0; i < str.length; i++ ) {
+            str[i] = new String( (String)key_v.elementAt( i ) );
+        }
+        
+        return str;
+    }
+
+    public static final String[] _cesAttributes = {
+        "adminurl",
+        "altserver",
+        "automountinformation",
+        "bootfile",
+        "bootparameter",
+        "cirbindcredentials",
+        "generation",
+        "homedirectory",
+        "internationalisdnnumber",
+        "labeleduri",
+        "membercertificatedescription",
+        "membernisnetgroup",
+        "memberuid",
+        "memberurl",
+        "nismapentry",
+        "nisnetgrouptriple",
+        "nsaddressbooksyncurl",
+        "presentationaddress",
+        "ref",
+        "replicaentryfilter",
+        "searchguide",
+        "subtreeaci",
+        "vlvfilter",
+        "vlvname",
+        "x121address"
+    };
+
+    public static final String CES_SYNTAX = "1.3.6.1.4.1.1466.115.121.1.26";
+
+    static {
+        /* static initializer to fill the ces attribute hash 
+         * this list was generated from the slapd.at.conf that
+         * ships with Netscape Directory Server 4.1 
+         */
+        for ( int i = 0; i < _cesAttributes.length; i++ ) {
+            registerAttributeSyntax( _cesAttributes[i], CES_SYNTAX );
+        }
+    }
+}
+
+
+
+
+
+
+
+
+
+
+
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDAPFilterDescriptor.java
@@ -0,0 +1,506 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.io.*;
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+import java.util.regex.PatternSyntaxException;
+import java.net.*;
+import netscape.ldap.*;
+
+/**
+ * Represents an LDAP filter configuration file read into memory.
+ * <P>
+ *
+ * Once you read in a filter file to create an object of this class,
+ * you can access the filter information through the methods that create
+ * <CODE>LDAPFilterList</CODE> and <CODE>LDAPFilter</CODE> objects.
+ * (You do not need to manually construct these objects yourself.)
+ * <P>
+ *
+ * This class (along with the other LDAP filter classes) provide
+ * functionality equivalent to the LDAP filter functions in the LDAP C API.
+ * <p>
+ *
+ * The format of the file/URL/buffer must be that as defined in the
+ * ldapfilter.conf(5) man page from the University of Michigan LDAP-3.3
+ * distribution.  <p>
+ *
+ * The LDAP filter classes provide a powerful way to configure LDAP clients
+ * by modifying a configuration file.<p>
+ *
+ * The following is a short example for how to use the
+ * LDAP filter classes.
+ *
+ * <pre>
+ *
+ * // ... Setup LDAPConnection up here ...
+ * <p>
+ *
+ * LDAPFilterDescriptor filterDescriptor;
+ * <p>
+ *
+ * // Create the LDAPFilterDescriptor given the file
+ * // "ldapfilter.conf".
+ * try {
+ *    filterDescriptor = new LDAPFilterDescriptor ( "ldapfilter.conf" );
+ *     <p>
+ *
+ *    // Now retrieve the Filters in the form of an
+ *    // LDAPFilterList
+ *     LDAPFilterList filterList = new filterDescriptor.getFilters("match_tag", "string_user_typed");
+ *     <p>
+ *
+ *    // For each filter, do the search.  Normally, you wouldn't
+ *    // do the search if the first filter matched, but this is
+ *    // just showing the enumeration type aspects of
+ *    // LDAPFilterList
+ *     LDAPFilter filter;
+ *     while ( filterList.hasMoreElements() ) {
+ *      filter = filterList.next();
+ *      LDAPResults results = LDAPConnection.search (
+ *                      strBase,                // base DN
+ *                      filter.getScope(),      // scope
+ *                      filter.getFilter(),     // completed filter
+ *                      null,                   // all attribs
+ *                      false );                // attrsOnly?
+ *     }
+ *     <p>
+ *
+ *     // ...more processing here...
+ * } catch ( BadFilterException e ) {
+ *      System.out.println ( e.toString() );
+ *      System.exit ( 0 );
+ * } catch ( IOException e ) {
+ *     // ...handle exception here...
+ * }
+ * </pre>
+ *
+ *
+ * @see LDAPFilterList
+ * @see LDAPFilter
+ * @version 1.0
+ */
+public class LDAPFilterDescriptor {
+
+    private Vector m_vFilterSet = new Vector();
+
+    private String m_strLine;
+    private int m_nLine;
+
+    private String m_strPrefix;
+    private String m_strAffix;
+    private LDAPIntFilterSet m_tmpFilterSet = null;
+    private String m_strLastMatchPattern = null;
+    private String m_strLastDelimiter = null;
+
+    /**
+     * The Default scope is used when a scope is not defined
+     * in the filter file.  The scope is the only "optional" parameter
+     * in the file.
+     */
+    private static final int DEFAULT_SCOPE = LDAPConnection.SCOPE_SUB;
+
+    /**
+     * Creates an LDAPFilterDescriptor object from an existing filter
+     * configuration file.  This file has the format as defined in the
+     * ldapfilter.conf(5) man page.
+     *
+     * @exception netscape.ldap.util.BadFilterException
+     *    One of the filters was not generated properly.  Most likely
+     *    this is due to an improperly formatted ldapfilter.conf file.
+     */
+    public LDAPFilterDescriptor ( String strFile )
+            throws FileNotFoundException, BadFilterException {
+        DataInputStream inputStream =
+        new DataInputStream ( new FileInputStream ( strFile ) );
+        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
+        init( reader );
+    }
+
+    /**
+     * Creates an LDAPFilterDescriptor object from an existing
+     * StringBuffer.  This file has the format as defined in the
+     * ldapfilter.conf(5) man page.
+     *
+     * @exception netscape.ldap.util.BadFilterException
+     *    One of the filters was not generated properly.  Most likely
+     *    this is due to an improperly formatted ldapfilter.conf file.
+     */
+    public LDAPFilterDescriptor ( StringBuffer strBuffer )
+            throws BadFilterException {
+        init( strBuffer );
+    }
+
+    /**
+     * Creates an LDAPFilterDescriptor object from a URL.
+     * This file has the format as defined in the
+     * ldapfilter.conf(5) man page.
+     *
+     * @exception netscape.ldap.util.BadFilterException
+     *    One of the filters was not generated properly.  Most likely
+     *    this is due to an improperly formatted ldapfilter.conf file.
+     */
+    public LDAPFilterDescriptor ( URL url )
+            throws IOException, BadFilterException {
+        URLConnection urlc = url.openConnection();
+        DataInputStream inputStream =
+        new DataInputStream ( urlc.getInputStream() );
+        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
+        init( reader );
+    }
+
+
+
+    /**
+     * This function initializes the LDAPFilterDescriptor.  It's
+     * called internally, and should never be called directly by the
+     * developer.
+     */
+    private void init ( Object inputObj)
+            throws BadFilterException {
+
+        String strCommentPattern = "^\\s*#|$";
+        String strDataPattern = "\\s*(?:\"([^\"]*)\")|([^\\s]*)\\s*";
+        Pattern patComment;
+        Pattern patData;
+        Vector vStrings = new Vector ( 5 );
+
+        try {
+            patComment = Pattern.compile ( strCommentPattern );
+            patData = Pattern.compile ( strDataPattern );
+        } catch ( PatternSyntaxException e ) {
+            // This should NEVER happen...
+            System.out.println ( "FATAL Error, couldn't compile pattern");
+            System.out.println ( "  " + e.getMessage() );
+            return;
+        }
+
+        // Setup some temporary variables.
+        m_nLine = 0;
+        try {
+            if (inputObj instanceof StringBuffer) {
+                StringBuffer ibuffer = (StringBuffer)inputObj;
+                StringBuffer buffer = new StringBuffer();
+                for (int i=0; i<ibuffer.length(); i++) {
+                    if (ibuffer.charAt(i) == '\n') {
+                        m_strLine = buffer.toString();
+                        m_nLine++;
+                        setFilter(patComment, patData, vStrings);
+                        buffer = new StringBuffer();
+                    } else
+                        buffer.append(ibuffer.charAt(i));
+                    }
+            } else {
+                while ((m_strLine=((BufferedReader)inputObj).readLine()) != null) {
+                    m_nLine++;
+                    setFilter(patComment, patData, vStrings);
+                }
+            }
+
+            // BUGBUG: Fixed. 7-28-97
+            // We're done with the input, so we need to append the
+            // last temporary FilterSet into the list of FilterSets.
+            if ( m_tmpFilterSet != null ) {
+                m_vFilterSet.addElement ( m_tmpFilterSet );
+            }
+
+        } catch ( IOException e ) {
+        }
+    }
+
+    private void setFilter(Pattern patComment, Pattern patData,
+      Vector vStrings) throws IOException, BadFilterException {
+        Matcher dataMatcher;
+        LDAPFilter tmpFilter = null;
+
+        if ( ! patComment.matcher(m_strLine).lookingAt() ) {
+//        	System.out.println("comment pattern " + patComment.pattern() +
+//        					   " does not match " + m_strLine);
+        	dataMatcher = patData.matcher(m_strLine);
+            // System.out.println ( "\nNEW LINE: " + m_strLine );
+            if ( ! vStrings.isEmpty() ) {
+                vStrings.removeAllElements();
+            }
+
+            while ( dataMatcher.find() ) {
+                // Within this while loop, we're looking for
+                // all the data tokens.  Our regular
+                // expression is setup to look for words
+                // separated by whitespace or sets of
+                // characters in quotataion marks.  A remnant
+                // of the regexp is that we have two
+                // backreferences, only one will have data at
+                // any time.
+            	int groupCount = dataMatcher.groupCount();
+                for ( int i = 1; i <= groupCount; i++ ) {
+                    if ( dataMatcher.group(i) != null ) {
+                        if ( ! dataMatcher.group(i).equals ( "" ) ) {
+//                            System.out.println ( "Match #" + i +
+//                            		": \"" + dataMatcher.group(i) + "\"" );
+                            vStrings.addElement ( dataMatcher.group(i));
+                        }
+                    }
+                }
+            }
+
+            switch ( vStrings.size() ) {
+            case 1:
+                // If the current filter set is not null,
+                // add it to the filter set vector.
+                if ( m_tmpFilterSet != null ) {
+                    m_vFilterSet.addElement ( m_tmpFilterSet );
+                }
+
+                // Now create a new filterset.
+                m_tmpFilterSet = new LDAPIntFilterSet
+                    ( (String)vStrings.elementAt ( 0 ) );
+
+            break;
+
+                // Two tokens mens we're the the second (or
+                // higher line in a token.  We need to append
+                // the information stored in the list onto
+                // the tmpFilter.
+            case 2:
+
+                if ( ( m_strLastMatchPattern != null ) &&
+                    ( m_strLastDelimiter != null ) ) {
+                    tmpFilter = new LDAPFilter(
+                    m_strLastMatchPattern,
+                    m_strLastDelimiter,
+                    (String)vStrings.elementAt ( 0 ),
+                    (String)vStrings.elementAt ( 1 ),
+                    DEFAULT_SCOPE );
+                    tmpFilter.setLine ( m_nLine );
+                    if ( m_tmpFilterSet != null ) {
+                        m_tmpFilterSet.appendFilter ( tmpFilter );
+                    } else {
+                        throw MakeException ( "Attempting to add a filter to a null filterset" );
+                    }
+                } else {
+                    throw MakeException ( "Attempting to create a relative filter with no preceeding full filter" );
+                }
+            break;
+
+            // Three tokens means we're the second (or
+            // higher line in a filter.  create a new
+            // filter grabbing info from the last filter
+            case 3:
+
+                if ( ( m_strLastMatchPattern != null ) &&
+                ( m_strLastDelimiter != null ) ) {
+                    tmpFilter = new LDAPFilter (
+                        m_strLastMatchPattern,
+                        m_strLastDelimiter,
+                        (String)vStrings.elementAt ( 0 ),
+                        (String)vStrings.elementAt ( 1 ),
+                        (String)vStrings.elementAt ( 2 ) );
+                    tmpFilter.setLine ( m_nLine );
+
+
+                    if ( m_tmpFilterSet != null ) {
+                        m_tmpFilterSet.appendFilter ( tmpFilter );
+                    } else {
+                        throw MakeException
+                            ("Attempting to add a filter to a null filterset");
+                    }
+
+                } else {
+                    throw MakeException
+                        ("Attempting to create a relative filter with no preceeding full filter" );
+                }
+            break;
+
+            // 4 tokens means this is the first line in a
+            // token.   All data is new.  However, we're using
+            // the default scope.
+            case 4:
+                tmpFilter = new LDAPFilter (
+                    (String)vStrings.elementAt ( 0 ),
+                    (String)vStrings.elementAt ( 1 ),
+                    (String)vStrings.elementAt ( 2 ),
+                    (String)vStrings.elementAt ( 3 ),
+                    DEFAULT_SCOPE );
+                tmpFilter.setLine ( m_nLine );
+                m_strLastMatchPattern = (String)vStrings.elementAt ( 0 );
+                m_strLastDelimiter = (String)vStrings.elementAt ( 1 );
+                if ( m_tmpFilterSet != null ) {
+                    m_tmpFilterSet.newFilter ( tmpFilter );
+                } else {
+                    throw MakeException
+                        ("Attempting to add a filter to a null filterset");
+                }
+            break;
+
+            // 5 tokens means this is the first line in a
+            // token.   All data is new.
+            case 5:
+                tmpFilter = new LDAPFilter (
+                    (String)vStrings.elementAt ( 0 ),
+                    (String)vStrings.elementAt ( 1 ),
+                    (String)vStrings.elementAt ( 2 ),
+                    (String)vStrings.elementAt ( 3 ),
+                    (String)vStrings.elementAt ( 4 ) );
+                tmpFilter.setLine ( m_nLine );
+                m_strLastMatchPattern = (String)vStrings.elementAt ( 0 );
+                m_strLastDelimiter = (String)vStrings.elementAt ( 1 );
+                if ( m_tmpFilterSet != null ) {
+                    m_tmpFilterSet.newFilter ( tmpFilter );
+                } else {
+                    throw MakeException
+                        ("Attempting to add a filter to a null filterset");
+                }
+
+            break;
+
+            default:
+                throw MakeException ( "Wrong number of tokens (" + vStrings.size() + ")" );
+
+            //break;
+
+            }
+        }
+    }
+
+    /**
+     * just a utility method to create an exception.
+     */
+    private BadFilterException MakeException ( String strMsg ) {
+        return new BadFilterException
+          ( "BadFilterException while creating Filters,\n" +
+            "Line Number: " + m_nLine +
+            ",\n --> " + m_strLine + "\nThe error is: " +
+            strMsg, m_nLine );
+    }
+
+        /**
+     * Output a text dump of this filter descriptor.  It cycles
+     * through all of the internal LDAPIntFilterSet objects and calls
+     * their toString() methods.
+     *
+     * @see LDAPIntFilterSet#toString
+     */
+    public String toString() {
+        StringBuffer strBuf = new StringBuffer ( 4000 );
+        for ( int i = 0; i < m_vFilterSet.size(); i++ ) {
+            strBuf.append ( "Filter Set number: " + i + "\n" );
+            strBuf.append (
+                ((LDAPIntFilterSet)m_vFilterSet.elementAt ( i )).toString() +
+            "\n" );
+            strBuf.append ( "\n" );
+            //System.out.println ( (m_vFilterSet.elementAt ( i )).toString());
+        }
+        return strBuf.toString();
+    }
+
+    /**
+     * Return all the filters which match the strTagPat (regular
+     * expression), and the user input (strValue)
+     */
+    public LDAPFilterList getFilters ( String strTagPat, String strValue )
+        throws IllegalArgumentException {
+
+        strTagPat = strTagPat.trim();
+        strValue = strValue.trim();
+
+        if ( ( strTagPat == null ) || ( strTagPat.equals ("") ) ) {
+            throw new IllegalArgumentException
+                    ( "The Tag Pattern can not be null" );
+        }
+
+        if ( ( strValue == null ) || ( strValue.equals ("") ) ) {
+            throw new IllegalArgumentException ( "The Value can not be null" );
+        }
+
+        LDAPFilterList retList = new LDAPFilterList();
+
+        Pattern patTag;    // The strTagPat that's compiled
+
+        // first we need to make a new regexp from the strTagPat
+        // For efficiency, we're precompiling the strTagPat into
+        // a pattern here.  That pattern doesn't change, the Tag string
+        // changes per LDAPFIlterSet.
+        try {
+            patTag = Pattern.compile ( strTagPat );
+        } catch ( PatternSyntaxException e ) {
+            throw new IllegalArgumentException
+            ( "The parameter: " + strTagPat + " is not valid" );
+        }
+
+        // We "ask" each of the filterset's to see if there is
+        // a matching filter.
+        boolean bMatched = false;
+        int i = 0;
+        while ( ! bMatched ) {
+            Vector vMatchingFilters =
+            ((LDAPIntFilterSet)m_vFilterSet.elementAt ( i )).getFilters
+                (patTag, strValue );
+
+            if ( vMatchingFilters.size() > 0 ) {
+                for ( int j = 0; j < vMatchingFilters.size(); j++ ) {
+                    LDAPFilter tmpFilter =
+                    (LDAPFilter)
+                        ((LDAPFilter)
+                        vMatchingFilters.elementAt ( j )).clone();
+                    tmpFilter.setupFilter ( strValue, m_strPrefix,
+                                  m_strAffix );
+                    bMatched = true; // this really doesn't matter.
+                    retList.add ( tmpFilter );
+                }
+                return retList;
+            }
+            i++;
+        }
+        return null;
+    }
+
+
+        /**
+     * Prepend the parameter (strPrefix) and append the second
+     * parameter (strAffix) to every filter that is returned by the
+     * getFilters() method.  <p>
+     */
+    public void setFilterAffixes ( String strPrefix, String strAffix ) {
+        m_strPrefix = strPrefix;
+        m_strAffix = strAffix;
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/ByteBuf.java
@@ -0,0 +1,449 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.io.RandomAccessFile;
+import java.io.Serializable;
+
+/**
+ * This class is similar to the <CODE>java.lang.StringBuffer</CODE>
+ * class.  Instead of storing a string, an object of this class
+ * stores an array of bytes.  (This is referred to as a "byte buffer".)
+ * <P>
+ *
+ * This class also differs from <CODE>StringBuffer</CODE> in the
+ * following ways:
+ * <UL>
+ * <LI>None of the methods are synchronized. You cannot share a
+ * byte buffer among multiple threads.
+ * <LI>Converting to a String requires a copy of the character data.
+ * <LI>In order to speed up memory allocation, <CODE>Alloc</CODE>
+ * and <CODE>Recycle</CODE> methods are provided.  You can "recycle"
+ * any <CODE>ByteBuf</CODE> objects you no longer need by using the
+ * <CODE>Recycle</CODE> method.  Calling the <CODE>Alloc</CODE>
+ * method will reuse objects that have been "recycled."  To
+ * To clear out the cache of these "recycled" objects, use
+ * the <CODE>EmptyRecycler</CODE> method.
+ * <LI>Additional "helper" methods are provided (for example,
+ * functions for comparing data).
+ * </UL>
+ */
+public final class ByteBuf implements Serializable {
+
+    static final long serialVersionUID = -786393456618166871L;
+    private byte value[];
+    private int count;
+
+    /**
+     * Constructs an empty byte buffer with the default length of 16.
+     */
+    public ByteBuf() {
+        this(16);
+    }
+
+    /**
+     * Constructs an empty byte buffer with the specified initial length.
+     * @param length initial number of bytes that this buffer should hold
+     */
+    public ByteBuf(int length) {
+        value = new byte[length];
+    }
+
+    /**
+     * Constructs a byte buffer with the specified initial value.
+     * The new byte buffer is 16 bytes longer than the initial value.
+     * @param str initial value that this buffer should hold
+     */
+    public ByteBuf(String str) {
+        this(str.length() + 16);
+        append(str);
+    }
+
+    /**
+     * Constructs a byte buffer with the specified length.
+     * An initial value is stored in this buffer, starting
+     * at the specified offset.
+     * @param bytes array of bytes to initially store in the buffer
+     * @param offset index where you want the initial value to start in the array
+     * @param length length of the buffer to allocate
+     */
+    public ByteBuf(byte bytes[], int offset, int length) {
+        value = new byte[length];
+        System.arraycopy(bytes, offset, value, 0, length);
+        count = length;
+    }
+
+    /**
+     * Returns the length (character count) of the byte buffer.
+     */
+    public int length() {
+        return count;
+    }
+
+    /**
+     * Returns the current capacity of the byte buffer. The capacity
+     * is the amount of storage available for newly inserted bytes.
+     * If the capacity is exceeded, more space will be allocated.
+     */
+    public int capacity() {
+        return value.length;
+    }
+
+    /**
+     * Ensures that the capacity of the buffer is at least equal to the
+     * specified minimum capacity.
+     * @param minimumCapacity the minimum number of bytes that you want
+     * the byte buffer to hold
+     */
+    public void ensureCapacity(int minimumCapacity) {
+        int maxCapacity = value.length;
+
+        if (minimumCapacity > maxCapacity) {
+            int newCapacity = (maxCapacity + 1) * 2;
+            if (minimumCapacity > newCapacity) {
+                newCapacity = minimumCapacity;
+            }
+
+            byte newValue[] = new byte[newCapacity];
+            System.arraycopy(value, 0, newValue, 0, count);
+            value = newValue;
+        }
+    }
+
+    /**
+     * Sets the length of the byte buffer. If you set a length that is
+     * shorter than the current length, bytes at the end of the buffer
+     * are lost. If you increase the length of the buffer, the values
+     * of the new bytes in the buffer are set to 0.
+     * @param newLength the new length of the buffer
+     * @exception StringIndexOutOfBoundsException  You have specified
+     * an invalid length.
+     */
+    public void setLength(int newLength) {
+        if (newLength < 0) {
+            throw new StringIndexOutOfBoundsException(newLength);
+        }
+        if (count < newLength) {
+            ensureCapacity(newLength);
+            for (; count < newLength; count++) {
+                value[count] = 0;
+            }
+        }
+        count = newLength;
+    }
+
+    /**
+     * Returns the byte at the specified index.  The value of an index
+     * can range from 0 to length - 1.
+     * @param index index of the byte to find
+     * @exception StringIndexOutOfBoundsException You have specified an
+     * invalid index.
+     */
+    public byte byteAt(int index) {
+        if ((index < 0) || (index >= count)) {
+            throw new StringIndexOutOfBoundsException(index);
+        }
+        return value[index];
+    }
+
+    /**
+     * Copies the bytes (from the section of the byte buffer from the index
+     * <CODE>srcBegin</CODE> to the index <CODE>srcEnd - 1 </CODE>)
+     * into the specified byte array.  The copied
+     * bytes are inserted in the byte array at the index specified by
+     * <CODE>dstBegin</CODE>. Both <CODE>srcBegin</CODE> and
+     * <CODE>srcEnd</CODE> must be valid indexes in the buffer.
+     * @param srcBegin index identifying the start of the section
+     * of the byte buffer to copy
+     * @param srcEnd index identifying the end of the section
+     * of the byte buffer to copy. (Copy all bytes
+     * before the byte identified by this index.)
+     * @param dst the byte array to copy the data to
+     * @param dstBegin index of the byte array identifying the
+     * location to which the byte buffer is copied
+     * @exception StringIndexOutOfBoundsException You specified an invalid index into the buffer.
+     */
+    public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) {
+        if ((srcBegin < 0) || (srcBegin >= count)) {
+            throw new StringIndexOutOfBoundsException(srcBegin);
+        }
+        if ((srcEnd < 0) || (srcEnd > count)) {
+            throw new StringIndexOutOfBoundsException(srcEnd);
+        }
+        if (srcBegin < srcEnd) {
+            System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);
+        }
+    }
+
+    /**
+     * Sets the value of the byte at the specified index.
+     * @param index the index of the byte to set
+     * @param b the new value to set
+     * @exception StringIndexOutOfBoundsException You have specified
+     * an invalid index.
+     */
+    public void setByteAt(int index, byte b) {
+        if ((index < 0) || (index >= count)) {
+            throw new StringIndexOutOfBoundsException(index);
+        }
+        value[index] = b;
+    }
+
+    /**
+     * Appends an object to the end of this byte buffer.
+     * @param obj the object to append to the buffer
+     * @return the same <CODE>ByteBuf</CODE> object (not a new object)
+     * with the string representation of the specified object appended.
+     */
+    public ByteBuf append(Object obj) {
+        return append(String.valueOf(obj));
+    }
+
+    /**
+     * Appends a string to the end of this byte buffer.
+     * This method appends one byte for each character in the string.
+     * The upper 8 bits of the character are stripped off.
+     * <P>
+     *
+     * If you want to retain all bits in the character (not just
+     * the lower 8 bits), use <CODE>append(String.getBytes())</CODE>
+     * instead.
+     * @param str the string that you want appended to the buffer
+     * @return the same <CODE>ByteBuf</CODE> object (not a new object)
+     * with the specified string appended
+     */
+    public ByteBuf append(String str) {
+        if (str == null) {
+            str = String.valueOf(str);
+        }
+
+        int len = str.length();
+        ensureCapacity(count + len);
+        for (int i=0 ; i<len ; i++) {
+            value[count++] = (byte) str.charAt(i);
+        }
+        return this;
+    }
+
+    /**
+     * Appends an array of bytes to the end of this byte buffer.
+     * @param str the array of bytes to append to this buffer
+     * @return the same <CODE>ByteBuf</CODE> object (not a new object)
+     * with the specified bytes appended.
+     */
+    public ByteBuf append(byte str[]) {
+        int len = str.length;
+        ensureCapacity(count + len);
+        System.arraycopy(str, 0, value, count, len);
+        count += len;
+        return this;
+    }
+
+    /**
+     * Appends a part of an array of bytes to the end of this byte buffer.
+     * @param str the array of bytes to append to this buffer
+     * @param offset the index in the array marking the start of the
+     * section to copy
+     * @param len the number of bytes to add
+     * @return the same <CODE>ByteBuf</CODE> object (not a new object)
+     * with the specified section of the byte array appended
+     */
+    public ByteBuf append(byte str[], int offset, int len) {
+        ensureCapacity(count + len);
+        System.arraycopy(str, offset, value, count, len);
+        count += len;
+        return this;
+    }
+
+    /**
+     * Appends a byte buffer to the end of this byte buffer.
+     * @param buf the byte buffer to append to this buffer
+     * @return the original <CODE>ByteBuf</CODE> object (not a new object)
+     * with bytes from the specified byte buffer appended.
+     */
+    public ByteBuf append(ByteBuf buf) {
+        append(buf.toBytes(), 0, buf.length());
+        return this;
+    }
+
+    /**
+     * Appends a boolean to the end of this byte buffer.
+     * @param b the boolean value that you want appended to this buffer
+     * @return  the original <CODE>ByteBuf</CODE> object (not a new object)
+     * with bytes from the string representation of the boolean value appended.
+     */
+    public ByteBuf append(boolean b) {
+        return append(String.valueOf(b));
+    }
+
+    /**
+     * Appends a byte to the end of this byte buffer.
+     * @param b the byte to append to this buffer
+     * @return the original <CODE>ByteBuf</CODE> object (not a new object)
+     * with the specified byte appended.
+     */
+    public ByteBuf append(byte b) {
+        ensureCapacity(count + 1);
+        value[count++] = b;
+        return this;
+    }
+
+    /**
+     * Appends an integer to the end of this byte buffer.
+     * @param i the integer to append to this byte buffer
+     * @return the original <CODE>ByteBuf</CODE> object (not a new object)
+     * with the string representation of the specified integer appended.
+     */
+    public ByteBuf append(int i) {
+        return append(String.valueOf(i));
+    }
+
+    /**
+     * Appends a <CODE>long</CODE> value to the end of this byte buffer.
+     * @param l the <CODE>long</CODE> value to append to this buffer
+     * @return the original <CODE>ByteBuf</CODE> object (not a new object)
+     * with the string representation of the specified <CODE>long</CODE>
+     * value appended.
+     */
+    public ByteBuf append(long l) {
+        return append(String.valueOf(l));
+    }
+
+    /**
+     * Appends a <CODE>float</CODE> to the end of this byte buffer.
+     * @param f the <CODE>float</CODE> value to append to this buffer
+     * @return the original <CODE>ByteBuf</CODE> object (not a new object)
+     * with the string representation of the specified <CODE>float</CODE>
+     * value appended.
+     */
+    public ByteBuf append(float f) {
+        return append(String.valueOf(f));
+    }
+
+    /**
+     * Appends a <CODE>double</CODE> to the end of this byte buffer.
+     * @param d the <CODE>double</CODE> value to append to this buffer
+     * @return the original <CODE>ByteBuf</CODE> object (not a new object)
+     * with the string representation of the specified <CODE>double</CODE>
+     * value appended.
+     */
+    public ByteBuf append(double d) {
+        return append(String.valueOf(d));
+    }
+
+    /**
+     * Returns the data in the byte buffer to a string.
+     * @return the string representation of the data in the byte buffer.
+     */
+    public String toString() {
+        return new String(value, 0, count);
+    }
+
+    /**
+     * Returns the data in the byte buffer as a byte array.
+     * @return the byte array containing data in the byte buffer.
+     */
+    public byte[] toBytes() {
+        byte[] b = new byte[count];
+        System.arraycopy(value, 0, b, 0, count);
+        return b;
+    }
+
+    /**
+     * Invokes the <CODE>InputStream.read</CODE> method and appends the
+     * the bytes read to this byte buffer.
+     * @param file the input stream from which to read the bytes
+     * @param max_bytes the maximum number of bytes to read into the
+     * byte buffer
+     * @return the number of bytes read, or -1 if there is no more data
+     * to read.
+     * @exception IOException An I/O error has occurred.
+     */
+    public int read(InputStream file, int max_bytes)
+      throws IOException {
+        ensureCapacity(count + max_bytes);
+        int i = file.read(value, count, max_bytes);
+        if (i > 0) count += i;
+        return i;
+    }
+
+    /**
+     * Invokes the <CODE>RandomAccessFile.read</CODE> method, appending
+     * the bytes read to this byte buffer.
+     * @param file the <CODE>RandomAccessFile</CODE> object from which 
+     * to read the bytes
+     * @param max_bytes the maximum number of bytes to read into the
+     * byte buffer
+     * @return the number of bytes read, or -1 if there is no more data
+     * to read.
+     * @exception IOException An I/O error has occurred.
+     */
+    public int read(RandomAccessFile file, int max_bytes)
+      throws IOException {
+        ensureCapacity(count + max_bytes);
+        int i = file.read(value, count, max_bytes);
+        if (i > 0) count += i;
+        return i;
+    }
+
+    /**
+     * Writes the contents of the byte buffer to the specified output stream.
+     * @param out the output stream
+     * @exception IOException An I/O error has occurred.
+     */
+    public void write(OutputStream out) throws IOException {
+        out.write(value, 0, count);
+    }
+
+    /**
+     * Writes the contents of the byte buffer to the specified
+     * <CODE>RandomAccessFile</CODE> object.
+     * @param out the <CODE>RandomAccessFile</CODE> object
+     * dexception IOException An I/O error has occurred.
+     */
+    public void write(RandomAccessFile out) throws IOException {
+        out.write(value, 0, count);
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDAPIntFilterSet.java
@@ -0,0 +1,159 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ *  Represents an LDAPIntFilterSet object.  This is an internal object that
+ *  should never be instantiated directly by the developer.
+ */
+
+public class LDAPIntFilterSet {
+
+    private Vector m_vLDAPIntFilterList;
+    private String m_strTag;
+
+    private Matcher m_matcher = null;
+    /**
+     * Return a Vector of filters that match botht the tag pattern
+     * (in Perl5Pattern form), and the string strValue.  This method
+     * should only be called by LDAPFilterDescriptor().
+     */
+
+     // remember, we have the string (m_strTag), the pattern has
+     // been precompiled by the LDAPFilterDescriptor (patTag)
+    Vector getFilters ( Pattern patTag,
+                String matcherValue ) {
+        Vector vRet = new Vector();
+
+        if ( m_matcher == null ) {
+            m_matcher = patTag.matcher(m_strTag);
+        }
+
+        // Check to see if the strTag (converted into patTag)
+        // matches the tag string from the file (converted into
+        // m_matcherTag)
+        if ( m_matcher.find() ) {
+            LDAPIntFilterList tmpIntFilterList;
+            LDAPFilter tmpFilter;
+            for ( int i = 0; i < m_vLDAPIntFilterList.size(); i++ ) {
+                tmpIntFilterList =
+                  (LDAPIntFilterList)m_vLDAPIntFilterList.elementAt ( i );
+
+                if ( tmpIntFilterList.MatchFilter ( matcherValue ) ) {
+                    for (int j=0; j < tmpIntFilterList.numFilters(); j++ ) {
+                        vRet.addElement ( tmpIntFilterList.getFilter ( j ));
+                    }
+                    // potential BUGBUG, i'm not sure if we want
+                    // to get out  of this loop now or if we just
+                    // want to get out of the external loop.  For
+                    // now, go with the former.
+                    return vRet;
+                }
+            }
+        }
+
+        return vRet;
+    }
+
+    /**
+     * Create an LDAPIntFilterSet with a given Tag string.  The tag
+     * string specifies which applications or query types should use
+     * this filter set.  It is normally a single token on a line by
+     * itself in the filter configuration file. <p>
+     * For more information about the filter configuration file, see
+     * the man page for ldapfilter.conf.
+     */
+    public LDAPIntFilterSet ( String strTag ) {
+        m_strTag = strTag;
+        m_vLDAPIntFilterList = new Vector();
+    }
+
+    /**
+     * Add a new filter to this filter set.
+     *
+     * @exception netscape.ldap.util.BadFilterException
+     *    If the regular expression pattern given in the first token
+     *    is bad.
+     */
+    void newFilter ( LDAPFilter filter ) throws BadFilterException {
+        LDAPIntFilterList tmpFilterList = new LDAPIntFilterList( filter );
+        m_vLDAPIntFilterList.addElement ( tmpFilterList );
+    }
+
+    /**
+     * Append a new filter to the existing set.  This happens when the
+     * LDAPFilterDescriptor object reads a line from the filter
+     * configuration file that has 2 or 3 tokens.
+     */
+    void appendFilter ( LDAPFilter filter ) {
+        ((LDAPIntFilterList)m_vLDAPIntFilterList.lastElement()).AddFilter ( filter );
+    }
+
+
+
+    /**
+     * Return true if this filter set matches the regular expression
+     * string that is passed in.
+     */
+    boolean match ( String strTagPat ) {
+    	return Pattern.matches(strTagPat, m_strTag);
+    }
+
+    /**
+     * Print out the String representation of this object.  It calls
+     * the toString() method of all the LDAPFilter objects contained
+     * within it's set.
+     *
+     * @see LDAPFilter#toString()
+     */
+    public String toString() {
+        StringBuffer strBuf = new StringBuffer ( 2000 );
+        strBuf.append ( "  strTag: " + m_strTag + "\n" );
+        for ( int i = 0; i < m_vLDAPIntFilterList.size(); i++ ) {
+            strBuf.append ( "  filter #: " + i + "\n" );
+            strBuf.append (
+                ((LDAPIntFilterList)m_vLDAPIntFilterList.elementAt(i)).toString() );
+            strBuf.append ( "\n" );
+        }
+        return strBuf.toString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIFAddContent.java
@@ -0,0 +1,111 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import netscape.ldap.LDAPAttribute;
+
+/**
+ *
+ * An object of this class represents the content of an LDIF record that
+ * specifies a new entry to be added.  This class implements the
+ * <CODE>LDIFContent</CODE> interface.
+ * <P>
+ *
+ * To get this object from an <CODE>LDIFRecord</CODE> object,
+ * use the <CODE>getContent</CODE> method and cast the return value as
+ * <CODE>LDIFAddContent</CODE>.
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.LDIFRecord#getContent
+ */
+public class LDIFAddContent extends LDIFBaseContent {
+
+    /**
+     * Internal variables
+     */
+    private LDAPAttribute m_attrs[] = null;
+    static final long serialVersionUID = -665548826721177756L;
+
+    /**
+     * Constructs a new <CODE>LDIFAddContent</CODE> object with
+     * the specified attributes.
+     * @param attrs an array of <CODE>LDAPAttribute</CODE> objects
+     * representing the attributes of the entry to be added
+     */
+    public LDIFAddContent(LDAPAttribute attrs[]) {
+        m_attrs = attrs;
+    }
+
+    /**
+     * Returns the content type. You can use this with the
+     * <CODE>getContent</CODE> method of the <CODE>LDIFRecord</CODE>
+     * object to determine the type of content specified in the record.
+     * @return the content type (which is
+     * <CODE>LDIFContent.ADD_CONTENT</CODE>).
+     * @see netscape.ldap.util.LDIFRecord#getContent
+     */
+    public int getType() {
+        return ADD_CONTENT;
+    }
+
+    /**
+     * Retrieves the list of the attributes specified in the content
+     * of the LDIF record.
+     * @return an array of <CODE>LDAPAttribute</CODE> objects that
+     * represent the attributes specified in the content of the LDIF record.
+     */
+    public LDAPAttribute[] getAttributes() {
+        return m_attrs;
+    }
+
+    /**
+     * Returns the string representation of the content of the LDIF record.
+     * @return the string representation of the content of the LDIF record.
+     */
+    public String toString() {
+        String s = "";
+        for (int i = 0; i < m_attrs.length; i++) {
+            s = s + m_attrs[i].toString();
+        }
+        if ( getControls() != null ) {
+            s += getControlString();
+        }
+        return "LDIFAddContent {" + s + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/BadFilterException.java
@@ -0,0 +1,103 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+/**
+ * The exception thrown when there is a problem with either an LDAPFilter
+ * or with the File/URL/Buffer form which we're creating the LDAPFilter.
+ *
+ * @see LDAPFilter
+ * @see LDAPFilterDescriptor
+ * @version 1.0
+ */
+public class BadFilterException extends Exception {
+
+    private String m_strException;
+    private int m_nLine = -1;
+
+    /**
+     * Creates an <b>Unknown</b> BadFilterException
+     */
+    public BadFilterException () {
+        m_strException = "Unknown Error";
+    }
+
+    /**
+     * Creates a BadFilterException with the
+     * given string
+     */
+    public BadFilterException ( String s ) {
+        m_strException = s;
+    }
+
+    /**
+     * Creates a BadFilterException with the
+     * given string and line number
+     */
+    public BadFilterException ( String s, int nErrorLineNumber ) {
+        m_strException = s;
+        m_nLine = nErrorLineNumber;
+    }
+
+    /**
+     * Returns the exception string.
+     */
+    public String toString() {
+        return m_strException;
+    }
+
+
+    /**
+     * If appropriate, return the line number of the ldapfilter.conf
+     * file (or url or buffer) where this error occurred.  This method
+     * will return -1 if the line number was not set.
+     */
+    public int getErrorLineNumber() {
+        return m_nLine;
+    }
+
+    /**
+     * Set the line number in the ldapfilter.conf file/url/buffer where
+     * this error occurred.
+     */
+    void setErrorLineNumber ( int nErrorLineNumber ) {
+        m_nLine = nErrorLineNumber;
+    }
+}
+
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/util/LDIFRecord.java
@@ -0,0 +1,214 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.util;
+
+import java.io.Serializable;
+import netscape.ldap.LDAPControl;
+
+/**
+ * An object of this class represents an LDIF record in an LDIF
+ * file (or in LDIF data). A record can contain a list of attributes
+ * (which describes an entry) or a list of modifications (which
+ * decribes the changes that need to be made to an entry).
+ * Each record also has a distinguished name.
+ * <P>
+ *
+ * You can get an <CODE>LDIFRecord</CODE> object from LDIF data
+ * by calling the <CODE>nextRecord</CODE> method of the
+ * <CODE>LDIF</CODE> object holding the data.
+ * <P>
+ *
+ * If you are constructing a new <CODE>LDIFRecord</CODE> object,
+ * you can specify the content of the record in one of the
+ * following ways:
+ * <P>
+ *
+ * <UL>
+ * <LI>To create a record that specifies an entry, use an object of
+ * the <CODE>LDIFAttributeContent</CODE> class.
+ * <LI>To create a record that specifies a modification to be made,
+ * use an object of one of the following classes:
+ * <UL>
+ * <LI>Use <CODE>LDIFAddContent</CODE> to add a new entry.
+ * <LI>Use <CODE>LDIFModifyContent</CODE> to modify an entry.
+ * <LI>Use <CODE>LDIFDeleteContent</CODE> to delete an entry.
+ * </UL>
+ * </UL>
+ * <P>
+ *
+ * @version 1.0
+ * @see netscape.ldap.util.LDIF
+ * @see netscape.ldap.util.LDIFAddContent
+ * @see netscape.ldap.util.LDIFModifyContent
+ * @see netscape.ldap.util.LDIFDeleteContent
+ * @see netscape.ldap.util.LDIFAttributeContent
+ */
+public class LDIFRecord implements Serializable {
+
+    /**
+     * Internal variables
+     */
+    private String m_dn = null;
+    private LDIFBaseContent m_content = null;
+    static final long serialVersionUID = -6537481934870076178L;
+
+    /**
+     * Constructs a new <CODE>LDIFRecord</CODE> object with the
+     * specified content.
+     * @param dn distinguished name of the entry associated with
+     * the record
+     * @param content content of the LDIF record.  You can specify
+     * an object of the <CODE>LDIFAttributeContent</CODE>,
+     * <CODE>LDIFAddContent</CODE>, <CODE>LDIFModifyContent</CODE>,
+     * or <CODE>LDIFDeleteContent</CODE> classes.
+     * @see netscape.ldap.util.LDIFAddContent
+     * @see netscape.ldap.util.LDIFModifyContent
+     * @see netscape.ldap.util.LDIFDeleteContent
+     * @see netscape.ldap.util.LDIFAttributeContent
+     */
+    public LDIFRecord(String dn, LDIFContent content) {
+        m_dn = dn;
+        m_content = (LDIFBaseContent)content;
+    }
+
+    /**
+     * Retrieves the distinguished name of the LDIF record.
+     * @return the distinguished name of the LDIF record.
+     */
+    public String getDN() {
+        return m_dn;
+    }
+
+    /**
+     * Retrieves the content of the LDIF record.  The content is
+     * an object of the <CODE>LDIFAttributeContent</CODE>,
+     * <CODE>LDIFAddContent</CODE>, <CODE>LDIFModifyContent</CODE>,
+     * or <CODE>LDIFDeleteContent</CODE> classes.
+     * <P>
+     *
+     * To determine the class of the object, use the <CODE>getType</CODE>
+     * method of that object.  <CODE>getType</CODE> returns one of
+     * the following values:
+     * <UL>
+     * <LI><CODE>LDIFContent.ATTRIBUTE_CONTENT</CODE> (the object is an
+     * <CODE>LDIFAttributeContent</CODE> object)
+     * <LI><CODE>LDIFContent.ADD_CONTENT</CODE> (the object is an
+     * <CODE>LDIFAddContent</CODE> object)
+     * <LI><CODE>LDIFContent.MODIFICATION_CONTENT</CODE> (the object is an
+     * <CODE>LDIFModifyContent</CODE> object)
+     * <LI><CODE>LDIFContent.DELETE_CONTENT</CODE> (the object is an
+     * <CODE>LDIFDeleteContent</CODE> object)
+     * </UL>
+     * <P>
+     *
+     * For example:
+     * <PRE>
+     * ...
+     * import netscape.ldap.*;
+     * import netscape.ldap.util.*;
+     * import java.io.*;
+     * import java.util.*;
+     * ...
+     *     try {
+     *         // Parse the LDIF file test.ldif.
+     *         LDIF parser = new LDIF( "test.ldif" );
+     *         // Iterate through each LDIF record in the file.
+     *         LDIFRecord nextRec = parser.nextRecord();
+     *         while ( nextRec != null ) {
+     *             // Based on the type of content in the record,
+     *             // get the content and cast it as the appropriate
+     *             // type.
+     *             switch( nextRec.getContent().getType() ) {
+     *                 case LDIFContent.ATTRIBUTE_CONTENT:
+     *                     LDIFAttributeContent attrContent =
+     *                         (LDIFAttributeContent)nextRec.getContent();
+     *                     break;
+     *                 case LDIFContent.ADD_CONTENT:
+     *                     LDIFAddContent addContent =
+     *                         (LDIFAddContent)nextRec.getContent();
+     *                     break;
+     *                 case LDIFContent.MODIFICATION_CONTENT:
+     *                     LDIFModifyContent modifyContent =
+     *                         (LDIFModifyContent)nextRec.getContent();
+     *                     break;
+     *                 case LDIFContent.DELETE_CONTENT:
+     *                     LDIFDeleteContent deleteContent =
+     *                         (LDIFDeleteContent)nextRec.getContent();
+     *                     break;
+     *             }
+     *             ...
+     *             // Iterate through each record.
+     *             nextRec = parser.nextRecord();
+     *         }
+     *     } catch ( IOException e ) {
+     *         System.out.println( "Error: " + e.toString() );
+     *         System.exit(1);
+     *     }
+     * ...
+     * </PRE>
+     *
+     * @return the content of the LDIF record.
+     * @see netscape.ldap.util.LDIFAddContent
+     * @see netscape.ldap.util.LDIFModifyContent
+     * @see netscape.ldap.util.LDIFDeleteContent
+     * @see netscape.ldap.util.LDIFAttributeContent
+     */
+    public LDIFContent getContent() {
+        return m_content;
+    }
+
+    /**
+     * Retrieves the list of controls specified in the content
+     * of the LDIF record, if any.
+     * @return an array of <CODE>LDAPControl</CODE> objects that
+     * represent any controls specified in the LDIF record,
+     * or <CODE>null</CODE> if none were specified.
+     */
+    public LDAPControl[] getControls() {
+        return (m_content == null) ? null : m_content.getControls();
+    }
+
+    /**
+     * Gets the string representation of the <CODE>LDIFRecord</CODE>
+     * object.
+     * @return the string representation of the LDIF record.
+     */
+    public String toString() {
+        return "LDIFRecord {dn=" + m_dn + ", content=" + m_content + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/errors/ErrorCodes_ja.props
@@ -0,0 +1,52 @@
+0=\u6210\u529F
+1=\u30AA\u30DA\u30EC\u30FC\u30B7\u30E7\u30F3 \u30A8\u30E9\u30FC
+2=\u30D7\u30ED\u30C8\u30B3\u30EB \u30A8\u30E9\u30FC
+3=\u5236\u9650\u6642\u9593\u3092\u8D85\u904E\u3057\u307E\u3057\u305F
+4=\u5BB9\u91CF\u306E\u9650\u754C\u3092\u8D85\u904E\u3057\u307E\u3057\u305F
+5=\u6BD4\u8F03\u7D50\u679C false
+6=\u6BD4\u8F03\u7D50\u679C true
+7=\u53B3\u5BC6\u306A\u8A8D\u8A3C\u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002
+8=\u53B3\u5BC6\u306A\u8A8D\u8A3C\u304C\u5FC5\u8981\u3067\u3059\u3002
+9=\u90E8\u5206\u7684\u306A\u7D50\u679C\u3068\u30EC\u30D5\u30A7\u30E9\u30EB\u3092\u53D7\u4FE1\u3057\u307E\u3057\u305F
+10=\u30EC\u30D5\u30A7\u30E9\u30EB\u3092\u53D7\u4FE1\u3057\u307E\u3057\u305F\u3002
+11=\u7BA1\u7406\u306E\u7BC4\u56F2\u3092\u8D85\u3048\u3066\u3044\u307E\u3059\u3002
+12=\u5FC5\u9808\u306E\u30A8\u30AF\u30B9\u30C6\u30F3\u30B7\u30E7\u30F3\u304C\u3042\u308A\u307E\u305B\u3093
+13=\u6A5F\u5BC6\u6027\u304C\u5FC5\u8981\u3067\u3059\u3002
+14=SASL \u30D0\u30A4\u30F3\u30C9\u4E2D\u3067\u3059\u3002
+16=\u305D\u306E\u3088\u3046\u306A\u5C5E\u6027\u306F\u3042\u308A\u307E\u305B\u3093\u3002
+17=\u5C5E\u6027\u306E\u7A2E\u985E\u304C\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002
+18=\u30DE\u30C3\u30C1\u30F3\u30B0\u304C\u4E0D\u9069\u5207\u3067\u3059\u3002
+19=\u5236\u7D04\u9055\u53CD\u3067\u3059\u3002
+20=\u30BF\u30A4\u30D7\u307E\u305F\u306F\u5024\u304C\u5B58\u5728\u3057\u307E\u3059\u3002
+21=\u69CB\u6587\u306B\u8AA4\u308A\u304C\u3042\u308A\u307E\u3059\u3002
+32=\u305D\u306E\u3088\u3046\u306A\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u306F\u3042\u308A\u307E\u305B\u3093\u3002
+33=\u30A8\u30A4\u30EA\u30A2\u30B9\u306B\u554F\u984C\u304C\u3042\u308A\u307E\u3059\u3002
+34=DN \u306E\u69CB\u6587\u306B\u8AA4\u308A\u304C\u3042\u308A\u307E\u3059\u3002
+35=\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u306F\u30EA\u30FC\u30D5\u30CE\u30FC\u30C9\u3067\u3059\u3002
+36=\u30A8\u30A4\u30EA\u30A2\u30B9 \u30C7\u30EA\u30D5\u30A1\u30EC\u30F3\u30B9\u306B\u554F\u984C\u304C\u3042\u308A\u307E\u3059\u3002
+48=\u8A8D\u8A3C\u304C\u4E0D\u9069\u5F53\u3067\u3059\u3002
+49=\u8A3C\u660E\u66F8\u304C\u7121\u52B9\u3067\u3059\u3002
+50=\u30A2\u30AF\u30BB\u30B9\u6A29\u304C\u3042\u308A\u307E\u305B\u3093\u3002
+51=DSA \u304C\u30D3\u30B8\u30FC\u72B6\u614B\u3067\u3059\u3002
+52=DSA \u304C\u5229\u7528\u3067\u304D\u307E\u305B\u3093\u3002
+53=DSA \u304C\u5B9F\u884C\u3055\u308C\u307E\u305B\u3093\u3002
+54=\u30EB\u30FC\u30D7\u304C\u691C\u51FA\u3055\u308C\u307E\u3057\u305F\u3002
+64=\u540D\u524D\u4ED8\u3051\u9055\u53CD
+65=\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8 \u30AF\u30E9\u30B9\u9055\u53CD
+66=\u30EA\u30FC\u30D5\u30CE\u30FC\u30C9\u4EE5\u5916\u3067\u30AA\u30DA\u30EC\u30FC\u30B7\u30E7\u30F3\u3092\u884C\u3046\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002
+67=RDN \u3067\u30AA\u30DA\u30EC\u30FC\u30B7\u30E7\u30F3\u3092\u884C\u3046\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002
+68=\u65E2\u306B\u5B58\u5728\u3057\u3066\u3044\u307E\u3059\u3002
+69=\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8 \u30AF\u30E9\u30B9\u3092\u5909\u66F4\u3067\u304D\u307E\u305B\u3093\u3002
+71=\u8907\u6570\u306E DSA \u306B\u5F71\u97FF\u3057\u307E\u3059
+80=\u539F\u56E0\u4E0D\u660E\u306E\u30A8\u30E9\u30FC
+81=LDAP \u30B5\u30FC\u30D0\u3068\u901A\u4FE1\u3067\u304D\u307E\u305B\u3093
+85=\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u304C\u5236\u9650\u6642\u9593\u3092\u8D85\u904E\u3057\u307E\u3057\u305F
+89=LDAP \u30E1\u30BD\u30C3\u30C9\u306B\u4E0D\u6B63\u306A\u30D1\u30E9\u30E1\u30FC\u30BF\u304C\u6E21\u3055\u308C\u307E\u3057\u305F
+91=LDAP \u30B5\u30FC\u30D0\u306B\u63A5\u7D9A\u3067\u304D\u307E\u305B\u3093
+92=\u3053\u306E\u30D0\u30FC\u30B8\u30E7\u30F3\u306E LDAP \u30D7\u30ED\u30C8\u30B3\u30EB\u3067\u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002
+93=\u8981\u6C42\u3055\u308C\u305F LDAP \u30B3\u30F3\u30C8\u30ED\u30FC\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002
+94=\u7D50\u679C\u304C\u8FD4\u3055\u308C\u307E\u305B\u3093\u3002
+95=\u3055\u3089\u306B\u7D50\u679C\u304C\u8FD4\u3055\u308C\u307E\u3059\u3002
+96=\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u304C\u30EB\u30FC\u30D7\u3092\u691C\u51FA\u3057\u307E\u3057\u305F\u3002
+97=\u30EC\u30D5\u30A7\u30E9\u30EB \u30DB\u30C3\u30D7 \u30EA\u30DF\u30C3\u30C8\u3092\u8D85\u904E\u3057\u307E\u3057\u305F\u3002
+112=TLS\u3092\u-6a75\u59cb\u3067\u304d\u307e\u305b\u3093\u3002
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/errors/ErrorCodes_de.props
@@ -0,0 +1,52 @@
+0=Erfolg
+1=Fehler bei Operation
+2=Protokollfehler
+3=Zeitbeschrnkung berschritten
+4=Grenbeschrnkung berschritten
+5=Vergleich meldet Ergebnis FALSCH
+6=Vergleich meldet Ergebnis WAHR
+7=Intensive Echtheitsprfung wird nicht untersttzt
+8=Intensive Echtheitsprfung erforderlich
+9=Teilergebnisse und Referenze empfangen
+10=Referenze empfangen
+11=Verwaltungsbeschrnkung berschritten
+12=Kritische Erweiterung nicht verfgbar
+13=Vertraulichkeit erforderlich
+14=SASL-Bindung luft
+16=Attribut nicht vorhanden
+17=Nicht definierter Attributtyp
+18=Keine geeignete bereinstimmung
+19=Versto gegen Beschrnkung
+20=Typ oder Wert ist vorhanden
+21=Ungltige Syntax
+32=Objekt nicht vorhanden
+33=Alias-Problem
+34=Ungltige DN-Syntax
+35=Objekt ist ein Blattobjekt
+36=Problem beim Auflsen einer Alias-Referenz
+48=Unpassende Echtheitsprfung
+49=Ungltige Echtheitsnachweise
+50=Ungengender Zugriff
+51=LDAP-Server ist belegt
+52=LDAP-Server ist nicht verfgbar
+53=LDAP-Server ist nicht zur Durchfhrung bereit
+54=Schleife festgestellt
+64=Versto gegen Benennungsregeln
+65=Versto gegen Objektklasse
+66=Operation ist nur bei Blattobjekten zulssig
+67=Operation nicht fr RDN zulssig
+68=Bereits vorhanden
+69=Objektklasse kann nicht gendert werden
+71=Wirkt sich auf mehrere LDAP-Servers aus
+80=Unbekannter Fehler
+81=Verbindung zu LDAP-Server nicht mglich
+85=Client-Zeitbeschrnkung berschritten
+89=Falscher Parameter fr LDAP-Methode
+91=Verbindung zu LDAP-Server nicht mglich
+92=Wird von dieser Version des LDAP-Protokolls nicht untersttzt
+93=Angeforderte LDAP-Steuerung wurde nicht gefunden
+94=Es wurden keine Ergebnisse zurckgegeben
+95=Es stehen noch weitere Ergebnisse zur Verfgung
+96=Client stellte Schleife fest
+97=Beschrnkung fr Zwischenschritte bei Referenz berschritten
+112=TLS kann nicht activiert werden
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/errors/ErrorCodes.props
@@ -0,0 +1,52 @@
+0=Success
+1=Operations error
+2=Protocol error
+3=Timelimit exceeded
+4=Sizelimit exceeded
+5=Compare false
+6=Compare true
+7=Strong authentication not supported
+8=Strong authentication required
+9=Partial results and referral received
+10=Referral received
+11=Administrative limit exceeded
+12=Critical extension unavailable
+13=Confidentiality required
+14=SASL bind in progress
+16=No such attribute
+17=Undefined attribute type
+18=Inappropriate matching
+19=Constraint violation
+20=Type or value exists
+21=Invalid syntax
+32=No such object
+33=Alias problem
+34=Invalid DN syntax
+35=Object is a leaf
+36=Alias dereferencing problem
+48=Inappropriate authentication
+49=Invalid credentials
+50=Insufficient access
+51=LDAP server is busy
+52=LDAP server is unavailable
+53=LDAP server is unwilling to perform
+54=Loop detected
+64=Naming violation
+65=Object class violation
+66=Operation not allowed on nonleaf
+67=Operation not allowed on RDN
+68=Already exists
+69=Cannot modify object class
+71=Affects multiple LDAP servers
+80=Unknown error
+81=Cannot contact LDAP server
+85=Client Timelimit exceeded
+89=Bad parameter to an LDAP method
+91=Cannot connect to the LDAP server
+92=Not supported by this version of the LDAP protocol
+93=Requested LDAP control not found
+94=No results returned
+95=More results to return
+96=Client detected loop
+97=Referral hop limit exceeded
+112=Cannot start TLS
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/errors/ErrorCodes_fr.props
@@ -0,0 +1,52 @@
+0=Succs
+1=Erreur d'oprations
+2=Erreur de protocole
+3=Dlai dpass
+4=Taille dpasse
+5=Comparaison fausse
+6=Comparaison vraie
+7=Authentification forte non prise en charge
+8=Authentification forte requise
+9=Rfrences et rsultats partiels trouvs
+10=Rfrences trouvs
+11=Limite dpasse
+12=Extension critique non disponible
+13=Confidentialit requise
+14=Liaison SASL en cours
+16=Aucun attribut de ce type
+17=Type d'attribut non dfini
+18=Correspondance inadquate
+19=Violation de contrainte
+20=Type ou valeur existant
+21=Syntaxe non valide
+32=Aucun objet de ce type
+33=Problme d'alias
+34=Syntaxe DN non valide
+35=L'objet est une feuille
+36=Problme de suppression d'une rfrence  un alias
+48=Authentification inadquate
+49=Rfrences non valides
+50=Accs insuffisant
+51=Le serveur LDAP est occup
+52=Le serveur LDAP n'est pas disponible
+53=Le serveur LDAP ne veut pas traiter la demande
+54=Boucle dtecte
+64=Violation d'attribution de nom
+65=Violation de classe d'objet
+66=Opration non autorise sur un noeud
+67=Opration non autorise sur RDN
+68=Existe dj
+69=Impossible de modifier la classe d'objet
+71=Concerne plusieurs serveurs LDAP
+80=Erreur inconnue
+81=Impossible de contacter le serveur LDAP
+85=Client dlai dpass
+89=Mauvais paramtre attribu  une mthode LDAP
+91=Impossible d'tablir une connexion au serveur LDAP
+92=Non pris en charge par cette version du protocole LDAP
+93=Commande LDAP demande introuvable
+94=Aucun rsultat renvoy
+95=Autres rsultats  venir
+96=Client a dtect la boucle
+97=Nombre de rebonds sur rfrence trop grand
+112=Impossible d'activer TLS
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterNot.java
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the filter not.
+ * See RFC 1777.
+ * <pre>
+ *   not [2] Filter
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterNot extends JDAPFilter {
+
+    /**
+     * Internal variables
+     */
+    private JDAPFilter m_filter = null;
+
+    /**
+     * Constructs the filter.
+     */
+    public JDAPFilterNot(JDAPFilter filter) {
+        super();
+        m_filter = filter;
+    }
+
+    /**
+     * Gets ber representation of the filter.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        BERTag element = new BERTag(BERTag.CONSTRUCTED|BERTag.CONTEXT|2,
+          m_filter.getBERElement(), false /* true */);
+        return element;
+    }
+
+    /**
+     * Gets string reprensetation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPFilterNot {" + m_filter.toString() + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPAVA.java
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import java.io.*;
+import netscape.ldap.ber.stream.*;
+
+/**
+ * This class implements the attribute value assertion.
+ * This object is used with filters.
+ * <pre>
+ * AttributeValueAssertion ::= SEQUENCE {
+ *   attributType AttributeType,
+ *   attributValue AttributeValue
+ * }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPAVA {
+    /**
+     * Internal variables
+     */
+    protected String m_type = null;
+    protected String m_val = null;
+
+    /**
+     * Constructs the attribute value assertion.
+     * @param type attribute type
+     * @param val attribute value
+     */
+    public JDAPAVA(String type, String val) {
+        m_type = type;
+        m_val = val;
+    }
+
+    /**
+     * Retrieves the AVA type.
+     * @return AVA type
+     */
+    public String getType() {
+        return m_type;
+    }
+
+    /**
+     * Retrieves the AVA value.
+     * @return AVA value
+     */
+    public String getValue() {
+        return m_val;
+    }
+
+    /**
+     * Retrieves the ber representation.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BEROctetString(m_type));
+
+        seq.addElement(JDAPFilterOpers.getOctetString(m_val));
+
+        return seq;
+    }
+
+    /**
+     * Retrieves the string representation parameters.
+     * @return string representation parameters
+     */
+    public String getParamString() {
+        return "{type=" + m_type + ", value=" + m_val + "}";
+    }
+
+    /**
+     * Retrieves the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPAVA " + getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterGreaterOrEqual.java
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the greater or equal filter.
+ * See RFC 1777.
+ * <pre>
+ * greaterOrEqual [5] AttributeValueAssertion
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterGreaterOrEqual extends JDAPFilterAVA {
+    /**
+     * Constructs greater or equal filter.
+     * @param ava attribute value assertion
+     */
+    public JDAPFilterGreaterOrEqual(JDAPAVA ava) {
+        super(BERTag.CONSTRUCTED|BERTag.CONTEXT|5, ava);
+    }
+
+    /**
+     * Retrieves the string representation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPFilterGreaterOrEqual {" +
+          super.getAVA().toString() + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterSet.java
@@ -0,0 +1,105 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the base class of filter "and" and filter "or".
+ *
+ * @version 1.0
+ */
+public abstract class JDAPFilterSet extends JDAPFilter {
+    /**
+     * Internal variables
+     */
+    private int m_tag;
+    private Vector m_set = new Vector();
+
+    /**
+     * Constructs the filter set.
+     * @param tag tag
+     */
+    public JDAPFilterSet(int tag) {
+        super();
+        m_tag = tag;
+    }
+
+    /**
+     * Adds filter into the filter set.
+     * @param filter adding filter
+     */
+    public void addElement(JDAPFilter filter) {
+        m_set.addElement(filter);
+    }
+
+    /**
+     * Gets the ber representation of the filter.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        try {
+            BERSet filters = new BERSet();
+            for (int i = 0; i < m_set.size(); i++) {
+                JDAPFilter f = (JDAPFilter)m_set.elementAt(i);
+                filters.addElement(f.getBERElement());
+            }
+            BERTag element = new BERTag(m_tag, filters, true);
+            return element;
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Gets the filter set parameters.
+     * @return set parameters
+     */
+    public String getParamString() {
+        String s = "";
+        for (int i = 0; i < m_set.size(); i++) {
+            if (i != 0)
+                s = s + ",";
+            JDAPFilter f = (JDAPFilter)m_set.elementAt(i);
+            s = s + f.toString();
+        }
+        return s;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterEqualityMatch.java
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the equality match filter.
+ * See RFC 1777.
+ * <pre>
+ * equalityMatch [3] AttributeValueAssertion
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterEqualityMatch extends JDAPFilterAVA {
+    /**
+     * Constructs less or equal filter.
+     * @param ava attribute value assertion
+     */
+    public JDAPFilterEqualityMatch(JDAPAVA ava) {
+        super(BERTag.CONSTRUCTED|BERTag.CONTEXT|3, ava);
+    }
+
+    /**
+     * Retrieves the string representation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPFilterEqualityMatch {" +
+          super.getAVA().toString() + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterAnd.java
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the filter And.
+ * <pre>
+ *   and [0] SET OF Filter
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterAnd extends JDAPFilterSet {
+    /**
+     * Constructs the filter.
+     */
+    public JDAPFilterAnd() {
+        super(BERTag.CONSTRUCTED|BERTag.CONTEXT|0);
+    }
+
+    /**
+     * Gets string reprensetation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPFilterAnd {" + super.getParamString() + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterOpers.java
@@ -0,0 +1,195 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.Vector;
+import java.io.*;
+import netscape.ldap.ber.stream.*;
+
+/**
+ * This class provides miscellaneous operations for JDAPFilter object.
+ * It converts string with escape characters to the byte array. It also
+ * returns the ber octet string for the specified string with escape
+ * characters.
+ */
+public class JDAPFilterOpers {
+
+    private static final String escapeKey = "\\";
+    private static final boolean m_debug = false;
+
+    /**
+     * Returns the octetString for the given string
+     * @return The octetString for the given string
+     */
+    static BEROctetString getOctetString(String str) {
+        if (str.indexOf(escapeKey) >= 0) {
+            byte[] byteVal = JDAPFilterOpers.getByteValues(str);
+            return new BEROctetString(byteVal);
+        }
+        else
+            return new BEROctetString(str);
+    }
+
+    /**
+     * Preprocess the LDAPv2 RFC1960 style filter escape sequences (precede
+     * a character with a a backslash) and convert them into the
+     * LDAPv3 style RFC2254 escape sequences (encode a character as a backslash
+     * followed by the two hex digits representing the character ASCII value).
+     * 
+     * LDAPv3 style unescaping is done from the getByteValues()method. We must 
+     * process LDAPv2 escaped characters earlier to get rid of possible "\(" \)"
+     * sequences which would make filter parsing in the JDAPFilter operate incorrectly.
+     */
+    public static String convertLDAPv2Escape(String filter) {
+       
+        if (filter.indexOf('\\') < 0) {
+            return filter;
+        }
+        
+        StringBuffer sb = new StringBuffer();
+        int i=0, start=0, len=filter.length();
+        while(start < len && (i = filter.indexOf('\\', start)) >= 0 ) {
+            sb.append(filter.substring(start, i+1)); // include also '\'
+            try {
+                char c = filter.charAt(i+1);
+
+                if ((c >= ' ' && c < 127) && !isHexDigit(c)) {    
+                    sb.append(Integer.toHexString(c));
+                }
+                else {
+                    sb.append(c);
+                }
+                
+                start = i + 2;
+            }
+            catch (IndexOutOfBoundsException e) {
+                throw new IllegalArgumentException("Bad search filter");
+            }
+        }
+        
+        if (start < len) {
+            sb.append(filter.substring(start));
+        }
+        
+        return sb.toString();
+    }
+
+    private static boolean isHexDigit(char c) {
+        return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
+    }
+    
+    /**
+     * This method converts the given string into bytes. It also handles
+     * the escape characters embedded in the given string.
+     * @param str The given string being converted into a byte array
+     * @return A byte array
+     */
+    static byte[] getByteValues(String str) {
+        int pos = 0;
+        Vector v = new Vector();
+        String val = new String(str);
+        int totalSize = 0;
+
+        // check if any escape character in the string
+        while ((pos = val.indexOf(escapeKey)) >= 0) {
+            String s1 = val.substring(0, pos);
+
+            try {
+                byte[] b = s1.getBytes("UTF8");
+                totalSize += b.length;
+                v.addElement(b);
+            } catch (UnsupportedEncodingException e) {
+                printDebug(e.toString());
+                return null;
+            }
+
+            Integer num = null;
+
+            // decode this number to integer, exception thrown when this is not the
+            // hex
+            try {
+                String hex = "0x"+val.substring(pos+1, pos+3);
+                num = Integer.decode(hex);
+            } catch (IndexOutOfBoundsException e) {
+                printDebug(e.toString());
+                throw new IllegalArgumentException("Bad search filter");
+            } catch (NumberFormatException e) {
+                printDebug(e.toString());
+                throw new IllegalArgumentException("Bad search filter");
+            }
+
+            byte[] b = {(byte)num.intValue()};
+            totalSize += b.length;
+
+            v.addElement(b);
+
+            // skip an escape and two chars after escape
+            val = val.substring(pos+3);
+         }
+
+        if (val.length() > 0) {
+            try {
+                byte[] b = val.getBytes("UTF8");
+                totalSize += b.length;
+                v.addElement(b);
+            } catch (UnsupportedEncodingException e) {
+                printDebug(e.toString());
+                return null;
+            }
+        }
+
+        byte[] result = new byte[totalSize];
+        pos = 0;
+        for (int i=0; i<v.size(); i++) {
+            byte[] b = (byte[])v.elementAt(i);
+            System.arraycopy(b, 0, result, pos, b.length);
+            pos = pos+b.length;
+        }
+
+        return result;
+    }
+
+    /**
+     * Print debug message
+     */
+    private static void printDebug(String str) {
+        if (m_debug)
+            System.out.println(str);
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilter.java
@@ -0,0 +1,270 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the filter.
+ * <pre>
+ *   Filter ::= CHOICE {
+ *     and [0] SET OF Filter,
+ *     or [1] SET OF Filter,
+ *     not [2] Filter,
+ *     equalityMatch [3] AttributeValueAssertion,
+ *     substrings [4] SubstringFilter,
+ *     greaterOrEqual [5] AttributeValueAssertion,
+ *     lessOrEqual [6] AttributeValueAssertion,
+ *     present [7] AttributeType,
+ *     approxMatch [8] AttributeValueAssertion
+ *   }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public abstract class JDAPFilter {
+    /**
+     * Constructs a empty filter.
+     */
+    public JDAPFilter() {
+    }
+
+    /**
+     * Constructs filter from filter string specified in RFC1558.
+     * <pre>
+     * <filter> ::= '(' <filtercomp> ')'
+     * <filtercomp> ::= <and> | <or> | <not> | <item>
+     * <and> ::= '&' <filterlist>
+     * <or> ::= '|' <filterlist>
+     * <not> ::= '!' <filter>
+     * <filterlist> ::= <filter> | <filter> <filterlist>
+     * <item> ::= <simple> | <present> | <substring>
+     * <simple> ::= <attr> <filtertype> <value>
+     * <filtertype> ::= <equal> | <approx> | <greater> | <less>
+     * <equal> ::= '='
+     * <approx> ::= '~='
+     * <greater> ::= '>='
+     * <less> ::= '<='
+     * <present> ::= <attr> '=*'
+     * <substring> ::= <attr> '=' <initial> <any> <final>
+     * <initial> ::= NULL | <value>
+     * <any> ::= '*' <starval>
+     * <starval> ::= NULL | <value> '*' <starval>
+     * <final> ::= NULL | <value>
+     * </pre>
+     * @param filter filter string as specified in RFC1558
+     * @return filter
+     */
+    public static JDAPFilter getFilter(String filter) {
+        String f = new String(filter);
+        f.trim();
+        if (f.startsWith("(") && f.endsWith(")")) {
+            return getFilterComp(f.substring(1,f.length()-1));
+        }
+        return getFilterComp(filter);
+    }
+
+    /**
+     * Constructs the filter computation.
+     * @param f filter string within brackets
+     * @return filter
+     */
+    public static JDAPFilter getFilterComp(String f) {
+        f.trim();
+        if (f.startsWith("&")) {         /* and */
+            JDAPFilter filters[] = getFilterList(f.substring(1, f.length()));
+            if (filters == null) {
+                throw new IllegalArgumentException("Bad search filter");
+            }
+            JDAPFilterAnd and = new JDAPFilterAnd();
+            for (int i = 0; i < filters.length; i++) {
+                and.addElement(filters[i]);
+            }
+            return and;
+        } else if (f.startsWith("|")) {  /* or  */
+            JDAPFilter filters[] = getFilterList(f.substring(1, f.length()));
+            if (filters == null) {
+                throw new IllegalArgumentException("Bad search filter");
+            }
+            JDAPFilterOr or = new JDAPFilterOr();
+            for (int i = 0; i < filters.length; i++) {
+                or.addElement(filters[i]);
+            }
+            return or;
+        } else if (f.startsWith("!")) {  /* not */
+            JDAPFilter filter = getFilter(f.substring(1, f.length()));
+            if (filter == null) {
+                throw new IllegalArgumentException("Bad search filter");
+            }
+            return new JDAPFilterNot(filter);
+        } else {                         /* item */
+            return getFilterItem(f.substring(0, f.length()));
+        }
+    }
+
+    /**
+     * Parses a list of filters
+     * @param list filter list (i.e. (filter)(filter)...)
+     * @return list of filters
+     */
+    public static JDAPFilter[] getFilterList(String list) {
+        list.trim();
+
+        int level = 0;
+        int start = 0;
+        int end = 0;
+        Vector v = new Vector();
+
+        for (int i = 0; i < list.length(); i++) {
+            if (list.charAt(i) == '(') {
+                if (level == 0) {
+                    start = i;
+                }
+                level++;
+            }
+            if (list.charAt(i) == ')') {
+                level--;
+                if (level == 0) {
+                    end = i;
+                    v.addElement(JDAPFilter.getFilter(list.substring(start, end+1)));
+                }
+            }
+        }
+
+        if (v.size() == 0)
+            return null;
+
+        JDAPFilter f[] = new JDAPFilter[v.size()];
+        for (int i = 0; i < v.size(); i++) {
+            f[i] = (JDAPFilter)v.elementAt(i);
+        }
+
+        return f;
+    }
+
+    /**
+     * Gets filter item.
+     * @param item filter item string
+     * @return filter
+     */
+    public static JDAPFilter getFilterItem(String item) {
+        item.trim();
+        int idx = item.indexOf('=');
+        if (idx == -1)
+            return null;
+
+        String type = item.substring(0, idx).trim();
+        String value = item.substring(idx+1).trim(); /* skip = */
+
+        // Only values can contain escape sequences
+        if (type.indexOf('\\') >= 0) {
+            throw new IllegalArgumentException("Bad search filter");
+        }
+
+        /* make decision by looking at the type */
+        type.trim();
+        if (type.endsWith("~")) {
+            JDAPAVA ava = new
+              JDAPAVA(type.substring(0, type.length()-1), value);
+            return new JDAPFilterApproxMatch(ava);
+        } else if (type.endsWith(">")) {
+            JDAPAVA ava = new
+              JDAPAVA(type.substring(0, type.length()-1), value);
+            return new JDAPFilterGreaterOrEqual(ava);
+        } else if (type.endsWith("<")) {
+            JDAPAVA ava = new
+              JDAPAVA(type.substring(0, type.length()-1), value);
+            return new JDAPFilterLessOrEqual(ava);
+        } else if (type.endsWith(":")) {
+            return new JDAPFilterExtensible(type.substring(0, type.length()-1), value);
+        }
+
+        /* for those that are not simple */
+        if (value.startsWith("*") && value.length() == 1) {
+            return new JDAPFilterPresent(type);
+        }
+
+        /* if value contains no '*', then it is equality */
+        if (value.indexOf('*') == -1) {
+            JDAPAVA ava = new JDAPAVA(type, value);
+            return new JDAPFilterEqualityMatch(ava);
+        }
+
+        /* must be substring at this point */
+        StringTokenizer st = new StringTokenizer(value, "*");
+        JDAPFilterSubString sub = new JDAPFilterSubString(type);
+
+        String initial = null;
+        if (!value.startsWith("*")) {
+            initial = st.nextToken();
+            initial.trim();
+        }
+        sub.addInitial(initial);
+
+        while (st.hasMoreTokens()) {
+            String any = st.nextToken();
+            any.trim();
+            if (st.hasMoreTokens()) {
+                sub.addAny(any);
+            } else {
+                if (value.endsWith("*")) {
+                    sub.addAny(any);
+                    sub.addFinal(null);
+                } else {
+                    sub.addFinal(any);
+                }
+            }
+        }
+
+        return sub;
+    }
+
+    /**
+     * Gets the ber representation of filter.
+     * @return ber representation of filter
+     */
+    public abstract BERElement getBERElement();
+
+    /**
+     * Retrieves the string representation of filter.
+     * @return string representation of filter
+     */
+    public abstract String toString();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPBERTagDecoder.java
@@ -0,0 +1,140 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class is to help BER libraries to make decision
+ * on how to decode an implicit object.
+ */
+public class JDAPBERTagDecoder extends BERTagDecoder {
+    /**
+     * Gets an application specific ber element from the stream.
+     * @param decoder ber decoder to use
+     * @param tag ber tag to get
+     * @param stream input stream
+     * @param bytes_read number of bytes read
+     * @param implicit to indicate a tag implicit or not
+     */
+    public BERElement getElement(BERTagDecoder decoder, int tag,
+        InputStream stream, int[] bytes_read, boolean[] implicit)
+        throws IOException {
+        BERElement element = null;
+        switch (tag) {
+            case 0x60:  /* [APPLICATION 0] For Bind Request */
+            case 0x61:  /* [APPLICATION 1] Bind Response */
+            case 0x63:  /* [APPLICATION 3] Search Request
+                         * If doing search without bind first,
+                 * x500.arc.nasa.gov returns tag [APPLICATION 3]
+                 * in Search Response. Gee.
+                         */
+            case 0x64:  /* [APPLICATION 4] Search Response */
+            case 0x65:  /* [APPLICATION 5] Search Result */
+            case 0x67:  /* [APPLICATION 7] Modify Response */
+            case 0x69:  /* [APPLICATION 9] Add Response */
+            case 0x6a:  /* [APPLICATION 10] Del Request */
+            case 0x6b:  /* [APPLICATION 11] Del Response */
+            case 0x6d:  /* [APPLICATION 13] ModifyRDN Response */
+            case 0x6f:  /* [APPLICATION 15] Compare Response */
+            case 0x78:  /* [APPLICATION 23] Extended Response */
+            case 0x73:  /* [APPLICATION 19] SearchResultReference */
+                element = new BERSequence(decoder, stream, bytes_read);
+                implicit[0] = true;
+            break;
+            case 0x80:  /* [APPLICATION 16] 64+16 */
+                element = new BERInteger(stream, bytes_read);
+                implicit[0] = true;
+            break;
+            /* 16/02/97 MS specific */
+            case 0x85:  /* Context Specific [5]:
+                 * (a) Handle Microsoft v3 referral bugs! (Response)
+                 * (b) Handle Microsoft v3 supportedVersion in Bind
+                 *     response
+                 */
+                element = new BERInteger(stream, bytes_read);
+                implicit[0] = true;
+            break;
+            case 0x87:  /* Context Specific [7]:
+                 * Handle Microsoft Filter "present" in
+                 * search request.
+                 */
+                element = new BEROctetString(decoder, stream, bytes_read);
+                implicit[0] = true;
+            break;
+            case 0x8a:  /* Context Specific [10]:
+                         * Handle extended response
+                         */
+                element = new BEROctetString(decoder, stream, bytes_read);
+                implicit[0] = true;
+            break;
+            case 0x8b:  /* Context Specific [11]:
+                         * Handle extended response
+                         */
+                element = new BEROctetString(decoder, stream, bytes_read);
+                implicit[0] = true;
+            break;
+            case 0xa3:  /* Context Specific <Construct> [3]:
+                 * Handle Microsoft v3 sasl bind request
+                 */
+                element = new BERSequence(decoder, stream, bytes_read);
+                implicit[0] = true;
+            break;
+            case 0xa7:  /* Context Specific <Construct> [7]:
+                 * Handle Microsoft v3 serverCred in
+                 * bind response. MS encodes it as SEQUENCE OF
+                 * while it should be CHOICE OF.
+                 */
+                element = new BERSequence(decoder, stream, bytes_read);
+                implicit[0] = true;
+            break;
+            case 0xa0:  /* Context Specific <Construct> [0]:
+                 * v3 Server Control.
+                 * SEQUENCE of SEQUENCE of {OID  [critical] [value]}
+                 */
+                element = new BERSequence(decoder, stream, bytes_read);
+                implicit[0] = true;
+            break;
+            default:
+                throw new IOException();
+        }
+        return element;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterAVA.java
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the attribute value assertion filter.
+ *
+ * @version 1.0
+ */
+public abstract class JDAPFilterAVA extends JDAPFilter {
+    /**
+     * Internal variables
+     */
+    private int m_tag;
+    private JDAPAVA m_ava = null;
+
+    /**
+     * Constructs base filter for other attribute value assertion.
+     * @param tag attribute tag
+     * @param ava attribute value assertion
+     */
+    public JDAPFilterAVA(int tag,
+        JDAPAVA ava) {
+        m_tag = tag;
+        m_ava = ava;
+    }
+
+    /**
+     * Get attribute value assertion.
+     * @return value assertion
+     */
+    public JDAPAVA getAVA() {
+        return m_ava;
+    }
+
+    /**
+     * Gets the ber representation of the filter.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        BERTag element = new BERTag(m_tag, m_ava.getBERElement(), true);
+        return element;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterExtensible.java
@@ -0,0 +1,148 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the extended match filter.
+ * <pre>
+ * extensibleMatch [9] AttributeValueAssertion
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterExtensible extends JDAPFilter {
+    /**
+     * Constructs extensible match filter.
+     * @param match Matching rule assertion
+     */
+    public JDAPFilterExtensible(String type, String match) {
+        m_tag = BERTag.CONSTRUCTED|BERTag.CONTEXT|9;
+        m_type = type;
+        m_value = match;
+    }
+
+    /**
+     * Gets ber representation of the filter.
+     * <PRE>
+     * Extended filter:   [type] [':dn'][':'oid]':='value
+     *
+     * BER:   extensibleMatch    [9] MatchingRuleAssertion
+     *        MatchingRuleAssertion ::= SEQUENCE {
+     *             matchingRule    [1] MatchingRuleID OPTIONAL,
+     *             type            [2] AttributeDescription OPTIONAL,
+     *             matchValue      [3] AssertionValue,
+     *             dnAttributes    [4] BOOLEAN DEFAULT FALSE
+     *        }
+     * </PRE>
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        String value = m_value;
+        String defs = m_type;
+
+        /* Need either ':dn' or ':'oid */
+        int colonIndex = defs.lastIndexOf(':');
+        if ( colonIndex == -1 ) {
+            return null;
+        }
+        /* Is it dn or oid? */
+        boolean isDN = false;
+        String oid = null;
+        if ( defs.regionMatches( true, colonIndex+1, "dn", 0, 2 ) )
+            isDN = true;
+        else
+            oid = defs.substring( colonIndex+1 );
+
+        /* Any more? */
+        defs = defs.substring( 0, colonIndex );
+        colonIndex = defs.lastIndexOf(':');
+        if ( colonIndex >= 0 ) {
+            /* Is it dn or oid? */
+            if ( defs.regionMatches( true, colonIndex+1, "dn", 0, 2 ) )
+                isDN = true;
+            else
+                oid = defs.substring( colonIndex+1 );
+        }
+
+        BERSequence seq = new BERSequence();
+        BERTag tag;
+
+        /* Was there an oid? */
+        if ( oid != null ) {
+            tag = new BERTag( BERTag.CONTEXT|BERTag.MRA_OID, new
+                                    BEROctetString(oid), true );
+            seq.addElement( tag );
+        }
+
+        /* Was there an attribute description? */
+        if ( defs.length() > 0 ) {
+            tag = new BERTag( BERTag.CONTEXT|BERTag.MRA_TYPE, new
+                                    BEROctetString(defs), true );
+            seq.addElement( tag );
+        }
+
+        /* Got to have a value */
+        tag = new BERTag( BERTag.CONTEXT|BERTag.MRA_VALUE, new
+                                BEROctetString(value), true );
+        seq.addElement( tag );
+
+        /* Was ':dn' specified? */
+        tag = new BERTag( BERTag.CONTEXT|BERTag.MRA_DNATTRS, new
+                                BERBoolean(isDN), true );
+        seq.addElement( tag );
+
+        BERTag element = new BERTag( m_tag, seq, true );
+        return element;
+    }
+
+    /**
+     * Retrieves the string representation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPFilterExtensible {" + m_value + "}";
+    }
+
+    private int m_tag;
+    private String m_type = null;
+    private String m_value = null;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterPresent.java
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the filter present.
+ * See RFC 1777.
+ * <pre>
+ *   present [7] AttributeType
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterPresent extends JDAPFilter {
+    /**
+     * Internal variables
+     */
+    private String m_type = null;
+
+    /**
+     * Constructs the filter.
+     * @param type attribute type
+     */
+    public JDAPFilterPresent(String type) {
+        super();
+        m_type = type;
+    }
+
+    /**
+     * Gets ber representation of the filter.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        BEROctetString s = new BEROctetString(m_type);
+        BERTag element = new BERTag(BERTag.CONTEXT|7, s, true);
+        return element;
+    }
+
+    /**
+     * Gets string reprensetation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPFilterPresent {" + m_type + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterApproxMatch.java
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the approximate match filter.
+ * <pre>
+ * approxMatch [8] AttributeValueAssertion
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterApproxMatch extends JDAPFilterAVA {
+    /**
+     * Constructs approximate match filter.
+     * @param ava attribute value assertion
+     */
+    public JDAPFilterApproxMatch(JDAPAVA ava) {
+        super(BERTag.CONSTRUCTED|BERTag.CONTEXT|8, ava);
+    }
+
+    /**
+     * Retrieves the string representation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPFilterApproximateMatch {" +
+          super.getAVA().toString() + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterOr.java
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the filter And.
+ * See RFC 1777.
+ * <pre>
+ *   or [1] SET OF Filter
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterOr extends JDAPFilterSet {
+    /**
+     * Constructs the filter.
+     */
+    public JDAPFilterOr() {
+        super(BERTag.CONSTRUCTED|BERTag.CONTEXT|1);
+    }
+
+    /**
+     * Gets string reprensetation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPFilterOr {" + super.getParamString() + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterSubString.java
@@ -0,0 +1,169 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the filter substring.
+ * See RFC 1777.
+ * <pre>
+ * [4] SEQUENCE {
+ *   type AttributeType,
+ *   SEQUENCE OF CHOICE {
+ *     initial [0] LDAPString,
+ *     any [1] LDAPString,
+ *     final [2] LDAPString
+ *   }
+ *     }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterSubString extends JDAPFilter {
+    /**
+     * Internal variables
+     */
+    private String m_type = null;
+    private Vector m_initial = new Vector();
+    private Vector m_any = new Vector();
+    private Vector m_final = new Vector();
+
+    /**
+     * Constructs the filter.
+     * @param type attribute type
+     */
+    public JDAPFilterSubString(String type) {
+        super();
+        m_type = type;
+    }
+
+    /**
+     * Adds initial substring.
+     * @param s initial substring
+     */
+    public void addInitial(String s) {
+        m_initial.addElement(s);
+    }
+
+    /**
+     * Adds any substring.
+     * @param s any substring
+     */
+    public void addAny(String s) {
+        m_any.addElement(s);
+    }
+
+    /**
+     * Adds final substring.
+     * @param s final substring
+     */
+    public void addFinal(String s) {
+        m_final.addElement(s);
+    }
+
+    /**
+     * Gets ber representation of the filter.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BEROctetString(m_type));
+        BERSequence str_seq = new BERSequence();
+        for (int i = 0; i < m_initial.size(); i++) {
+            String val = (String)m_initial.elementAt(i);
+            if (val == null)
+                continue;
+            BERTag str = new BERTag(BERTag.CONTEXT|0,
+                JDAPFilterOpers.getOctetString(val), true);
+            str_seq.addElement(str);
+        }
+        for (int i = 0; i < m_any.size(); i++) {
+            String val = (String)m_any.elementAt(i);
+            if (val == null)
+                continue;
+            BERTag str = new BERTag(BERTag.CONTEXT|1,
+              JDAPFilterOpers.getOctetString(val), true);
+            str_seq.addElement(str);
+        }
+        for (int i = 0; i < m_final.size(); i++) {
+            String val = (String)m_final.elementAt(i);
+            if (val == null)
+                continue;
+            BERTag str = new BERTag(BERTag.CONTEXT|2,
+              JDAPFilterOpers.getOctetString(val), true);
+            str_seq.addElement(str);
+        }
+        seq.addElement(str_seq);
+        BERTag element = new BERTag(BERTag.CONSTRUCTED|BERTag.CONTEXT|4,
+          seq, true);
+        return element;
+    }
+
+    /**
+     * Gets string reprensetation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        String initial = "";
+        for (int i = 0; i < m_initial.size(); i++) {
+            if (i != 0)
+                initial = initial + ",";
+            initial = initial + (String)m_initial.elementAt(i);
+        }
+
+        String any = "";
+        for (int i = 0; i < m_any.size(); i++) {
+            if (i != 0)
+                any = any + ",";
+            any = any + (String)m_any.elementAt(i);
+        }
+
+        String s_final = "";
+        for (int i = 0; i < m_final.size(); i++) {
+            if (i != 0)
+                s_final = s_final + ",";
+            s_final = s_final + (String)m_final.elementAt(i);
+        }
+
+        return "JDAPFilterSubString {type=" + m_type + ", initial=" + initial +
+          ", any=" + any + ", final=" + s_final + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/JDAPFilterLessOrEqual.java
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the less or equal filter.
+ * <pre>
+ * lessOrEqual [6] AttributeValueAssertion
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPFilterLessOrEqual extends JDAPFilterAVA {
+    /**
+     * Constructs less or equal filter.
+     * @param ava attribute value assertion
+     */
+    public JDAPFilterLessOrEqual(JDAPAVA ava) {
+        super(BERTag.CONSTRUCTED|BERTag.CONTEXT|6, ava);
+    }
+
+    /**
+     * Retrieves the string representation of the filter.
+     * @return string representation
+     */
+    public String toString() {
+        return "JDAPFilterLessOrEqual {" +
+          super.getAVA().toString() + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPModifyRequest.java
@@ -0,0 +1,140 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the modify request.
+ * <pre>
+ *   ModifyRequest ::= [APPLICATION 6] SEQUENCE {
+ *     object LDAPDN,
+ *     modification SEQUENCE OF SEQUENCE {
+ *       operation ENUMERATED {
+ *         add (0),
+ *         delete (1),
+ *         replace (2)
+ *       },
+ *       modification SEQUENCE {
+ *         type AttributeType,
+ *         values SET OF AttributeValue
+ *       }
+ *     }
+ *   }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPModifyRequest extends JDAPBaseDNRequest
+    implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected String m_dn = null;
+    protected LDAPModification m_mod[] = null;
+
+    /**
+     * Constructs the modify request
+     * @param dn distinguished name of modifying
+     * @param mod list of modifications
+     */
+    public JDAPModifyRequest(String dn, LDAPModification mod[]) {
+        m_dn = dn;
+        m_mod = mod;
+    }
+
+    /**
+     * Retrieves protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.MODIFY_REQUEST;
+    }
+
+    /**
+     * Sets the base dn component.
+     * @param basedn base dn
+     */
+    public void setBaseDN(String basedn) {
+        m_dn = basedn;
+    }
+
+    /**
+     * Gets the base dn component.
+     * @return base dn
+     */
+    public String getBaseDN() {
+        return m_dn;
+    }
+
+    /**
+     * Gets the ber representation of modify request.
+     * @return ber representation of modify request
+     */
+    public BERElement getBERElement() {
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BEROctetString(m_dn));
+        BERSequence mod_list = new BERSequence();
+        for (int i = 0; i < m_mod.length; i++) {
+            mod_list.addElement(m_mod[i].getBERElement());
+        }
+        seq.addElement(mod_list);
+        BERTag element = new BERTag(BERTag.APPLICATION|BERTag.CONSTRUCTED|6,
+          seq, true);
+        return element;
+    }
+
+    /**
+     * Retrieves string representation of modify request.
+     * @return string representation of request
+     */
+    public String toString() {
+        String s = "";
+        for (int i = 0; i < m_mod.length; i++) {
+            if (i != 0)
+                s = s + "+";
+            s = s + m_mod[i].toString();
+        }
+        return "ModifyRequest {object=" + m_dn + ", modification=" + s + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPSearchResponse.java
@@ -0,0 +1,159 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the search response. This object
+ * is sent from the ldap server to the interface.
+ * <pre>
+ * entry [APPLICATION 4] SEQUENCE {
+ *   objectName LDAPDN,
+ *   attributes SEQUENCE OF SEQUENCE {
+ *     AttributeType,
+ *     SET OF AttributeValue
+ *   }
+ * }
+ * </pre>
+ *
+ * Note that the following is the LDAPv3 definition:
+ * <pre>
+ * SearchResultEntry ::= [APPLICATION 4] SEQUENCE {
+ *   objectName LDAPDN,
+ *   attributes PartialAttributeList
+ * }
+ * PartialAttributeList ::= SEQUENCE OF SEQUENCE {
+ *   type AttributeDescription,
+ *   vals SET OF AttributeValue
+ * }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPSearchResponse implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected String m_object_name = null;
+    protected BERElement m_element = null;
+    protected LDAPAttribute m_attributes[] = null;
+
+    /**
+     * Constructs search response.
+     * @param element ber element of search response
+     */
+    public JDAPSearchResponse(BERElement element) throws IOException {
+        m_element = element;
+
+        BERTag tag = (BERTag)element;
+        BERSequence seq = (BERSequence)tag.getValue();
+        BEROctetString name = (BEROctetString)seq.elementAt(0);
+        byte buf[] = null;
+        buf = name.getValue();
+        if (buf == null)
+            m_object_name = null;
+        else {
+            try{
+                m_object_name = new String(buf, "UTF8");
+            } catch(Throwable x)
+            {}
+        }
+        BERSequence attrs = (BERSequence)seq.elementAt(1);
+        if (attrs.size() > 0) {
+            m_attributes = new LDAPAttribute[attrs.size()];
+            for (int i = 0; i < attrs.size(); i++) {
+                m_attributes[i] = new LDAPAttribute(attrs.elementAt(i));
+            }
+        }
+    }
+
+    /**
+     * Retrieves ber representation of the result.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        return m_element;
+    }
+
+    /**
+     * Retrieves object name
+     * @return object name
+     */
+    public String getObjectName() {
+        return m_object_name;
+    }
+
+    /**
+     * Retrieves attributes
+     * @return attributes
+     */
+    public LDAPAttribute[] getAttributes() {
+        return m_attributes;
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.SEARCH_RESPONSE;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        String s = "";
+        if (m_attributes != null) {
+            for (int i = 0; i < m_attributes.length; i++) {
+                if (i != 0)
+                    s = s + ",";
+                s = s + m_attributes[i].toString();
+            }
+        }
+        return "SearchResponse {entry='" + m_object_name + "', attributes='" +
+          s + "'}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPModifyRDNResponse.java
@@ -0,0 +1,81 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the modifyRDN response. This object
+ * is sent from the ldap server to the interface.
+ * <pre>
+ * ModifyRDNResponse ::= [APPLICATION 13] LDAPResult
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPModifyRDNResponse extends JDAPResult
+    implements JDAPProtocolOp {
+
+    /**
+     * Constructs modifyRDN response.
+     * @param element ber element of modifyRDN response
+     */
+    public JDAPModifyRDNResponse(BERElement element) throws IOException {
+        super(((BERTag)element).getValue());
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.MODIFY_RDN_RESPONSE;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        return "ModifyRDNResponse " + super.getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPModifyRDNRequest.java
@@ -0,0 +1,159 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the modify rdn request. This
+ * object is sent to the ldap server.
+ * <pre>
+ * ModifyRDNRequest ::= [APPLICATION 12] SEQUENCE {
+ *   entry LDAPDN,
+ *   newrdn RelativeLDAPDN,
+ *   deleteoldrdn BOOLEAN
+ * }
+ * </pre>
+ *
+ * Note that LDAPv3 rename this object to JDAPModifyDNRequest
+ * and has the following defintion:
+ * <pre>
+ * ModifyDNRequest ::= [APPLICATION 12] SEQUENCE {
+ *   entry LDAPDN,
+ *   newrdn RelativeLDAPDN,
+ *   deleteoldrdn BOOLEAN,
+ *   newSuperior [0] LDAPDN OPTIONAL
+ * }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPModifyRDNRequest extends JDAPBaseDNRequest
+    implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected String m_old_dn = null;
+    protected String m_new_rdn = null;
+    protected boolean m_delete_old_dn;
+    protected String m_new_superior;
+
+    /**
+     * Constructs modify RDN request.
+     * @param old_dn old distinguished name
+     * @param new_rdn new distinguished name
+     * @param delete_old_dn delete the old distinguished name
+     */
+    public JDAPModifyRDNRequest(String old_dn, String new_rdn,
+      boolean delete_old_dn) {
+        m_old_dn = old_dn;
+        m_new_rdn = new_rdn;
+        m_delete_old_dn = delete_old_dn;
+        m_new_superior = null;
+    }
+
+    /**
+     * Constructs modify DN request.
+     * @param old_dn old distinguished name
+     * @param new_rdn new distinguished name
+     * @param delete_old_dn delete the old distinguished name
+     * @param new_superior parent dn
+     */
+    public JDAPModifyRDNRequest(String old_dn, String new_rdn,
+      boolean delete_old_dn, String new_superior) {
+        m_old_dn = old_dn;
+        m_new_rdn = new_rdn;
+        m_delete_old_dn = delete_old_dn;
+        m_new_superior = new_superior;
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.MODIFY_RDN_REQUEST;
+    }
+
+    /**
+     * Sets the base dn.
+     * @param basedn base dn
+     */
+    public void setBaseDN(String basedn) {
+        m_old_dn = basedn;
+    }
+
+    /**
+     * Gets the base dn component.
+     * @return base dn
+     */
+    public String getBaseDN() {
+        return m_old_dn;
+    }
+
+    /**
+     * Gets the ber representation of the request.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BEROctetString(m_old_dn));
+        seq.addElement(new BEROctetString(m_new_rdn));
+        seq.addElement(new BERBoolean(m_delete_old_dn));
+        /* LDAPv3 new parent dn feature support */
+        if (m_new_superior != null)
+            seq.addElement(new BERTag(BERTag.CONTEXT|0,
+              new BEROctetString (m_new_superior), true));
+        BERTag element = new BERTag(BERTag.APPLICATION|BERTag.CONSTRUCTED|12,
+          seq, true);
+        return element;
+    }
+
+    /**
+     * Gets the string representation of the request.
+     * @return string representation
+     */
+    public String toString() {
+        return "ModifyRDNRequest {entry=" + m_old_dn + ", newrdn=" +
+          m_new_rdn + ", deleteoldrdn=" + m_delete_old_dn + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPModifyResponse.java
@@ -0,0 +1,80 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the modify response. This object
+ * is sent from the ldap server to the interface. See RFC
+ * 1777.
+ * <pre>
+ * ModifyResponse ::= [APPLICATION 7] LDAPResult
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPModifyResponse extends JDAPResult implements JDAPProtocolOp {
+    /**
+     * Constructs modify response.
+     * @param element ber element of bind response
+     */
+    public JDAPModifyResponse(BERElement element) throws IOException {
+        super(((BERTag)element).getValue());
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.MODIFY_RESPONSE;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        return "ModifyResponse " + super.getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPBaseDNRequest.java
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This is the base class for all the request that
+ * has a base dn component. The existence of this
+ * class is due to the JDAPReferralThread.
+ *
+ * @version 1.0
+ */
+public abstract class JDAPBaseDNRequest {
+
+    /**
+     * Sets the base dn component in the request.
+     * @param basedn base DN
+     */
+    public abstract void setBaseDN(String basedn);
+
+    /**
+     * Gets the base dn component in the request.
+     * @return base dn
+     */
+    public abstract String getBaseDN();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPCompareRequest.java
@@ -0,0 +1,121 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the compare request. This object
+ * is sent to the ldap server.
+ * <pre>
+ *   CompareRequest ::= [APPLICATION 14] SEQUENCE {
+ *     entry LDAPDN,
+ *     ava AttributeValueAssertion
+ *   }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPCompareRequest extends JDAPBaseDNRequest
+    implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected String m_dn = null;
+    protected JDAPAVA m_ava = null;
+
+    /**
+     * Constructs the compare request.
+     * @param dn distinguished name of the entry to be compared
+     * @param ava attribut value assertion
+     */
+    public JDAPCompareRequest(String dn, JDAPAVA ava) {
+        m_dn = dn;
+        m_ava = ava;
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return operation type
+     */
+    public int getType() {
+        return JDAPProtocolOp.COMPARE_REQUEST;
+    }
+
+    /**
+     * Sets the base dn.
+     * @param basedn base dn
+     */
+    public void setBaseDN(String basedn) {
+        m_dn = basedn;
+    }
+
+    /**
+     * Gets the base dn.
+     * @return base dn
+     */
+    public String getBaseDN() {
+        return m_dn;
+    }
+
+    /**
+     * Retrieves the ber representation of the request.
+     * @return ber request
+     */
+    public BERElement getBERElement() {
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BEROctetString(m_dn));
+        seq.addElement(m_ava.getBERElement());
+        BERTag element = new BERTag(BERTag.APPLICATION|BERTag.CONSTRUCTED|14,
+          seq, true);
+        return element;
+    }
+
+    /**
+     * Retrieves the string representation of the request.
+     * @return string representation
+     */
+    public String toString() {
+        return "CompareRequest {entry=" + m_dn + ", ava=" + m_ava.toString() +
+          "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPBindRequest.java
@@ -0,0 +1,192 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the bind request. This object is
+ * sent to the ldap server.
+ * <pre>
+ * BindRequest ::= [APPLICATION 0] SEQUENCE {
+ *   version INTEGER(1..127) ,
+ *   name LDAPDN,
+ *   authentication CHOICE {
+ *     simple [0] OCTET STRING,
+ *     krbv42LDAP [1] OCTET STRING,
+ *     krbv42DSA [2] OCTET STRING
+ *   }
+ * }
+ * </pre>
+ *
+ * Note that LDAPv3 bind reuqest is structured as follows:
+ * <pre>
+ * BindRequest ::= [APPLICATION 0] SEQUENCE {
+ *   version INTEGER (1..127)
+ *   name LDAPDN,
+ *   authentication AuthenticationChoice
+ * }
+ * AuthenticationChoice ::= CHOICE {
+ *   simple [0] OCTET STRING,
+ *          -- 1 and 2 reserved
+ *   sasl [3] SaslCredentials
+ * }
+ * SaslCredentials ::= SEQUENCE {
+ *   mechanism LDAPString,
+ *   credentials OCTET STRING
+ * }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPBindRequest implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected int m_version;
+    protected String m_name = null;
+    protected String m_password = null;
+    protected String m_mechanism = null;
+    protected byte m_credentials[] = null;
+
+    /**
+     * Constructs anonymous or simple bind request.
+     * @param version version
+     * @param name distinguished name
+     * @param password password
+     */
+    public JDAPBindRequest(int version, String name, String password) {
+        m_version = version;
+        m_name = name;
+        m_password = password;
+    }
+
+    /**
+     * Constructs a LDAP v3.0 SaslCredentials bind request.
+     * @param version version
+     * @param name distinguished name
+     * @param mechanism mechanism (must not be null)
+     * @param credentials credientials
+     */
+    public JDAPBindRequest(int version, String name, String mechanism,
+      byte credentials[]) {
+        m_version = version;
+        m_name = name;
+        m_mechanism = mechanism;
+        m_credentials = credentials;
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.BIND_REQUEST;
+    }
+
+    /**
+     * Retrieves the ber representation of the request.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        /* anonymous bind
+         * [*] umich-ldap-v3.3:
+         *     0x60 0x07        (implicit [Application 0] Sequence)
+         *     0x02 0x01 0x02   (Integer)
+         *     0x04 0x00        (OctetString)
+         *     0x80 0x00        (implicit OctetString)
+         * [*] zoomit server v1.0:
+         *     0x60 0x0b
+         *     0x30 0x09        (sequece)
+         *     0x02 0x01 0x02
+         *     0x04 0x00
+         *     0xa0 0x02         (explicit tag)
+         *     0x04 0x00
+         * simple bind with "cn=root,o=ncware,c=ca", "password"
+         * [*] umich-ldap-v3.3:
+         *     0x60 0x24        ([APPLICATION 0])
+         *     0x02 0x01 0x02   (version - Integer)
+         *     0x04 0x15 c n = r o o t , o = n c w a r e ,
+         *               c = c a
+         *     0x80 0x08 p a s s w o r d
+         */
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BERInteger(m_version));
+        seq.addElement(new BEROctetString(m_name));
+        BERTag auth = null;
+        if (m_mechanism == null) {
+            auth = new BERTag(BERTag.CONTEXT, new BEROctetString(m_password), true);
+        } else {
+            BERSequence sasl = new BERSequence();
+            sasl.addElement(new BEROctetString(m_mechanism));
+            if (m_credentials == null) {
+                sasl.addElement(new BEROctetString((byte[])null));
+            } else {
+                sasl.addElement(new BEROctetString(m_credentials, 0,
+                  m_credentials.length));
+            }
+            auth = new BERTag(BERTag.SASLCONTEXT|3,  /* SaslCredentials */
+              sasl, true);
+        }
+        seq.addElement(auth);
+        BERTag element = new BERTag(BERTag.APPLICATION|BERTag.CONSTRUCTED|0,
+          seq, true);
+        return element;
+    }
+
+    /**
+     * Retrieves the string representation of the request parameters.
+     * @return string representation parameters
+     */
+    public String getParamString() {
+        return "{version=" + m_version + ", name=" + m_name +
+               ", authentication=" + ((m_password == null) ? m_password : "********") + "}";
+    }
+
+    /**
+     * Retrieves the string representation of the request.
+     * @return string representation
+     */
+    public String toString() {
+        return "BindRequest " + getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPExtendedRequest.java
@@ -0,0 +1,120 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the ExtendedRequest request. This object
+ * is sent to the ldap server and is a v3 request. See RFC 1777.
+ * <pre>
+ * ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
+ *   requestName  [0] LDAPOID,
+ *   requestValue [1] OCTET STRING OPTIONAL
+ * }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPExtendedRequest implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected String m_oid = null;
+    protected byte m_value[] = null;
+
+    /**
+     * Constructs extended request.
+     * @param oid object identifier
+     * @param value request value
+     */
+    public JDAPExtendedRequest(String oid, byte value[]) {
+        m_oid = oid;
+        m_value = value;
+    }
+
+    /**
+     * Retrieves protocol operation type.
+     * @return protcol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.EXTENDED_REQUEST;
+    }
+
+    /**
+     * Gets the ber representation of extended request.
+     * @return ber representation of request
+     */
+    public BERElement getBERElement() {
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BERTag(BERTag.CONTEXT|0,
+          new BEROctetString (m_oid), true));
+        if (m_value != null) {
+            seq.addElement(new BERTag(BERTag.CONTEXT|1,
+              new BEROctetString (m_value, 0, m_value.length), true));
+        }
+        BERTag element = new BERTag(BERTag.APPLICATION|BERTag.CONSTRUCTED|23,
+          seq, true);
+        return element;
+    }
+
+    /**
+     * Retrieves the string representation of add request parameters.
+     * @return string representation of add request parameters
+     */
+    public String getParamString() {
+        String s = "";
+        if (m_value != null) {
+            try{
+                s = new String(m_value, "UTF8");
+            } catch(Throwable x) {}
+        }
+        return "{OID='" + m_oid + "', value='" + s + "'}";
+    }
+
+    /**
+     * Retrieves the string representation of add request.
+     * @return string representation of add request
+     */
+    public String toString() {
+        return "ExtendedRequest " + getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPSearchRequest.java
@@ -0,0 +1,238 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the search request. This object is
+ * sent to the ldap server.
+ * <pre>
+ * SearchRequest ::= [APPLICATION 3] SEQUENCE {
+ *   baseObject LDAPDN,
+ *   scope ENUMERATED {
+ *     baseObject (0),
+ *     singleLevel (1),
+ *     wholeSubtree (2)
+ *   },
+ *   derefAliases ENUMERATED {
+ *     neverDerefAliases (0),
+ *     derefInSearching (1),
+ *     DerefFindingBaseObj (2),
+ *     DerefAlways (3)
+ *   },
+ *   sizeLimit INTEGER(0..maxInt),
+ *   timeLimit INTEGER(0..maxInt),
+ *   attrsOnly BOOLEAN,
+ *   filter Filter,
+ *   attributes SEQUENCE OF AttributeType
+ * }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPSearchRequest extends JDAPBaseDNRequest
+    implements JDAPProtocolOp {
+    /**
+     * search scope
+     */
+    public final static int BASE_OBJECT = 0;
+    public final static int SINGLE_LEVEL = 1;
+    public final static int WHOLE_SUBTREE = 2;
+    /**
+     * alias dereference
+     */
+    public final static int NEVER_DEREF_ALIASES = 0;
+    public final static int DEREF_IN_SEARCHING = 1;
+    public final static int DEREF_FINDING_BASE_OBJ = 2;
+    public final static int DEREF_ALWAYS = 3;
+
+    public final static String DEFAULT_FILTER = "(objectclass=*)";
+    /**
+     * Private variables
+     */
+    protected String m_base_dn = null;
+    protected int m_scope;
+    protected int m_deref;
+    protected int m_size_limit;
+    protected int m_time_limit;
+    protected boolean m_attrs_only;
+    protected String m_filter = null;
+    protected JDAPFilter m_parsedFilter = null; 
+    protected String m_attrs[] = null;
+
+    /**
+     * Constructs search request.
+     * @param base_dn base object entry relative to the search
+     * @param scope scope of the search
+     * @param deref how alias objects should be handled
+     * @param size_limit maximum number of entries
+     * @param time_limit maximum time (in time) allowed
+     * @param attrs_only should return type only
+     * @param filter string filter based on RFC1558
+     * @param attrs list of attribute types
+     * @exception IllegalArgumentException if the filter has bad syntax
+     * 
+     */
+    public JDAPSearchRequest(String base_dn, int scope, int deref,
+        int size_limit, int time_limit, boolean attrs_only,
+        String filter, String attrs[]) throws IllegalArgumentException {
+        m_base_dn = base_dn;
+        m_scope = scope;
+        m_deref = deref;
+        m_size_limit = size_limit;
+        m_time_limit = time_limit;
+        m_attrs_only = attrs_only;
+        m_filter = (filter == null) ? DEFAULT_FILTER : filter;
+        m_parsedFilter = JDAPFilter.getFilter(
+            JDAPFilterOpers.convertLDAPv2Escape(m_filter));
+        if (m_parsedFilter == null){
+            throw new IllegalArgumentException("Bad search filter");
+        }        
+        m_attrs = attrs;
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return operation type
+     */
+    public int getType() {
+        return JDAPProtocolOp.SEARCH_REQUEST;
+    }
+
+    /**
+     * Sets the base dn component.
+     * @param basedn base dn
+     */
+    public void setBaseDN(String basedn) {
+        m_base_dn = basedn;
+    }
+
+    /**
+     * Gets the base dn component.
+     * @return base dn
+     */
+    public String getBaseDN() {
+        return m_base_dn;
+    }
+
+    /**
+     * Gets the ber representation of search request.
+     * @return ber representation of request.
+     */
+    public BERElement getBERElement() {
+        /* Assumed that searching with the following criteria:
+         *     base object = "c=ca"
+         *     filter      = FilterPresent(objectClass)
+         * [*] zoomit server v1.0 (search on c=ca)
+         *     0x63 0x81 0x8d              ([APPLICATION 3])
+         *     0x30 0x81 0x8a 0x04 0x00    (seq of)
+         *     0x0a 0x01 0x02
+         *     0x0a 0x01 0x00
+         *     0x02 0x01 0x65
+         *     0x02 0x01 0x1e
+         *     0x01 0x01 0x00
+         *     0xa0 0x3b
+         *     0x30 0x39 0xa5 0x0d
+         *     0x30 0x0b 0x04 0x07 P A G E _ D N
+         *     0x04 0x00
+         *     0xa3 0x0e
+         *     0x30 0x0c 0x04 0x08 P A G E _ K E Y
+         *     0x04 0x00 0xa3 0x18
+         *     0x30 0x16 0x04 0x0e z c A n y A t t r i b u t e
+         *     0x04 0x04 c = c a
+         *     0x30 0x3a 0x04 0x0b O b j e c t C l a s s
+         *     0x04 0x11 a l i a s e d O b j e c t N a m e
+         *     0x04 0x07 d s e T y p e
+         *     0x04 0x0f t e l e p h o n e N u m b e r
+         * [*] umich-ldap-v3.3:
+         *     0x63 0x24          ([APPLICATION 3])
+         *     0x04 0x04 c = c a  (base object - OctetString)
+         *     0x0a 0x01 0x00     (scope - Enumerated)
+         *     0x0a 0x01 0x00     (derefAlias - Enumerated)
+         *     0x02 0x01 0x00     (size limit - Integer)
+         *     0x02 0x01 0x00     (time limit - Integer)
+         *     0x01 0x01 0x00     (attr only - Boolean)
+         *     0x87 0x0b o b j e c t C l a s s (filter)
+         *     0x30 0x00          (attrs - Sequence of OctetString)
+         */
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BEROctetString(m_base_dn));
+        seq.addElement(new BEREnumerated(m_scope));
+        seq.addElement(new BEREnumerated(m_deref));
+        seq.addElement(new BERInteger(m_size_limit));
+        seq.addElement(new BERInteger(m_time_limit));
+        seq.addElement(new BERBoolean(m_attrs_only));
+        seq.addElement(m_parsedFilter.getBERElement());
+        BERSequence attr_type_list = new BERSequence();
+        if (m_attrs != null) {
+            for (int i = 0; i < m_attrs.length; i++) {
+                attr_type_list.addElement(new BEROctetString(m_attrs[i]));
+            }
+        }
+        seq.addElement(attr_type_list);
+        BERTag element = new BERTag(BERTag.APPLICATION|BERTag.CONSTRUCTED|3,
+          seq, true);
+        return element;
+    }
+
+    /**
+     * Retrieves the string representation of the request.
+     * @return string representation
+     */
+    public String toString() {
+        String s = null;
+        if (m_attrs != null) {
+            s = "";
+            for (int i = 0; i < m_attrs.length; i++) {
+                if (i != 0)
+                    s = s + "+";
+                s = s + m_attrs[i];
+            }
+        }
+        return "SearchRequest {baseObject=" + m_base_dn + ", scope=" +
+          m_scope + ", derefAliases=" + m_deref + ",sizeLimit=" +
+          m_size_limit + ", timeLimit=" + m_time_limit + ", attrsOnly=" +
+          m_attrs_only + ", filter=" + m_filter + ", attributes=" +
+          s + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPDeleteRequest.java
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the delete request. This object
+ * is sent to the ldap server.
+ * <pre>
+ * DelRequest ::= [APPLICATION 10] LDAPDN
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPDeleteRequest extends JDAPBaseDNRequest
+    implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected String m_dn = null;
+
+    /**
+     * Constructs the delete request.
+     * @param dn Distinguished name to delete
+     */
+    public JDAPDeleteRequest(String dn) {
+        m_dn = dn;
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return operation type
+     */
+    public int getType() {
+        return JDAPProtocolOp.DEL_REQUEST;
+    }
+
+    /**
+     * Sets the base dn.
+     * @param basedn base dn
+     */
+    public void setBaseDN(String basedn) {
+        m_dn = basedn;
+    }
+
+    /**
+     * Gets the base dn.
+     * @return base dn
+     */
+    public String getBaseDN() {
+        return m_dn;
+    }
+
+    /**
+     * Gets the ber representation of the delete request.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        /* Assumed that deleteing "cn=patrick,o=ncware,c=ca"
+         * [*] umich-ldap-v3.3
+         *     0x4a 0x18  (implicit OctetString)
+         *     c n = p a t r i c k , o = n c w a r e , c = c a
+         */
+        BEROctetString s = new BEROctetString(m_dn);
+        BERTag element = new BERTag(BERTag.APPLICATION|10,
+          s, true);
+        return element;
+    }
+
+    /**
+     * Retrieves the string representation of the delete request.
+     * @return string representation
+     */
+    public String toString() {
+        return "DeleteRequest {entry=" + m_dn + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPResult.java
@@ -0,0 +1,290 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the ldap result where stores
+ * the request status. It is the base class for all
+ * the response except search response. This object is
+ * sent from the server to the client interface.
+ * <pre>
+ * LDAPResult ::= SEQUENCE {
+ *   resultCode ENUMERATED {
+ *     success (0),
+ *     ...
+ *   },
+ *   matchedDN LDAPDN,
+ *   errorMessage LDAPString
+ * }
+ * </pre>
+ *
+ * Note that LDAPv3 supports referral within the LDAP
+ * Result. The added component is:
+ *
+ * <pre>
+ * LDAPResult ::= SEQUENCE {
+ *   ...
+ *   errorMessage LDAPString,
+ *   referral [3] Referral OPTIONAL
+ * }
+ * </pre>
+ *
+ */
+public class JDAPResult {
+    /**
+     * Result code based on RFC1777
+     */
+    public final static int SUCCESS                      = 0;
+    public final static int OPERATION_ERROR              = 1;
+    public final static int PROTOCOL_ERROR               = 2;
+    public final static int TIME_LIMIT_EXCEEDED          = 3;
+    public final static int SIZE_LIMIT_EXCEEDED          = 4;
+    public final static int COMPARE_FALSE                = 5;
+    public final static int COMPARE_TRUE                 = 6;
+    public final static int AUTH_METHOD_NOT_SUPPORTED    = 7;
+    public final static int STRONG_AUTH_REQUIRED         = 8;
+    /* Referrals Within the LDAPv2 Protocol */
+    public final static int LDAP_PARTIAL_RESULTS         = 9;
+    /* Added for LDAPv3 - BEGIN */
+    public final static int REFERRAL                     = 10;
+    public final static int ADMIN_LIMIT_EXCEEDED         = 11;
+    public final static int UNAVAILABLE_CRITICAL_EXTENSION = 12;
+    public final static int CONFIDENTIALITY_REQUIRED     = 13;
+    public final static int SASL_BIND_IN_PROGRESS        = 14;
+    /* Added for LDAPv3 - END */
+    public final static int NO_SUCH_ATTRIBUTE            = 16;
+    public final static int UNDEFINED_ATTRIBUTE_TYPE     = 17;
+    public final static int INAPPROPRIATE_MATCHING       = 18;
+    public final static int CONSTRAINT_VIOLATION         = 19;
+    public final static int ATTRIBUTE_OR_VALUE_EXISTS    = 20;
+    public final static int INVALID_ATTRIBUTE_SYNTAX     = 21;
+    public final static int NO_SUCH_OBJECT               = 32;
+    public final static int ALIAS_PROBLEM                = 33;
+    public final static int INVALID_DN_SYNTAX            = 34;
+    public final static int IS_LEAF                      = 35;
+    public final static int ALIAS_DEREFERENCING_PROBLEM  = 36;
+    public final static int INAPPROPRIATE_AUTHENTICATION = 48;
+    public final static int INVALID_CREDENTIALS          = 49;
+    public final static int INSUFFICIENT_ACCESS_RIGHTS   = 50;
+    public final static int BUSY                         = 51;
+    public final static int UNAVAILABLE                  = 52;
+    public final static int UNWILLING_TO_PERFORM         = 53;
+    public final static int LOOP_DETECT                  = 54;
+    public final static int NAMING_VIOLATION             = 64;
+    public final static int OBJECT_CLASS_VIOLATION       = 65;
+    public final static int NOT_ALLOWED_ON_NONLEAF       = 66;
+    public final static int NOT_ALLOWED_ON_RDN           = 67;
+    public final static int ENTRY_ALREADY_EXISTS         = 68;
+    public final static int OBJECT_CLASS_MODS_PROHIBITED = 69;
+    public final static int AFFECTS_MULTIPLE_DSAS        = 71;
+    public final static int OTHER                        = 80;
+    public final static int SERVER_DOWN                  = 81;
+    public final static int PARAM_ERROR                  = 89;
+    public final static int CONNECT_ERROR                = 91;
+    public final static int LDAP_NOT_SUPPORTED           = 92;
+    public final static int CONTROL_NOT_FOUND            = 93;
+    public final static int NO_RESULTS_RETURNED          = 94;
+    public final static int MORE_RESULTS_TO_RETURN       = 95;
+    public final static int CLIENT_LOOP                  = 96;
+    public final static int REFERRAL_LIMIT_EXCEEDED      = 97;
+
+    /**
+     * Private variable
+     */
+    protected BERElement m_element = null;
+    protected int m_result_code;
+    protected String m_matched_dn = null;
+    protected String m_error_message = null;
+    protected String m_referrals[] = null;
+
+    /**
+     * Constructs ldap result.
+     * @param element ber element
+     */
+    public JDAPResult(BERElement element) throws IOException {
+        /* Result from a successful bind request.
+         * [*] umich-ldap-v3.3
+         *     0x0a 0x07      (implicit [APPLICATION 1] OctetString)
+         *     0x0a 0x01 0x00 (result code)
+         *     0x04 0x00      (matched dn)
+         *     0x04 0x00      (error message)
+         * Referrals in ldap-v2.0
+         * [*] umich-ldap-v3.3
+         *     0x65 0x2a
+         *     0x0a 0x01 0x09
+         *     0x04 0x00
+         *     0x04 0x23 R e f e r r a l : 0x0a
+         *               l d a p : / / l d a p .
+         *               i t d . u m i c h . e d u
+         */
+        m_element = element;
+        BERSequence seq = (BERSequence)element;
+        /*
+         * Possible return from [x500.arc.nasa.gov]:
+         * SEQUENCE {SEQUENCE {Enumerated{2} ... }}
+         */
+        BERElement e = seq.elementAt(0);
+        if (e.getType() == BERElement.SEQUENCE)
+            seq = (BERSequence)e;
+        m_result_code = ((BEREnumerated)seq.elementAt(0)).getValue();
+        byte buf[] = null;
+        buf = ((BEROctetString)seq.elementAt(1)).getValue();
+        if (buf == null)
+            m_matched_dn = null;
+        else {
+            try{
+                m_matched_dn = new String(buf, "UTF8");
+            } catch(Throwable x)
+            {}
+        }
+        buf = ((BEROctetString)seq.elementAt(2)).getValue();
+        if (buf == null)
+            m_error_message = null;
+        else {
+            try {
+                m_error_message = new String(buf, "UTF8");
+            } catch(Throwable x)
+            {}
+        }
+        /* 12/05/97 extract LDAPv3 referrals */
+        if (seq.size() >= 4) {
+            BERTag t = (BERTag)seq.elementAt(3);
+            BERElement v = t.getValue();
+            if (v.getType() == BERElement.INTEGER) {
+                /* MS - [CONTEXT-5] Integer {3} */
+                /* TBD */
+
+            // else if this element is BERSequence which contains referral information
+            } else if (v instanceof BERSequence) {
+                /* Netscape */
+                BERSequence rseq = (BERSequence)v;
+                if (rseq.size() > 0) {
+                    m_referrals = new String[rseq.size()];
+                    for (int i = 0; i < rseq.size(); i++) {
+                        try{
+                            m_referrals[i] = new
+                            String(((BEROctetString)rseq.elementAt(i)).getValue(), "UTF8");
+                        } catch(Throwable x)
+                        {}
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Gets the result code.
+     * @return result code
+     */
+    public int getResultCode() {
+        return m_result_code;
+    }
+
+    /**
+     * Gets the matched dn.
+     * @return matched dn
+     */
+    public String getMatchedDN() {
+        return m_matched_dn;
+    }
+
+    /**
+     * Gets the error message.
+     * @return error message
+     */
+    public String getErrorMessage() {
+        return m_error_message;
+    }
+
+    /**
+     * Retrieves referrals from the LDAP Result.
+     * @return list of referrals in URL format
+     */
+    public String[] getReferrals() {
+        return m_referrals;
+    }
+
+    /**
+     * Retrieves the ber representation of the result.
+     * @return ber representation of the result
+     */
+    public BERElement getBERElement() {
+        return m_element;
+    }
+
+    /**
+     * Retrieves string representation of the result. Usually,
+     * the inherited class calls this to retrieve the parameter
+     * string.
+     * @return string representation
+     */
+    public String getParamString() {
+        StringBuffer sb = new StringBuffer("{resultCode=");
+        sb.append(m_result_code);
+        if (m_matched_dn != null) {
+            sb.append(", matchedDN=");
+            sb.append(m_matched_dn);
+        }
+        if (m_error_message != null) {
+            sb.append(", errorMessage=");
+            sb.append(m_error_message);
+        }
+        if (m_referrals != null && m_referrals.length > 0) {
+            sb.append(", referrals=");
+            for (int i=0; i < m_referrals.length; i++) {
+                sb.append((i==0 ? "" : " "));
+                sb.append(m_referrals[i]);
+            }
+        }
+        sb.append("}");
+        return sb.toString();
+    }
+
+    /**
+     * Retrieves string representation of the result.
+     * @return string representation
+     */
+    public String toString() {
+        return "Result " + getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPCompareResponse.java
@@ -0,0 +1,79 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the compare response. This object
+ * is sent from the ldap server to the interface.
+ * <pre>
+ * CompareResponse ::= [APPLICATION 15] LDAPResult
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPCompareResponse extends JDAPResult implements JDAPProtocolOp {
+    /**
+     * Constructs compare response.
+     * @param element ber element of delete response
+     */
+    public JDAPCompareResponse(BERElement element) throws IOException {
+        super(((BERTag)element).getValue());
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.COMPARE_RESPONSE;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        return "CompareResponse " + super.getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPSearchResultReference.java
@@ -0,0 +1,115 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the search result reference. See RFC 1777.
+ * <pre>
+ * SearchResultReference :: [APPLICATION 19] SEQUENCE OF LDAPURL
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPSearchResultReference implements JDAPProtocolOp {
+
+    /**
+     * Internal variables
+     */
+    protected String m_urls[] = null;
+    protected BERElement m_element = null;
+
+    /**
+     * Constructs extended response.
+     * @param element ber element of add response
+     */
+    public JDAPSearchResultReference(BERElement element) throws IOException {
+        m_element = element;
+        BERSequence seq = (BERSequence)((BERTag)element).getValue();
+        if (seq.size() < 0)
+            return;
+        m_urls = new String[seq.size()];
+        for (int i=0; i < seq.size(); i++) {
+            BEROctetString o = (BEROctetString)seq.elementAt(i);
+            m_urls[i] = new String(o.getValue(), "UTF8");
+        }
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.SEARCH_RESULT_REFERENCE;
+    }
+
+    /**
+     * Retrieves the BER representation of this object.
+     */
+    public BERElement getBERElement() {
+        return m_element;
+    }
+
+    /**
+     * Retrieves a list of urls.
+     */
+    public String[] getUrls() {
+        return m_urls;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        String urls = "";
+        if (m_urls != null) {
+            for (int i = 0; i < m_urls.length; i++) {
+                if (i != 0)
+                    urls += ",";
+                urls += m_urls[i];
+            }
+        }
+        return "SearchResultReference " + urls;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPSearchResult.java
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the search result. This object
+ * is sent from the ldap server to the interface. Note
+ * that search response is separated into search response
+ * and search result. The search response contains the
+ * result from the server, while the research result indicates
+ * the end of the search response sequence.
+ * <pre>
+ * resultCode [APPLICATION 5] LDAPResult
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPSearchResult extends JDAPResult implements JDAPProtocolOp {
+    /**
+     * Constructs search result.
+     * @param element ber element of search result
+     */
+    public JDAPSearchResult(BERElement element) throws IOException {
+        super(((BERTag)element).getValue());
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.SEARCH_RESULT;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        return "SearchResult " + super.getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPBindResponse.java
@@ -0,0 +1,115 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the bind response. This object
+ * is sent from the ldap server to the interface.
+ * <pre>
+ * BindResponse = [APPLICATION 1] LDAPResult
+ * </pre>
+ *
+ * Note that LDAPv3.0 Bind Response is structured as follows:
+ * <pre>
+ * BindResponse ::= [APPLICATION 1] SEQUENCE {
+ *   COMPONENTS OF LDAPResult,
+ *   serverCreds [7] SaslCredentials OPTIONAL
+ * }
+ * </pre>
+ *
+ */
+public class JDAPBindResponse extends JDAPResult implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected byte[] m_credentials = null;
+
+    /**
+     * Constructs bind response.
+     * @param element ber element of bind response
+     */
+    public JDAPBindResponse(BERElement element) throws IOException {
+        super(((BERTag)element).getValue());
+        /* LDAPv3 Sasl Credentials support */
+        BERSequence s = (BERSequence)((BERTag)element).getValue();
+        if (s.size() <= 3) {
+            return;
+        }
+        BERElement e = s.elementAt(3);
+        if (e.getType() == BERElement.TAG) {
+			BERElement el = ((BERTag)e).getValue();
+			if (el instanceof BERSequence) {
+				el = ((BERSequence)el).elementAt(0);
+			}
+            BEROctetString str = (BEROctetString)el;
+            try{
+                m_credentials = str.getValue();
+            } catch(Exception ex)
+            {}
+        }
+    }
+
+    /**
+     * Retrieves Sasl Credentials. LDAPv3 support.
+     * @return credentials
+     */
+    public byte[] getCredentials() {
+        return m_credentials;
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.BIND_RESPONSE;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        return "BindResponse " + super.getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPDeleteResponse.java
@@ -0,0 +1,79 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the delete response. This object
+ * is sent from the ldap server to the interface.
+ * <pre>
+ * DeleteResponse ::= [APPLICATION 11] LDAPResult
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPDeleteResponse extends JDAPResult implements JDAPProtocolOp {
+    /**
+     * Constructs delete response.
+     * @param element ber element of delete response
+     */
+    public JDAPDeleteResponse(BERElement element) throws IOException {
+        super(((BERTag)element).getValue());
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.DEL_RESPONSE;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        return "DeleteResponse " + super.getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPExtendedResponse.java
@@ -0,0 +1,131 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the extended response. This object
+ * is sent from the ldap server to the interface and is
+ * a v3 response. See RFC 1777.
+ * <pre>
+ * ExtendedResponse :: [APPLICATION 23] SEQUENCE {
+ *   COMPONENTS OF LDAPResult,
+ *   responseName [10] LDAPOID OPTIONAL,
+ *   response     [11] OCTET STRING OPTIONAL
+ * }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPExtendedResponse extends JDAPResult
+    implements JDAPProtocolOp {
+
+    /**
+     * Internal variables
+     */
+    protected String m_oid = null;
+    protected byte[] m_value = null;
+
+    /**
+     * Constructs extended response.
+     * @param element ber element of add response
+     */
+    public JDAPExtendedResponse(BERElement element) throws IOException {
+        super(((BERTag)element).getValue());
+        BERSequence seq = (BERSequence)((BERTag)element).getValue();
+        for (int i = 0; i < seq.size(); i++) {
+            try {
+                BERElement el = seq.elementAt(i);
+                if (el.getType() != BERElement.TAG)
+                    continue;
+                BERTag t = (BERTag)el;
+                switch (t.getTag()&0x0f) {
+                    case 10:
+                        BEROctetString oid = (BEROctetString)t.getValue();
+                        try{
+                            m_oid = new String(oid.getValue(), "UTF8");
+                        } catch(Throwable x)
+                        {}
+                        break;
+                    case 11:
+                        BEROctetString value = (BEROctetString)t.getValue();
+                        m_value = value.getValue();
+                        break;
+                }
+            } catch (ClassCastException e) {
+            }
+        }
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.EXTENDED_RESPONSE;
+    }
+
+    /**
+     * Retrieves the results of the extended operation.
+     * @return extended operation results as byte array
+     */
+    public byte[] getValue() {
+        return m_value;
+    }
+
+    /**
+     * Retrieves the oid of the extended operation.
+     * @return extended operation oid.
+     */
+    public String getID() {
+        return m_oid;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        return "ExtendedResponse " + super.getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPAbandonRequest.java
@@ -0,0 +1,102 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the abandon request. This object
+ * is sent to the ldap server. See RFC 1777.
+ * <pre>
+ * AbandonRequest ::= [APPLICATION 16] MessageID
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPAbandonRequest implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected int m_msgid;
+
+    /**
+     * Constructs abandon request.
+     * @param msgid message identifier
+     */
+    public JDAPAbandonRequest(int msgid) {
+        m_msgid = msgid;
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.ABANDON_REQUEST;
+    }
+
+    /**
+     * Gets the ber representation of abandon request.
+     * @return ber representation of request
+     */
+    public BERElement getBERElement() {
+        /* Assumed m_msgid = 1. The BER encoding output
+         * should be
+         *
+         * [*] umich-ldap-v3.3:
+         *     0x50 (implicit tagged integer)
+         *     0x01 (length)
+         *     0x01 (message id)
+         */
+        BERInteger i = new BERInteger(m_msgid);
+        BERTag element = new BERTag(BERTag.APPLICATION|16, i, true);
+        return element;
+    }
+
+    /**
+     * Retrieves the string representation of abandon request.
+     * @return string representation
+     */
+    public String toString() {
+        return "AbandonRequest {msgid=" + m_msgid + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPAddResponse.java
@@ -0,0 +1,80 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the add response. This object
+ * is sent from the ldap server to the interface. See
+ * RFC 1777.
+ * <pre>
+ * AddResponse ::= [APPLICATION 9] LDAPResult
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPAddResponse extends JDAPResult implements JDAPProtocolOp {
+    /**
+     * Constructs add response.
+     * @param element ber element of add response
+     */
+    public JDAPAddResponse(BERElement element) throws IOException {
+        super(((BERTag)element).getValue());
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.ADD_RESPONSE;
+    }
+
+    /**
+     * Retrieve the string representation.
+     * @return string representation
+     */
+    public String toString() {
+        return "AddResponse " + super.getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPUnbindRequest.java
@@ -0,0 +1,93 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This class implements the unbind request and is a protocol operation.
+ * A protocol operation is embedded within JDAPMessage which is sent
+ * between client and server. This object is sent to the ldap server.
+ * <pre>
+ * UnbindRequest ::= [APPLICATION 2] NULL
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPUnbindRequest implements JDAPProtocolOp {
+    /**
+     * Constructs bind request.
+     */
+    public JDAPUnbindRequest() {
+    }
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return operation type
+     */
+    public int getType() {
+        return JDAPProtocolOp.UNBIND_REQUEST;
+    }
+
+    /**
+     * Gets the ber representation of the unbind rquest.
+     * @return ber representation
+     */
+    public BERElement getBERElement() {
+        /*
+         * [*] umich-ldap-v3.3:
+         *     0x42 0x00
+         * [*] umich-ldap-v3.0:
+         */
+        BERNull n = new BERNull();
+        BERTag element = new BERTag(BERTag.APPLICATION|2, n, true);
+        return element;
+    }
+
+    /**
+     * Retrieves the string representation of unbind operation.
+     * @return string representation
+     */
+    public String toString() {
+        return "UnbindRequest {}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPAddRequest.java
@@ -0,0 +1,160 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.*;
+import netscape.ldap.client.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+
+/**
+ * This class implements the add request. This object
+ * is sent to the ldap server. See RFC 1777.
+ * <pre>
+ * AddRequest ::= [APPLICATION 8] SEQUENCE {
+ *   entry LDAPDN,
+ *   attrs SEQUENCE OF SEQUENCE {
+ *     type AttributeType,
+ *     values SET OF AttributeValue
+ *   }
+ * }
+ * </pre>
+ *
+ * @version 1.0
+ */
+public class JDAPAddRequest extends JDAPBaseDNRequest
+    implements JDAPProtocolOp {
+    /**
+     * Internal variables
+     */
+    protected String m_dn = null;
+    protected LDAPAttribute m_attrs[] = null;
+
+    /**
+     * Constructs add request.
+     * @param dn distinguished name of adding entry
+     * @param attrs list of attribute associated with entry
+     */
+    public JDAPAddRequest(String dn, LDAPAttribute attrs[]) {
+        m_dn = dn;
+        m_attrs = attrs;
+    }
+
+    /**
+     * Retrieves protocol operation type.
+     * @return protcol type
+     */
+    public int getType() {
+        return JDAPProtocolOp.ADD_REQUEST;
+    }
+
+    /**
+     * Sets the base dn component.
+     * @param basedn base dn
+     */
+    public void setBaseDN(String basedn) {
+        m_dn = basedn;
+    }
+
+    /**
+     * Gets the base dn component.
+     * @return base dn
+     */
+    public String getBaseDN() {
+        return m_dn;
+    }
+
+    /**
+     * Gets the ber representation of add request.
+     * @return ber representation of request
+     */
+    public BERElement getBERElement() {
+        /* Assumed that adding cn=patrick,o=ncware,c=ca with
+         * following attributes:
+         *     cn: patrick
+         *     title: programmer
+         * [*] umich-ldap-v3.3:
+         *     0x68 0x46      ([APPLICATION8])
+         *     0x04 0x1a c n = p a t r i c k , 0x20
+         *               o = n c w a r e , 0x20 c =
+         *               c a  (entry - OctetString)
+         *     0x30 0x28      (SEQUENCE)
+         *     0x30 0x0f      (SEQUENCE)
+         *     0x04 0x02 c n  (attribute type - OctetString)
+         *     0x31 0x09      (SET OF)
+         *     0x04 0x07 p a t r i c k (attribute value - OctetString)
+         *     0x30 0x15
+         *     0x04 0x05 t i t l e
+         *     0x31 0x0c      (SET OF)
+         *     0x04 0x0a p r o g r a m m e r
+         */
+        BERSequence seq = new BERSequence();
+        seq.addElement(new BEROctetString (m_dn));
+        BERSequence attrs_list = new BERSequence();
+        for (int i = 0; i < m_attrs.length; i++) {
+            attrs_list.addElement(m_attrs[i].getBERElement());
+        }
+        seq.addElement(attrs_list);
+        BERTag element = new BERTag(BERTag.APPLICATION|BERTag.CONSTRUCTED|8,
+          seq, true);
+        return element;
+    }
+
+    /**
+     * Retrieves the string representation of add request parameters.
+     * @return string representation of add request parameters
+     */
+    public String getParamString() {
+        String s = "";
+        for (int i = 0; i < m_attrs.length; i++) {
+            if (i != 0)
+                s = s + " ";
+            s = s + m_attrs[i].toString();
+        }
+        return "{entry='" + m_dn + "', attrs='" + s + "'}";
+    }
+
+    /**
+     * Retrieves the string representation of add request.
+     * @return string representation of add request
+     */
+    public String toString() {
+        return "AddRequest " + getParamString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/client/opers/JDAPProtocolOp.java
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.client.opers;
+
+import java.util.*;
+import netscape.ldap.ber.stream.*;
+import java.io.*;
+import java.net.*;
+
+/**
+ * This is the base interface for all protocol operation
+ * that is embedded in a JDAPMessage (LDAP Message in RCF1777).
+ * Each protocol operation must implement this interface.
+ *
+ * @version 1.0
+ */
+public interface JDAPProtocolOp {
+    /**
+     * Protocol operation types
+     */
+    public final static int BIND_REQUEST        = 0;
+    public final static int BIND_RESPONSE       = 1;
+    public final static int UNBIND_REQUEST      = 2;
+    public final static int SEARCH_REQUEST      = 3;
+    public final static int SEARCH_RESPONSE     = 4;
+    public final static int SEARCH_RESULT       = 5;
+    public final static int MODIFY_REQUEST      = 6;
+    public final static int MODIFY_RESPONSE     = 7;
+    public final static int ADD_REQUEST         = 8;
+    public final static int ADD_RESPONSE        = 9;
+    public final static int DEL_REQUEST         = 10;
+    public final static int DEL_RESPONSE        = 11;
+    public final static int MODIFY_RDN_REQUEST  = 12;
+    public final static int MODIFY_RDN_RESPONSE = 13;
+    public final static int COMPARE_REQUEST     = 14;
+    public final static int COMPARE_RESPONSE    = 15;
+    public final static int ABANDON_REQUEST     = 16;
+    public final static int SEARCH_RESULT_REFERENCE = 19;
+    public final static int EXTENDED_REQUEST    = 23;
+    public final static int EXTENDED_RESPONSE   = 24;
+
+    /**
+     * Retrieves the protocol operation type.
+     * @return protocol type
+     */
+    public int getType();
+
+    /**
+     * Retrieves the ber representation of the operation.
+     * @return ber representation
+     */
+    public BERElement getBERElement();
+
+    /**
+     * Retrieves the string representation of the operation.
+     * @return string representation
+     */
+    public String toString();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERConstruct.java
@@ -0,0 +1,148 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This abstract class serves as a based class for constructed
+ * types such as sequence or set.
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public abstract class BERConstruct extends BERElement {
+    /**
+     * List of BER elements in the construct.
+     */
+    private Vector m_elements = new Vector();
+
+    /**
+     * Constructs a construct element.
+     */
+    public BERConstruct() {
+    }
+
+    /**
+     * Constructs a construct element from an input stream.
+     * @param decoder decoder for application specific BER
+     * @param stream input stream from socket
+     * @param bytes_read array of 1 int; value incremented by number
+     * of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERConstruct(BERTagDecoder decoder, InputStream stream,
+        int[] bytes_read) throws IOException {
+        int contents_length = super.readLengthOctets(stream,bytes_read);
+        int[] component_length = new int[1];
+        if (contents_length == -1) {
+            /* Constructed - indefinite length */
+            BERElement element = null;
+            {
+                component_length[0] = 0;
+                element = getElement(decoder, stream, component_length);
+                if (element != null)
+                    addElement(element);
+            } while (element != null);
+        } else {
+            /* Constructed - definite length */
+            bytes_read[0] += contents_length;
+            while (contents_length > 0)
+            {
+                component_length[0] = 0;
+                addElement(getElement(decoder, stream,component_length));
+                contents_length -= component_length[0];
+            }
+        }
+    }
+
+
+    /**
+     * Adds an element to the list.
+     */
+    public void addElement(BERElement element) {
+        m_elements.addElement(element);
+    }
+
+    /**
+     * Retrieves number of elements.
+     * @return number of elements.
+     */
+    public int size() {
+        return m_elements.size();
+    }
+
+    /**
+     * Gets ber element at specific position.
+     * @param index index of the element to get
+     * @return BER element.
+     */
+    public BERElement elementAt(int index) {
+        return (BERElement)m_elements.elementAt(index);
+    }
+
+    /**
+     * Sends the BER encoding directly to a stream.
+     * @param stream output stream
+     * @exception IOException failed to send
+     */
+    public void write(OutputStream stream) throws IOException {
+        stream.write(getType());
+
+        ByteArrayOutputStream contents_stream = new ByteArrayOutputStream();
+        for (int i = 0; i < m_elements.size(); i++)  {
+            BERElement e = elementAt(i);
+            e.write(contents_stream);
+        }
+        byte[] contents_buffer = contents_stream.toByteArray();
+        sendDefiniteLength(stream, contents_buffer.length);
+        stream.write(contents_buffer);
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public abstract int getType();
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public abstract String toString();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BEREnumerated.java
@@ -0,0 +1,97 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the Enumerated object.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Primitive Definite length.
+ *   tag = 0x0a
+ *   length = (short or long form)
+ *   one or more contents octets hold integral value
+ *   value in two's complement
+ *
+ * Example:  (Enumerated - 1)
+ *   0A 01 01
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BEREnumerated extends BERIntegral {
+
+    /**
+     * Constructs an enumerated element with a value.
+     * @param value integral value
+     */
+    public BEREnumerated(int value) {
+        super(value);
+    }
+
+    /**
+     * Constructs an enumerated element with the input stream.
+     * @param stream input stream from which to decode
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from array
+     * @exception IOException failed to construct
+     */
+    public BEREnumerated(InputStream stream, int[] bytes_read)
+        throws IOException {
+        super(stream, bytes_read);
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public int getType() {
+        return BERElement.ENUMERATED;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        return "Enumerated {" + getValue() + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERCharacterString.java
@@ -0,0 +1,195 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This is an abstract base class for character string types.
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public abstract class BERCharacterString extends BERElement {
+    /**
+     * Internal variables
+     */
+    protected String m_value = null;
+
+    /**
+     * Constructs a character string element containing a buffer.
+     */
+    public BERCharacterString() {
+    }
+
+    /**
+     * Constructs a character string element containing buffer.
+     * @param string a string value
+     */
+    public BERCharacterString(String string) {
+        m_value = string;
+    }
+
+    /**
+     * Constructs a character string element from a byte array.
+     * @param buffer buffer containing UTF8 data
+     */
+    public BERCharacterString(byte[] buffer) {
+        try{
+            m_value = new String(buffer,"UTF8");
+        } catch(Throwable x)
+        {}
+    }
+
+    /**
+     * Constructs a character string element from an input stream
+     * (for constructed encoding)
+     * @param stream input stream
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERCharacterString(BERTagDecoder decoder, InputStream stream,
+                        int[] bytes_read) throws IOException {
+        int octet;
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+        int[] component_length = new int[1];
+        BERElement element = null;
+
+        if (contents_length == -1) {
+            /* Constructed - indefinite length content octets. */
+            do {
+                component_length[0] = 0;
+                element = getElement(decoder,stream,component_length);
+                if (element != null) {
+                    /* element is a string of same type
+                     * - add it to the existing buffer */
+                    BERCharacterString octet_element = (BERCharacterString)element;
+                    String string_buffer = octet_element.getValue();
+                    if (m_value == null) {
+                        m_value = string_buffer;
+                    } else {
+                        m_value = m_value + string_buffer;
+                    }
+                }
+            } while (element != null);
+        } else {
+            /* Definite length content octets string. */
+            bytes_read[0] += contents_length;
+            while (contents_length > 0) {
+                component_length[0] = 0;
+                element = getElement(decoder,stream,component_length);
+                if (element != null) {
+                    /* element is a string of the same type
+                     * - add it to the existing buffer */
+                    BERCharacterString octet_element = (BERCharacterString)element;
+                    String string_buffer = octet_element.getValue();
+                    if (m_value == null) {
+                        m_value = string_buffer;
+                    } else {
+                        m_value = m_value + string_buffer;
+                    }
+                }
+                contents_length -= component_length[0];
+            }
+        }
+    }
+
+    /**
+     * Constructs a character string element from an input stream
+     * (for primitive encoding)
+     * @param stream source
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERCharacterString(InputStream stream, int[] bytes_read)
+        throws IOException {
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+
+        /* Definite length content octets string. */
+        if (contents_length > 0) {
+            byte[] buffer = new byte[contents_length];
+            for (int i = 0; i < contents_length; i++) {
+                buffer[i] = (byte) stream.read();
+            }
+            bytes_read[0] += contents_length;
+            try {
+                m_value = new String(buffer,"UTF8");
+            } catch(Throwable x)
+            {}
+        }
+    }
+
+    private byte[] byte_buf;
+
+    /**
+     * Writes BER to stream.
+     * @param stream output stream
+     */
+    public void write(OutputStream stream) throws IOException {
+      stream.write(getType());  /* tag */
+        if (m_value == null) {
+            sendDefiniteLength(stream, 0);
+        } else {
+            try {
+                byte_buf =  m_value.getBytes("UTF8");
+                sendDefiniteLength(stream, byte_buf.length);  /* length */
+            } catch(Throwable x)
+            {}
+            stream.write(byte_buf,0,byte_buf.length);  /* contents */
+        }
+    }
+
+    /**
+     * Gets the element value.
+     */
+    public String getValue() {
+        return m_value;
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public abstract int getType();
+
+    /**
+     * Gets the string representation.
+     * @return string representation.
+     */
+    public abstract String toString();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERSet.java
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the Set object. A set object can contain
+ * a set of BER elements.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *  tag    = 0x31 (always constructed)
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERSet extends BERConstruct {
+    /**
+     * Constructs a set element.
+     * @exception failed to construct
+     */
+    public BERSet() throws IOException {
+    }
+
+    /**
+     * Constructs a set element from an input stream.
+     * @param decoder decoder for application-specific BER
+     * @param stream source
+     * @param bytes_read array of 1 int; value incremented by number
+     * of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERSet(BERTagDecoder decoder, InputStream stream,
+        int[] bytes_read) throws IOException {
+        super(decoder, stream,bytes_read);
+    }
+
+    /**
+     * Sends the BER encoding directly to a stream.
+     * @param stream output stream
+     * @exception IOException failed to write
+     */
+    public void write(OutputStream stream) throws IOException {
+        super.write(stream);
+    }
+
+    /**
+     * Gets the element type.
+     * @return element type.
+     */
+    public int getType() {
+        return BERElement.SET;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        String elements = "";
+        for (int i = 0; i < super.size(); i++) {
+            if (i != 0)
+                elements = elements + ", ";
+            elements = elements + ((BERElement)super.elementAt(i)).toString();
+        }
+        return "Set {" + elements + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERBoolean.java
@@ -0,0 +1,128 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the Boolean object.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *  tag    = 0x01
+ *  length = 0x01
+ *  one contents octet (non-zero indicates TRUE).
+ *
+ * Example 1:  (false)
+ *   01 01 00
+ * Example 2:  (true)
+ *   01 01 FF
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERBoolean extends BERElement {
+    /**
+     * Internal variables
+     */
+    private boolean m_value = true;
+
+    /**
+     * Constructs a boolean element.
+     * @param value boolean value
+     */
+    public BERBoolean(boolean value) {
+        m_value = value;
+    }
+
+    /**
+     * Constructs a boolean element from an input stream.
+     * @param stream source
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERBoolean(InputStream stream, int[] bytes_read) throws IOException {
+        int octet = stream.read();  /* skip length */
+        bytes_read[0]++;
+        octet = stream.read();      /* content octet */
+        bytes_read[0]++;
+
+        if (octet > 0)
+            m_value = true;
+        else
+            m_value = false;
+    }
+
+    /**
+     * Sends the BER encoding directly to a stream.
+     * @param stream output stream
+     */
+    public void write(OutputStream stream) throws IOException {
+        stream.write(BERElement.BOOLEAN);
+        stream.write(0x01);
+        if (m_value)
+            stream.write(0xFF);  /* non-zero means true. */
+        else
+            stream.write(0x00);  /* zero means false. */
+    }
+
+    /**
+     * Gets the boolean value.
+     */
+    public boolean getValue() {
+        return m_value;
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public int getType() {
+        return BERElement.BOOLEAN;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        return "Boolean {" + m_value + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERReal.java
@@ -0,0 +1,229 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the Real object.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *  tag    = 0x09
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERReal extends BERElement {
+    /**
+     * Constants: special ASN.1 real values
+     */
+    public final static float PLUS_INFINITY = 1.0f/0.0f;
+    public final static float MINUS_INFINITY = -1.0f/0.0f;
+
+    /**
+     * Value of element
+     */
+    private float m_value = 0;
+
+    /**
+     * Constructs a real element with a value
+     * @param value float value
+     */
+    public BERReal(float value) {
+        m_value = value;
+    }
+
+    /**
+     * Constructs a real element from an input stream.
+     * @param stream source
+     * @param bytes_read array of 1 int; value incremented by
+     *        number of bytes read from stream.
+     * @exception IOException failed to construct
+     */
+    public BERReal(InputStream stream, int[] bytes_read) throws IOException {
+        int length = super.readLengthOctets(stream, bytes_read);
+
+        if (length == 0)
+            /* zero length indicates value is zero */
+            m_value = 0;
+        else {
+            int octet = stream.read(); /* first content octet */
+            bytes_read[0]++;
+
+            if (octet == 0x40)  /* bit 8 = 1 */
+                m_value = PLUS_INFINITY;
+            else if (octet == 0x41)  /* bit 8 = 1 and bit 1 = 1 */
+                m_value = MINUS_INFINITY;
+            else if ((octet & 0x80) > 0) {
+                /* bit 8 = 1 */
+                /* Binary encoding */
+                /* M = S*N*2F where S = -1 or 1, 0<= F <= 3. */
+                int sign;
+                int base;
+                int number;
+                int f;        /* binary scaling factor */
+                int exponent;
+                int mantissa;
+                int num_exponent_octets;
+                int contents_length_left;
+
+                if ((octet & 0x40) > 0) sign = -1;
+                else sign = 1;
+
+                if ((octet & 0x20) > 0) {
+                    if ((octet & 0x10) > 0) {
+                        /* bits 6+5 = 11 */
+                        /* reserved for future use */
+                        base = 0;
+                    } else {
+                        /* bits 6+5 = 10 */
+                        base = 16;
+                    }
+                } else if ((octet & 0x10) > 0) {
+                    /* bits 6+5 = 01 */
+                    base = 8;
+                } else {
+                    /* bits 6+5 = 00 */
+                    base = 2;
+                }
+
+                if ((octet & 0x08) > 0) {
+                    if ((octet & 0x04) > 0) {
+                        /* bits 4+3 = 11 */
+                        f = 3;
+                    } else {
+                        /* bits 4+3 = 10 */
+                        f = 2;
+                    }
+                } else if ((octet & 0x04) > 0) {
+                    /* bits 4+3 = 01 */
+                    f = 1;
+                } else {
+                    /* bits 4+3 = 00 */
+                    f = 0;
+                }
+
+                if ((octet & 0x02) > 0) {
+                    if ((octet & 0x01) > 0) {
+                        /* bits 2+1 = 11 */
+                        /* Following octet encodes the number of octets used to
+                         * encode the exponent.
+                         */
+                        num_exponent_octets = stream.read();
+                        bytes_read[0]++;
+                        exponent = readTwosComplement(stream,bytes_read,num_exponent_octets);
+                    } else {
+                        /* bits 2+1 = 10 */
+                        num_exponent_octets = 3;
+                        exponent = readTwosComplement(stream,bytes_read,num_exponent_octets);
+                    }
+                } else if ((octet & 0x01) > 0) {
+                    /* bits 2+1 = 01 */
+                    num_exponent_octets = 2;
+                    exponent = readTwosComplement(stream,bytes_read,num_exponent_octets);
+                } else {
+                    /* bits 2+1 = 00 */
+                    num_exponent_octets = 1;
+                    exponent = readTwosComplement(stream,bytes_read,num_exponent_octets);
+                }
+
+                contents_length_left = length - 1 - num_exponent_octets;
+                number = readUnsignedBinary(stream, bytes_read, contents_length_left);
+
+                mantissa = (int)(sign * number * Math.pow(2, f));
+                m_value = mantissa * (float)Math.pow((double)base,(double)exponent);
+            } else {
+                /* bits 8 + 7 = 00 */
+                /* ISO 6093 field */
+                /*** NOTE: It has been agreed that this feature will
+                 *         not be provided right now.
+                 */
+                 throw new IOException("real ISO6093 not supported. ");
+            }
+        }
+    }
+
+    /**
+     * Sends the BER encoding directly to a stream.
+     * @param stream output stream
+     * @exception IOException failed to write
+     */
+    public void write(OutputStream stream) throws IOException {
+        if (m_value == 0) {
+            stream.write(BERElement.REAL);
+            stream.write(0x00);     /* length */
+        } else if (m_value == PLUS_INFINITY) {
+            stream.write(BERElement.REAL);
+            stream.write(0x01);     /* length */
+            stream.write(0x40);     /* contents */
+        } else if (m_value == MINUS_INFINITY) {
+            stream.write(BERElement.REAL);
+            stream.write(0x01);     /* length */
+            stream.write(0x41);     /* contents */
+        } else {
+            /* Non-special real value */
+            /* NOTE: currently always sends as a base 2 binary encoding
+             * (see X.2 09 section 10.5.)
+             *
+             * M = S * N * 2F
+             *
+             * Simple encoding always uses F = 1.
+             */
+             // bcm - incomplete.
+        }
+    }
+
+    /**
+     * Gets the element type.
+     * @return element type
+     */
+    public int getType() {
+        return BERElement.REAL;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag
+     */
+    public String toString() {
+        return "Real {" + m_value + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERInteger.java
@@ -0,0 +1,102 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the Integer object.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Primitive Definite length.
+ *   tag = 0x02
+ *   length = (short or long form)
+ *   one or more contents octets hold integer
+ *   value in two's complement
+ *
+ * Example 1:  (zero)
+ *   02 01 00
+ * Example 2:  (1)
+ *   02 01 01
+ * Example 3:  (300 - short form)
+ *   02 02 01 2C
+ * Example 4:  (300 - long form)
+ *   02 84 00 00 01 2C
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERInteger extends BERIntegral {
+
+    /**
+     * Constructs a integer element.
+     * @param value integer value
+     */
+    public BERInteger(int value) {
+        super(value);
+    }
+
+    /**
+     * Constructs an integer element with the input stream.
+     * @param stream input stream
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERInteger(InputStream stream, int[] bytes_read) throws IOException {
+        super(stream, bytes_read);
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public int getType() {
+        return BERElement.INTEGER;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        return "Integer {" + getValue() + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERChoice.java
@@ -0,0 +1,114 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the Choice object. Note that this class may be
+ * used by a client.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Encoding is the encoding of the specific type used.
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERChoice extends BERElement {
+    /**
+     * Internal variables
+     */
+    private BERElement m_value = null;
+
+    /**
+     * Constructs a choice element.
+     * @param value any BERElement value
+     */
+    public BERChoice(BERElement value) {
+        m_value = value;
+    }
+
+    /**
+     * Constructs a choice element from an input stream.
+     * Note that with the current decoding architecture choice types
+     * will not be decoded as choices but rather as the types
+     * chosen. The following method will never be called.
+     * @param stream input stream
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERChoice(BERTagDecoder decoder, InputStream stream,
+                     int[] bytes_read) throws IOException {
+        m_value = getElement(decoder, stream, bytes_read);
+    }
+
+    /**
+     * Sends the BER encoding of the chosen type directly to a stream.
+     * @param stream output stream
+     * @exception IOException failed to write
+     */
+    public void write(OutputStream stream) throws IOException {
+        m_value.write(stream);
+    }
+
+    /**
+     * Gets the value of the chosen type.
+     */
+    public BERElement getValue() {
+        return m_value;
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public int getType() {
+        return BERElement.CHOICE;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        return "CHOICE {" + m_value + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERSequence.java
@@ -0,0 +1,98 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the Sequence object. A sequence object can
+ * contains a sequence of BER Elements.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *  tag    = 0x30 (always constructed)
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERSequence extends BERConstruct {
+    /**
+     * Constructs a sequence element.
+     */
+    public BERSequence() {
+        super();
+    }
+
+    /**
+     * Constructs a sequence element from an input stream.
+     * @param decoder application-specific BER decoder
+     * @param stream input stream from which to read BER
+     * @param bytes_read array of 1 int; value is incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERSequence(BERTagDecoder decoder, InputStream stream,
+        int[] bytes_read) throws IOException {
+
+        super(decoder, stream, bytes_read);
+    }
+
+    /**
+     * Gets the element type.
+     * @return element type.
+     */
+    public int getType() {
+        return BERElement.SEQUENCE;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        String elements = "";
+        for (int i = 0; i < super.size(); i++) {
+            if (i != 0)
+                elements = elements + ", ";
+            elements = elements + ((BERElement)super.elementAt(i)).toString();
+        }
+        return "Sequence {" + elements + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERAny.java
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the "any" object that is unknown to the
+ * BER package but conforms to BER rules.
+ *
+ * <pre>
+ * Encoding Rule:
+ *   The encoding is that of the particular implementation.
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERAny extends BERElement {
+    /**
+     * Internal variables
+     */
+    private BERElement m_value = null;
+
+    /**
+     * Constructs an "any" element.
+     * @param value BERElement value
+     */
+    public BERAny(BERElement value) {
+        m_value = value;
+    }
+
+    /**
+     * Constructs an "any" element from an input stream.
+     * Note that with the current decoding architecture "any" types
+     * will not be decoded as any's but rather as the particular
+     * implementation.  The following method will never be called.
+     * @param stream input stream
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERAny(BERTagDecoder decoder, InputStream stream,
+                      int[] bytes_read) throws IOException {
+        m_value = getElement(decoder, stream, bytes_read);
+    }
+
+    /**
+     * Sends the BER encoding directly to an output stream.
+     * @param stream output stream
+     */
+    public void write(OutputStream stream) throws IOException {
+        m_value.write(stream);
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public int getType() {
+        return BERElement.ANY;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        return "ANY {" + m_value + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERNull.java
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the NULL type.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   tag = 0x05
+ *   length value is zero (short or long form).
+ *   no contents
+ *
+ * Example 1:  (short form)
+ *   05 00
+ * Example 2:  (long form)
+ *   05 81 00
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERNull extends BERElement {
+    /**
+     * Constructs a NULL element.
+     */
+    public BERNull() {
+    }
+
+    /**
+     * Constructs a null element from an input stream.
+     * @param stream input stream from socket
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERNull(InputStream stream, int[] bytes_read) throws IOException {
+        /* The result should be zero of course */
+        readLengthOctets(stream,bytes_read);
+    }
+
+    /**
+     * Sends the BER encoding directly to stream.
+     * @param stream output stream
+     * @exception IOException failed to write
+     */
+    public void write(OutputStream stream) throws IOException {
+        byte[] buffer = new byte[2];
+        buffer[0] = (byte)BERElement.NULL;  /* NULL tag */
+        buffer[1] = 0x00;  /* length */
+        stream.write(buffer);
+    }
+
+    /**
+     * Gets the element type.
+     * @return element type.
+     */
+    public int getType() {
+        return BERElement.NULL;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        return "Null {}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERElement.java
@@ -0,0 +1,336 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the tagged object type. A nested tag is
+ * allowed. A tagged element contains another BER element.
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public abstract class BERElement implements Serializable {
+    /**
+     * Possible element types.
+     */
+    public final static int BOOLEAN = 0x01;
+    public final static int INTEGER = 0x02;
+    public final static int BITSTRING = 0x03;
+    public final static int OCTETSTRING = 0x04;
+    public final static int NULL = 0x05;
+    public final static int OBJECTID = 0x06;
+    public final static int REAL = 0x09;
+    public final static int ENUMERATED = 0x0a;
+    public final static int SET = 0x31;          /* always constructed */
+    public final static int SEQUENCE = 0x30;     /* always constructed */
+    public final static int NUMERICSTRING = 0x12;
+    public final static int PRINTABLESTRING = 0x13;
+    public final static int TELETEXSTRING = 0x14;
+    public final static int VIDEOTEXSTRING = 0x15;
+    public final static int IA5STRING = 0x16;
+    public final static int UTCTIME = 0x17;
+    public final static int GRAPHICSTRING = 0x19;
+    public final static int VISIBLESTRING = 0x1A;
+    public final static int GENERALSTRING = 0x1B;
+
+    /**
+    * Internal (non-transmitted) tags.
+    */
+    public final static int TAG = -1;
+    public final static int CHOICE = -2;
+    public final static int ANY = -3;
+
+    /**
+     * Possible tags.
+     */
+    public final static int EOC = 0x00;  /* End Of Construction */
+    public final static int UNIVERSAL = 0x00;
+    public final static int APPLICATION = 0x40;
+    public final static int CONTEXT = 0x80;
+    public final static int SASLCONTEXT = 0xa0;
+    public final static int PRIVATE = 0xC0;
+    public final static int PRIMITIVE = 0x00;
+    public final static int CONSTRUCTED = 0x20;
+
+    public final static int MRA_OID = 0x01;
+    public final static int MRA_TYPE = 0x02;
+    public final static int MRA_VALUE = 0x03;
+    public final static int MRA_DNATTRS = 0x04;
+    public final static int EXOP_REQ_OID = 0x00;
+    public final static int EXOP_REQ_VALUE = 0x01;
+    public final static int EXOP_RES_OID = 0x0a;
+    public final static int EXOP_RES_VALUE = 0x0b;
+    public final static int SK_MATCHRULE = 0x00;
+    public final static int SK_REVERSE = 0x01;
+    public final static int SR_ATTRTYPE = 0x00;
+
+    /**
+     * Gets a ber element from the input stream.
+     * @param decoder decoder for application specific BER
+     * @param stream source of ber encoding
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to decode an element.
+     */
+    public static BERElement getElement(BERTagDecoder decoder,
+        InputStream stream, int[] bytes_read) throws IOException {
+
+        BERElement element = null;
+        int tag = stream.read();
+        bytes_read[0] = 1;
+
+        if (tag == EOC) {
+            stream.read();    /* length octet (always zero) */
+            bytes_read[0] = 1;
+            element = null;
+        } else if (tag == BOOLEAN)  {
+            element = new BERBoolean(stream, bytes_read);
+        } else if (tag == INTEGER) {
+            element = new BERInteger(stream, bytes_read);
+        } else if (tag == BITSTRING) {
+            element = new BERBitString(stream, bytes_read);
+        } else if (tag == (BITSTRING | CONSTRUCTED)) {
+            element = new BERBitString(decoder, stream, bytes_read);
+        } else if (tag == OCTETSTRING) {
+            element = new BEROctetString(stream, bytes_read);
+        } else if (tag == (OCTETSTRING | CONSTRUCTED)) {
+            element = new BEROctetString(decoder, stream, bytes_read);
+        } else if (tag == NULL) {
+            element = new BERNull(stream, bytes_read);
+        } else if (tag == OBJECTID) {
+            element = new BERObjectId(stream, bytes_read);
+        } else if (tag == REAL) {
+            element = new BERReal(stream, bytes_read);
+        } else if (tag == ENUMERATED) {
+            element = new BEREnumerated(stream, bytes_read);
+        } else if (tag == SEQUENCE) {
+            element = new BERSequence(decoder, stream, bytes_read);
+        } else if (tag == SET) {
+            element = new BERSet(decoder, stream, bytes_read);
+        } else if (tag == NUMERICSTRING) {
+            element = new BERNumericString(stream, bytes_read);
+        } else if (tag == (NUMERICSTRING | CONSTRUCTED)) {
+            element = new BERNumericString(decoder, stream, bytes_read);
+        } else if (tag == PRINTABLESTRING) {
+            element = new BERPrintableString(stream, bytes_read);
+        } else if (tag == (PRINTABLESTRING | CONSTRUCTED)) {
+            element = new BERPrintableString(decoder, stream, bytes_read);
+        } else if (tag == UTCTIME) {
+            element = new BERUTCTime(stream, bytes_read);
+        } else if (tag == (UTCTIME | CONSTRUCTED)) {
+            element = new BERUTCTime(decoder, stream, bytes_read);
+        } else if (tag == VISIBLESTRING) {
+            element = new BERVisibleString(stream, bytes_read);
+        } else if (tag == (VISIBLESTRING | CONSTRUCTED)) {
+            element = new BERVisibleString(decoder, stream, bytes_read);
+        } else if ((tag & (APPLICATION | PRIVATE | CONTEXT)) > 0) {
+            element = new BERTag(decoder, tag, stream, bytes_read);
+        } else
+            throw new IOException("invalid tag " + tag);
+
+        return element;
+    }
+
+    /**
+     * Reads and decodes a length byte and then that many octets
+     * from the input stream.
+     * @param stream input stream from which to read
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @return length of contents or -1 if indefinite length.
+     * @exception IOException failed to read octets
+     */
+    public static int readLengthOctets(InputStream stream, int[] bytes_read)
+        throws IOException {
+        int contents_length = 0;
+        int octet = stream.read();
+        bytes_read[0]++;
+
+        if (octet == 0x80)
+            /* Indefinite length */
+            contents_length = -1;
+        else if ((octet & 0x80) > 0) {
+            /* Definite (long form) - num octets encoded in 7 rightmost bits */
+            int num_length_octets = (octet & 0x7F);
+
+            for (int i = 0; i < num_length_octets; i++) {
+                octet = stream.read();
+                bytes_read[0]++;
+                contents_length = (contents_length<<8) + octet;
+            }
+        } else {
+            /* Definite (short form) - one length octet.  Value encoded in   */
+            /* 7 rightmost bits.                                             */
+            contents_length = octet;
+        }
+        return contents_length;
+    }
+
+    /**
+     * Writes length octets (definite length only) to stream.
+     * Uses shortform whenever possible.
+     * @param stream output stream to write to
+     * @param num_content_octets value to be encode into length octets
+     * @exception IOException failed to read octets
+     */
+    public static void sendDefiniteLength(OutputStream stream,
+        int num_content_octets) throws IOException {
+
+        int bytes_written = 0;
+
+        if (num_content_octets <= 127) {
+            /* Use short form */
+            stream.write(num_content_octets);
+        } else {
+            /* Using long form:
+             * Need to determine how many octets are required to
+             * encode the length.
+             */
+            int num_length_octets = 0;
+            int num = num_content_octets;
+            while (num >= 0) {
+                num_length_octets++;
+                num = (num>>8);
+                if (num <= 0)
+                    break;
+            }
+
+            byte[] buffer = new byte[num_length_octets+1];
+            buffer[0] = (byte)(0x80 | num_length_octets);
+
+            num = num_content_octets;
+            for (int i = num_length_octets; i > 0; i--) {
+                buffer[i] = (byte)(num & 0xFF);
+                num = (num>>8);
+            }
+
+            stream.write(buffer);
+        }
+    }
+
+    /**
+     * Reads a number of bytes from an input stream and form
+     * an integer..
+     * @param stream source of data
+     * @param bytes_read number of bytes read
+     * @param length number of bytes to be read (1 to 4)
+     * @return the value of the data as two's complement.
+     * @exception IOException failed to read octets
+     */
+    protected int readUnsignedBinary(InputStream stream,
+                 int[] bytes_read, int length) throws IOException {
+        int value = 0;
+        int octet;
+
+        for (int i = 0; i < length; i++) {
+            octet = stream.read();
+            bytes_read[0]++;
+            value = (value<<8) + octet;
+        }
+
+        return value;
+    }
+
+    /**
+     * Reads the two's complement representation of an integer from
+     * an input stream.
+     * @param stream source of data
+     * @param bytes_read number of bytes read
+     * @param length number of bytes to be read
+     * @return the integer value as two's complement.
+     * @exception IOException failed to read octets
+     */
+    protected int readTwosComplement(InputStream stream,
+                 int[] bytes_read, int length) throws IOException {
+        int value = 0;
+        if (length > 0) {
+            boolean negative = false;
+            int octet = stream.read();
+            bytes_read[0]++;
+            if ((octet & 0x80) > 0)  /* left-most bit is 1. */
+                negative = true;
+
+            for (int i = 0; i < length; i++) {
+                if (i > 0) {
+                    octet = stream.read();
+                    bytes_read[0]++;
+                }
+                if (negative)
+                    value = (value<<8) + (int)(octet^0xFF)&0xFF;
+                else
+                    value = (value<<8) + (int)(octet&0xFF);
+            }
+            if (negative)  /* convert to 2's complement */
+                value = (value + 1) * -1;
+        }
+        return value;
+    }
+
+    /**
+     * Converts byte to hex string.
+     * @param value byte value
+     * @return string representation of Hex String
+     */
+    public String byteToHexString(byte value) {
+        if (value < 0)
+            return Integer.toHexString((value & 0x7F) + 128);
+        else
+            return Integer.toHexString(value);
+    }
+
+    /**
+     * Sends the BER encoding directly to a stream.
+     * @param stream output stream
+     */
+    public abstract void write(OutputStream stream) throws IOException;
+
+    /**
+     * Gets the element type.
+     * @return element type.
+     */
+    public abstract int getType();
+
+    /**
+     * Gets the string representation.
+     * @return string representation of an element.
+     */
+    public abstract String toString();
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERBitString.java
@@ -0,0 +1,297 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.util.BitSet;
+import java.io.*;
+
+/**
+ * This class is for the BitString object. Note that the BitSet class
+ * has a bug: size() returns the size of the internal allocated memory
+ * rather than the number of bits. Current work-around is to maintain
+ * the number of bits ourselves in m_value_num_bits.
+ * Change is required when BitSet is fixed.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Primitive Definite length.
+ *   tag = 0x03
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERBitString extends BERElement {
+    /**
+     * Internal variables
+     */
+    private BitSet m_value;
+    private int m_value_num_bits;
+
+    /**
+     * Constructs a boolean element.
+     * @param value boolean value
+     */
+    public BERBitString(BitSet value) {
+        m_value = value;
+    }
+
+    /**
+     * Constructs a bitstring element from an input stream
+     * (for constructed encodings).
+     * @param stream source
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERBitString(BERTagDecoder decoder, InputStream stream,
+                        int[] bytes_read) throws IOException {
+        int octet;
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+        int[] component_length = new int[1];
+        BERElement element = null;
+
+        if (contents_length == -1) {
+            /* Constructed - indefinite length. */
+            {
+                component_length[0] = 0;
+                element = getElement(decoder,stream,component_length);
+                if (element != null) {
+                    /* element is a bitstring - add it to the existing BitSet */
+                    BERBitString bit_string_element = (BERBitString)element;
+
+                    BitSet new_bit_set = new BitSet(m_value_num_bits +
+                                          bit_string_element.getSize());
+
+                    for (int i = 0; i<m_value_num_bits; i++)
+                        if (m_value.get(i))
+                            new_bit_set.set(i);
+                    for (int j = 0; j<bit_string_element.getSize(); j++)
+                        if (bit_string_element.getValue().get(j))
+                            new_bit_set.set(m_value_num_bits+j);
+                    m_value = new_bit_set;
+                    m_value_num_bits += bit_string_element.getSize();
+                }
+            } while (element != null);
+        } else {
+            /* Constructed - definite length */
+            bytes_read[0] += contents_length;
+            while (contents_length > 0) {
+                component_length[0] = 0;
+                element = getElement(decoder,stream,component_length);
+                if (element != null) {
+                    /* element is a bitstring - add it to the existing BitSet */
+                    BERBitString bit_string_element = (BERBitString)element;
+
+                    BitSet new_bit_set = new BitSet(m_value_num_bits +
+                                          bit_string_element.getSize());
+                    for (int i = 0; i<m_value_num_bits; i++)
+                        if (m_value.get(i))
+                            new_bit_set.set(i);
+                    for (int j = 0; j<bit_string_element.getSize(); j++)
+                        if (bit_string_element.getValue().get(j))
+                            new_bit_set.set(m_value_num_bits+j);
+                    m_value = new_bit_set;
+                    m_value_num_bits += bit_string_element.getSize();
+                }
+                contents_length -= component_length[0];
+            }
+        }
+    }
+
+    /**
+     * Constructs a bitstring element from an input stream
+     * (for primitive encodings).
+     * @param stream source
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERBitString(InputStream stream, int[] bytes_read)
+               throws IOException {
+        /* Primitive - definite length content octets string. */
+
+        int octet;
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+
+
+        /* First content octect doesn't encode any of
+         * the string - it encodes the number of unused
+         * bits in the final content octet.
+         */
+        int last_unused_bits = stream.read();
+        bytes_read[0]++;
+        contents_length--;
+
+        m_value_num_bits = ((contents_length-1)*8) + (8-last_unused_bits);
+        m_value = new BitSet();
+
+        int bit_num = 0;
+        for (int i = 0; i < contents_length-1; i++) {
+            octet = stream.read();
+            int mask = 0x80;
+            for (int j = 0; j < 8; j++) {
+                if ((octet & mask) > 0) {
+                    m_value.set(bit_num);
+                }
+                else
+                    m_value.clear(bit_num);
+                bit_num++;
+                mask = mask / 2;
+            }
+        }
+
+        octet = stream.read();  /* last content octet */
+        int mask = 0x80;
+        for (int j = 0; j < 8-last_unused_bits; j++) {
+            if ((octet & mask) > 0)
+                m_value.set(bit_num);
+            else
+                m_value.clear(bit_num);
+            bit_num++;
+            mask = mask / 2;
+        }
+
+        bytes_read[0] += contents_length;
+    }
+
+    /**
+     * Sends the BER encoding directly to a stream.
+     * Always sends in primitive form.
+     * @param stream output stream
+     */
+    public void write(OutputStream stream) throws IOException {
+        stream.write(BERElement.BITSTRING);
+
+        //int num_bits = m_value.size();   /* number of bits to send */
+        int num_bits = m_value_num_bits;
+
+        /* Number of bits unused int the last contents octet */
+        int last_unused_bits = 8 - (num_bits % 8);
+
+        /* Figure out the number of content octets */
+        int num_content_octets = (int)(num_bits/8) + 1;
+        if (last_unused_bits > 0)
+            num_content_octets += 1;
+        stream.write(num_content_octets);    /* length octet */
+
+        stream.write(last_unused_bits);    /* first content octet */
+
+        for (int i = 0; i < (int)(num_bits/8); i++) {
+            int new_octet = 0;
+            int bit = 0x80;
+            for (int j = 0; j < 8; j++) {
+                if (m_value.get(i*8+j))
+                    new_octet += bit;
+                bit = bit/2;
+            }
+            stream.write(new_octet);
+        }
+
+        /*
+         * Last octet may not use all bits. If last octet DOES use all
+         * bits then it has already been written above.
+         */
+        if (last_unused_bits > 0) {
+            int new_octet = 0;
+            int bit = 0x80;
+            for (int j = 0; j < last_unused_bits; j++) {
+                if (m_value.get(((int)(num_bits/8))*8+j))
+                    new_octet += bit;
+                bit = bit/2;
+            }
+            stream.write(new_octet);
+        }
+    }
+
+    /**
+     * Gets the bitstring value.
+     */
+    public BitSet getValue() {
+        return m_value;
+    }
+
+    /**
+     * Gets the number of bits.
+     * @return bit numbers.
+     */
+    public int getSize() {
+        return m_value_num_bits;
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public int getType() {
+        return BERElement.BITSTRING;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        String hex_string = "";
+        int octet;
+
+        //int num_bits = m_value.size();
+        int num_bits = m_value_num_bits;
+        for (int i = 0; i < (int)(num_bits/8); i++) {
+            octet = 0;
+            int bit = 0x80;
+            for (int j = 0; j < 8; j++) {
+                if (m_value.get(i*8+j))
+                    octet += bit;
+                bit = bit/2;
+            }
+            hex_string += " " + (byte)octet;
+        }
+
+        int bit = 0x80;
+        octet = 0;
+        for (int k = 0; k < num_bits-(int)(num_bits/8); k++) {
+            if (m_value.get(((int)(num_bits/8))*8+k))
+                octet += bit;
+            bit = bit/2;
+        }
+        hex_string += " " + (byte)octet;
+
+        return "Bitstring {" + hex_string + " }";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERObjectId.java
@@ -0,0 +1,208 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.util.StringTokenizer;
+import java.io.*;
+
+/**
+ * This class is for the Object ID object.
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERObjectId extends BERElement {
+    /**
+     * Values of each component of the OID
+     */
+    private int[] m_value = null;
+
+    /**
+     * Constructs an object ID element from an array of values.
+     * @param value object ID value as array of components
+     */
+    public BERObjectId(int[] value) {
+        m_value = new int[value.length];
+        System.arraycopy(value,0,m_value,0,value.length);
+    }
+
+    /**
+     * Constructs an object id element from a string.
+     * @param value object id value in format "2.100.3"
+     */
+    public BERObjectId(String value) {
+        StringTokenizer tokenizer = new StringTokenizer(value, ".");
+        m_value = new int[tokenizer.countTokens()];
+        for (int i=0; i<m_value.length; i++)
+            m_value[i] = Integer.parseInt(tokenizer.nextToken());
+    }
+
+    /**
+     * Constructs an object id element from an input stream.
+     * @param stream source
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERObjectId(InputStream stream, int[] bytes_read) throws IOException {
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+
+        bytes_read[0] += contents_length;
+        int[] contents_read = new int[1];
+
+        Vector oid = new Vector(10);
+        contents_read[0] = 0;
+        int sub_id = readSubIdentifier(stream, contents_read);
+
+        contents_length -= contents_read[0];
+        if (sub_id < 40)
+            oid.addElement(new Integer(0));
+        else if (sub_id < 80)
+            oid.addElement(new Integer(1));
+        else
+            oid.addElement(new Integer(2));
+        oid.addElement(new Integer(
+            sub_id - (((Integer)oid.elementAt(
+                oid.size()-1)).intValue() * 40)));
+
+        while (contents_length > 0) {
+            contents_read[0] = 0;
+            sub_id = readSubIdentifier(stream, contents_read);
+
+            contents_length -= contents_read[0];
+            oid.addElement(new Integer(sub_id));
+        }
+        m_value = new int[oid.size()];
+        for (int i = 0; i<oid.size(); i++)
+            m_value[i] = ((Integer)oid.elementAt(i)).intValue();
+    }
+
+    /**
+     * Sends the BER encoding directly to a stream. Note that OID must
+     * have >= 2 identifier components (values).
+     * @param stream output stream
+     * @exception IOException failed to write
+     */
+    public void write(OutputStream stream) throws IOException {
+        stream.write(BERElement.OBJECTID);
+
+        ByteArrayOutputStream contents_stream = new ByteArrayOutputStream();
+
+        /* first subidentifier packs two component values */
+        writeSubIdentifier(contents_stream,m_value[0]*40 + m_value[1]);
+
+        for (int i = 2; i < m_value.length; i++)  {
+            writeSubIdentifier(contents_stream,m_value[i]);
+        }
+        byte[] contents_buffer = contents_stream.toByteArray();
+        sendDefiniteLength(stream, contents_buffer.length);
+        stream.write(contents_buffer);
+    }
+
+    /**
+     * Reads a sub identifier from stream.
+     * @param stream input stream
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     */
+    private int readSubIdentifier(InputStream stream, int[] bytes_read)
+        throws IOException {
+        int octet;
+        int sub_id = 0;
+        do {
+            octet = stream.read();
+            bytes_read[0]++;
+            sub_id = (sub_id << 7) | (octet & 0x7F);
+        } while ((octet & 0x80) > 0);
+        return sub_id;
+    }
+
+    /**
+     * Sends the BER encoding of a sub identifier directly to stream.
+     * @param stream output stream
+     * @param value sub-identifier value
+     */
+    private void writeSubIdentifier(OutputStream stream, int value)
+        throws IOException {
+        ByteArrayOutputStream sub_id_stream = new ByteArrayOutputStream();
+        /* gather octets in reverse order */
+        while (value > 0) {
+            sub_id_stream.write(value & 0x7F);
+            value = value >> 7;
+        }
+        byte[] sub_id_buffer = sub_id_stream.toByteArray();
+        for (int i=sub_id_buffer.length-1; i>0; i--) {
+            /* all but last octet have bit 8 = 1 */
+            stream.write(sub_id_buffer[i] | 0x80);
+        }
+        stream.write(sub_id_buffer[0]);    /* last octet has bit 8 = 0 */
+    }
+
+    /**
+     * Gets the element value.
+     * @return element value.
+     */
+    public int[] getValue() {
+        return m_value;
+    }
+
+    /**
+     * Gets the element type.
+     * @return element type.
+     */
+    public int getType() {
+        return BERElement.OBJECTID;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of element.
+     */
+    public String toString() {
+        if (m_value == null)
+            return "ObjectIdentifier (null)";
+        String oid = "";
+        for (int i = 0; i < m_value.length; i++) {
+            if (i != 0)
+                oid = oid + " ";
+            oid = oid + m_value[i];
+        }
+        return "ObjectIdentifier {" + oid + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERPrintableString.java
@@ -0,0 +1,118 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the PrintableString type.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Primitive Definite length.
+ *   tag = 0x13
+ *   length = (short or long form)
+ *   one or more contents octets
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERPrintableString extends BERCharacterString {
+
+    /**
+     * Constructs a printable string element containing buffer.
+     * @param string string value
+     */
+    public BERPrintableString(String string) {
+        m_value = string;
+    }
+
+    /**
+     * Constructs a printables tring element from buffer.
+     * @param buffer byte array value
+     */
+    public BERPrintableString(byte[] buffer) {
+        super(buffer);
+    }
+
+    /**
+     * Constructs a printable string element from an input stream
+     * (for constructed encoding)
+     * @param stream source
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERPrintableString(BERTagDecoder decoder, InputStream stream,
+        int[] bytes_read) throws IOException {
+        super(decoder,stream,bytes_read);
+    }
+
+    /**
+     * Constructs a printablestring element from an input stream
+     * (for primitive encoding)
+     * @param stream source
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERPrintableString(InputStream stream, int[] bytes_read)
+        throws IOException {
+        super(stream,bytes_read);
+    }
+
+    /**
+     * Gets the element type.
+     * @return element type.
+     */
+    public int getType() {
+        return BERElement.PRINTABLESTRING;
+    }
+
+    /**
+     * Gets the string representation. Note that it prints out
+     * values in decimal form.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        if (m_value == null)
+            return "PrintableString (null)";
+        else
+            return "PrintableString {" + m_value + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BEROctetString.java
@@ -0,0 +1,221 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the OctetString type.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Primitive Definite length.
+ *   tag = 0x04
+ *   length = (short or long form)
+ *   one or more contents octets
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BEROctetString extends BERElement {
+
+    /**
+     * Raw value of element
+     */
+    private byte[] m_value = null;
+
+    /**
+     * Constructs an octet string element containing a copy of
+     * the contents of buffer.
+     * @param buffer a UCS-2 String
+     */
+    public BEROctetString(String buffer) {
+        if (buffer == null)
+            return;
+
+        try {
+            m_value = buffer.getBytes( "UTF8" );
+        } catch (Throwable xxx){};
+    }
+
+    /**
+     * Constructs an octet string element containing a reference to
+     * buffer.
+     * @param buffer a byte array, which must be in UTF-8 format if
+     * it is string data
+     */
+    public BEROctetString(byte[] buffer) {
+        m_value = buffer;
+    }
+
+    /**
+     * Constructs an octet string element containing a
+     * subset of buffer.
+     * @param buffer buffer containing 'octets'
+     * @param start start of buffer range to copy
+     * @param end end of buffer range to copy
+     */
+    public BEROctetString(byte[] buffer, int start, int end) {
+        m_value = new byte[end - start];
+
+        for (int i = 0; i < end - start; i++)
+            m_value[i] = buffer[start + i];
+    }
+
+    /**
+     * Constructs an octet string element from an input stream
+     * (for constructed encoding)
+     * @param decoder a decode that understands the specific tags
+     * @param stream source
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BEROctetString(BERTagDecoder decoder, InputStream stream,
+                          int[] bytes_read) throws IOException {
+        int octet;
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+        int[] component_length = new int[1];
+        BERElement element = null;
+
+        if (contents_length == -1) {
+            /* Constructed - indefinite length content octets. */
+            do {
+                component_length[0] = 0;
+                element = getElement(decoder,stream,component_length);
+                if (element != null) {
+                    /* element is an octetstring - add it to the existing buffer */
+                    BEROctetString octet_element = (BEROctetString)element;
+                    byte[] octet_buffer = octet_element.getValue();
+                    if (m_value == null) {
+                        m_value = new byte[octet_buffer.length];
+                        System.arraycopy(octet_buffer,0,
+                                        m_value,0,octet_buffer.length);
+                    } else {
+                        byte[] new_buffer = new byte[m_value.length +
+                                                   octet_buffer.length];
+                        System.arraycopy(m_value,0,new_buffer,0,m_value.length);
+                        System.arraycopy(octet_buffer,0,
+                                        new_buffer,m_value.length,
+                                        octet_buffer.length);
+                        m_value = new_buffer;
+                    }
+                }
+            } while (element != null);
+        } else {
+            /* Definite length content octets string. */
+            bytes_read[0] += contents_length;
+            m_value = new byte[contents_length];
+            int cnt=0, idx=0;
+            while (idx < contents_length) {
+                cnt = stream.read(m_value, idx, contents_length-idx);
+                idx += cnt;
+            }
+        }
+    }
+
+    /**
+     * Constructs an octet string element from an input stream
+     * (for primitive encoding)
+     * @param stream source
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BEROctetString(InputStream stream, int[] bytes_read)
+        throws IOException {
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+
+        /* Definite length content octets string. */
+        if (contents_length > 0) {
+            m_value = new byte[contents_length];
+            for (int i = 0; i < contents_length; i++) {
+                m_value[i] = (byte) stream.read();
+            }
+            bytes_read[0] += contents_length;
+        }
+    }
+
+    /**
+     * Writes BER to stream
+     * @exception IOException failed to write
+     */
+    public void write(OutputStream stream) throws IOException {
+        stream.write((byte)BERElement.OCTETSTRING);  /* OCTETSTRING tag */
+        if (m_value == null) {
+            sendDefiniteLength(stream, 0);
+        } else {
+            sendDefiniteLength(stream, m_value.length);  /* length */
+          stream.write(m_value,0,m_value.length);  /* contents */
+        }
+    }
+
+    /**
+     * Gets the element value.
+     */
+    public byte[] getValue() {
+        return m_value;
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public int getType() {
+        return BERElement.OCTETSTRING;
+    }
+
+    /**
+     * Gets the string representation.
+     * NOTE: currently prints out values in decimal form.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        if (m_value == null) {
+            return "OctetString (null)";
+        }
+        StringBuffer octets = new StringBuffer("OctetString {");
+        for (int i = 0; i < m_value.length; i++) {
+            if (i != 0) {
+                octets.append(' ');
+            }
+            octets.append(byteToHexString(m_value[i]));
+        }
+        octets.append('}');
+        return octets.toString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERUTCTime.java
@@ -0,0 +1,184 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the UTCTime object.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Primitive Definite length.
+ *   tag = 0x17
+ *   length = (short or long form)
+ *   one or more contents octets
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERUTCTime extends BERElement {
+
+    /**
+     * Internal variables
+     */
+    private String m_value = null;
+
+    /**
+     * Constructs a UTC time element containing the specified string.
+     * @param utc_string string in UTC time format
+     */
+    public BERUTCTime(String utc_string) {
+        m_value = utc_string;
+    }
+
+    /**
+     * Constructs a UTCTime element from an input stream
+     * (for constructed encoding)
+     * @param stream source
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERUTCTime(BERTagDecoder decoder, InputStream stream,
+                          int[] bytes_read) throws IOException {
+        int octet;
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+        int[] component_length = new int[1];
+        BERElement element = null;
+
+        m_value = "";
+
+        if (contents_length == -1) {
+            /* Constructed - indefinite length content octets. */
+            {
+                component_length[0] = 0;
+                element = getElement(decoder,stream,component_length);
+                if (element != null) {
+                    /* element is an octetstring - add it to the existing buffer */
+                    BERUTCTime utc_element = (BERUTCTime)element;
+                    m_value += utc_element.getValue();
+                }
+            } while (element != null);
+        } else {
+            /* Definite length content octets string. */
+            bytes_read[0] += contents_length;
+            while (contents_length > 0) {
+                component_length[0] = 0;
+                element = getElement(decoder,stream,component_length);
+                if (element != null) {
+                    /* element is an octetstring - add it to the existing buffer */
+                    BERUTCTime utc_element = (BERUTCTime)element;
+                    m_value += utc_element.getValue();
+                }
+                contents_length -= component_length[0];
+            }
+        }
+    }
+
+    /**
+     * Constructs a UTC time element from an input stream
+     * (for primitive encoding)
+     * @param stream source
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERUTCTime(InputStream stream, int[] bytes_read) throws IOException {
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+
+        /* Definite length content octets string. */
+        if (contents_length > 0) {
+            byte[] byte_buf = new byte[contents_length];
+            for (int i = 0; i < contents_length; i++) {
+                byte_buf[i] = (byte) stream.read();
+            }
+            bytes_read[0] += contents_length;
+            try{
+                m_value = new String(byte_buf, "UTF8");
+            } catch(Throwable x)
+            {}
+        }
+    }
+
+    private byte[] byte_buf;
+    /**
+     * Writes BER to a stream.
+     * @exception IOException failed to write
+     */
+    public void write(OutputStream stream) throws IOException {
+        stream.write((byte)getType());
+        if (m_value == null) {
+            sendDefiniteLength(stream, 0);
+        } else {
+
+            try{
+                byte_buf = m_value.getBytes("UTF8");
+                sendDefiniteLength(stream, byte_buf.length);  /* length */
+            } catch(Throwable x)
+            {}
+            stream.write(byte_buf,0,byte_buf.length);  /* contents */
+        }
+    }
+
+    /**
+     * Gets the element value.
+     */
+    public String getValue() {
+        return m_value;
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public int getType() {
+        return BERElement.UTCTIME;
+    }
+
+    /**
+     * Gets the string representation.
+     * NOTE: currently prints out values in decimal form.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        if (m_value == null)
+            return "UTCTime (null)";
+        else
+            return "UTCTime {" + m_value + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERNumericString.java
@@ -0,0 +1,118 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the NumericString type.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Primitive Definite length.
+ *   tag = 0x12
+ *   length = (short or long form)
+ *   one or more contents octets
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERNumericString extends BERCharacterString {
+
+    /**
+     * Constructs a numeric string element from a string
+     * @param string string with value of element
+     */
+    public BERNumericString(String string) {
+        m_value = string;
+    }
+
+    /**
+     * Constructs a numeric string element from a byte array
+     * @param buffer buffer
+     */
+    public BERNumericString(byte[] buffer) {
+        super(buffer);
+    }
+
+    /**
+     * Constructs a numeric string element from an input stream
+     * (for constructed encoding)
+     * @param stream source
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERNumericString(BERTagDecoder decoder, InputStream stream,
+                          int[] bytes_read) throws IOException {
+        super(decoder,stream,bytes_read);
+    }
+
+    /**
+     * Constructs a numericstring element from an input stream
+     * (for primitive encoding)
+     * @param stream input stream
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERNumericString(InputStream stream, int[] bytes_read)
+        throws IOException {
+        super(stream,bytes_read);
+    }
+
+    /**
+     * Gets the element type.
+     * @return element type.
+     */
+    public int getType() {
+        return BERElement.NUMERICSTRING;
+    }
+
+    /**
+     * Gets the string representation. Note that currently prints out
+     * values in decimal form.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        if (m_value == null)
+            return "NumericString (null)";
+        else
+            return "NumericString {" + m_value + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERVisibleString.java
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the VisibleString object.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Primitive Definite length.
+ *   tag = 0x1A
+ *   length = (short or long form)
+ *   one or more contents octets
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso X.209
+ */
+public class BERVisibleString extends BERCharacterString {
+
+    /**
+     * Constructs a visiblestring element.
+     * @param string string
+     */
+    public BERVisibleString(String string) {
+        m_value = string;
+    }
+
+    /**
+     * Constructs a visiblestring element from buffer.
+     * @param buffer buffer
+     */
+    public BERVisibleString(byte[] buffer) {
+        super(buffer);
+    }
+
+    /**
+     * Constructs a visiblestring element with the input stream.
+     * (for constructed encoding)
+     * @param stream input stream
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERVisibleString(BERTagDecoder decoder, InputStream stream,
+                          int[] bytes_read) throws IOException {
+        super(decoder,stream,bytes_read);
+    }
+
+    /**
+     * Constructs a visiblestring element with the input stream.
+     * (for primitive encoding)
+     * @param stream input stream
+     * @param bytes_read array of 1 int, incremented by number of bytes read
+     * @exception IOException failed to construct
+     */
+    public BERVisibleString(InputStream stream, int[] bytes_read)
+        throws IOException {
+        super(stream,bytes_read);
+    }
+
+    /**
+     * Gets the element type.
+     */
+    public int getType() {
+        return BERElement.VISIBLESTRING;
+    }
+
+    /**
+     * Gets the string representation. Note that currently prints out
+     * values in decimal form.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        if (m_value == null)
+            return "VisibleString (null)";
+
+        return "VisibleString {" + m_value + "}";
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERTag.java
@@ -0,0 +1,184 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This class is for the tagged object type. A nested tag is
+ * allowed. A tagged element contains another
+ * ber element.
+ *
+* <pre>
+ * ENCODING RULE:
+ *  tag    = whatever it is constructed with
+ * </pre>
+ *
+  * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public class BERTag extends BERElement {
+    /**
+     * Value of tag
+     */
+    private int m_tag = 0;
+    /**
+     * Value of element
+     */
+    private BERElement m_element = null;
+    /**
+     * Implicit or not
+     */
+    private boolean m_implicit = false;
+
+    /**
+     * Constructs a tag element.
+     * @param tag tag value
+     * @param element ber element
+     * @param implicit tagged implicitly
+     */
+    public BERTag(int tag, BERElement element, boolean implicit) {
+        m_tag = tag;
+        m_element = element;
+        m_implicit = implicit;
+    }
+
+    /**
+     * Constructs a tag element from an input stream.
+     * @param decoder decoder object for application-specific tags
+     * @param tag tag value; already stripped from stream
+     * @param stream source
+     * @param bytes_read array of 1 int; incremented by number
+     * of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERTag(BERTagDecoder decoder, int tag, InputStream stream,
+        int[] bytes_read) throws IOException {
+
+        m_tag = tag;
+        boolean[] implicit = new boolean[1];
+
+        /*
+         * Need to use user callback to decode contents of
+         * a non-universal tagged value.
+         */
+        m_element = decoder.getElement(decoder, tag, stream, bytes_read,
+                      implicit);
+        m_implicit = implicit[0];
+    }
+
+    /**
+     * Gets the element from the tagged object.
+     * @return BER element.
+     */
+    public BERElement getValue() {
+        return m_element;
+    }
+
+    /**
+     * Sets the implicit tag. If it is an implicit tag,
+     * the next element tag can be omitted (it will
+     * not be sent to a stream or buffer).
+     * @param value implicit flag
+     */
+    public void setImplicit(boolean value) {
+        m_implicit = value;
+    }
+
+    /**
+     * Sends the BER encoding directly to a stream.
+     * @param stream output stream
+     * @exception IOException failed to send
+     */
+    public void write(OutputStream stream) throws IOException {
+        stream.write(m_tag);  /* bcm - assuming tag is one byte */
+
+        ByteArrayOutputStream contents_stream = new ByteArrayOutputStream();
+        m_element.write(contents_stream);
+        byte[] contents_buffer = contents_stream.toByteArray();
+
+        if (m_implicit) {
+            /* Assumes tag is only one byte.  Rest of buffer is */
+            /* length and contents of tagged element.           */
+            stream.write(contents_buffer, 1, contents_buffer.length -1);
+        } else {
+            /* Send length */
+            sendDefiniteLength(stream, contents_buffer.length);
+            /* Send contents */
+            stream.write(contents_buffer);
+        }
+    }
+
+    /**
+     * Gets the element type.
+     * @return element type.
+     */
+    public int getType() {
+        return BERElement.TAG;
+    }
+
+    /**
+     * Gets the element tag.
+     * @return element tag.
+     */
+    public int getTag() {
+        return m_tag;
+    }
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public String toString() {
+        String s = "";
+        if ((m_tag & 0xC0) == 0)
+            /* bits 8 + 7 are zeros */
+            s = s + "UNIVERSAL-";
+        else if (((m_tag & 0x80) & (m_tag & 0x40)) > 0)
+            /* bits 8 + 7 are ones */
+            s = s + "PRIVATE-";
+        else if ((m_tag & 0x40) > 0)
+            /* bit 8 is zero, bit 7 is one */
+            s = s + "APPLICATION-";
+        else if ((m_tag & 0x80) > 0)
+            /* bit 8 is one, bit 7 is zero */
+            s = s + "CONTEXT-";
+        return "[" + s + (m_tag&0x1f) + "] " + m_element.toString();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERTagDecoder.java
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This is an abstract class which should be extended
+ * for use by the BERTag class in decoding application
+ * specific BER tags. Since different applications may
+ * define their own tag, the BER package needs a tag decoder
+ * to give hints on how to decode implicitly tagged
+ * objects. Each application should extend this
+ * decoder.
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public abstract class BERTagDecoder {
+
+    /**
+     * Gets an application specific ber element from an input stream.
+     * @param decoder an instance of a BERTagDecoder
+     * @param tag element tag
+     * @param stream source stream
+     * @param bytes_read array of 1 int; value incremented by number
+     * of bytes read from stream
+     * @param implicit array of implicit flags
+     */
+    public abstract BERElement getElement(BERTagDecoder decoder, int tag,
+        InputStream stream, int[] bytes_read, boolean[] implicit)
+        throws IOException;
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/netscape/ldap/ber/stream/BERIntegral.java
@@ -0,0 +1,195 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package netscape.ldap.ber.stream;
+
+import java.util.*;
+import java.io.*;
+
+/**
+ * This is the base class for integral types such as Integer and
+ * Enumerated.
+ *
+ * <pre>
+ * ENCODING RULE:
+ *   Primitive Definite length.
+ *   tag = << depends on type >>
+ *   length = (short or long form)
+ *   one or more contents octets hold integral value
+ *   value in two's complement
+ *
+ * Example 1:  (Integer - zero)
+ *   02 01 00
+ * Example 2:  (Enumerated - 1)
+ *   0A 01 01
+ * Example 3:  (Integer - 300, short form)
+ *   02 02 01 2C
+ * Example 4:  (Integer - 300, long form)
+ *   02 84 00 00 01 2C
+ * </pre>
+ *
+ * @version 1.0
+ * seeAlso CCITT X.209
+ */
+public abstract class BERIntegral extends BERElement {
+    /**
+     * Value of element
+     */
+    private int m_value;
+
+    /**
+     * Constructs an integral type with a value.
+     * @param value integer value
+     */
+    public BERIntegral(int value) {
+        m_value = value;
+    }
+
+    /**
+     * Constructs an integral element from an input stream.
+     * @param stream source
+     * @param bytes_read array of 1 int; value incremented by
+     * number of bytes read from stream
+     * @exception IOException failed to construct
+     */
+    public BERIntegral(InputStream stream, int[] bytes_read) throws IOException {
+        int contents_length = super.readLengthOctets(stream, bytes_read);
+
+        /* Definite length content octets string. */
+        if (contents_length > 0) {
+            boolean negative = false;
+            int octet = stream.read();
+            bytes_read[0]++;
+            if ((octet & 0x80) > 0)  /* left-most bit is 1. */
+                negative = true;
+
+            for (int i = 0; i < contents_length; i++) {
+                if (i > 0) {
+                    octet = stream.read();
+                    bytes_read[0]++;
+                }
+                if (negative)
+                    m_value = (m_value<<8) + (int)(octet^0xFF)&0xFF;
+                else
+                    m_value = (m_value<<8) + (int)(octet&0xFF);
+            }
+            if (negative)  /* convert to 2's complement */
+                m_value = (m_value + 1) * -1;
+        }
+    }
+
+
+    /**
+     * Writes BER to stream.
+     * @param stream output stream
+     * @exception IOException on failure to write
+     */
+    public void write(OutputStream stream) throws IOException {
+        int binary_value = m_value;
+        int num_content_octets = 0;
+        int total_ber_octets;
+        int offset=1;
+        int lead;
+        int i;
+
+        byte[] content_octets = new byte[10];  /* should be plenty big */
+        byte[] net_octets = new byte[10]; /* pse need this in network order */
+
+        /* Get content octets - need to determine length */
+        if (m_value == 0) {
+            num_content_octets = 1;
+            content_octets[offset] = (byte)0x00;
+            net_octets[offset] = (byte)0x00;
+        } else {
+
+            if (m_value < 0)  /* convert from 2's complement */
+                binary_value = (m_value * -1) -1;
+
+            do {
+                if (m_value < 0)
+                    content_octets[num_content_octets+offset] =
+                        (byte)((binary_value^0xFF)&0xFF);
+                else
+                    content_octets[num_content_octets+offset] =
+                        (byte)(binary_value&0xFF);
+
+                binary_value = (binary_value>>8);
+                num_content_octets++;
+            } while (binary_value > 0);
+            
+            /* pse 1/16/96 we've just created a string that is in non-network order
+               flip it for net order */
+            for (i=0; i<num_content_octets; i++)
+                net_octets[offset+num_content_octets-1-i] = content_octets[offset+i];
+
+            /* pse 1/16/96 if we have the value encoded and the leading encoding bit is set
+               then stuff in a leading zero byte */
+            lead = (int)net_octets[offset];
+
+            if ((m_value > 0) && ((lead & 0x80) > 0)) {
+                offset = 0;
+                net_octets[offset] = (byte)0x00;
+                num_content_octets++;
+            }
+
+        }
+        stream.write(getType());
+        sendDefiniteLength(stream, num_content_octets);
+        stream.write(net_octets,offset,num_content_octets);  /* contents */
+    }
+
+    /**
+     * Gets the integral value.
+     * @return element value.
+     */
+    public int getValue() {
+        return m_value;
+    }
+
+    /**
+     * Gets the element type.
+     * @return element type.
+     */
+    public abstract int getType();
+
+    /**
+     * Gets the string representation.
+     * @return string representation of tag.
+     */
+    public abstract String toString();
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/LdapContextImpl.java
@@ -0,0 +1,638 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+import javax.naming.event.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import com.netscape.jndi.ldap.controls.NetscapeControlFactory;
+import com.netscape.jndi.ldap.common.Debug;
+
+import java.util.*;
+
+/**
+ * Implementation for the DirContext. The context also supports controls
+ * through the implementation of LdapContext interface and events through
+ * the implementaion of EventDirContext.
+ * Semantically, the LdapContextImpl corresponds to a directory entry.
+ * Thus a context is associated with a DN (m_ctxDN). Multiple contexts share
+ * the same LDAPConnection which is wrapped into a LdapService object
+ * (m_ldapSvc). Each context also maintains a set of environment properties
+ * (m_ctxEnv). A context environment is shared among mutiple contexts using a
+ * variation of copy-on-write algorithm (see common.ShareableEnv class).
+ * 
+ * Each context also maintains a set of LDAPSearchConstraints, as search
+ * constrainsts like e.g. server controls, or max number of returned search
+ * search results, are context specific. The LdapService reads the 
+ * LDAPSearchConstraints from a context that makes a service request.
+ */
+public class LdapContextImpl implements EventDirContext, LdapContext {
+
+    /**
+     * Context environment setting
+     */
+    protected ContextEnv m_ctxEnv;
+
+    /**
+     * DN associated with this context
+     * The default value is the root DSE ("")
+     */
+    protected String m_ctxDN;
+
+    /**
+     * Ldap Connection/Service
+     */
+    protected LdapService m_ldapSvc;
+
+
+    /**
+     * Ldap Connection Search Constraints
+     */
+    protected LDAPSearchConstraints m_searchCons;
+
+    // TODO Should have a constructor that accepts attributes
+    
+    /**
+     * Constructor
+     */
+    public LdapContextImpl(Hashtable env) throws NamingException{
+        m_ctxEnv = new ContextEnv(env); // no need to clone (Hashtable)env.clone());
+        m_ldapSvc = new LdapService();
+        m_ldapSvc.connect(this); // BLITS but to be removed, hurts lazy resource usage
+        getDN();
+        getSearchConstraints();
+    }
+
+    /**
+     * Copy Constructor
+     */
+    public LdapContextImpl(String ctxDN, LdapContextImpl cloneCtx) throws NamingException{
+        
+        m_ctxEnv = (ContextEnv)cloneCtx.m_ctxEnv.clone();
+
+        // An instance of ldapService is shared among multiple contexts.
+        // Increment the client reference count
+        m_ldapSvc = cloneCtx.m_ldapSvc;
+        cloneCtx.m_ldapSvc.incrementClientCount();
+        
+        if (cloneCtx.getSearchConstraints().getServerControls() == null) {
+            m_searchCons = cloneCtx.getSearchConstraints();
+        }
+        else {
+            // In LdapContext Context Controls are not inherited by derived contexts
+            m_searchCons = (LDAPSearchConstraints) cloneCtx.getSearchConstraints().clone();
+            m_searchCons.setServerControls((LDAPControl[])null);
+        }    
+        
+        m_ctxDN = ctxDN;
+    }
+
+
+    /**
+     * Close the context when finalized
+     */
+    protected void finalize() {
+        Debug.println(1, "finalize ctx");
+        try {
+            close();
+        }
+        catch (Exception e) {}
+    }    
+    
+    /**
+     * Disconnect the Ldap Connection if close is requested
+     * LDAP operations can not be performed any more ones
+     * the context is closed
+     */
+    public void close() throws NamingException {
+        m_ldapSvc.disconnect();
+        m_ldapSvc = null;
+    }
+
+    /**
+     * Return LdapJdk search constraints for this context
+     */ 
+    LDAPSearchConstraints getSearchConstraints() throws NamingException{
+        if (m_searchCons == null) {
+            LDAPSearchConstraints cons = new LDAPSearchConstraints();
+            m_ctxEnv.updateSearchCons(cons);
+            m_searchCons = cons;
+        }    
+        return m_searchCons;
+    }
+
+    /**
+     * Return DN for this context
+     */
+    String getDN() throws NamingException{
+        if (m_ctxDN == null) {
+            LDAPUrl url = m_ctxEnv.getDirectoryServerURL();  
+            if (url != null && url.getDN() != null) {
+                m_ctxDN = url.getDN();
+            }
+            else {
+                m_ctxDN = "";
+            }
+        }
+        return m_ctxDN;
+    }
+    
+    /**
+     * Return reference to the context environment
+     */
+    ContextEnv getEnv() {
+        return m_ctxEnv;
+    } 
+    
+    /**
+     * Conver object to String
+     */
+    public String toString() {
+        return this.getClass().getName() + ": " + m_ctxDN;
+    }
+    
+    /**
+     * Check if LdapURL is passed as the name paremetr to a method
+     * If that's the case, craete environment for the ldap url
+     */
+    String checkLdapUrlAsName(String name) throws NamingException{
+        if (name.startsWith("ldap://")) {
+            m_ctxEnv.setProperty(ContextEnv.P_PROVIDER_URL, name);            
+            close(); // Force reconnect
+            m_ldapSvc = new LdapService();
+            // Return New name relative to the context
+            return "";
+        }
+        return name;
+    }    
+     
+    /**
+     * Environment operatins (javax.naming.Context interface)
+     */
+      
+    public Hashtable getEnvironment() throws NamingException {
+        return m_ctxEnv.getAllProperties();
+    }
+
+    public Object addToEnvironment(String propName, Object propValue) throws NamingException {
+        if (propName.equalsIgnoreCase(m_ctxEnv.P_TRACE)) {
+            m_ldapSvc.setTraceOutput(propValue);
+        }            
+        return m_ctxEnv.updateProperty(propName, propValue, getSearchConstraints());
+    }
+
+    public Object removeFromEnvironment(String propName) throws NamingException {
+        if (propName.equalsIgnoreCase(m_ctxEnv.P_TRACE)) {
+            m_ldapSvc.setTraceOutput(null);
+        }
+        return m_ctxEnv.removeProperty(propName);
+    }
+
+    /**
+     * Name operations (javax.naming.Context interface)
+     */
+
+    public String composeName(String name, String prefix) throws NamingException {
+        return name + "," + prefix;
+    }
+
+    public Name composeName(Name name, Name prefix) throws NamingException {
+        String compoundName = composeName(name.toString(), prefix.toString());
+        return LdapNameParser.getParser().parse(compoundName);
+    }
+
+    public String getNameInNamespace() throws NamingException {
+        return new String(m_ctxDN);
+    }
+
+    public NameParser getNameParser(String name) throws NamingException {
+        return LdapNameParser.getParser();
+    }
+
+    public NameParser getNameParser(Name name) throws NamingException {
+        return LdapNameParser.getParser();
+    }
+     
+    /**
+     * Search operations (javax.naming.DirContext interface)
+     */
+     
+    public NamingEnumeration search(String name, String filter, SearchControls cons) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        return m_ldapSvc.search(this, name, filter, /*attrs=*/null, cons);
+    }
+
+    public NamingEnumeration search(String name, String filterExpr, Object[] filterArgs, SearchControls cons) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        String filter = ProviderUtils.expandFilterExpr(filterExpr, filterArgs);
+        return m_ldapSvc.search(this, name, filter, /*attrs=*/null, cons);
+    }
+
+    public NamingEnumeration search(String name, Attributes matchingAttributes) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        String filter = ProviderUtils.attributesToFilter(matchingAttributes);
+        return m_ldapSvc.search(this, name, filter, /*attrs=*/null, /*jndiCons=*/null);
+    }
+
+    public NamingEnumeration search(String name, Attributes matchingAttributes, String[] attributesToReturn) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        String filter = ProviderUtils.attributesToFilter(matchingAttributes);
+        return m_ldapSvc.search(this, name, filter, attributesToReturn, /*jndiCons=*/null);
+    }
+
+    public NamingEnumeration search(Name name, String filter, SearchControls cons) throws NamingException {
+        return m_ldapSvc.search(this, name.toString(), filter, /*attrs=*/null, cons);
+    }
+
+    public NamingEnumeration search(Name name, String filterExpr, Object[] filterArgs, SearchControls cons) throws NamingException {
+        String filter = ProviderUtils.expandFilterExpr(filterExpr, filterArgs);
+        return m_ldapSvc.search(this, name.toString(), filter, /*attrs=*/null, cons);
+    }
+
+    public NamingEnumeration search(Name name, Attributes attrs) throws NamingException {
+        String filter = ProviderUtils.attributesToFilter(attrs);
+        return m_ldapSvc.search(this, name.toString(), filter, /*attr=*/null, /*jndiCons=*/null);
+    }
+
+    public NamingEnumeration search(Name name, Attributes matchingAttributes, String[] attributesToReturn) throws NamingException {
+        String filter = ProviderUtils.attributesToFilter(matchingAttributes);
+        return m_ldapSvc.search(this, name.toString(), filter, attributesToReturn, /*jndiCons=*/null);
+    }    
+
+    /**
+     * Attribute Operations (javax.naming.DirContext interface)
+     */
+
+    public Attributes getAttributes(String name) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        return m_ldapSvc.readAttrs(this, name, null);
+    }
+
+    public Attributes getAttributes(String name, String[] attrIds) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        return m_ldapSvc.readAttrs(this, name, attrIds);
+    }
+
+    public Attributes getAttributes(Name name) throws NamingException {
+        return m_ldapSvc.readAttrs(this, name.toString(), null);
+
+    }
+
+    public Attributes getAttributes(Name name, String[] attrIds) throws NamingException {
+        return m_ldapSvc.readAttrs(this, name.toString(), attrIds);
+
+    }
+
+    public void modifyAttributes(String name, int mod_op, Attributes attrs) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        m_ldapSvc.modifyEntry(this, name, AttributesImpl.jndiAttrsToLdapModSet(mod_op, attrs));
+    }
+
+    public void modifyAttributes(String name, ModificationItem[] mods) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        m_ldapSvc.modifyEntry(this, name, AttributesImpl.jndiModsToLdapModSet(mods));
+    }
+
+    public void modifyAttributes(Name name, int mod_op, Attributes attrs) throws NamingException {
+        m_ldapSvc.modifyEntry(this, name.toString(), AttributesImpl.jndiAttrsToLdapModSet(mod_op, attrs));
+
+    }
+
+    public void modifyAttributes(Name name, ModificationItem[] mods) throws NamingException {
+        m_ldapSvc.modifyEntry(this, name.toString(), AttributesImpl.jndiModsToLdapModSet(mods));
+    }
+
+    /**
+     * Ldap entry operations (javax.naming.DirContext interface)
+     */
+
+    public Context createSubcontext(String name) throws NamingException {
+        // Directory entry must have attributes
+        throw new OperationNotSupportedException();
+    }
+
+    public Context createSubcontext(Name name) throws NamingException {
+        // Directory entry must have attributes
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext createSubcontext(String name, Attributes attrs) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        return m_ldapSvc.addEntry(this, name, AttributesImpl.jndiAttrsToLdapAttrSet(attrs));
+    }
+
+    public DirContext createSubcontext(Name name, Attributes attrs) throws NamingException {
+        return m_ldapSvc.addEntry(this, name.toString(), AttributesImpl.jndiAttrsToLdapAttrSet(attrs));
+
+    }
+
+    public void destroySubcontext(String name) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        m_ldapSvc.delEntry(this, name);
+    }
+
+    public void destroySubcontext(Name name) throws NamingException {
+        m_ldapSvc.delEntry(this, name.toString());
+
+    }
+
+    /**
+     * Naming Bind/Rename operations
+     * (javax.naming.Context, javax.naming.DirContext interface)
+     */
+
+    public void bind(String name, Object obj) throws NamingException {        
+        name = checkLdapUrlAsName(name);
+        m_ldapSvc.addEntry(this, name.toString(),
+            ObjectMapper.objectToAttrSet(obj, name, this, /*attrs=*/null));
+    }    
+
+    public void bind(Name name, Object obj) throws NamingException {
+        bind(name.toString(), obj);
+    }
+
+    public void bind(String name, Object obj, Attributes attrs) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        m_ldapSvc.addEntry(this, name.toString(),
+            ObjectMapper.objectToAttrSet(obj, name, this, attrs));
+    }
+
+    public void bind(Name name, Object obj, Attributes attrs) throws NamingException {
+        bind(name.toString(), obj, attrs);
+    }
+
+    public void rebind(String name, Object obj) throws NamingException {
+        rebind(name, obj, /*attrs=*/null);
+    }
+
+    public void rebind(Name name, Object obj) throws NamingException {
+        rebind(name.toString(), obj, null);
+    }
+
+    public void rebind(String name, Object obj, Attributes attrs) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        try {
+            bind(name, obj, attrs);
+        }
+        catch (NameAlreadyBoundException ex) {
+            unbind(name);
+            bind(name, obj, attrs);
+        }
+    }
+
+    public void rebind(Name name, Object obj, Attributes attrs) throws NamingException {
+        rebind(name.toString(), obj, attrs);
+    }
+
+    public void rename(String oldName, String newName) throws NamingException {
+        oldName = checkLdapUrlAsName(oldName);
+        LdapNameParser parser = LdapNameParser.getParser();
+        Name oldNameObj = parser.parse(oldName);
+        Name newNameObj = parser.parse(newName);
+        rename(oldNameObj, newNameObj);
+    }
+
+    public void rename(Name oldName, Name newName) throws NamingException {
+        // Can rename only RDN        
+        if (newName.size() != oldName.size()) {
+            throw new InvalidNameException("Invalid name " + newName);
+        }
+        Name oldPrefix = oldName.getPrefix(oldName.size() -1);
+        Name newPrefix = newName.getPrefix(oldName.size() -1);
+        if (!newPrefix.equals(oldPrefix)) {
+            throw new InvalidNameException("Invalid name " + newName);
+        }
+        m_ldapSvc.changeRDN(this, oldName.toString(), newName.get(newName.size()-1));
+    }
+
+    public void unbind(String name) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        // In ldap every entry is naming context
+        destroySubcontext(name);
+    }
+
+    public void unbind(Name name) throws NamingException {
+        // In ldap every entry is naming context
+        destroySubcontext(name);
+    }
+
+    /**
+     * List Operations (javax.naming.Context interface)
+     */
+
+    public NamingEnumeration list(String name) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        return m_ldapSvc.listEntries(this, name, /*returnBindings=*/false);
+    }
+
+    public NamingEnumeration list(Name name) throws NamingException {
+        return m_ldapSvc.listEntries(this, name.toString(), /*returnBindings=*/false);
+    }
+
+    public NamingEnumeration listBindings(String name) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        return m_ldapSvc.listEntries(this, name, /*returnBindings=*/true);
+    }
+
+    public NamingEnumeration listBindings(Name name) throws NamingException {
+        return m_ldapSvc.listEntries(this, name.toString(), /*returnBindings=*/true);
+    }
+
+    /**
+     * Lookup Operations (javax.naming.Context interface)
+     */
+
+    public Object lookup(String name) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        return m_ldapSvc.lookup(this, name);
+    }
+
+    public Object lookup(Name name) throws NamingException {
+        return m_ldapSvc.lookup(this, name.toString());
+    }
+
+    public Object lookupLink(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Object lookupLink(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+
+    /**
+     * Schema Operations (javax.naming.DirContext interface)
+     */
+    public DirContext getSchema(String name) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        return m_ldapSvc.getSchema(this, name);
+    }
+
+    public DirContext getSchema(Name name) throws NamingException {
+        return m_ldapSvc.getSchema(this, name.toString());
+    }
+
+    public DirContext getSchemaClassDefinition(String name) throws NamingException {
+        name = checkLdapUrlAsName(name);
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext getSchemaClassDefinition(Name name) throws NamingException {
+        return getSchemaClassDefinition(name.toString());
+    }
+
+    /**
+     * Naming Event methods javax.naming.event.EventDirContext interface)
+     */
+    public void addNamingListener(String target, int scope, NamingListener l) throws NamingException {
+        EventService eventSvc = m_ldapSvc.getEventService(this);
+        String filter = LdapService.DEFAULT_FILTER;
+        SearchControls ctls = new SearchControls();
+        ctls.setSearchScope(scope);
+        eventSvc.addListener(this, target, filter, ctls, l);
+    }
+
+    public void addNamingListener(Name target, int scope, NamingListener l) throws NamingException {
+        addNamingListener(target.toString(), scope, l);
+    }
+
+    public void addNamingListener(String target, String filter, SearchControls ctls, NamingListener l)throws NamingException {
+        EventService eventSvc = m_ldapSvc.getEventService(this);
+        eventSvc.addListener(this, target, filter, ctls, l);
+
+    }
+
+    public void addNamingListener(Name target, String filter, SearchControls ctls, NamingListener l)throws NamingException {
+        addNamingListener(target.toString(), filter, ctls, l);
+    }
+
+    public void addNamingListener(String target, String filterExpr, Object[] filterArgs, SearchControls ctls, NamingListener l)throws NamingException {
+        EventService eventSvc = m_ldapSvc.getEventService(this);
+        String filter = ProviderUtils.expandFilterExpr(filterExpr, filterArgs);
+        eventSvc.addListener(this, target, filter, ctls, l);
+    }
+
+    public void addNamingListener(Name target, String filterExpr, Object[] filterArgs, SearchControls ctls, NamingListener l)throws NamingException {
+        addNamingListener(target.toString(), filterExpr, filterArgs, ctls, l);
+    }
+
+    public void removeNamingListener(NamingListener l) throws NamingException {
+        EventService eventSvc = m_ldapSvc.getEventService(this);
+        eventSvc.removeListener(l);
+    }
+
+    public boolean targetMustExist() {
+        return true;
+    }
+
+    /**
+     * LdapContext methods (javax.naming.ldap.LdapContext interface)
+     */
+    public ExtendedResponse extendedOperation(ExtendedRequest req)throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Control[] getRequestControls() throws NamingException {
+        LDAPControl[] ldapCtls = m_searchCons.getServerControls();
+        if (ldapCtls == null) {
+            return null;
+        }
+        Control[] ctls = new Control[ldapCtls.length];
+        for (int i=0; i < ldapCtls.length; i++) {
+            ctls[i] = (Control) ldapCtls[i];
+        }
+        return ctls;
+    }
+
+    public void setRequestControls(Control[] reqCtls) throws NamingException {
+        LDAPControl[] ldapCtls = new LDAPControl[reqCtls.length];
+        for (int i=0; i < reqCtls.length; i++) {
+            try {
+                ldapCtls[i] = (LDAPControl) reqCtls[i];
+            }
+            catch (ClassCastException ex) {
+                throw new NamingException(
+                    "Unsupported control type " + reqCtls[i].getClass().getName());
+            }
+        }
+        
+        getSearchConstraints().setServerControls(ldapCtls);           
+    }
+
+    public Control[] getResponseControls() throws NamingException {
+        LDAPControl[] ldapCtls = m_ldapSvc.getConnection().getResponseControls();
+        if (ldapCtls == null) {
+            return null;
+        }
+        // Parse raw controls
+        Control[] ctls = new Control[ldapCtls.length];
+        for (int i=0; i < ldapCtls.length; i++) {
+            ctls[i] = NetscapeControlFactory.getControlInstance(ldapCtls[i]);
+            if (ctls[i] == null) {
+                throw new NamingException("Unsupported control " + ldapCtls[i].getID());
+            }
+        }
+        return ctls;
+    }
+
+    public LdapContext newInstance(Control[] reqCtls) throws NamingException {
+        LdapContextImpl clone = new LdapContextImpl(m_ctxDN, this);
+        // This controls are to be set on the the LDAPConnection
+        clone.m_ctxEnv.setProperty(ContextEnv.P_CONNECT_CTRLS, reqCtls);
+        return clone;
+    }
+
+    public void reconnect(Control[] reqCtls) throws NamingException {
+        close();
+        m_ldapSvc = new LdapService();
+        // This controls are to be set on the the LDAPConnection
+        if (reqCtls != null) {
+            m_ctxEnv.setProperty(ContextEnv.P_CONNECT_CTRLS, reqCtls);
+        }
+        m_ldapSvc.connect(this);
+    }
+    
+    public Control[] getConnectControls() {
+        return (Control[])m_ctxEnv.getProperty(ContextEnv.P_CONNECT_CTRLS);
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/BaseSearchEnum.java
@@ -0,0 +1,165 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+import com.netscape.jndi.ldap.common.ExceptionMapper;
+
+import netscape.ldap.*;
+
+import java.util.*;
+
+/**
+ * Wrapper for the LDAPSearchResult that implements all NamingEnumeration methods 
+ * except next() (left to be implemented by subclasses). Because LDAPJDK does
+ * not provide for capability to ignoral referrals, the class is using hasMore()
+ * method to read ahead search results and "ignore" referrals if required.
+ * Base class for BindingEnum, NameClassPairEnum and SearchResultEnum
+ */
+abstract class BaseSearchEnum implements NamingEnumeration {
+
+    LDAPSearchResults m_res;
+    LdapContextImpl m_ctx;
+    Name m_ctxName;
+    private LDAPEntry nextEntry;
+    private LDAPException nextException;
+    
+    public BaseSearchEnum(LDAPSearchResults res, LdapContextImpl ctx) throws NamingException{
+        m_res = res;
+        m_ctx = ctx;
+        try {
+            m_ctxName = LdapNameParser.getParser().parse(m_ctx.m_ctxDN);
+        }
+        catch ( NamingException e ) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+    LDAPEntry nextLDAPEntry() throws NamingException{
+        if (nextException == null && nextEntry == null) {
+            hasMore();
+        }            
+        try {        
+            if (nextException != null) {
+                if (nextException instanceof LDAPReferralException) {
+                    throw new LdapReferralException(m_ctx,
+                              (LDAPReferralException)nextException);
+                }
+                else {
+                    throw ExceptionMapper.getNamingException(nextException);
+                }
+            }
+            return nextEntry;
+        }
+        finally {
+            nextException = null;
+            nextEntry = null;
+        }       
+    }
+
+    public Object nextElement() {
+        try {
+            return next();
+        }
+        catch ( Exception e ) {
+            System.err.println( "Error in BaseSearchEnum.nextElement(): " + e.toString() );
+            e.printStackTrace(System.err);
+            return null;
+        }        
+    }
+
+    public boolean hasMore() throws NamingException{
+        
+        if (nextEntry != null || nextException != null) {
+            return true;
+        }
+        
+        if (m_res.hasMoreElements()) {
+            try {
+                nextEntry = m_res.next();
+                return true;
+            }
+            catch (LDAPReferralException e) {
+                boolean ignoreReferrals = m_ctx.m_ctxEnv.ignoreReferralsMode();
+                if (ignoreReferrals) {
+                    
+                    return hasMore();
+                    
+                    // PARTIAL_SEARCH_RESULT should be thrown according to the
+                    // Implmentation Guidelines for LDAPSP, but is not done by
+                    // the Sun LDAPSP 1.2, so we not doing it either.
+                    //nextException = new LDAPException("Ignoring referral", 9);
+                    //return true;
+                }
+                else {
+                    nextException = e;
+                    return true;
+                }       
+            }
+            catch ( LDAPException e ) {
+                nextException = e;
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean hasMoreElements() {
+        try {
+            return hasMore();
+        }
+        catch ( Exception e ) {
+            System.err.println( "Error in BaseSearchEnum.hasMoreElements(): " + e.toString() );
+            e.printStackTrace(System.err);
+            return false;
+        }        
+
+    }
+
+    public void close() throws NamingException{
+        try {
+            m_ctx.m_ldapSvc.getConnection().abandon(m_res);
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/EventService.java
@@ -0,0 +1,583 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+import javax.naming.event.*;
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+import java.util.*;
+import com.netscape.jndi.ldap.common.*;
+
+/**
+ * Event Service monitors changes on the server
+ * Implemented with the persistent search control. Uses ldapjdk asynchronous
+ * interfaces so that multiple search requests can be processed by a single
+ * thread
+ *
+ */
+class EventService implements Runnable{
+
+    LdapService m_ldapSvc;
+    Vector m_eventList = new Vector();
+    Thread m_monitorThread;
+    LDAPSearchListener m_msgQueue; // for asynch ldap search
+    
+    /**
+     * Constructor
+     */
+    public EventService (LdapService ldapSvc) {
+        m_ldapSvc = ldapSvc;
+    }
+
+    /**
+     * Add change event listener
+     */
+    synchronized void addListener (LdapContextImpl ctx, String name,
+                      String filter,SearchControls jndiCtrls, NamingListener l)
+                      throws NamingException{
+        
+        EventEntry event = null;
+        LDAPSearchListener sl = null; // Search listener for this request
+
+        Debug.println(1, "ADD LISTENER");
+
+        // Create DN by appending the name to the current context
+        String base = ctx.getDN();
+        if (name.length() > 0) {
+            if (base.length() > 0) {
+                base = name + "," + base;
+            }
+            else {
+                base = name;
+            }
+        }
+                
+        //Create search constraints
+        LDAPConnection ld = (LDAPConnection) m_ldapSvc.getConnection().clone();
+        LDAPSearchConstraints cons=ld.getSearchConstraints();
+        LDAPPersistSearchControl psearchCtrl = createSrchCtrl(l);
+        cons.setServerControls(psearchCtrl);
+
+        // return obj flag is ignored in this implementation
+        boolean returnObjs = jndiCtrls.getReturningObjFlag();
+        
+        // Attributes in jndiCtrls.getReturningAttributes() are ignored 
+        // This is because we are not returning objects in the NamingEvent
+        // and thus listeners can not read attributes from the event.
+        // Request only javaClassName to be able to determine object type
+        String[] attrs = new String[] { "javaclassname" }; 
+            
+        // Search scope
+        int scope = ProviderUtils.jndiSearchScopeToLdap(jndiCtrls.getSearchScope());
+
+        // Check if such change is already monitored, search for the event entry
+        for (int i=0; i < m_eventList.size(); i++) {
+            EventEntry ee = (EventEntry) m_eventList.elementAt(i);
+            if (ee.isEqualEvent(base, scope, filter, attrs, cons)) {
+                event = ee;
+                break;
+            }
+        }
+        
+        // If event entry does not exist, send an asynch persistent search
+        // request and create a new event entry
+        if (event == null) {
+            try {                    
+                Debug.println(1, "Do persistent search for " + base);
+                sl = ld.search( base, scope, filter, attrs,
+                                false, /*l=*/null, cons);
+                int[] ids = sl.getMessageIDs();
+                int id = ids[ids.length-1];
+                event = new EventEntry(id, ctx, base, scope, filter, attrs, cons);
+                m_eventList.addElement(event);
+            }
+            catch(Exception ex) {
+                throw ExceptionMapper.getNamingException(ex);
+            }
+        }
+
+        // regiter naming listener with the event
+        event.addListener(l);
+
+        // Add this search request to the m_msgQueue so it can be
+        // processed by the monitor thread
+        if (m_msgQueue == null) {
+            m_msgQueue = sl;
+        }
+        else {
+            m_msgQueue.merge(sl);
+        }
+        
+        // Create new event if reqested change is not already monitored
+        if (m_monitorThread == null) {
+            m_monitorThread = new Thread (this, "EventService");
+            m_monitorThread.setDaemon(true);
+            m_monitorThread.start();
+        }    
+    }
+    
+    /**
+     * Remove change event listener
+     */
+     synchronized void removeListener(NamingListener listener)throws NamingException {
+        boolean removed = false;
+
+        // Check and the listener against all event entries. If an event is
+        // left with no listeners, abandon associated ldap request
+        for(int i = m_eventList.size()-1; i>=0; i--) {
+            EventEntry ee = (EventEntry)m_eventList.elementAt(i);
+            if (ee.removeListener(listener)) {
+                removed = true;
+
+                // If no listeners left abandon persistent search and
+                // delete entry
+                if (ee.isEmpty()) {
+                    abandonRequest(ee.id);
+                    m_eventList.removeElement(ee);
+                }
+            }
+        }
+        
+        // Stop the monitor thread if no events are left
+        // Actually, the thread should stop by itself, as when no outstanding
+        // events are left LDAPSearchListener.getResponse() should return null
+        if (m_eventList.size() == 0) {
+            m_monitorThread = null;
+        }            
+      
+        if (!removed) {
+            throw new NamingException("Listener not found");
+        }
+     }    
+
+    /**
+     * Abandon LDAP request with the specified message ID
+     */
+     private void abandonRequest(int id) {
+        LDAPConnection ldc = m_ldapSvc.getConnection();
+        try {
+            ldc.abandon(id);
+        }
+        catch (LDAPException ex) {}
+     }
+         
+     
+    /**
+     * Main monitor thread loop. Wait for persistent search change notifications
+     */
+    public void run() {
+        
+        LDAPMessage msg = null;
+
+        
+        while (m_monitorThread != null) {
+
+            try {
+                
+                // Block untill a message is received
+                msg = m_msgQueue.getResponse();
+                
+            }
+            catch (LDAPException ex) {
+                processNetworkError(ex);
+            }
+
+            // Terminate if no more requests left
+            if (msg == null) {
+                Debug.println(1, "No more messages, bye");
+                m_monitorThread = null;
+                return;
+            }                        
+          
+            synchronized (EventService.this) {
+                
+                EventEntry eventEntry = getEventEntry(msg.getMessageID());                
+
+                // If no listeners, abandon this message id
+                if (eventEntry == null) {
+                    Debug.println(1, "Received ldap msg with unknown id="+msg.getMessageID());
+
+                    if (! (msg instanceof LDAPResponse)) {
+                        abandonRequest(msg.getMessageID());
+                    }                    
+                    continue;
+                }
+                
+                // Check for error message ...
+                if (msg instanceof LDAPResponse) {
+                    processResponseMsg((LDAPResponse) msg, eventEntry);
+                }
+                    
+                // ... or referral ...
+                else if (msg instanceof LDAPSearchResultReference) {
+                    processSearchResultRef((LDAPSearchResultReference) msg, eventEntry);
+                }                   
+
+            
+                // ... then must be a LDAPSearchResult carrying change control
+                else if (msg instanceof LDAPSearchResult) {
+                    processSearchResultMsg((LDAPSearchResult) msg, eventEntry);
+                }
+            }
+        } // end of synchronized block            
+    }
+    
+    /**
+     * On network error, create NamingExceptionEvent and delever it to all
+     * listeners on all events.
+     */
+    private void processNetworkError(LDAPException ex) {
+        NamingException nameEx = ExceptionMapper.getNamingException(ex);
+        for(int i=0; i<m_eventList.size(); i++) {
+            EventEntry ee = (EventEntry)m_eventList.elementAt(i);
+            dispatchEvent(new NamingExceptionEvent(ee.ctx, nameEx), ee);
+        }
+    }                
+    
+    /**
+     * Response message carries a LDAP error. Response with the code 0 (SUCCESS),
+     * should never be received as persistent search never completes, it has to
+     * be abandon. Referral messages are ignored
+     */
+    private void processResponseMsg(LDAPResponse rsp, EventEntry ee) {
+        if (rsp.getResultCode() == 0) {
+            return;  // this should never happen, but  just in case
+        }
+        else if (rsp.getResultCode() == LDAPException.REFERRAL) {
+            return; // ignore referral
+        }
+        
+        LDAPException ex = new LDAPException( "error result",rsp.getResultCode(),
+                           rsp.getErrorMessage(), rsp.getMatchedDN());
+        NamingException nameEx = ExceptionMapper.getNamingException(ex);
+        dispatchEvent(new NamingExceptionEvent(ee.ctx, nameEx), ee);
+    }        
+    
+    /**
+     * Process change notification attached as the change control to the message
+     */
+    private void processSearchResultMsg(LDAPSearchResult res, EventEntry ee) {
+        LDAPEntry modEntry = res.getEntry();
+               
+        Debug.println(1, "Changed " + modEntry.getDN());
+
+        /* Get any entry change controls. */
+        LDAPControl[] ctrls = res.getControls();
+
+        // Can not create event without change control
+        if (ctrls == null) {
+            NamingException ex = new NamingException(
+            "Can not create NamingEvent, no change control info");
+            dispatchEvent(new NamingExceptionEvent(ee.ctx, ex), ee);
+        }
+
+        // Multiple controls might be in the message
+        for (int i=0; i < ctrls.length; i++) {
+            LDAPEntryChangeControl changeCtrl = null;
+
+            if (ctrls[i] instanceof LDAPEntryChangeControl) {
+                changeCtrl = (LDAPEntryChangeControl) ctrls[i];
+
+                // Can not create event without change control
+                if (changeCtrl.getChangeType() == -1) {
+                    NamingException ex = new NamingException(
+                    "Can not create NamingEvent, no change control info");
+                    dispatchEvent(new NamingExceptionEvent(ee.ctx, ex), ee);
+                }
+      
+                // Convert control into a NamingEvent and dispatch to listeners
+                try {
+                    NamingEvent event = createNamingEvent(ee.ctx, modEntry, changeCtrl);
+                    dispatchEvent(event, ee);
+                }
+                catch (NamingException ex) {
+                    dispatchEvent(new NamingExceptionEvent(ee.ctx, ex), ee);
+                }
+            }
+        }                       
+    }
+    
+    /**
+     * Search continuation messages are ignored.
+     */
+    private void processSearchResultRef(LDAPSearchResultReference ref, EventEntry ee) {
+        ; // Do nothing, message ignored, do not dispatch NamingExceptionEvent
+    }
+
+    /**
+     * Find event entry by message ID
+     */
+    private EventEntry getEventEntry(int id) {
+        for (int i=0; i < m_eventList.size(); i++) {
+            EventEntry ee = (EventEntry) m_eventList.elementAt(i);
+            if (ee.id == id) {
+                return ee;
+            }
+        }            
+        return null;
+    }
+    
+    /**
+     * Dispatch naming event to all listeners
+     */
+    private void dispatchEvent(EventObject event, EventEntry eventEntry) {
+        NamingListener[] dispatchList = null;
+
+        // Copy listeners so that list can be modifed during dispatching
+        synchronized (eventEntry) {
+            dispatchList = new NamingListener[eventEntry.listeners.size()];
+            for (int i=0; i < dispatchList.length; i++) {
+                dispatchList[i] = (NamingListener)eventEntry.listeners.elementAt(i);
+            }
+        }
+           
+        // dispatch to all listeners
+        for (int i=0; i < dispatchList.length; i++) {
+            if (event instanceof NamingEvent) {
+                ((NamingEvent)event).dispatch(dispatchList[i]);
+            }
+            else {
+                ((NamingExceptionEvent)event).dispatch(dispatchList[i]);
+            }    
+        }
+    }
+
+    /**
+     * Create naming event from a change control
+     */
+    private NamingEvent createNamingEvent(LdapContextImpl ctx, LDAPEntry entry,
+                        LDAPEntryChangeControl changeCtrl)throws NamingException{
+
+        Binding oldBd = null, newBd = null;            
+        int eventType = -1;
+        Object changeInfo = null;
+        String oldName = null, newName = null;
+
+        // Get the class name from the entry
+        String className = ObjectMapper.getClassName(entry);
+
+        // Get information on the type of change made
+        int changeType = changeCtrl.getChangeType();
+        switch ( changeType ) {
+            case LDAPPersistSearchControl.ADD:
+                eventType = NamingEvent.OBJECT_ADDED;
+                newName = LdapNameParser.getRelativeName(ctx.m_ctxDN, entry.getDN());
+                break;
+            case LDAPPersistSearchControl.DELETE:
+                eventType = NamingEvent.OBJECT_REMOVED;
+                oldName = LdapNameParser.getRelativeName(ctx.m_ctxDN, entry.getDN());
+                break;
+            case LDAPPersistSearchControl.MODIFY:
+                eventType = NamingEvent.OBJECT_CHANGED;
+                oldName = newName = LdapNameParser.getRelativeName(ctx.m_ctxDN, entry.getDN());
+                break;
+            case LDAPPersistSearchControl.MODDN:
+                eventType = NamingEvent.OBJECT_RENAMED;
+                // Get the previous DN of the entry
+                String oldDN = changeCtrl.getPreviousDN();
+                if ( oldDN != null ) {
+                    oldName = LdapNameParser.getRelativeName(ctx.m_ctxDN, oldDN);
+                }
+                // newName might be outside the context for which the listener has registred
+                try {
+                    newName = LdapNameParser.getRelativeName(ctx.m_ctxDN, entry.getDN());
+                }
+                catch (NamingException ex) {}
+                break;
+        }
+
+        // Pass the change log number as event's change info
+        // If the change log number is not present the value is -1
+        changeInfo = new Integer(changeCtrl.getChangeNumber());
+
+        if (oldName != null) {
+            oldBd = new Binding(oldName, className, /*obj=*/null, /*isRelative=*/true);
+        }    
+        if (newName!= null) {
+            newBd = new Binding(newName, className, /*obj=*/null, /*isRelative=*/true);
+        }    
+        return new NamingEvent(ctx, eventType, newBd, oldBd, changeInfo);
+    }
+
+    /**
+     * Create a persistent search control.
+     */
+    private LDAPPersistSearchControl createSrchCtrl(NamingListener listener)
+                                     throws NamingException{
+        
+        int op = 0;
+        
+        if (listener instanceof ObjectChangeListener) {
+            op = LDAPPersistSearchControl.MODIFY;
+        }
+        if (listener instanceof NamespaceChangeListener) {
+            op |= LDAPPersistSearchControl.ADD |
+                     LDAPPersistSearchControl.DELETE |
+                     LDAPPersistSearchControl.MODDN;
+        }
+        if (op == 0) {
+            throw new NamingException("Non supported listener type " +
+                listener.getClass().getName());
+        }    
+
+        return  new LDAPPersistSearchControl( op, /*changesOnly=*/true,
+                          /*returnControls=*/true, /*isCritical=*/true );
+    }
+
+
+    /**
+     * Inner class that represents a binding between a change event,
+     * described with a set of search parameters, and a list of listeners
+     */
+    static private class EventEntry {
+        
+        LdapContextImpl ctx;
+        String base, filter, attrs[];
+        int scope;
+        LDAPSearchConstraints cons;
+        int id; // ldap message id
+        Vector listeners   = new Vector(); // vector of NamingListener
+        
+        /**
+         * Constructor
+         */
+        EventEntry(int id, LdapContextImpl ctx, String base, int scope,
+                   String filter, String[] attrs, LDAPSearchConstraints cons) {
+
+            this.id = id;
+            this.ctx = ctx;
+            this.base = base;
+            this.scope = scope;
+            this.filter = filter;
+            this.attrs = attrs;
+            this.cons = cons;
+        }
+        
+        /**
+         * Add Listsner
+         */
+        synchronized void addListener(NamingListener l) {
+            listeners.addElement(l);
+         }
+
+        /**
+         * Remove listener
+         */
+        synchronized boolean removeListener(NamingListener l) {
+            return listeners.removeElement(l);
+        }    
+
+        /**
+         * Chech whether there are any listeners
+         */
+        boolean isEmpty() {
+            return listeners.size() == 0;
+         }    
+         
+
+        /**
+         * Check whether this event paramaters are matched
+         */
+        boolean isEqualEvent(String base, int scope, String filter,
+                      String[] attrs, LDAPSearchConstraints cons) {
+        
+            if (!this.base.equals(base) || this.scope != scope ||
+                !this.filter.equals(filter)) {
+                    
+                return false;
+            }
+            
+            // attrs[] 
+            if (this.attrs == null) {
+                if (attrs != null) {
+                    return false;
+                }
+            }
+            else if (attrs == null) {
+                return false;
+            }
+            else if (this.attrs.length != attrs.length) {
+                return false;
+            }
+            else {
+                // Attr sets may be the same but in diffferent order
+                for (int i=0; i < this.attrs.length; i++) {
+                    boolean found = false;
+                    for (int j=0; j < this.attrs.length; j++) {
+                        if (this.attrs[i].equals(attrs[j])) {
+                            found = true;
+                            break;
+                        }                            
+                    }
+                    if (!found) {
+                        return false;
+                    } 
+                }
+            }    
+
+            // Check if persistent search is for the same change type
+            LDAPPersistSearchControl
+                psearch1 = (LDAPPersistSearchControl)this.cons.getServerControls()[0],
+                psearch2 = (LDAPPersistSearchControl)cons.getServerControls()[0];
+            int types1 = psearch1.getChangeTypes(),
+                types2 = psearch2.getChangeTypes();                
+            return (types1 == types2);
+        }
+        
+        public String toString() {
+            LDAPPersistSearchControl
+                psearch = (LDAPPersistSearchControl)cons.getServerControls()[0];
+
+            String str = "[EventEntry] base=" + base + " scope=" + scope +
+                         " filter=" + filter + " attrs={";
+            for (int i=0; i < attrs.length; i++) {
+                if (i>0) {
+                    str += " ";
+                }
+                str += attrs[i];
+            }
+            str += "} chanageTypes=" + psearch.getChangeTypes();
+            str += " listeners=" + listeners.size();
+            str += " id=" + id;
+            return str;
+        }
+    }
+}    
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/BindingEnum.java
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+import com.netscape.jndi.ldap.common.ExceptionMapper;
+
+import netscape.ldap.*;
+
+import java.util.*;
+
+/**
+ * Wrapper for the LDAPSearchResult. Convert each LDAPEntry entry into
+ * a JNDI Binding. Bindings are accessed through the NamingEnumeration
+ * interface
+ */
+class BindingEnum extends BaseSearchEnum {
+
+    public BindingEnum(LDAPSearchResults res, LdapContextImpl ctx)  throws NamingException {
+        super(res, ctx);
+    }
+
+    public Object next() throws NamingException{
+        LDAPEntry entry = nextLDAPEntry();
+        String name = LdapNameParser.getRelativeName(m_ctxName, entry.getDN());
+        Object obj = ObjectMapper.entryToObject(entry, m_ctx);
+        String className = obj.getClass().getName();
+        return new Binding(name, className, obj, /*isRelative=*/true);
+    }
+
+}
\ No newline at end of file
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/ProviderUtils.java
@@ -0,0 +1,299 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+
+import java.util.*;
+
+/**
+ * Common utility methods
+ *
+ */
+class ProviderUtils {
+
+    public static final String DEFAULT_FILTER = "(objectclass=*)";
+
+    static int jndiSearchScopeToLdap(int jndiScope) throws NamingException {
+        int scope = -1;
+        if (jndiScope == SearchControls.SUBTREE_SCOPE) {
+            scope = LDAPConnection.SCOPE_SUB;
+        }
+        else if (jndiScope == SearchControls.ONELEVEL_SCOPE) {
+            scope = LDAPConnection.SCOPE_ONE;
+        }
+        else if (jndiScope == SearchControls.OBJECT_SCOPE) {
+            scope = LDAPConnection.SCOPE_BASE;
+        }
+        else {
+            throw new InvalidSearchControlsException("Illegal value for the search scope");
+        }
+        return scope;
+    }        
+
+    
+    /**
+     * Convert Attribute List to a LDAP filter
+     *
+     * @return LDAP Filter
+     * @throw NamingException
+     * @param attrs An Attribute List
+     */
+    static String attributesToFilter(Attributes attrs) throws NamingException{
+        
+        if (attrs == null || attrs.size() == 0) {
+            return DEFAULT_FILTER;
+        }
+        
+        String filter = "";
+        
+        for (NamingEnumeration attrEnum = attrs.getAll(); attrEnum.hasMore();) {
+            Attribute attrib = (Attribute) attrEnum.next();
+            
+            //Has attributes any values
+            if ( attrib.size() == 0) {
+                // test only for presence of the attribute
+                filter += "(" + attrib.getID() + "=*)";
+                continue;
+            }
+            
+            // Add attribute values to the filter, ecsaping if necessary
+            String attrValues = "";
+            for (NamingEnumeration valEnum = attrib.getAll(); valEnum.hasMore();) {
+                Object val = valEnum.next();
+                if (val instanceof String) {
+                    attrValues += "(" + attrib.getID() + "=" + escapeString((String)val) +")";
+                }    
+                else if (val instanceof byte[]) {
+                    attrValues += "(" + attrib.getID() + "=" + escapeBytes((byte[])val) +")";
+                }
+                else if (val == null) {
+                    //null is allowed value in Attribute.add(Object), accept it just in case
+                    attrValues += "(" + attrib.getID() + "=*)";
+                }
+                else {
+                    throw new NamingException(
+                    "Wrong Attribute value, expecting String or byte[]");
+                }
+            }
+            filter += (attrib.size() > 1) ? ("(|" + attrValues + ")") : attrValues;
+        }
+        
+        return (attrs.size() > 1) ? ("(&" + filter + ")") : filter;
+    }    
+            
+
+    /**
+     * Expand filterExpr. Each occurrence of a variable "{n}", where n is a non-negative
+     * integer, is replaced with a variable from the filterArgs array indexed by the 'n'.
+     * FilterArgs can be Strings or byte[] and they are escaped according to the RFC2254
+     */
+     static String expandFilterExpr(String filterExpr, Object[] filterArgs) throws InvalidSearchFilterException{
+        StringTokenizer tok = new StringTokenizer(filterExpr, "{}", /*returnTokens=*/true);
+        
+        if (tok.countTokens() == 1) {            
+            return filterExpr; // No escape characters
+        }
+        
+        StringBuffer out= new StringBuffer();
+        boolean expectVarIdx = false, expectVarOff = false;
+        Object arg= null;
+        while (tok.hasMoreTokens()) {
+            String s = tok.nextToken();
+            
+            if (expectVarIdx) {
+                expectVarIdx = false;
+                try {
+                    int idx = Integer.parseInt(s);
+                    arg = filterArgs[idx];
+                    expectVarOff = true;
+                }
+                catch (IndexOutOfBoundsException e) {
+                    throw new InvalidSearchFilterException("Filter expression variable index out of bounds");
+                }
+
+                catch (Exception e) {
+                    throw new InvalidSearchFilterException("Invalid filter expression");
+                }
+            }
+                    
+            else if (expectVarOff) {
+                expectVarOff = false;
+                if (!s.equals("}")) {
+                    throw new InvalidSearchFilterException("Invalid filter expression");
+                }
+                if (arg instanceof String) {
+                    out.append(escapeString((String)arg));
+                }
+                else if (arg instanceof byte[]) {
+                    out.append(escapeBytes((byte[])arg));
+                }
+                else {                
+                    throw new InvalidSearchFilterException("Invalid filter argument type");
+                }
+                arg = null;
+            }
+            
+            else if  (s.equals("{")) {
+                expectVarIdx = true;
+            }
+            else {
+                out.append(s);
+            }
+        }
+        if (expectVarIdx || expectVarOff) {
+            throw new InvalidSearchFilterException("Invalid filter expression");
+        }    
+        return out.toString();
+    }    
+
+         
+    /**
+     * Escape a string according to the RFC 2254
+     */
+    static String escapeString(String str) {
+        String charToEscape = "\\*()\000";
+        StringTokenizer tok = new StringTokenizer(str, charToEscape, /*returnTokens=*/true);
+        
+        if (tok.countTokens() == 1) {            
+            return str; // No escape characters
+        }
+        
+        StringBuffer out= new StringBuffer();
+        while (tok.hasMoreTokens()) {
+            String s = tok.nextToken();
+            
+            if (s.equals("*")) {
+                out.append("\\2a");
+            }
+            else if (s.equals("(")) {
+                out.append("\\28");
+            }    
+            else if (s.equals(")")) {
+                out.append("\\29");
+            }    
+            else if (s.equals("\\")) {
+                out.append("\\5c");
+            }
+            else if (s.equals("\000")) {
+                out.append("\\00");
+            }
+            else {
+                out.append(s);
+            }
+        }
+        return out.toString();
+    }    
+
+    
+    /**
+     * Escape a byte array according to the RFC 2254
+     */
+    static final String hexDigits="0123456789abcdef";
+    
+    static String escapeBytes(byte[] bytes) {
+        StringBuffer out = new StringBuffer("");
+        for (int i=0; i < bytes.length; i++) {
+
+            int low  = bytes[i] & 0x0f;
+            int high = (bytes[i] & 0xf0) >> 4;
+            out.append("\\");
+            out.append(hexDigits.charAt(high));
+            out.append(hexDigits.charAt(low));
+        }
+        return out.toString();
+    }    
+
+    /**
+     * A method used only for testing
+     */
+    private    static void testAttributesToFilter() {
+        try {
+            System.out.println(attributesToFilter(null));
+            
+            BasicAttributes attrs = new BasicAttributes(true);        
+            
+            System.out.println(attrs + " = " + attributesToFilter(attrs));
+            
+            attrs.put (new BasicAttribute("attr1", "val1"));
+            attrs.put (new BasicAttribute("attr2", "(val2)\\*x"));
+            attrs.put (new BasicAttribute("attr3"));
+            BasicAttribute attr4 = new BasicAttribute("attr4", "val41");
+            attr4.add("val42");
+            attrs.put(attr4);
+            attrs.put("attr5", new byte[] { (byte)0x23, (byte)0x3, (byte)0x0, (byte)0xab, (byte)0xff});
+            System.out.println(attrs + " = " +attributesToFilter(attrs));            
+        }
+        catch (Exception e) {
+            System.err.println(e);
+        }    
+    }    
+
+    /**
+     * A method used only for testing
+     */
+    private    static void testFilterExpr() {
+        try {
+            String filterExpr = "(&(attr0={0})(attr1={1}))";
+            Object [] args = new Object[] { "val*0", new byte[] { (byte)0xf0, (byte) 0x3a}};
+            String filter = null;
+            filter = expandFilterExpr(filterExpr, args);
+            System.out.println(filterExpr + " -> " + filter);
+        }
+        catch (Exception e) {
+            System.err.println(e);
+        }    
+    }    
+
+    /**
+     * Test
+     */
+    public static void main(String[] args) {
+        /*testAttributesToFilter();
+        String x = "012\0003";
+        byte[] b = x.getBytes();
+        for (int i=0; i < b.length; i++) {
+            System.out.println(i+"="+b[i]);
+        }*/
+        testFilterExpr();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/LdapService.java
@@ -0,0 +1,582 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+import netscape.ldap.*;
+import java.util.*;
+import java.io.*;
+import com.netscape.jndi.ldap.common.*;
+import com.netscape.jndi.ldap.schema.SchemaRoot;
+
+/**
+ * Ldap Service encapsulates a Ldap connection and Ldap operations over the
+ * connection. The connection is established in a lazy manner, first time a
+ * Ldap operation is initiated. A Ldap Service object is shared by multiple
+ * contexts. The object maintains a reference counter which is incremented
+ * when a context is cloned, and decremeneted when a context is closed. The
+ * associated Ldap Connection is relased when the reference counter reaches
+ * zero.
+ *
+ * LDAPsearchConstraints are always read from a context, because ldap service
+ * is a shared object and each context may request different search constraints.
+ *
+ */
+class LdapService {
+
+    public static final String DEFAULT_FILTER = "(objectclass=*)";
+    public static final int    DEFAULT_SCOPE = LDAPv3.SCOPE_SUB;
+    public static final String DEFAULT_HOST = "localhost";
+    public static final int    DEFAULT_PORT = LDAPv2.DEFAULT_PORT;    
+    public static final int    DEFAULT_SSL_PORT = 636;
+    
+    private LDAPConnection m_ld;
+    private EventService m_eventSvc;
+    
+    /**
+     * The number of contexts that are currently sharing this LdapService.
+     * Essentially, a reference counter. Incremented in the LdapContextImpl
+     * copy constructor. Decremented in the LdapService.disconnect().
+     * When the count reaches zero, the LDAPConnection is released.
+     */
+    private int m_clientCount;
+    
+        
+    public LdapService() {
+        m_ld = new LDAPConnection();
+        m_clientCount = 1;
+    }
+
+    LDAPConnection getConnection() {
+        return m_ld;
+    }
+
+    /**
+     * Connect to the server and send bind request to authenticate the user
+     */
+    void connect(LdapContextImpl ctx) throws NamingException{
+
+        if (m_ld.isConnected()) {
+            return; //already connected
+        }
+        
+        LDAPUrl url = ctx.m_ctxEnv.getDirectoryServerURL();
+        String host = (url != null) ? url.getHost() : DEFAULT_HOST;
+        int    port = (url != null) ? url.getPort() : DEFAULT_PORT;
+        String user   = ctx.m_ctxEnv.getUserDN();
+        String passwd = ctx.m_ctxEnv.getUserPassword();
+        String socketFactory = ctx.m_ctxEnv.getSocketFactory();
+        Object cipherSuite   = ctx.m_ctxEnv.getCipherSuite();
+        int    ldapVersion   = ctx.m_ctxEnv.getLdapVersion();
+        boolean isSSLEnabled = ctx.m_ctxEnv.isSSLEnabled();
+        String[] saslMechanisms = ctx.m_ctxEnv.getSaslMechanisms();
+        LDAPControl[] ldCtrls= ctx.m_ctxEnv.getConnectControls();
+        Object traceOut = ctx.m_ctxEnv.getProperty(ContextEnv.P_TRACE);
+
+        // Set default ssl port if DS not specifed
+        if (isSSLEnabled && url == null) {
+            port = DEFAULT_SSL_PORT;
+        }
+
+        // SSL is enabled but no Socket factory specified. Use the
+        // ldapjdk default one        
+        if (isSSLEnabled && socketFactory == null) {
+            m_ld = new LDAPConnection(new LDAPSSLSocketFactory());
+        }    
+
+        // Set the socket factory and cipher suite if cpecified
+        if (socketFactory != null) {
+            try {
+                LDAPSSLSocketFactory sf = null;
+                if (cipherSuite != null) {
+                    Debug.println(1, "CIPHERS=" + cipherSuite);
+                    sf = new LDAPSSLSocketFactory(socketFactory, cipherSuite);
+                }
+                else {
+                    sf = new LDAPSSLSocketFactory(socketFactory);
+                }    
+                m_ld = new LDAPConnection(sf);
+                Debug.println(1, "SSL CONNECTION");
+            }
+            catch (Exception e) {
+                throw new IllegalArgumentException(
+                "Illegal value for java.naming.ldap.factory.socket: " + e);
+            }
+        }
+
+        // Enable tracing 
+        if (traceOut != null) {
+            setTraceOutput(traceOut);
+        }
+        
+        try {
+            if (ldCtrls != null) {
+                m_ld.setOption(LDAPv3.SERVERCONTROLS, ldCtrls);
+            }
+            
+            if (saslMechanisms != null) { // sasl Auth
+                m_ld.authenticate(ctx.m_ctxEnv.getSaslAuthId(),
+                                  saslMechanisms,
+                                  ctx.m_ctxEnv.getSaslProps(),
+                                  ctx.m_ctxEnv.getSaslCallback());
+            }
+            else { // simple auth
+                m_ld.connect(ldapVersion, host, port, user, passwd);
+            }                
+        }
+        catch (LDAPException e) {            
+           // If ldapVersion is not specified in ctx env
+           // fallback to ldap v2 if v3 is bot supported
+            if (e.getLDAPResultCode() == e.PROTOCOL_ERROR &&
+                ldapVersion == 3 &&
+                saslMechanisms == null &&
+                ctx.m_ctxEnv.getProperty(
+                     ctx.m_ctxEnv.P_LDAP_VERSION) == null) {
+                
+                try {
+                    m_ld.connect(2, host, port, user, passwd);
+                }
+                catch (LDAPException e2) {
+                    throw ExceptionMapper.getNamingException(e2);
+                }
+            }
+            else {
+                throw ExceptionMapper.getNamingException(e);
+            }                
+        }
+    }
+
+    protected void finalize() {
+        try {
+            m_ld.disconnect();
+        }
+        catch (Exception e) {}
+    }
+
+    boolean isConnected() {
+        return (m_ld.isConnected());
+    }
+    
+
+    /**
+     * Physically disconect only if the client count is zero
+     */
+    synchronized void disconnect() {
+        try {
+            if (m_clientCount > 0) {
+                m_clientCount--;
+            }    
+            if (m_clientCount == 0 && isConnected()) {
+                m_ld.disconnect();
+            }
+        }
+        catch (Exception e) {}
+    }    
+
+    /**
+     * Increment client count
+     */
+    synchronized void incrementClientCount() {
+        m_clientCount++;
+    }
+        
+    /**
+     * LDAP search operation
+     */
+    NamingEnumeration search (LdapContextImpl ctx, String name, String filter, String[] attrs, SearchControls jndiCtrls) throws NamingException{
+        Debug.println(1, "SEARCH");
+        String base = ctx.getDN();
+        int scope  = LDAPConnection.SCOPE_SUB;
+        LDAPSearchConstraints cons=ctx.getSearchConstraints();
+        boolean returnObjs = false;
+                
+        connect(ctx); // Lazy Connect
+
+        // Create DN by appending the name to the current context
+        if (name.length() > 0) {
+            if (base.length() > 0) {
+                base = name + "," + base;
+            }
+            else {
+                base = name;
+            }
+        }
+                
+        // Map JNDI SearchControls to ldapjdk LDAPSearchConstraints
+        if (jndiCtrls != null) {
+            int maxResults = (int)jndiCtrls.getCountLimit();
+            int timeLimitInMsec = jndiCtrls.getTimeLimit();
+            // Convert timeLimit in msec to sec 
+            int timeLimit = timeLimitInMsec/1000;
+            if (timeLimitInMsec > 0 && timeLimitInMsec < 1000) {
+                timeLimit = 1; //sec
+            }
+            
+            // Clone cons if maxResults or timeLimit is different from the default one
+            if (cons.getServerTimeLimit() != timeLimit || cons.getMaxResults() != maxResults) {
+                cons = (LDAPSearchConstraints)cons.clone();
+                cons.setMaxResults(maxResults);
+                cons.setServerTimeLimit(timeLimit);
+            }    
+            
+            // TODO The concept of links is not well described in JNDI docs.
+            // We can only specify dereferencing of Aliases, but Links and
+            // Aliases are not the same; IGNORE jndiCtrls.getDerefLinkFlag()
+        
+            // Attributes to return
+            attrs = jndiCtrls.getReturningAttributes();
+            if (attrs != null && attrs.length==0) {
+                //return no attributes
+                attrs = new String[] { "1.1" };
+               
+               // TODO check whether ldap compare operation should be performed
+               // That's the case if: (1) scope is OBJECT_SCOPE, (2) no attrs
+               // are requested to return (3) filter has the form (name==value)
+               // where no wildcards ()&|!=~><* are used.
+                
+            }            
+            
+            // Search scope
+            scope = ProviderUtils.jndiSearchScopeToLdap(jndiCtrls.getSearchScope());
+
+            // return obj flag
+            returnObjs = jndiCtrls.getReturningObjFlag();
+        }    
+            
+        try {
+            // Perform Search
+            boolean attrsOnly  = ctx.m_ctxEnv.getAttrsOnlyFlag();
+            LDAPSearchResults res = m_ld.search( base, scope, filter, attrs, attrsOnly, cons );
+            return new SearchResultEnum(res, returnObjs, ctx);
+        }
+        catch (LDAPReferralException e) {
+            throw new LdapReferralException(ctx, e);
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+    
+    /**
+     * List child entries using LDAP lookup operation
+     */
+    NamingEnumeration listEntries(LdapContextImpl ctx, String name, boolean returnBindings) throws NamingException{
+        Debug.println(1, "LIST " + (returnBindings ? "BINDINGS" : ""));
+        String base = ctx.getDN();
+
+        connect(ctx); // Lazy Connect
+        
+        // Create DN by appending the name to the current context
+        if (name.length() > 0) {
+            if (base.length() > 0) {
+                base = name + "," + base;
+            }
+            else {
+                base = name;
+            }
+        }
+            
+        try {
+            // Perform One Level Search
+            String[] attrs = null; // return all attributes if Bindings are requested 
+            if (!returnBindings) { // for ClassNamePairs
+                attrs = new String[]{"javaclassname"}; //attr names must be in lowercase
+            }
+            LDAPSearchConstraints cons=ctx.getSearchConstraints();
+            LDAPSearchResults res = m_ld.search( base, LDAPConnection.SCOPE_ONE, DEFAULT_FILTER, attrs, /*attrsOnly=*/false, cons);
+            if (returnBindings) {
+                return new BindingEnum(res, ctx);
+            }
+            else {
+                return new NameClassPairEnum(res, ctx);
+            }
+        }
+        catch (LDAPReferralException e) {
+            throw new LdapReferralException(ctx, e);
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+    /**
+     * Lookup an entry using LDAP search operation
+     */
+    Object lookup(LdapContextImpl ctx, String name) throws NamingException{
+        Debug.println(1, "LOOKUP");        
+        String base = ctx.getDN();
+
+        connect(ctx); // Lazy Connect
+
+        // Create DN by appending the name to the current context
+        if (name.length() > 0) {
+            if (base.length() > 0) {
+                base = name + "," + base;
+            }
+            else {
+                base = name;
+            }
+        }
+            
+        try {
+            // Perform Base Search
+            String[] attrs = null; // return all attrs
+            LDAPSearchConstraints cons=ctx.getSearchConstraints();
+            LDAPSearchResults res = m_ld.search( base, LDAPConnection.SCOPE_BASE, DEFAULT_FILTER, attrs, /*attrsOnly=*/false, cons);
+            if (res.hasMoreElements()) {
+                LDAPEntry entry = res.next();
+                return ObjectMapper.entryToObject(entry, ctx);
+            }
+            return null; // should never get here
+
+        }
+        catch (LDAPReferralException e) {
+            throw new LdapReferralException(ctx, e);
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+    /**
+     * Read LDAP entry attributes
+     */
+    Attributes readAttrs (LdapContextImpl ctx, String name, String[] attrs) throws NamingException{
+        Debug.println(1, "READ ATTRS");
+        String base = ctx.getDN();
+        int scope  = LDAPConnection.SCOPE_BASE;
+        
+        connect(ctx); // Lazy Connect
+
+        // Create DN by appending the name to the current context
+        if (name.length() > 0) {
+            if (base.length() > 0) {
+                base = name + "," + base;
+            }
+            else {
+                base = name;
+            }
+        }
+
+        try {
+            // Perform Search
+            LDAPSearchConstraints cons=ctx.getSearchConstraints();
+            LDAPSearchResults res = m_ld.search(base, scope, DEFAULT_FILTER, attrs, /*attrsOnly=*/false, cons);
+            while (res.hasMoreElements()) {
+                LDAPEntry entry = res.next();
+                return new AttributesImpl(entry.getAttributeSet(),
+                       ctx.m_ctxEnv.getUserDefBinaryAttrs());
+            }
+            return null;
+        }
+        catch (LDAPReferralException e) {
+            throw new LdapReferralException(ctx, e);
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+    /**
+     * Modify LDAP entry attributes
+     */
+    void modifyEntry(LdapContextImpl ctx, String name, LDAPModificationSet mods) throws NamingException{
+        Debug.println(1, "MODIFY");
+        String base = ctx.getDN();
+        
+        if (mods.size() == 0) {
+            return;
+        }
+        connect(ctx); // Lazy Connect
+
+        // Create DN by appending the name to the current context
+        if (name.length() > 0) {
+            if (base.length() > 0) {
+                base = name + "," + base;
+            }
+            else {
+                base = name;
+            }
+        }
+        
+        try {
+            // Perform Modify
+            m_ld.modify(base, mods);
+        }
+        catch (LDAPReferralException e) {
+            throw new LdapReferralException(ctx, e);
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+    /**
+     * Create a new LDAP entry
+     */
+    LdapContextImpl addEntry(LdapContextImpl ctx, String name, LDAPAttributeSet attrs) throws NamingException{
+        Debug.println(1, "ADD");        
+        String dn = ctx.getDN();
+        
+        connect(ctx); // Lazy Connect
+
+        // Create DN by appending the name to the current context
+        if (name.length() == 0) {
+            throw new IllegalArgumentException("Name can not be empty");
+        }    
+        if (dn.length() > 0) {
+            dn = name + "," + dn;
+        }
+        else {
+            dn = name;
+        }
+        
+        try {
+            // Add a new entry
+            m_ld.add(new LDAPEntry(dn, attrs));
+            return new LdapContextImpl(dn, ctx);
+        }
+        catch (LDAPReferralException e) {
+            throw new LdapReferralException(ctx, e);
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+    /**
+     * Delete a LDAP entry
+     */
+    void delEntry(LdapContextImpl ctx, String name) throws NamingException{
+        Debug.println(1, "DELETE");
+        String dn = ctx.getDN();
+        
+        connect(ctx); // Lazy Connect
+
+        // Create DN by appending the name to the current context
+        if (name.length() == 0) {
+            throw new IllegalArgumentException("Name can not be empty");
+        }    
+        if (dn.length() > 0) {
+            dn = name + "," + dn;
+        }
+        else {
+            dn = name;
+        }
+        
+        try {
+            // Perform Delete
+            m_ld.delete(dn);
+        }
+        catch (LDAPReferralException e) {
+            throw new LdapReferralException(ctx, e);
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+    /**
+     * Chanage RDN for a LDAP entry
+     */
+    void changeRDN(LdapContextImpl ctx, String name, String newRDN) throws NamingException{
+        Debug.println(1, "RENAME");
+        String dn = ctx.getDN();
+        
+        connect(ctx); // Lazy Connect
+
+        // Create DN by appending the name to the current context
+        if (name.length() == 0 || newRDN.length() == 0) {
+            throw new IllegalArgumentException("Name can not be empty");
+        }    
+        if (dn.length() > 0) {
+            dn = name + "," + dn;
+        }
+        else {
+            dn = name;
+        }
+
+        try {
+            // Rename
+            m_ld.rename(dn, newRDN, ctx.m_ctxEnv.getDeleteOldRDNFlag());            
+        }
+        catch (LDAPReferralException e) {
+            throw new LdapReferralException(ctx, e);
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+    /**
+     * Schema Operations
+     */
+    DirContext getSchema(LdapContextImpl ctx, String name) throws NamingException {        
+        connect(ctx); // Lazy Connect        
+        return new SchemaRoot(m_ld);
+    }
+
+    /**
+     * Return the event service
+     */
+    EventService getEventService(LdapContextImpl ctx) throws NamingException {
+        connect(ctx); // Lazy Connect
+        if (m_eventSvc == null) {
+            m_eventSvc = new EventService(this);
+        }    
+        return m_eventSvc;
+    }
+    
+    /**
+     * Enable/Disable ldap message trace.
+     * @param out Trace output or null (disable trace). Output can
+     * be specified as a file name or a java OutputStream. If an
+     * empty string is specified, the output is sent to System.err.
+     * A file name prefixed with a '+' will open the file in append mode.
+     */
+    void setTraceOutput(Object out) throws NamingException {
+        try {
+            m_ld.setProperty(m_ld.TRACE_PROPERTY, out);
+        }
+        catch (Exception e) {
+            throw new IllegalArgumentException("Can not open trace output " + e);
+        }            
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/ObjectMapper.java
@@ -0,0 +1,509 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.spi.*;
+import netscape.ldap.*;
+import netscape.ldap.util.*;
+import java.io.*;
+import java.util.*;
+import com.netscape.jndi.ldap.common.Debug;
+
+/**
+ * Class used to map Java objects to ldap entries back and forth
+*/
+public class ObjectMapper {
+
+    /**
+     * Schema object classes for mapping java objects to ldap entries
+     */
+    static final String OC_JAVAOBJECT = "javaObject";  // abstract oc
+    static final String OC_SERIALOBJ  = "javaSerializedObject";//aux oc
+    static final String OC_MARSHALOBJ = "javaMarshalledObject";//aux oc   
+    static final String OC_REFERENCE  = "javaNamingReference"; //aux oc
+    //static final String OC_REMOTEOBJ  = "javaRemoteObject";    //aux oc, deprecated
+    static final String OC_CONTAINER  = "javaContainer";  //structural oc
+
+    /**
+     * Schema attributes for mapping java objects to ldap entries
+     */
+    static final String AT_CLASSNAME   = "javaClassName";         //required
+    static final String AT_CLASSNAMES  = "javaClassNames";       //optional 
+    static final String AT_DESCRIPTION = "description";          //optional  
+    static final String AT_JAVADOC     = "javaDoc";              //optional   
+    static final String AT_CODEBASE    = "javaCodeBase";         //optional
+    static final String AT_SERIALDATA  = "javaSerializedData";   //required
+    static final String AT_REFADDR     = "javaReferenceAddress"; //optional
+    static final String AT_OBJFACTORY  = "javaFactory";          //optional 
+    //static final String AT_REMOTELOC   = "javaRemoteLocation";   //required, deprecated
+    
+    //Default Object class for NameClassPair
+    static final String DEFAULT_OBJCLASS = "javax.naming.directory.DirContext";
+    
+    static Object entryToObject(LDAPEntry entry, LdapContextImpl ctx) throws NamingException {
+        Object obj = entryToObject(entry);
+        if (obj == null) {
+            obj = new LdapContextImpl(entry.getDN(), ctx);
+        }    
+
+        // SP is required to contact the DirectoryManager first to obtain an object 
+        try {
+            String relName = LdapNameParser.getRelativeName(ctx.m_ctxDN, entry.getDN());
+            Name nameObj = LdapNameParser.getParser().parse(relName);
+            Attributes attrs = new AttributesImpl(entry.getAttributeSet(),
+                                                  ctx.m_ctxEnv.getUserDefBinaryAttrs());
+            obj = DirectoryManager.getObjectInstance(obj, nameObj, ctx, ctx.getEnvironment(), attrs);
+        }
+        catch (Exception ex) {
+            if (ex instanceof NamingException) {
+                throw (NamingException)ex;
+            }
+            NamingException nameEx = new NamingException("NamingManager.getObjectInstance failed");
+            nameEx.setRootCause(ex);
+            throw nameEx;
+        }
+        
+        return obj;
+
+    }
+
+    /**
+     * Convert a Ldap entry into a java object
+     */
+    static Object entryToObject(LDAPEntry entry) throws NamingException {
+                
+        try { 
+            LDAPAttributeSet attrs = entry.getAttributeSet();
+        
+            // TODO javaCodeBase to be processed
+            
+            LDAPAttribute attr = null;
+            if ((attr = attrs.getAttribute(AT_SERIALDATA)) != null) {
+                byte[] serdata = (byte[])attr.getByteValues().nextElement();
+                return deserializeObject(serdata);
+            }
+            
+            // Reference
+            else if ((attr = attrs.getAttribute(AT_REFADDR)) != null) {
+                return decodeRefObj(attrs);
+            }
+                        
+            return null;
+        }
+        catch (Exception ex) {
+            if (ex instanceof NamingException) {
+                throw (NamingException)ex;
+            }
+            NamingException nameEx = new NamingException("NamingManager.getStateToStore failed");
+            nameEx.setRootCause(ex);
+            throw nameEx;
+        }    
+    }
+
+    /**
+     * Get the className for NameClassPair from an entry
+     */
+    static String getClassName(LDAPEntry entry) {
+        LDAPAttributeSet attrs = entry.getAttributeSet();
+        LDAPAttribute attrClass = attrs.getAttribute(AT_CLASSNAME);
+        if (attrClass != null) {
+            String className = (String)attrClass.getStringValues().nextElement();
+            return className;
+        }    
+        return DEFAULT_OBJCLASS;
+    }
+    
+
+    /**
+     * Convert a java object with an optional set of attributes into a LDAP entry
+     */
+    static LDAPAttributeSet objectToAttrSet(Object obj, String name, LdapContextImpl ctx,  Attributes attrs) throws NamingException {
+    
+        // SP is required to contact the DirectoryManager first to obtain a state object 
+        try {
+            Name nameObj = LdapNameParser.getParser().parse(name);
+            DirStateFactory.Result stb = DirectoryManager.getStateToBind(obj, nameObj, ctx, ctx.getEnvironment(), attrs);
+            obj = stb.getObject();
+            attrs = stb.getAttributes();
+        }
+        catch (Exception ex) {
+            if (ex instanceof NamingException) {
+                throw (NamingException)ex;
+            }
+            NamingException nameEx = new NamingException("NamingManager.getStateToStore failed");
+            nameEx.setRootCause(ex);
+            throw nameEx;
+        }
+
+        if (obj == null) {
+            return AttributesImpl.jndiAttrsToLdapAttrSet(attrs);
+        }    
+        else if (attrs == null) {
+            attrs = new BasicAttributes(/*ignoreCase=*/true);
+        }    
+
+        Attribute objectclass = attrs.get("objectClass");
+        if (objectclass == null) {
+            objectclass = attrs.get("objectclass"); // try lower case
+        }
+        if (objectclass == null) {
+            objectclass = new BasicAttribute("objectClass", "top");
+            objectclass.add(OC_CONTAINER);
+            attrs.put(objectclass);
+        }
+        
+        // Root object class
+        objectclass.add(OC_JAVAOBJECT);
+
+        if (obj instanceof Reference) {
+            objectclass.add(OC_REFERENCE);
+            char delimChar = ctx.m_ctxEnv.getRefSeparator();
+            attrs = encodeRefObj(delimChar, (Reference)obj, attrs);
+        }
+        
+        else if (obj instanceof Referenceable) {
+            objectclass.add(OC_REFERENCE);
+            char delimChar = ctx.m_ctxEnv.getRefSeparator();
+            attrs = encodeRefObj(delimChar, ((Referenceable)obj).getReference(), attrs);
+        }
+        
+        else if (obj instanceof Serializable) {
+            if (objectclass.contains(OC_MARSHALOBJ)) {
+                ; // do nothing
+            }
+            else if (objectclass.contains(OC_MARSHALOBJ.toLowerCase())) {
+                ; // do nothing
+            }
+            else {
+                objectclass.add(OC_SERIALOBJ);
+            }                
+            attrs = encodeSerialObj((Serializable)obj , attrs);
+        }
+        
+        else if (obj instanceof DirContext) {
+            attrs = encodeDirCtxObj((DirContext)obj , attrs);
+        }
+        
+        else {
+            throw new NamingException("Can not bind object of type " +
+                  obj.getClass().getName());
+        }    
+            
+        return AttributesImpl.jndiAttrsToLdapAttrSet(attrs);
+    }    
+
+    /**
+     * Deserialized object, create object from a stream of bytes
+     */
+    private static Object deserializeObject(byte[] byteBuf) throws NamingException {
+    
+        ByteArrayInputStream bis = null;
+        ObjectInputStream  objis = null;
+
+        try {
+            bis   = new ByteArrayInputStream(byteBuf);
+            objis = new ObjectInputStream(bis);
+            return objis.readObject();
+        }
+        catch(Exception ex) {
+            NamingException nameEx = new NamingException("Failed to deserialize object");
+            nameEx.setRootCause(ex);
+            throw nameEx;
+        }
+        finally {
+            try {
+                if (objis != null) {
+                    objis.close();
+                }
+                if (bis != null) {
+                    bis.close();
+                }
+            }
+            catch (Exception ex) {}
+        }
+    }
+
+
+    /**
+     * Serialize object, convert object to a stream of bytes
+     */
+    private static byte[] serializeObject(Object obj) throws NamingException {
+
+        ByteArrayOutputStream bos = null;
+        ObjectOutputStream  objos = null;
+
+        try {
+            bos   = new ByteArrayOutputStream();
+            objos = new ObjectOutputStream(bos);
+            objos.writeObject(obj);
+            objos.flush();
+            return bos.toByteArray();
+        }
+        catch(Exception ex) {
+            NamingException nameEx = new NamingException("Failed to serialize object");
+            nameEx.setRootCause(ex);
+            throw nameEx;
+        }
+        finally {
+            try {
+                if (objos != null) {
+                    objos.close();
+                }
+                if (bos != null) {
+                    bos.close();
+                }
+            }
+            catch (Exception ex) {}
+        }
+    }    
+
+    /**
+     * Decode Jndi Reference Object
+     */
+    private static Reference decodeRefObj(LDAPAttributeSet attrs) throws NamingException {        
+        try {
+
+            LDAPAttribute attr = null;
+            String className=null, factory = null, factoryLoc = null; 
+            if ((attr = attrs.getAttribute(AT_CLASSNAME)) == null ) {
+                throw new NamingException("Bad Reference encoding, no attribute " + AT_CLASSNAME);
+            }    
+            className = (String)attr.getStringValues().nextElement();
+            
+            if ((attr = attrs.getAttribute(AT_OBJFACTORY)) != null ) {
+                factory = (String)attr.getStringValues().nextElement();
+            }    
+            if ((attr = attrs.getAttribute(AT_CODEBASE)) != null ) {
+                factoryLoc = (String)attr.getStringValues().nextElement();
+            }    
+
+            Reference ref = new Reference(className, factory, factoryLoc);
+            
+            if ((attr = attrs.getAttribute(AT_REFADDR)) == null ) {
+                return ref; // no refAddr
+            }    
+
+            for (Enumeration e = attr.getStringValues(); e.hasMoreElements();) {
+                decodeRefAddr((String)e.nextElement(), ref);
+            }
+            
+            return ref;
+        }    
+        catch (Exception ex) {
+            if (ex instanceof NamingException) {
+                throw (NamingException)ex;
+            }
+            NamingException nameEx = new NamingException("NamingManager.getStateToStore failed");
+            nameEx.setRootCause(ex);
+            throw nameEx;
+        }    
+    }
+
+    /**
+     * Decode RefAddr according to the <draft-ryan-java-schema-01.rev.txt>
+     * StringRefAddr are encoded as #posNo#refType#refValue where posNo is the 
+     * refAddr position (index) inside a rerference. BynaryRefAddr is encoded
+     * as #posNo#refType##data where data is the base64 encoding of the serialized
+     * form of the entire BinaryRefAddr instance.
+     */    
+    private static void decodeRefAddr(String enc, Reference ref) throws NamingException{
+        
+        if (enc.length() == 0) {
+            throw new NamingException("Bad Reference encoding, empty refAddr");
+        }
+        
+        String delimChar = enc.substring(0,1);
+        
+        StringTokenizer tok = new StringTokenizer(enc, delimChar);
+        
+        int tokCount = tok.countTokens();
+        if (tokCount != 3 && tokCount != 4)  {
+            Debug.println(3, "enc=" + enc + " delimChar="+delimChar + " tokCount="+tokCount);
+            throw new NamingException("Bad Reference encoding");
+        }
+        
+        String type = null;
+        int posn = -1;
+        for (int i = 0; i < tokCount; i++)    {
+            String s = tok.nextToken();
+        
+            if (i == 0) { // position
+                try {
+                    posn = Integer.parseInt(s);
+                }
+                catch (Exception e) {
+                    throw new NamingException("Bad Reference encoding, refAddr position not an initger");
+                }
+            }
+            
+            else if (i == 1) { // type
+                if (s.length() == 0) {
+                    throw new NamingException("Bad Reference encoding, empty refAddr type");
+                }
+                type = s;
+            }
+            
+            else if (i == 2) { // value for StringRefAddr, empty for BinaryRefAddr
+                if (s.length() == 0 && tokCount != 4) { // should be empty for binary refs
+                    throw new NamingException("Bad Reference encoding, empty refAddr string value");
+                }
+                ref.add(posn, new StringRefAddr(type, s));
+            }
+            
+            else { // base64 encoding of the serialized BinaryRefAddr
+                if (s.length() == 0) {
+                    throw new NamingException("Bad Reference encoding, empty refAddr binary value");
+                }
+                MimeBase64Decoder base64Dec = new MimeBase64Decoder();
+                ByteBuf in  = new ByteBuf(s), out = new ByteBuf();
+                base64Dec.translate(in, out);
+                base64Dec.eof(out);
+                ref.add(posn, (RefAddr) deserializeObject(out.toBytes()));
+            }
+        }
+    }    
+
+
+    /**
+     * Encode Jndi Reference Object
+     */
+    private static Attributes encodeRefObj(char delimChar, Reference ref, Attributes attrs) throws NamingException {
+        
+        if (ref.getClassName() != null) {
+            attrs.put(new BasicAttribute(AT_CLASSNAME, ref.getClassName()));
+        }
+        if (ref.getFactoryClassName() != null) {
+            attrs.put(new BasicAttribute(AT_OBJFACTORY, ref.getFactoryClassName()));
+        }    
+        if (ref.getFactoryClassLocation() != null) {
+            attrs.put(new BasicAttribute(AT_CODEBASE, ref.getFactoryClassLocation()));
+        }    
+
+        if(ref.size() > 0) {
+            BasicAttribute refAttr = new BasicAttribute(AT_REFADDR);
+            for(int i = 0; i < ref.size(); i++) {
+                refAttr.add(encodeRefAddr(delimChar, i, ref.get(i)));
+            }
+            attrs.put(refAttr);
+        }
+        return attrs;
+    }
+
+    /**
+     * Encode RefAddr according to the <draft-ryan-java-schema-01.rev.txt>
+     * StringRefAddr are encoded as #posNo#refType#refValue where posNo is the 
+     * refAddr position (index) inside a rerference. BynaryRefAddr is encoded
+     * as #posNo#refType##data where data is the base64 encoding of the serialized
+     * form of the entire BinaryRefAddr instance.
+
+     */    
+    private static String encodeRefAddr(char delimChar, int idx, RefAddr refAddr) throws NamingException{
+        
+        if(refAddr instanceof StringRefAddr) {
+
+            String content = (String) refAddr.getContent();
+            if (content != null && content.length() > 0 && content.charAt(0) == delimChar) {
+                throw new NamingException(
+                "Can not encode StringRefAddr, value starts with the delimiter character " + delimChar);
+            }    
+            return delimChar + idx +
+                   delimChar + refAddr.getType() +
+                   delimChar + content;
+        }
+        
+        else { // BinaryRefAdd
+        
+            byte[] serialRefAddr = serializeObject(refAddr);
+            MimeBase64Encoder base64 = new MimeBase64Encoder();
+            ByteBuf in  = new ByteBuf(), out = new ByteBuf();
+            in.append(serialRefAddr);
+            base64.translate(in, out);
+            base64.eof(out);
+            return delimChar + idx +
+                   delimChar + refAddr.getType() +
+                   delimChar + delimChar + out.toString();
+        }
+    }
+    
+    
+    /**
+     * Encode Serializable object
+     */
+     
+     static Attributes encodeSerialObj(Serializable obj, Attributes attrs) throws NamingException{
+        if (attrs.get(AT_CLASSNAME) == null) {
+            attrs.put(new BasicAttribute(AT_CLASSNAME, obj.getClass().getName()));
+        }
+        attrs.put(new BasicAttribute(AT_SERIALDATA, serializeObject(obj)));
+        return attrs;
+     }
+     
+    /**
+     * Encode DirContext object (merege attributes)
+     */
+    static Attributes encodeDirCtxObj(DirContext obj, Attributes attrs) throws NamingException{
+        Attributes ctxAttrs = obj.getAttributes("");
+        for (NamingEnumeration itr = ctxAttrs.getAll(); itr.hasMore();) {
+            attrs.put((Attribute)itr.next());
+        }
+        return attrs;
+    }
+    
+    public static void main(String[] args) {
+            byte[] serialRefAddr = { (byte)'a', (byte)'0', (byte)'A', (byte)0x10, (byte)0x7f, (byte)0xaa };
+            MimeBase64Encoder base64 = new MimeBase64Encoder();
+            MimeBase64Decoder base64Dec = new MimeBase64Decoder();
+            ByteBuf in  = new ByteBuf(), out = new ByteBuf();
+            in.append(serialRefAddr);
+            base64.translate(in, out);
+            base64.eof(out);
+            System.err.println("in="+in);
+            System.err.println("out="+out);
+            in  = new ByteBuf(out.toString());
+            out = new ByteBuf();
+            base64Dec.translate(in, out);
+            base64Dec.eof(out);
+            System.err.println("in="+in);
+            System.err.println("out="+out);
+            
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/ContextEnv.java
@@ -0,0 +1,622 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import com.netscape.jndi.ldap.common.*;
+
+import java.util.*;
+
+/**
+ * Context Environment
+ */
+class ContextEnv extends ShareableEnv  {
+
+    public static final String DEFAULT_HOST = "localhost";
+    public static final int    DEFAULT_PORT = LDAPv2.DEFAULT_PORT;
+    public static final int    DEFAULT_SSL_PORT = 636;
+    public static final int    DEFAULT_LDAP_VERSION = 3;    
+
+    // JNDI defined environment propertiies
+    public static final String P_PROVIDER_URL = Context.PROVIDER_URL;
+    public static final String P_SECURITY_PROTOCOL = Context.SECURITY_PROTOCOL;
+    public static final String P_SECURITY_AUTHMODE = Context.SECURITY_AUTHENTICATION;
+    public static final String P_USER_DN = Context.SECURITY_PRINCIPAL;
+    public static final String P_USER_PASSWORD = Context.SECURITY_CREDENTIALS;
+    public static final String P_APPLET = Context.APPLET;
+    public static final String P_AUTHORITATIVE = Context.AUTHORITATIVE;
+    public static final String P_LANGUAGE = Context.LANGUAGE;
+    public static final String P_BATCHSIZE = Context.BATCHSIZE;
+    public static final String P_REFERRAL_MODE = Context.REFERRAL;
+
+    // Custom properties
+    public static final String P_CONNECT_CTRLS = "java.naming.ldap.control.connect";
+    public static final String P_BINARY_ATTRS = "java.naming.ldap.attributes.binary";
+    public static final String P_ATTRS_ONLY = "java.naming.ldap.typesOnly";
+    public static final String P_DELETE_OLDRDN = "java.naming.ldap.deleteRDN";    
+    public static final String P_SOCKET_FACTORY = "java.naming.ldap.factory.socket";
+    public static final String P_CIPHER_SUITE = "java.naming.ldap.ssl.ciphers"; // new
+    public static final String P_TIME_LIMIT = "java.naming.ldap.timelimit";     // new
+    public static final String P_MAX_RESULTS = "java.naming.ldap.maxresults";   // new
+    public static final String P_DEREF_ALIASES = "java.naming.ldap.derefAliases";
+    public static final String P_REFERRAL_HOPLIMIT = "java.naming.referral.limit";
+    public static final String P_LDAP_VERSION = "java.naming.ldap.version";
+    public static final String P_JNDIREF_SEPARATOR = "java.naming.ref.separator";
+    public static final String P_SASL_AUTHID = "java.naming.security.sasl.authorizationId";
+    public static final String P_SASL_CALLBACK = "java.naming.security.sasl.callback";
+    public static final String P_SASL_PKGS = "javax.security.sasl.client.pkgs";
+    
+    private static final String SASL_PROP_PREFIX = "javax.security.sasl";
+    
+    public static final String P_TRACE = LDAPConnection.TRACE_PROPERTY;
+    
+    // Possible values for the Context.REFERRAL env property
+    private static final String V_REFERRAL_FOLLOW = "follow";
+    private static final String V_REFERRAL_IGNORE = "ignore";
+    private static final String V_REFERRAL_THROW_EXCEPTION = "throw";
+
+    // Possible values for the java.naming.ldap.derefAliases env property
+    private static final String V_DEREF_NEVER = "never";
+    
+    private static final String V_DEREF_SEARCHING = "searching";
+    private static final String V_DEREF_FINDING = "finding";
+    private static final String V_DEREF_ALWAYS = "always";
+    
+    // Possible values for the java.naming... env property
+    private static final String V_AUTH_NONE = "none";
+    private static final String V_AUTH_SIMPLE = "simple";
+
+    /**
+     * Constructor for non root Contexts
+     *
+     * @param parent A reference to the parent context environment
+     * @param parentSharedEnvIdx index into parent's shared environemnt list
+     */
+    public ContextEnv(ShareableEnv parent, int parentSharedEnvIdx) {
+        super(parent, parentSharedEnvIdx);
+    }
+    
+    /**
+     * Constructor for the root context
+     * 
+     * @param initialEnv a hashtable with environemnt properties
+     */
+    public ContextEnv(Hashtable initialEnv) {
+        super(initialEnv);
+    }
+
+    /**
+     * Clone ContextEnv
+     *
+     * @return A "clone" of the current context environment
+     */
+    /**
+     * Clone ShareableEnv
+     * The code is the same as in the superclass (ShareableEnv) except that  
+     * a ContextEnv instance is returned
+     *
+     * @return A "clone" of the current context environment
+     */
+    public Object clone() {
+        
+        // First freeze updates for this context
+        freezeUpdates();
+        
+         // If the context has been modified, then it is the parent of the clone
+        if (m_sharedEnv != null) {
+            return new ContextEnv(this, m_sharedEnv.size()-1);
+        }
+        
+        // No changes has been done to the inherited parent context. Pass the parent
+        // context to the clone
+        else {
+            return new ContextEnv(m_parentEnv, m_parentSharedEnvIdx);
+        }    
+    }    
+
+    /**
+     * Update property value. Properties that pertain to LDAPSearchConstraints
+     * are immediately propagated. To take effect of properties that are connection
+     * related, (like user name/password, ssl mode) the context mujst be reconnected
+     * after the change of environment
+     */
+    Object updateProperty(String name, Object val, LDAPSearchConstraints cons) throws NamingException{
+        Object oldVal = getProperty(name);
+        setProperty(name,val);
+        try {
+            if (name.equalsIgnoreCase(P_BATCHSIZE)) {
+                updateBatchSize(cons);
+            }
+            else if (name.equalsIgnoreCase(P_TIME_LIMIT)) {
+                updateTimeLimit(cons);
+            }
+            else if (name.equalsIgnoreCase(P_MAX_RESULTS)) {
+                updateMaxResults(cons);
+            }
+            else if (name.equalsIgnoreCase(P_DEREF_ALIASES)) {
+                updateDerefAliases(cons);
+            }
+            else if (name.equalsIgnoreCase(P_REFERRAL_MODE)) {
+                updateReferralMode(cons);
+            }
+            else if (name.equalsIgnoreCase(P_REFERRAL_HOPLIMIT)) {
+                updateReferralHopLimit(cons);
+            }            
+        }
+        catch (IllegalArgumentException e) {
+            if (oldVal == null) {
+                removeProperty(name);
+            }
+            else {
+                setProperty(name, oldVal);
+            }
+            throw e;
+        }
+        return oldVal;
+    }
+    
+    /**
+     * Initialize LDAPSearchConstraints with environment properties
+     */
+    void updateSearchCons(LDAPSearchConstraints cons) throws NamingException{
+        updateBatchSize(cons);
+        updateTimeLimit(cons);
+        updateMaxResults(cons);
+        updateDerefAliases(cons);
+        updateReferralMode(cons);
+        updateReferralHopLimit(cons);
+    }
+    
+    /**
+     * Set the suggested number of result to return at a time during search in the
+     * default SearchConstraints for the connection.
+     * Specified with the env property java.naming.batchsize
+     */
+    void updateBatchSize(LDAPSearchConstraints cons) {
+        String size = (String)getProperty(P_BATCHSIZE);
+        if (size != null) {
+            int n = -1;
+            try {
+                n = Integer.parseInt(size);
+            }
+            catch (Exception e) {
+                throw new IllegalArgumentException("Illegal value for " + P_BATCHSIZE);
+            }
+            cons.setBatchSize(n);
+        }
+    }
+
+    /**
+     * Set the maximum number of milliseconds to wait for any operation under default
+     * SearchConstraints for the connection.
+     * Specified with the env property java.naming.ldap.timelimit
+     * Note: sun ldap does not have this property
+     */
+    void updateTimeLimit(LDAPSearchConstraints cons) {
+        String millis = (String)getProperty(P_TIME_LIMIT);
+        if (millis != null) {
+            int n = -1;
+            try {
+                n = Integer.parseInt(millis);
+            }
+            catch (Exception e) {
+                throw new IllegalArgumentException("Illegal value for " + P_TIME_LIMIT);
+            }
+            cons.setTimeLimit(n);
+        }
+    }
+
+    /**
+     * Set the maximum number of search results to be returned under default
+     * SearchConstraints for the connection.
+     * Specified with the env property java.naming.ldap.maxresults
+     * Note: sun ldap does not have this property
+     */
+    void updateMaxResults(LDAPSearchConstraints cons) {
+        String max = (String)getProperty(P_MAX_RESULTS);
+        if (max != null) {
+            int n = -1;
+            try {
+                n = Integer.parseInt(max);
+            }
+            catch (Exception e) {
+                throw new IllegalArgumentException(
+                "Illegal value for " + P_MAX_RESULTS);
+            }
+            cons.setMaxResults(n);
+        }
+    }
+
+    /**
+     * Set how aliases should be dereferenced under default SearchConstraints for the
+     * connection.
+     * Specified with the env property java.naming.ldap.derefAliases
+     */
+    final void updateDerefAliases(LDAPSearchConstraints cons) throws IllegalArgumentException{
+        String deref = (String)getProperty(P_DEREF_ALIASES);
+        if(deref != null) {
+            if(deref.equalsIgnoreCase(V_DEREF_NEVER)) {
+                cons.setDereference(LDAPv2.DEREF_NEVER);
+            }
+            else if(deref.equalsIgnoreCase(V_DEREF_SEARCHING)) {
+                        cons.setDereference(LDAPv2.DEREF_SEARCHING);
+                    }
+            else if(deref.equalsIgnoreCase(V_DEREF_FINDING)) {
+                cons.setDereference(LDAPv2.DEREF_FINDING);
+            }
+            else if(deref.equalsIgnoreCase(V_DEREF_ALWAYS)) {
+                cons.setDereference(LDAPv2.DEREF_ALWAYS);
+            }
+            else {
+                throw new IllegalArgumentException("Illegal value for " + P_DEREF_ALIASES);
+            }
+        }
+    }
+
+    /**
+     * Set referral parameters for the default SearchConstraints for the connection.
+     * Specified with the env property java.naming.referral
+     */
+    void updateReferralMode(LDAPSearchConstraints cons) {
+        String mode = (String)getProperty(P_REFERRAL_MODE);
+        if(mode != null) {
+            if(mode.equalsIgnoreCase(V_REFERRAL_FOLLOW)) {
+                cons.setReferrals(true);
+                String user = getUserDN(), passwd = getUserPassword();
+                if (user != null && passwd != null) {
+                    cons.setRebindProc(new ReferralRebindProc(user, passwd));
+                }    
+            }
+            else if(mode.equalsIgnoreCase(V_REFERRAL_THROW_EXCEPTION)) {
+                cons.setReferrals(false);
+            }
+            else if(mode.equalsIgnoreCase(V_REFERRAL_IGNORE)) {
+                //If MANAGEDSAIT control is not supported by the server
+                //(e.g. Active Directory) should enable exception and ignore it
+                cons.setServerControls(new LDAPControl(
+                    LDAPControl.MANAGEDSAIT, /*critical=*/false, null));
+                cons.setReferrals(false);
+            }
+            else {
+                throw new IllegalArgumentException("Illegal value for " + P_REFERRAL_MODE);
+            }    
+        }
+    }
+
+    /**
+     * Check if referrals are to be ignored
+     */
+    boolean ignoreReferralsMode() {
+        String mode = (String)getProperty(P_REFERRAL_MODE);
+        return mode == null || mode.equalsIgnoreCase(V_REFERRAL_IGNORE);
+    }
+
+    /**
+     * Implementation for LDAPRebind interface. Provide user name, password
+     * to autenticate with the referred to directory server.
+     */
+    static class ReferralRebindProc implements LDAPRebind {
+        LDAPRebindAuth auth;
+        
+        public ReferralRebindProc(String user, String passwd) {
+            auth = new LDAPRebindAuth(user, passwd);
+        }    
+        
+        public LDAPRebindAuth getRebindAuthentication(String host, int port) {
+            return auth;
+        }
+    }
+
+    /**
+     * Set maximal number of referral hops under default SearchConstraints for the
+     * connection.
+     * Specified with the env property java.naming.referral.limit
+     */
+    void updateReferralHopLimit(LDAPSearchConstraints cons) throws IllegalArgumentException{
+        String limit = (String)getProperty(P_REFERRAL_HOPLIMIT);
+        if(limit != null) {
+            int n = -1;
+            try {
+                n = Integer.parseInt(limit);
+            }
+            catch (Exception e) {
+                throw new IllegalArgumentException("Illegal value for " + P_REFERRAL_HOPLIMIT);
+            }
+            cons.setHopLimit(n);
+        }
+    }
+
+
+    /**
+     * Check if SSL mode is enabled
+     */
+    boolean isSSLEnabled() throws NamingException {
+        String secMode = (String)getProperty(P_SECURITY_PROTOCOL);
+        if(secMode != null) {
+            if(secMode.equalsIgnoreCase("ssl")) {
+                return true;
+            }
+            else {
+                throw new AuthenticationNotSupportedException(
+                "Unsupported value for " + P_SECURITY_PROTOCOL);
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Get the Directory Server URL
+     */
+    LDAPUrl getDirectoryServerURL() throws NamingException{
+        String url =  (String) getProperty(Context.PROVIDER_URL);
+        try {
+            return (url == null) ? null : new LDAPUrl(url);
+        }
+        catch (java.net.MalformedURLException e) {
+            throw new IllegalArgumentException(
+            "Illegal value for " + Context.PROVIDER_URL);
+        }
+    }
+
+    /**
+     * Get Ldap Version. If not specified the default is version 3
+     */
+    int getLdapVersion() throws NamingException{
+        String version = (String) getProperty(P_LDAP_VERSION);
+        if (version != null) {
+            int v = -1;
+            try {
+                v = Integer.parseInt(version);
+            }
+            catch (Exception e) {
+                throw new IllegalArgumentException(
+                "Illegal value for java.naming.ldap.version property.");
+            }
+            /*if ( v !=2 && v !=3) { 
+                throw new IllegalArgumentException(
+                "Illegal value for + java.naming.ldap.version property.");
+            }BLITS*/
+            return v;
+        }
+        return DEFAULT_LDAP_VERSION;
+    }        
+    
+    /**
+     * Get user authenticate name
+     */
+    String getUserDN() {
+        return (String) getProperty(Context.SECURITY_PRINCIPAL);
+    }        
+
+    /**
+     * Get user authenticate password
+     */
+    String getUserPassword() {
+        return (String) getProperty(Context.SECURITY_CREDENTIALS);
+    }    
+
+    /**
+     * Get full qualified socket factory class name
+     */
+    String getSocketFactory() {
+        return (String)getProperty(P_SOCKET_FACTORY);
+    }    
+
+    /**
+     * Get cipher suite for the socket factory
+     */
+    Object getCipherSuite() {
+        return getProperty(P_CIPHER_SUITE);
+    }    
+
+    /**
+     * Get controls to be used during a connection request like ProxyAuth
+     */
+    LDAPControl[] getConnectControls() throws NamingException{        
+        Control[] reqCtls = (Control[])getProperty(P_CONNECT_CTRLS);
+        if (reqCtls != null) {
+            LDAPControl[] ldapCtls = new LDAPControl[reqCtls.length];
+            for (int i=0; i < reqCtls.length; i++) {
+                try {
+                    ldapCtls[i] = (LDAPControl) reqCtls[i];
+                }
+                catch (ClassCastException ex) {
+                    throw new NamingException(
+                    "Unsupported control type " + reqCtls[i].getClass().getName());
+                }
+            }
+            return ldapCtls;
+        }
+        return null;
+    }
+
+    /**
+     * Flag whether search operation should return attribute names only
+     * (no values). Read environment property P_ATTRS_ONLY. If not defined
+     * FALSE is returned (return attribute values by default)
+     */
+    boolean getAttrsOnlyFlag() {
+        String flag = (String)getProperty(P_ATTRS_ONLY);
+        if (flag == null) {
+            return false; //default
+        }
+        else if (flag.equalsIgnoreCase("true")) {
+            return true;
+        }    
+        else if (flag.equalsIgnoreCase("false")) {
+            return false;
+        }    
+        else {
+            throw new IllegalArgumentException("Illegal value for " + P_ATTRS_ONLY);
+        }
+    }    
+
+    /**
+     * Flag whether rename operation should delete old RDN
+     * Read environment property P_ATTRS_ONLY. If not defined
+     * TRUE is returned (delete old RDN by default)     
+     */
+    boolean getDeleteOldRDNFlag() {
+        String flag = (String)getProperty(P_DELETE_OLDRDN);
+        if (flag == null) {
+            return true; //default
+        }
+        else if (flag.equalsIgnoreCase("true")) {
+            return true;
+        }    
+        else if (flag.equalsIgnoreCase("false")) {
+            return false;
+        }    
+        else {
+            throw new IllegalArgumentException("Illegal value for " + P_DELETE_OLDRDN);
+        }
+    }
+
+    /**
+     * A user defined value for the separator for JNDI References.
+     * The default value is '#'.
+     * Read environment property P_JNDIREF_SEPARATOR.
+     */
+    char getRefSeparator() throws NamingException{
+        String sep = (String)getProperty(P_JNDIREF_SEPARATOR );
+        if(sep != null) {
+            if (sep.length() !=1) {
+                throw new IllegalArgumentException("Illegal value for " + P_JNDIREF_SEPARATOR);
+            }            
+            return sep.charAt(0);
+        }
+        return '#';
+    }
+
+    /**
+     * A user defined list of names of binary attributes. This list augments the
+     * default list of well-known binary attributes. List entries are space separated
+     * Read environment property P_BINARY_ATTRS.
+     */
+    String[] getUserDefBinaryAttrs() {
+        String binAttrList = (String)getProperty(P_BINARY_ATTRS);
+        if (binAttrList == null) {
+            return null;
+        }
+        
+        StringTokenizer tok = new StringTokenizer(binAttrList);        
+        String[] binAttrs = new String[tok.countTokens()];
+        for (int i=0; tok.hasMoreTokens(); i++) {
+            binAttrs[i] = tok.nextToken();
+        }
+        return binAttrs;
+    }
+
+    /**
+     * Check if sasl auth mode is requested. If the value of auth property is
+     * neither of (null, none, or simple) then assume it is a space separated
+     * list of sasl mechanis names
+     */
+    String[] getSaslMechanisms() {
+        String authMode = (String)getProperty(P_SECURITY_AUTHMODE);
+        if(authMode != null) {
+            if(authMode.equalsIgnoreCase(V_AUTH_NONE)) {
+                return null;
+            }
+            else if (authMode.equalsIgnoreCase(V_AUTH_SIMPLE)) {
+                 return null;
+            }     
+            else {
+                // The value must be a space separated list of sasl
+                // mechanism names
+                StringTokenizer tok = new StringTokenizer(authMode);
+                int cnt = tok.countTokens();
+                String[] mechanisms = new String[cnt];
+                for (int i=0; tok.hasMoreTokens(); i++) {
+                    mechanisms[i] = tok.nextToken();
+                }                                        
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Returned all sasl properties (startwith javax.security.sasl) except
+     * AUTHID and CALLBACK, as a Hashtable. AUTHID and CALLBACK as used 
+     * directly as parameters to authenticate()
+     * 
+     */
+    Hashtable getSaslProps() {
+        Hashtable props = getAllProperties();
+        Hashtable saslProps = new Hashtable();
+        String prefixUpperCase = SASL_PROP_PREFIX.toUpperCase();
+        
+        for (Enumeration e = props.keys(); e.hasMoreElements();) {
+            String key = (String) e.nextElement();
+            if (key.startsWith(SASL_PROP_PREFIX) ||
+                key.startsWith(prefixUpperCase)) {
+                if (!key.equalsIgnoreCase(P_SASL_AUTHID) && 
+                    !key.equalsIgnoreCase(P_SASL_CALLBACK)) {
+                    saslProps.put(key, props.get(key));
+                }                    
+            }
+        }
+        return (saslProps.size() > 0) ? saslProps : null;
+
+    }
+
+    /**
+     * Return DN to be used for sasl auth. Check first the P_SASL_AUTHID
+     * property, then fallback to P_USERDN if not defined.    
+     */
+    String getSaslAuthId() {
+        String id = (String)getProperty(P_SASL_AUTHID);
+        if (id != null) {
+            return id;
+        }       
+        return (String)getProperty(P_USER_DN);
+    }        
+
+    /**
+     * Return the callback object for sasl, if specified
+     */
+    Object getSaslCallback() {
+        return getProperty(P_SASL_CALLBACK);
+    }
+}   
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/LdapNameParser.java
@@ -0,0 +1,184 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import java.util.Hashtable;
+import java.util.Properties;
+import javax.naming.*;
+
+class LdapNameParser implements NameParser {
+
+    private static LdapNameParser m_parser;
+    
+    // A table with compound name syntax properties
+    static Properties nameSyntax;
+    static {
+        nameSyntax = new Properties();
+        nameSyntax.put("jndi.syntax.direction", "right_to_left");
+        nameSyntax.put("jndi.syntax.separator", ",");
+        nameSyntax.put("jndi.syntax.ignorecase", "true");
+        nameSyntax.put("jndi.syntax.escape", "\\");
+        nameSyntax.put("jndi.syntax.beginquote", "\"");
+        nameSyntax.put("jndi.syntax.trimblanks", "true");        
+        nameSyntax.put("jndi.syntax.separator.ava", "+");
+        nameSyntax.put("jndi.syntax.separator.typeval", "=");
+    }
+
+    // Can not be constructed
+    private LdapNameParser() {}
+    
+    // Shared instance must be used
+    public static LdapNameParser getParser() {
+        if (m_parser == null) {
+            m_parser = new LdapNameParser();
+        }
+        return m_parser;
+    }
+    
+    // implements parse
+    public Name parse(String name) throws NamingException {
+        return new CompoundName(name, nameSyntax);
+    }
+    
+    /**
+     * A convenience method for extracting RDN
+     * @return RDN for the DN
+     * @param dn Ldap Distinguished name
+     * @throw NamingException Name parsing failed
+     */
+    static String getRDN(String dn) throws NamingException {
+        Name parsedName = getParser().parse(dn);
+        if (parsedName.size() > 0) {
+            return parsedName.get(parsedName.size()-1);
+        }
+        return "";
+    }
+
+    /**
+     * A convenience method for extracting attribute name from name=val
+     * @return attribute name or null if "=" not found
+     * @param nameEqVal name=value
+     */
+    static String getAttrName(String nameEqVal) throws NamingException {
+        int eq = nameEqVal.indexOf("=");
+        return (eq >= 0) ? nameEqVal.substring(0,eq).trim() : null;
+    }
+
+    /**
+     * A convenience method for extracting attribute value from name=val
+     * @return attribute value or null if "=" not found
+     * @param nameEqVal name=value
+     */
+    static String getAttrValue(String nameEqVal) throws NamingException {
+        int eq = nameEqVal.indexOf("=");
+        return (eq >= 0) ? nameEqVal.substring(eq+1).trim() : null;
+    }
+
+    /**
+     * A convenience method for extracting relative name from the ancestor context
+     * @return name relative to an ancestor context
+     * @param ctx ancestor context distinguished name
+     * @param entry distinguished name
+     */
+    static String getRelativeName(String ctx, String entry) throws NamingException{
+        if (entry==null) {
+            entry = "";
+        }
+        Name contextName = getParser().parse(ctx);
+        Name entryName = getParser().parse(entry);
+        if (!entryName.startsWith(contextName)) {
+            throw new NamingException("Name not in context");
+        }
+        return entryName.getSuffix(contextName.size()).toString();
+    }    
+
+    /**
+     * A convenience method for extracting relative name from the ancestor context
+     * @return name relative to an ancestor context
+     * @param ctx ancestor context distinguished name
+     * @param entry distinguished name
+     */
+    static String getRelativeName(Name contextName, String entry) throws NamingException{
+        if (entry==null) {
+            entry = "";
+        }    
+        Name entryName = getParser().parse(entry);
+        if (!entryName.startsWith(contextName)) {
+            throw new NamingException("Name not in context");
+        }
+        return entryName.getSuffix(contextName.size()).toString();
+    }
+
+    /**
+     * Unit test
+     */
+    public static void main0(String[] args) {
+        if (args.length != 1) {
+            System.out.println("Usage LdapNameParser <name>");
+            System.exit(1);
+        }
+        try {
+            Name name = getParser().parse(args[0]);
+            System.out.println(name);
+            System.out.println("rdn: " + getParser().getRDN(args[0]));
+            name.add("attr=val");
+            System.out.println(name);
+            System.out.println(name.get(0));
+            System.out.println("in name=val name:<" + getAttrName("name=val ") + 
+                                "> val:<" + getAttrValue("name=val ") + ">");
+        }
+        catch (Exception e) {
+            System.err.println(e);
+        }    
+    }    
+
+    // Relative name test
+    public static void main(String[] args) {
+        if (args.length != 2) {
+            System.out.println("Usage LdapNameParser <ctxname> <entryname>");
+            System.exit(1);
+        }
+        try {
+            System.out.println("relativeName: " + getParser().getRelativeName(args[0], args[1]));
+        }
+        catch (Exception e) {
+            System.err.println(e);
+        }    
+    }    
+
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/NameClassPairEnum.java
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+import com.netscape.jndi.ldap.common.ExceptionMapper;
+
+import netscape.ldap.*;
+
+import java.util.*;
+
+/**
+ * Wrapper for the LDAPSearchResult. Convert each LDAPEntry entry into
+ * a JNDI NameClassPair. NameClassPairs are accessed through the NamingEnumeration
+ * interface
+ */
+class NameClassPairEnum extends BaseSearchEnum {
+
+    public NameClassPairEnum(LDAPSearchResults res, LdapContextImpl ctx) throws NamingException{
+        super(res, ctx);
+    }
+
+    public Object next() throws NamingException{
+        LDAPEntry entry = nextLDAPEntry();
+        String name = LdapNameParser.getRelativeName(m_ctxName, entry.getDN());
+        String className = ObjectMapper.getClassName(entry);
+        return new NameClassPair(name, className, /*isRelative=*/true);
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/LdapReferralException.java
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+
+import java.util.*;
+
+/**
+ * A wrapper for the ldapjdk LDAPReferralException
+ *
+ */
+class LdapReferralException extends javax.naming.ldap.LdapReferralException {
+    
+    LDAPReferralException m_ldapEx;
+    LdapContextImpl m_srcCtx;
+    int m_referralIdx = 0;
+    
+    public LdapReferralException(LdapContextImpl srcCtx, LDAPReferralException ldapEx) {
+        m_srcCtx = srcCtx;
+        m_ldapEx = ldapEx;
+    }
+    
+    public Object getReferralInfo() {
+        return m_ldapEx.getURLs()[m_referralIdx].toString();
+    }
+    
+    public Context getReferralContext() throws NamingException{
+        Hashtable env = m_srcCtx.getEnv().getAllProperties();
+        env.put(ContextEnv.P_PROVIDER_URL, m_ldapEx.getURLs()[m_referralIdx].toString());
+        return new LdapContextImpl(env);
+    }
+
+    public Context getReferralContext(Hashtable env) throws NamingException{
+        return getReferralContext(env, null);
+    }
+    
+    public Context getReferralContext(Hashtable env, Control[] reqCtls) throws NamingException{
+        
+        env.put(ContextEnv.P_PROVIDER_URL, m_ldapEx.getURLs()[m_referralIdx].toString());
+        if (reqCtls != null) {
+             env.put(ContextEnv.P_CONNECT_CTRLS, reqCtls);
+        }             
+        return new LdapContextImpl(env);
+    }
+    
+
+    /**
+     * Skip the referral to be processed
+     */
+    public boolean skipReferral() {
+        int maxIdx = m_ldapEx.getURLs().length - 1;
+        if (m_referralIdx < maxIdx) {
+            m_referralIdx++;
+            return true;
+        }
+        return false;
+    }    
+
+    public void retryReferral() {
+    }        
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/AttributesImpl.java
@@ -0,0 +1,358 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Luke (lukemz@onemodel.org)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+
+import netscape.ldap.*;
+
+import java.util.*;
+
+/**
+ * Wrapper for LDAPAttributeSet which implements JNDI Attribute interface
+ */
+class AttributesImpl implements Attributes {
+
+    // TODO Create JndiAttribute class so that getAttributeDefinition and
+    // getAttributeSyntaxDefinition can be implemented
+   
+    LDAPAttributeSet m_attrSet;
+
+    /**
+     * A list of predefined binary attribute name
+     */
+    static String[] m_binaryAttrs = {
+      "photo", "userpassword", "jpegphoto", "audio", "thumbnailphoto", "thumbnaillogo",
+      "usercertificate",  "cacertificate", "certificaterevocationlist",
+      "authorityrevocationlist", "crosscertificatepair", "personalsignature",
+      "x500uniqueidentifier", "javaserializeddata"};
+    
+    /**
+     * A list of user defined binary attributes specified with the environment
+     * property java.naming.ldap.attributes.binary
+     */
+    static String[] m_userBinaryAttrs = null;
+    
+    public AttributesImpl(LDAPAttributeSet attrSet, String[] userBinaryAttrs) {
+        m_attrSet = attrSet;
+        m_userBinaryAttrs = userBinaryAttrs;
+    }    
+    
+    public Object clone() {
+        return new AttributesImpl((LDAPAttributeSet)m_attrSet.clone(), m_userBinaryAttrs);
+    }    
+
+    public Attribute get(String attrID) {
+        LDAPAttribute attr = m_attrSet.getAttribute(attrID);
+        return (attr == null) ? null : ldapAttrToJndiAttr(attr);
+    }
+
+    public NamingEnumeration getAll() {
+        return new AttributeEnum(m_attrSet.getAttributes());
+    }
+
+    public NamingEnumeration getIDs() {
+        return new AttributeIDEnum(m_attrSet.getAttributes());
+    }
+
+    public boolean isCaseIgnored() {
+        return false;
+    }
+
+    public Attribute put(String attrID, Object val) {
+        LDAPAttribute attr = m_attrSet.getAttribute(attrID);
+        if (val == null) { // no Value
+            m_attrSet.add(new LDAPAttribute(attrID));
+        }    
+        else if (val instanceof byte[]) {
+            m_attrSet.add(new LDAPAttribute(attrID, (byte[])val));
+        }
+        else {
+            m_attrSet.add(new LDAPAttribute(attrID, val.toString()));
+        }
+        return (attr == null) ? null : ldapAttrToJndiAttr(attr);
+    }
+
+    public Attribute put(Attribute jndiAttr) {
+        try {
+            LDAPAttribute oldAttr = m_attrSet.getAttribute(jndiAttr.getID());
+            m_attrSet.add(jndiAttrToLdapAttr(jndiAttr));
+            return (oldAttr == null) ? null : ldapAttrToJndiAttr(oldAttr);
+        }
+        catch (NamingException e) {
+            System.err.println( "Error in AttributesImpl.put(): " + e.toString() );
+            e.printStackTrace(System.err);
+        }
+        return null;
+    }
+
+    public Attribute remove(String attrID) {
+        Attribute attr = get(attrID);
+        m_attrSet.remove(attrID);
+        return attr;
+    }    
+    
+    public int size() {
+        return m_attrSet.size();
+    }
+
+    
+    /**
+     * Check if an attribute is a binary one
+     */
+    static boolean isBinaryAttribute(String attrID) {
+        
+         // attr name contains ";binary"
+        if (attrID.indexOf(";binary") >=0) {
+            return true;
+        }
+        
+        attrID = attrID.toLowerCase();
+                
+        // check the predefined binary attr table
+        for (int i=0; i < m_binaryAttrs.length; i++) {
+            if (m_binaryAttrs[i].equals(attrID)) {
+                return true;
+            }
+        }
+        
+        // check user specified binary attrs with
+        for (int i=0; m_userBinaryAttrs != null && i < m_userBinaryAttrs.length; i++) {
+            if (m_userBinaryAttrs[i].equals(attrID)) {
+                return true;
+            }
+        }
+        
+        return false;
+    }
+    
+    /**
+     * Convert a JNDI Attributes object into a LDAPAttributeSet
+     */
+    static LDAPAttributeSet jndiAttrsToLdapAttrSet(Attributes jndiAttrs) throws NamingException{
+        LDAPAttributeSet attrs = new LDAPAttributeSet();
+        for (Enumeration itr = jndiAttrs.getAll(); itr.hasMoreElements();) {
+            attrs.add(jndiAttrToLdapAttr((Attribute) itr.nextElement()));
+        }
+        return attrs;
+    }    
+        
+    /**
+     * Convert a JNDI Attribute to a LDAPAttribute
+     */
+    static LDAPAttribute jndiAttrToLdapAttr(Attribute jndiAttr) throws NamingException{
+        LDAPAttribute attr = new LDAPAttribute(jndiAttr.getID());
+        
+        for (NamingEnumeration vals = jndiAttr.getAll(); vals.hasMoreElements();) {
+            Object val = vals.nextElement();
+            if (val == null) {
+                ;  // no value
+            }    
+            else if (val instanceof byte[]) {
+                attr.addValue((byte[])val);
+            }
+            else {
+                attr.addValue(val.toString());
+            }    
+        }
+        return attr;
+    }
+    
+    /**
+     * Convert a LDAPAttribute to a JNDI Attribute
+     */
+    static Attribute ldapAttrToJndiAttr(LDAPAttribute attr) {
+        BasicAttribute jndiAttr = new BasicAttribute(attr.getName());
+        Enumeration itrVals = null;
+        if (isBinaryAttribute(attr.getName())) {
+            itrVals = attr.getByteValues();
+        }
+        else {
+            itrVals = attr.getStringValues();
+        }
+	/* Performance enhancement for an attribute with many values.
+	 * If number of value over threshold, use TreeSet to quickly
+	 * eliminate value duplication. Locally extends JNDI attribute
+	 * to pass TreeSet directly to Vector of JNDI attribute.
+	 */    
+	if (attr.size() < 50 ) {
+          if (itrVals != null) {
+              while ( itrVals.hasMoreElements() ) {
+                  jndiAttr.add(itrVals.nextElement());
+              }
+          }    
+	} 
+	else {
+	  /* A local class to allow constructing a JNDI attribute
+	   * from a TreeSet.
+	   */
+	  class BigAttribute extends BasicAttribute {
+		public BigAttribute (String id, TreeSet val) {
+			super(id);
+			values = new Vector (val);
+		}
+	  }
+	  TreeSet valSet = new TreeSet();
+          if (itrVals != null) {
+              while ( itrVals.hasMoreElements() ) {
+                  valSet.add(itrVals.nextElement());
+              }
+          }    
+          jndiAttr = new BigAttribute(attr.getName(), valSet);
+	}
+        return jndiAttr;
+    }
+
+    /**
+     * Convert and array of JNDI ModificationItem to a LDAPModificationSet
+     */
+    static LDAPModificationSet jndiModsToLdapModSet(ModificationItem[] jndiMods) throws NamingException{
+        LDAPModificationSet mods = new LDAPModificationSet();
+        for (int i=0; i < jndiMods.length; i++) {
+            int modop = jndiMods[i].getModificationOp();
+            LDAPAttribute attr = jndiAttrToLdapAttr(jndiMods[i].getAttribute());
+            if (modop == DirContext.ADD_ATTRIBUTE) {
+                mods.add(LDAPModification.ADD, attr);
+            }
+            else if (modop == DirContext.REPLACE_ATTRIBUTE) {
+                mods.add(LDAPModification.REPLACE, attr);
+            }    
+            else if (modop == DirContext.REMOVE_ATTRIBUTE) {
+                mods.add(LDAPModification.DELETE, attr);
+            }
+            else {
+                // Should never come here. ModificationItem can not
+                // be constructed with a wrong value
+            }
+        }
+        return mods;
+    }    
+
+    /**
+     * Create a LDAPModificationSet from a JNDI mod operation and JNDI Attributes
+     */
+    static LDAPModificationSet jndiAttrsToLdapModSet(int modop, Attributes jndiAttrs) throws NamingException{
+        LDAPModificationSet mods = new LDAPModificationSet();
+        for (NamingEnumeration attrEnum = jndiAttrs.getAll(); attrEnum.hasMore();) {
+            LDAPAttribute attr = jndiAttrToLdapAttr((Attribute)attrEnum.next());
+            if (modop == DirContext.ADD_ATTRIBUTE) {
+                mods.add(LDAPModification.ADD, attr);
+            }
+            else if (modop == DirContext.REPLACE_ATTRIBUTE) {
+                mods.add(LDAPModification.REPLACE, attr);
+            }    
+            else if (modop == DirContext.REMOVE_ATTRIBUTE) {
+                mods.add(LDAPModification.DELETE, attr);
+            }
+            else {
+                throw new IllegalArgumentException("Illegal Attribute Modification Operation");
+            }
+        }
+        return mods;
+    }
+}
+
+/**
+ * Wrapper for enumeration of LDAPAttrubute-s. Convert each LDAPAttribute
+ * into a JNDI Attribute accessed through the NamingEnumeration
+ */
+class AttributeEnum implements NamingEnumeration {
+    
+    Enumeration _attrEnum;
+    
+    public AttributeEnum(Enumeration attrEnum) {
+        _attrEnum = attrEnum;
+    }    
+
+    public Object next() throws NamingException{
+        LDAPAttribute attr = (LDAPAttribute) _attrEnum.nextElement();
+        return AttributesImpl.ldapAttrToJndiAttr(attr);
+    }
+
+    public Object nextElement() {
+        LDAPAttribute attr = (LDAPAttribute) _attrEnum.nextElement();
+        return AttributesImpl.ldapAttrToJndiAttr(attr);
+    }
+
+    public boolean hasMore() throws NamingException{
+        return _attrEnum.hasMoreElements();
+    }
+
+    public boolean hasMoreElements() {
+        return _attrEnum.hasMoreElements();
+    }
+
+    public void close() {
+    }
+}
+
+/**
+ * Wrapper for enumeration of LDAPAttrubute-s. Return the name for each
+ * LDAPAttribute accessed through the NamingEnumeration
+ */
+class AttributeIDEnum implements NamingEnumeration {
+
+    Enumeration _attrEnum;
+    
+    public AttributeIDEnum(Enumeration attrEnum) {
+        _attrEnum = attrEnum;
+    }    
+
+    public Object next() throws NamingException{
+        LDAPAttribute attr = (LDAPAttribute) _attrEnum.nextElement();
+        return attr.getName();
+    }
+
+    public Object nextElement() {
+        LDAPAttribute attr = (LDAPAttribute) _attrEnum.nextElement();
+        return attr.getName();
+    }
+
+    public boolean hasMore() throws NamingException{
+        return _attrEnum.hasMoreElements();
+    }
+
+    public boolean hasMoreElements() {
+        return _attrEnum.hasMoreElements();
+    }
+
+    public void close() {
+    }
+}    
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/SearchResultEnum.java
@@ -0,0 +1,91 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+import com.netscape.jndi.ldap.controls.NetscapeControlFactory;
+import com.netscape.jndi.ldap.common.ExceptionMapper;
+import netscape.ldap.*;
+import java.util.*;
+
+/**
+ * A wrapper for the LDAPSeatchResults. Convert a LDAPSearchResults enumeration
+ * of LDAPEntries into a JNDI NamingEnumeration of JNDI SearchResults.
+ */
+class SearchResultEnum extends BaseSearchEnum {
+
+    boolean m_returnObjs; // ReturningObjFlag in SearchControls
+    String[] m_userBinaryAttrs;
+    
+    public SearchResultEnum(LDAPSearchResults res, boolean returnObjs, LdapContextImpl ctx) throws NamingException{
+        super(res, ctx);
+        m_returnObjs = returnObjs;
+        m_userBinaryAttrs = ctx.m_ctxEnv.getUserDefBinaryAttrs();        
+    }
+
+    public Object next() throws NamingException{
+        LDAPEntry entry = nextLDAPEntry();
+        String name = LdapNameParser.getRelativeName(m_ctxName, entry.getDN());
+        Object obj = (m_returnObjs) ? ObjectMapper.entryToObject(entry, m_ctx) : null;
+        Attributes attrs = new AttributesImpl(entry.getAttributeSet(), m_userBinaryAttrs);
+            
+        // check for response controls
+        LDAPControl[] ldapCtls = m_res.getResponseControls();
+        if (ldapCtls != null) {
+            // Parse raw controls
+            Control[] ctls = new Control[ldapCtls.length];
+            for (int i=0; i < ldapCtls.length; i++) {
+                ctls[i] = NetscapeControlFactory.getControlInstance(ldapCtls[i]);
+                if (ctls[i] == null) {
+                    throw new NamingException("Unsupported control " + ldapCtls[i].getID());
+                }
+            }
+
+            SearchResultWithControls searchRes = 
+                new SearchResultWithControls(name, obj, attrs);
+            searchRes.setControls(ctls);
+
+            return searchRes;
+        }
+        else { // no controls
+            return new SearchResult(name, obj, attrs);
+        }    
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/LdapContextFactory.java
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.event.*;
+import javax.naming.spi.*;
+import java.util.*;
+
+public class LdapContextFactory implements InitialContextFactory {
+
+    public Context getInitialContext(Hashtable env) throws NamingException {
+        Hashtable ctxEnv = (Hashtable)env.clone();
+
+        // Read system properties as well. Add a system property to the
+        // env if it's name start with "java.naming." and it is not already
+        // present in the env (env has precedence over the System properties)        
+        for (Enumeration e = System.getProperties().keys(); e.hasMoreElements();) {
+            String key = (String) e.nextElement();
+            if (key.startsWith("java.naming.")||
+                key.startsWith("com.netscape.")) {
+                if (ctxEnv.get(key) == null) {
+                    ctxEnv.put(key,System.getProperty(key));
+                }
+            }
+        }
+
+        EventDirContext ctx = new LdapContextImpl(ctxEnv);
+        return ctx;
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/SearchResultWithControls.java
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap;
+
+import javax.naming.ldap.*;
+import javax.naming.directory.*;
+
+/**
+ * An extension of SearchResult that allows access to controls sent
+ * back with the results of a search
+ */
+class SearchResultWithControls extends SearchResult implements HasControls {
+
+    Control[] m_ctrls;
+
+    /**
+     * Enable constructors
+     */
+    public SearchResultWithControls(String name, Object obj, Attributes attrs) {
+        super(name, obj, attrs);
+    }
+
+    public SearchResultWithControls(String name, Object obj, Attributes attrs, boolean isRelative) {
+        super(name, obj, attrs, isRelative);
+    }
+
+    public SearchResultWithControls(String name, String className, Object obj, Attributes attrs) {
+        super(name, className, obj, attrs);
+    }
+
+    public SearchResultWithControls(String name, String className, Object obj, Attributes attrs, boolean isRelative) {
+        super(name, className, obj, attrs, isRelative);
+    }
+
+    /**
+     * Implements HasControls interface
+     */
+    public Control[] getControls() {
+        return m_ctrls;
+    }
+
+    /**
+     * Set controls array
+     */
+    public void setControls(Control[] ctrls) {
+        m_ctrls = ctrls;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/common/LdapContextAdapter.java
@@ -0,0 +1,110 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.common;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+import javax.naming.event.*;
+import java.util.Hashtable;
+
+public class LdapContextAdapter extends DirContextAdapter implements EventDirContext, LdapContext {
+
+/* LdapContext methods */
+    public ExtendedResponse extendedOperation(ExtendedRequest req)throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Control[] getRequestControls() throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Control[] getResponseControls() throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Control[] getConnectControls() throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public LdapContext newInstance(Control[] reqCtls) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void reconnect(Control[] reqCtls) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void setRequestControls(Control[] reqCtls) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+    /**
+     * Naming Event methods
+     */
+    public void addNamingListener(String target, int scope, NamingListener l) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void addNamingListener(Name target, int scope, NamingListener l) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void addNamingListener(String target, String filter, SearchControls ctls, NamingListener l)throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void addNamingListener(Name target, String filter, SearchControls ctls, NamingListener l)throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void addNamingListener(String target, String filter, Object[] filtrArgs, SearchControls ctls, NamingListener l)throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void addNamingListener(Name target, String filter, Object[] filtrArgs, SearchControls ctls, NamingListener l)throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void removeNamingListener(NamingListener l) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public boolean targetMustExist() {
+        return true;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/common/ShareableEnv.java
@@ -0,0 +1,424 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.common;
+
+import java.util.*;
+
+/**
+ * ShareableEnv manages a set of environment properties. The class enables a memory
+ * efficient sharing of the environment between multiple contexts, while preserving
+ * the semantics that each context has its own environment. If the environment for a
+ * context is changed, the change is not visible to other contexts. 
+ *
+ * The efficiency is achieved by implementing inheritance and override of environment
+ * properties ("subclass-on-write"). A read-only table of properties
+ * is shared among multiple contexts (<code>_sharedEnv</code>. If a context wants to
+ * modified a shared property, it will create a separate table (<code>_privateEnv</code>)
+ * to make the modifications. This table overrides the values in the shared table.
+ * 
+ * Note1: The class is not thread safe, it requires external synchronization
+ * Note2: The class does not provide enumaration. Call getAllProperties() and then
+ * use the standard Hashtable enumaration techniques.
+ */
+public class ShareableEnv implements Cloneable{
+
+    /**
+     * A special value that denotes a removed propety. Because shared property tables 
+     * are read-only, a shared property is deleted in the curent context by assigning 
+     * the REMOVED_PROPERTY value in the _modEnv table.
+     */
+    private static final Object REMOVED_PROPERTY = new Object();
+
+    /**
+     * A table of most recent environment modifications. These modifications are not
+     * shared until the current context is cloned, which moves _privateEnv to
+     * _sharedEnv
+     */
+    protected Hashtable m_privateEnv;
+    
+    /**
+     * A set of environment propeties that have been changed in this Context and are
+     * shared with one or more child contexts. Read-only access.
+     */
+    protected Vector m_sharedEnv; // A vector of Hashtables
+     
+    /**
+     * Shared environment inherited from the parent context
+     */
+    protected ShareableEnv m_parentEnv;
+    
+    /**
+     * Index into parent _sharedEnv list. Designates all environment chnages
+     * in the parent context that are visible to this child context
+     */
+    protected int m_parentSharedEnvIdx = -1;
+
+    /**
+     * No-arg constructor is private
+     */
+    private ShareableEnv() {}
+    
+    /**
+     * Constructor for non root Contexts
+     *
+     * @param parent A reference to the parent context environment
+     * @param parentSharedEnvIdx index into parent's shared environemnt list
+     */
+    public ShareableEnv(ShareableEnv parent, int parentSharedEnvIdx) {
+        m_parentEnv = parent;
+        m_parentSharedEnvIdx = parentSharedEnvIdx;
+    }
+    
+    /**
+     * Constructor for the root context
+     * 
+     * @param initialEnv a hashtable with environemnt properties
+     */
+    public ShareableEnv(Hashtable initialEnv) {
+        m_privateEnv = initialEnv;
+    }
+
+    /**
+     * Set the property value.
+     *
+     * @return the previous value of the specified property,
+     *         or <code>null</code> if it did not exist before.     
+     * @param prop property name
+     * @param val property value
+     */
+    public Object setProperty(String prop, Object val) {
+        
+        // Need the current value to be returned 
+        Object oldVal = getProperty(prop);
+        
+        // Lazy create _privateEnv table
+        if (m_privateEnv == null) {
+            m_privateEnv = new Hashtable(5);
+        }
+
+        // Add/Modify property
+        m_privateEnv.put(prop, val);
+        
+        return oldVal;
+    }
+
+    /**
+     * Get the property value.
+     *
+     * @return the object associated with the property name
+     *         or  <code>null</code> if property is not found
+     * @param  prop property name
+     */
+    public Object getProperty(String prop) {
+        
+        // First check most recent modifications
+        if (m_privateEnv != null) {
+            Object val = m_privateEnv.get(prop);
+            if (val != null) {
+                return (val == REMOVED_PROPERTY) ? null : val;
+            }
+        }
+        
+        // Then try shared properties
+        if (m_sharedEnv != null) {
+            return getSharedProperty(m_sharedEnv.size()-1, prop);
+        }
+        else {
+            return getSharedProperty(-1, prop);
+        }
+    }
+
+    /**
+     * Get the property value for the specified _sharedEnv index
+     *
+     * @return the object associated with the property name     
+     * @param envIdx start index in the shared environment list
+     * @param prop property name
+     */
+    private Object getSharedProperty(int envIdx, String prop) {
+        
+        // Check first the frozen updtates list
+        if (envIdx >= 0) {
+            for (int i= envIdx; i >= 0; i--) {
+                Hashtable tab = (Hashtable) m_sharedEnv.elementAt(i);
+                Object val = tab.get(prop);
+                if (val != null) {
+                    return (val == REMOVED_PROPERTY) ? null : val;
+                }
+            }
+        }
+        
+        // Check the parent env context
+        if (m_parentSharedEnvIdx >= 0) {
+            return m_parentEnv.getSharedProperty(m_parentSharedEnvIdx, prop);
+        }
+        
+        return null;
+    }
+
+    /**
+     * Remove property
+     *
+     * @return the previous value of the specified property,
+     *         or <code>null</code> if it did not exist before.     
+     * @param prop property name
+     */
+    public Object removeProperty(String prop) {
+        
+        Object val = null;
+        // Is this a shared property ?
+        if (m_sharedEnv != null) {
+            val = getSharedProperty(m_sharedEnv.size()-1, prop);
+        }
+        else {
+            val = getSharedProperty(-1, prop);
+        }
+        
+        if (val == null) { // Not a shared property, remove if physically
+            if (m_privateEnv != null) {
+                return m_privateEnv.remove(prop);
+            }
+        }
+        else {  //A shared property, hide it
+            setProperty(prop, REMOVED_PROPERTY);
+        }
+        return val;
+    }    
+
+    /**
+     * Create a table of all properties. First read all properties from the parent env,
+     * then merge the local updates. Notice that the data is processed in reverse order
+     * than in the getProperty method.
+     *
+     * @return a hashtable containing all properties visible in this context     
+     */
+    public Hashtable getAllProperties() {
+        Hashtable res = null;
+        
+        // First copy shared properties
+        if (m_sharedEnv != null) {
+            res = getAllSharedProperties(m_sharedEnv.size()-1);
+        }
+        else {
+            res = getAllSharedProperties(-1);
+        }
+
+        if (res == null) {
+            res = new Hashtable(51);
+        }    
+        
+        // Then apply private env
+        if (m_privateEnv != null) {
+            Hashtable tab = m_privateEnv;
+            for (Enumeration e = tab.keys(); e.hasMoreElements();) {
+                Object key = e.nextElement();
+                Object val = tab.get(key);
+                if (val != REMOVED_PROPERTY) {
+                    res.put(key, val);
+                }
+                else {
+                    res.remove(key);
+                }    
+            }
+        }    
+
+        return res;
+    }
+    
+    /**
+     * Create a table of all shared properties for the given envIdx. First read all
+     * properties from the parent env, then merge the local environment.
+     *
+     * @return a hashtable containing all properties visible for the shared environment index
+     * @param envIdx start index in the shared environment list
+     */
+    private Hashtable getAllSharedProperties(int envIdx) {
+        Hashtable res = null;
+        
+        // First copy parent env
+        if (m_parentEnv != null) {
+            res = m_parentEnv.getAllSharedProperties(m_parentSharedEnvIdx);
+        }
+        
+        if (res == null) {
+            res = new Hashtable(51);
+        }    
+
+        // Then copy _sharedEnv (older entries are processed before newer ones)
+        if (envIdx >= 0) {
+            for (int i= 0; i <= envIdx; i++) {
+                Hashtable tab = (Hashtable) m_sharedEnv.elementAt(i);
+                for (Enumeration e = tab.keys(); e.hasMoreElements();) {
+                    Object key = e.nextElement();
+                    Object val = tab.get(key);
+                    if (val != REMOVED_PROPERTY) {
+                        res.put(key, val);
+                    }
+                    else {
+                        res.remove(key);
+                    }    
+                }
+            }
+        }    
+        return res;
+    }
+
+    /**
+     * Freeze all environment changes changes in the current context. The "Freeze" is
+     * done by moving the _privateEnv table to _sharedEnv vector.
+     */
+    protected void freezeUpdates() {
+        if (m_privateEnv != null) {
+            // Lazy create _sharedEnv vector
+            if (m_sharedEnv == null) {
+                m_sharedEnv = new Vector();
+            }    
+            m_sharedEnv.addElement(m_privateEnv);
+            m_privateEnv = null;
+        }
+    }
+    
+    /**
+     * Clone ShareableEnv
+     *
+     * @return A "clone" of the current context environment
+     */
+    public Object clone() {
+        
+        // First freeze updates for this context
+        freezeUpdates();
+        
+         // If the context has been modified, then it is the parent of the clone
+        if (m_sharedEnv != null) {
+            return new ShareableEnv(this, m_sharedEnv.size()-1);
+        }
+        
+        // No changes has been done to the inherited parent context. Pass the parent
+        // context to the clone
+        else {
+            return new ShareableEnv(m_parentEnv, m_parentSharedEnvIdx);
+        }    
+    }    
+
+    /**
+     * Return string representation of the object
+     *
+     * @return a string representation of the object
+     */
+    public String toString() {
+        StringBuffer buf = new StringBuffer();
+        buf.append("ShareableEnv private=");
+        if (m_privateEnv != null) {
+            buf.append("(");
+            buf.append(m_privateEnv.size());
+            buf.append(")");
+        }
+        buf.append(" shared=");
+        if (m_sharedEnv != null) {
+            for (int i=0; i < m_sharedEnv.size(); i++) {
+                Hashtable tab = (Hashtable) m_sharedEnv.elementAt(i);
+                buf.append("(");
+                buf.append(tab.size());
+                buf.append(")");
+            }
+        }    
+        buf.append(" parentIdx=");
+        buf.append(m_parentSharedEnvIdx);
+                
+        return buf.toString();
+    }    
+
+    /**
+     * Test program 
+     */
+    public static void main(String[] args) {
+    
+        ShareableEnv c0 = new ShareableEnv(null, -1); // c=context 0=level 0=index
+        System.err.println("c0.getProperty(p1)="    + c0.getProperty("p1"));
+        System.err.println("c0.getAllProperties()=" + c0.getAllProperties());
+        System.err.println("c0.setProperty(p1,vxxx)=" + c0.setProperty("p1", "vxxx"));
+        System.err.println("c0.setProperty(p2,v2)=" + c0.setProperty("p2", "v2"));    
+        System.err.println("c0.setProperty(p3,v3)=" + c0.setProperty("p3", "v3"));
+        System.err.println("c0.setProperty(p1,v1)=" + c0.setProperty("p1", "v1"));        
+        System.err.println("c0.getAllProperties()=" + c0.getAllProperties());
+    
+        System.err.println("---");
+        ShareableEnv c01 = (ShareableEnv)c0.clone();
+        System.err.println("c01.getProperty(p1)="     + c01.getProperty("p1"));
+        System.err.println("c01.getAllProperties()="  + c01.getAllProperties());
+        System.err.println("c01.setProperty(p1,v1a)=" + c01.setProperty("p1", "v1a"));
+        System.err.println("c01.getProperty(p1)="     + c01.getProperty("p1"));
+        System.err.println("c01.removeProperty(p2)="  + c01.removeProperty("p2"));
+        System.err.println("c01.getProperty(p2)="     + c01.getProperty("p2"));    
+        System.err.println("c01.setProperty(p11,v11a)=" + c01.setProperty("p11", "v11a"));
+        System.err.println("c01.getAllProperties()="  + c01.getAllProperties());
+
+        System.err.println("---");
+        ShareableEnv c02 = (ShareableEnv)c0.clone();
+        System.err.println("c02.getProperty(p1)="     + c02.getProperty("p1"));
+        System.err.println("c02.getAllProperties()="  + c02.getAllProperties());
+
+        System.err.println("---");
+        ShareableEnv c011 = (ShareableEnv)c01.clone();
+        System.err.println("c011.getProperty(p1)="     + c011.getProperty("p1"));
+        System.err.println("c011.getAllProperties()="  + c011.getAllProperties());
+        System.err.println("c011.setProperty(p1,v11b)=" + c011.setProperty("p1", "v11b"));
+        System.err.println("c011.getProperty(p1)="     + c011.getProperty("p1"));
+        System.err.println("c011.getAllProperties()="  + c011.getAllProperties());
+
+        System.err.println("---");
+        System.err.println("c01.getAllProperties()="  + c01.getAllProperties());
+        System.err.println("c01.removeProperty(p11)="  + c01.removeProperty("p11"));
+        System.err.println("c01.getAllProperties()="  + c01.getAllProperties());
+        System.err.println("c011.getAllProperties()="  + c011.getAllProperties());
+
+        System.err.println("---");
+        ShareableEnv c012 = (ShareableEnv)c01.clone();
+        System.err.println("c012.getAllProperties()="  + c012.getAllProperties());
+        System.err.println("c012.getProperty(p1)="  + c012.getProperty("p1"));
+        
+        System.err.println("---");
+        System.err.println("c0="+c0);
+        System.err.println("c01="+c01);
+        System.err.println("c02="+c02);
+        System.err.println("c011="+c011);
+        System.err.println("c012="+c012);        
+        
+    }
+}    
+    
\ No newline at end of file
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/common/Debug.java
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.common;
+
+
+/**
+ * Class used to selectivly enable debug statements
+ */
+public class Debug {
+    
+    // lower number is a higher priority message. Level 0 is the
+    // highest priority to be used ONLY for errors
+    private static int m_level = 0;
+    
+    static {
+        try {
+            String level = System.getProperty("jndi.netscape.debug");
+            if (level != null) {
+                m_level = Integer.parseInt(level);
+            }
+        }
+        catch (Exception e) {}
+    }    
+    
+    
+    /**
+     * Set the debug level. To disable debugging set the level to -1
+     */
+    public static void setDebugLevel(int level) {
+        m_level = level;
+    }
+    
+    /**
+     * Get the debug level. If -1 is returned, then debugging is disabled
+     */
+    public static int getDebugLevel() {
+        return m_level;
+    }
+    
+    /**
+     * Print the message if its debug level is enabled
+     */
+    public static void println(int level, String msg) {
+        if (m_level >= 0 && level <= m_level) {
+            System.err.println(msg);
+        }
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/common/ExceptionMapper.java
@@ -0,0 +1,240 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.common;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+
+import java.util.Hashtable;
+
+/**
+ * Class used to map ldapjdk exceptions to JNDI NamingException
+*/
+public class ExceptionMapper {
+
+    public static NamingException getNamingException(Exception origException) {
+        
+        if (origException instanceof NamingException) {
+            return (NamingException)origException;
+        }
+        
+        /**
+         * LdapJDK exceptions
+         */
+        else if (origException instanceof LDAPReferralException) {
+            // Should never get here. The ldapjdk referral exceptions
+            // should be explicitly captured by the ecode and converted
+            // into jndi LdapReferralException instances.
+            return new NamingException("Provider internal error, LDAPReferralException not captured");
+        }
+        
+        else if (origException instanceof LDAPException) {
+            LDAPException ldapException = (LDAPException) origException;
+            int resCode = ldapException.getLDAPResultCode();
+            
+            if (resCode == LDAPException.OPERATION_ERROR) {
+                NamingException nameEx = new NamingException(ldapException.toString());
+                nameEx.setRootCause(ldapException);
+                return nameEx;
+            }
+            else if (resCode == LDAPException.PROTOCOL_ERROR) {
+                return new CommunicationException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.TIME_LIMIT_EXCEEDED) {
+                return new TimeLimitExceededException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.SIZE_LIMIT_EXCEEDED) {
+                return new SizeLimitExceededException(ldapException.toString());
+            }
+            // COMPARE_FALSE should never happen, but is included here for completeness
+            else if (resCode == LDAPException.COMPARE_FALSE) {
+                NamingException nameEx = new NamingException(ldapException.toString());
+                nameEx.setRootCause(ldapException);
+                return nameEx;
+            }    
+            // COMPARE_TRUE should never happen, but is included here for completeness
+            else if (resCode == LDAPException.COMPARE_TRUE) {
+                NamingException nameEx = new NamingException(ldapException.toString());
+                nameEx.setRootCause(ldapException);
+                return nameEx;
+            }
+            else if (resCode == LDAPException.AUTH_METHOD_NOT_SUPPORTED) {
+                return new AuthenticationNotSupportedException(ldapException.toString());
+            }
+            else if  (resCode == LDAPException.STRONG_AUTH_REQUIRED) {
+                return new AuthenticationNotSupportedException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.LDAP_PARTIAL_RESULTS) {
+                return new PartialResultException(ldapException.toString());
+            }
+            // REFERRAL code should be in LDAPReferralException
+            else if (resCode == LDAPException.REFERRAL) {
+                LDAPReferralException referralEx = (LDAPReferralException)ldapException;
+                // TODO create jndi LdapReferralException
+            }
+            else if (resCode == LDAPException.ADMIN_LIMIT_EXCEEDED) {
+                return new LimitExceededException(ldapException.toString());
+            }
+            else if(resCode == LDAPException.UNAVAILABLE_CRITICAL_EXTENSION) {
+                return new OperationNotSupportedException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.CONFIDENTIALITY_REQUIRED) {
+                return new AuthenticationNotSupportedException(
+                 "A secure connection is required for this operation");
+            }
+            // This shoud never propagate to the caller
+            else if (resCode == LDAPException.SASL_BIND_IN_PROGRESS) {
+                NamingException nameEx = new NamingException(ldapException.toString());
+                nameEx.setRootCause(ldapException);
+                return nameEx;
+            }
+            else if (resCode == LDAPException.NO_SUCH_ATTRIBUTE) {
+                return new NoSuchAttributeException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.UNDEFINED_ATTRIBUTE_TYPE) {
+                return  new InvalidAttributeIdentifierException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.INAPPROPRIATE_MATCHING) {
+                return new InvalidSearchFilterException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.CONSTRAINT_VIOLATION) {
+                return new InvalidSearchControlsException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.ATTRIBUTE_OR_VALUE_EXISTS) {
+                return new AttributeInUseException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.INVALID_ATTRIBUTE_SYNTAX) {
+                return new InvalidAttributeValueException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.NO_SUCH_OBJECT) {
+                return new NameNotFoundException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.ALIAS_PROBLEM) {
+                return new NamingException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.INVALID_DN_SYNTAX) {
+                return new InvalidNameException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.IS_LEAF) {
+                NamingException nameEx = new NamingException(ldapException.toString());
+                nameEx.setRootCause(ldapException);
+                return nameEx;
+            }
+            else if (resCode == LDAPException.ALIAS_DEREFERENCING_PROBLEM) {
+                NamingException nameEx = new NamingException(ldapException.toString());
+                nameEx.setRootCause(ldapException);
+                return nameEx;
+            }
+            else if (resCode == LDAPException.INAPPROPRIATE_AUTHENTICATION) {
+                //return new AuthenticationNotSupportedException(ldapException.toString());
+                return new AuthenticationException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.INVALID_CREDENTIALS) {
+                return new AuthenticationException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.INSUFFICIENT_ACCESS_RIGHTS) {
+                return new NoPermissionException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.BUSY) {
+                return new ServiceUnavailableException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.UNAVAILABLE) {
+                return new ServiceUnavailableException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.UNWILLING_TO_PERFORM) {
+                return new OperationNotSupportedException(ldapException.toString());
+            }
+            else if (resCode == LDAPException.LOOP_DETECT) {
+                NamingException nameEx = new NamingException(ldapException.toString());
+                nameEx.setRootCause(ldapException);
+                return nameEx;
+            }
+            else if (resCode == LDAPException.NAMING_VIOLATION) {
+                return new InvalidNameException(ldapException.toString());                
+            }
+            else if (resCode == LDAPException.OBJECT_CLASS_VIOLATION) {
+                return new SchemaViolationException(ldapException.toString());                
+            }
+            else if (resCode == LDAPException.NOT_ALLOWED_ON_NONLEAF) {
+                return new ContextNotEmptyException(ldapException.toString());                
+            }
+            else if (resCode == LDAPException.NOT_ALLOWED_ON_RDN) {
+                return new SchemaViolationException(ldapException.toString());                
+            }
+            else if (resCode == LDAPException.ENTRY_ALREADY_EXISTS) {
+                return new NameAlreadyBoundException(ldapException.toString());                
+            }
+            else if (resCode == LDAPException.OBJECT_CLASS_MODS_PROHIBITED) {
+                return new SchemaViolationException(ldapException.toString());                
+            }
+            else if (resCode == LDAPException.SERVER_DOWN) {
+                return new CommunicationException(ldapException.toString());                
+            }
+            else if (resCode == LDAPException.CONNECT_ERROR) {
+                return new CommunicationException(ldapException.toString());                
+            }
+
+            else {
+                // All other result codes
+                // 71     AFFECTS_MULTIPLE_DSAS
+                // 80     OTHER
+                // 89     PARAM_ERROR
+                // 92     LDAP_NOT_SUPPORTED
+                // 93     CONTROL_NOT_FOUND
+                // 94     NO_RESULTS_RETURNED
+                // 95     MORE_RESULTS_TO_RETURN
+                // 96     CLIENT_LOOP                referral                
+                // 97     REFERRAL_LIMIT_EXCEEDED    referral
+
+                NamingException nameEx = new NamingException(ldapException.toString());
+                nameEx.setRootCause(ldapException);
+                return nameEx;
+            }
+        }
+        
+        /**
+         * All other Exceptions
+         */
+        NamingException nameEx = new NamingException(origException.toString());
+        nameEx.setRootCause(origException);
+        return nameEx;
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/common/DirContextAdapter.java
@@ -0,0 +1,271 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.common;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+
+import java.util.Hashtable;
+
+public class DirContextAdapter implements DirContext {
+
+/* Context Methods */
+
+    public Object addToEnvironment(String propName, Object propValue) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void bind(String name, Object obj) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void bind(Name name, Object obj) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void close() throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public String composeName(String name, String prefix) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Name composeName(Name name, Name prefix) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Context createSubcontext(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Context createSubcontext(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void destroySubcontext(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void destroySubcontext(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Hashtable getEnvironment() throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public String getNameInNamespace() throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NameParser getNameParser(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NameParser getNameParser(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration list(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration list(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration listBindings(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration listBindings(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Object lookup(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Object lookup(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Object lookupLink(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Object lookupLink(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rebind(String name, Object obj) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rebind(Name name, Object obj) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Object removeFromEnvironment(String propName) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rename(String oldName, String newName) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rename(Name oldName, Name newName) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void unbind(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void unbind(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+
+/* DirContext Methods */
+
+    public void bind(String name, Object obj, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void bind(Name name, Object obj, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext createSubcontext(String name, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext createSubcontext(Name name, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Attributes getAttributes(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Attributes getAttributes(String name, String[] attrIds) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Attributes getAttributes(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Attributes getAttributes(Name name, String[] attrIds) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext getSchema(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext getSchema(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext getSchemaClassDefinition(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext getSchemaClassDefinition(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void modifyAttributes(String name, int mod_op, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void modifyAttributes(String name, ModificationItem[] mods) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void modifyAttributes(Name name, int mod_op, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void modifyAttributes(Name name, ModificationItem[] mods) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rebind(String name, Object obj, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rebind(Name name, Object obj, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration search(String name, String filter, SearchControls cons) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration search(String name, String filterExpr, Object[] filterArgs, SearchControls cons) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration search(String name, Attributes matchingAttributes) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration search(String name, Attributes matchingAttributes, String[] attributesToReturn) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration search(Name name, String filter, SearchControls cons) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration search(Name name, String filterExpr, Object[] filterArgs, SearchControls cons) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration search(Name name, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public NamingEnumeration search(Name name, Attributes matchingAttributes, String[] attributesToReturn) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapProxiedAuthControl.java
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import javax.naming.ldap.Control;
+import netscape.ldap.controls.*;
+
+/**
+ * Represents an LDAP v3 server control that specifies that you want
+ * the server to use the specified DN's identity for this operation.
+ * (The OID for this control is 2.16.840.1.113730.3.4.12.) *
+ */
+public class LdapProxiedAuthControl extends LDAPProxiedAuthControl implements Control {
+
+    /**
+     * Constructs an <CODE>LdapProxiedAuthControl</CODE> object with a
+     * DN to use as identity.
+     * @param dn DN to use as identity for execution of a request.
+     * @param critical <CODE>true</CODE> if the LDAP operation should be
+     * discarded when the server does not support this control (in other
+     * words, this control is critical to the LDAP operation).
+     */
+    public LdapProxiedAuthControl( String dn,
+                                   boolean critical) {
+        super( dn, critical);
+    }
+
+    /**
+     * Retrieves the ASN.1 BER encoded value of the LDAP control.
+     * Null is returned if the value is absent.
+     * @return A possibly null byte array representing the ASN.1 BER
+     * encoded value of the LDAP control.
+     */
+    public byte[] getEncodedValue() {
+        return getValue();
+    }
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/NetscapeControlFactory.java
@@ -0,0 +1,153 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+
+/**
+ * Factory for creating controls. Only controls send by the direcory server
+ * are processed.
+ */
+
+import javax.naming.*;
+import javax.naming.ldap.*;
+import netscape.ldap.LDAPControl;
+import netscape.ldap.controls.*;
+import com.netscape.jndi.ldap.common.ExceptionMapper;
+
+public class NetscapeControlFactory extends ControlFactory {
+
+    // "1.2.840.113556.1.4.473" Sort Control (Request) 
+    final static String REQ_SORT  = LDAPSortControl.SORTREQUEST;
+    
+    // "1.2.840.113556.1.4.474" Sort Control (Response)  
+    final static String RSP_SORT = LDAPSortControl.SORTRESPONSE;
+
+    // "2.16.840.1.113730.3.4.2" ManageDSAIT Control 
+    final static String REQ_MANAGEDSAIT = LDAPControl.MANAGEDSAIT;
+
+    // "2.16.840.1.113730.3.4.3" PersistentSearch Control 
+    final static String REQ_PERSISTENTSEARCH  = LDAPPersistSearchControl.PERSISTENTSEARCH;
+    
+    // "2.16.840.1.113730.3.4.4" PasswordExpired Control
+    final static String RSP_PWDEXPIRED = LDAPPasswordExpiredControl.EXPIRED;
+    
+    // "2.16.840.1.113730.3.4.5" PasswordExpiring Control 
+    final static String RSP_PWDEXPIRING = LDAPPasswordExpiringControl.EXPIRING;
+    
+    // "2.16.840.1.113730.3.4.7" EntryChanged Controle 
+    final static String RSP_ENTRYCHANGED = LDAPEntryChangeControl.ENTRYCHANGED;
+
+    // "2.16.840.1.113730.3.4.9" Virtual List (Request) 
+    final static String REQ_VIRTUALLIST = LDAPVirtualListControl.VIRTUALLIST;
+    
+    // "2.16.840.1.113730.3.4.10" Virtual List (Response)
+    final static String RSP_VIRTUALLIST = LDAPVirtualListResponse.VIRTUALLISTRESPONSE;
+
+    // "2.16.840.1.113730.3.4.12" Proxed Authentication
+    final static String REQ_PROXIEDAUTH  = LDAPProxiedAuthControl.PROXIEDAUTHREQUEST;
+
+
+    /**
+     * Creates a control using this control factory
+     * @param ctrl A non-null control.
+     * @return A possibly null Control.
+     * @exception NamingException If ctrl contains invalid data that prevents it from
+     * being used to create a control.
+     */
+    public Control getControlInstance(Control ctrl) throws NamingException {
+        if (ctrl == null) {
+            return null;
+        }
+        LDAPControl rawCtrl = new LDAPControl(
+            ctrl.getID(), ctrl.isCritical(), ctrl.getEncodedValue());
+        return getControlInstance(rawCtrl);        
+    }    
+        
+    /**
+     * Create a JNDI control from a raw ldapjdk control
+     * @param rawCtrl A non-null control.
+     * @return A possibly null Control.
+     * @exception NamingException If ctrl contains invalid data that prevents it from
+     * being used to create a control.
+     */
+    public static Control getControlInstance(LDAPControl rawCtrl) throws NamingException {
+        if (rawCtrl == null) {
+            return null;
+        }
+
+        try { 
+            String ctrlID = rawCtrl.getID();
+        
+             // Entry changed control is parsed by LDAPPersistSearchControl             
+            if (ctrlID.equals(RSP_ENTRYCHANGED)) {
+                return new LdapEntryChangeControl(
+                    rawCtrl.isCritical(), rawCtrl.getValue());
+            }
+            
+            // Password Expired control
+            else if(ctrlID.equals(RSP_PWDEXPIRED)) {
+                return new LdapPasswordExpiredControl(
+                    rawCtrl.isCritical(), rawCtrl.getValue());
+            }
+
+            // Password Expiring control
+            else if(ctrlID.equals(RSP_PWDEXPIRING)) {
+                return new LdapPasswordExpiringControl(
+                    rawCtrl.isCritical(), rawCtrl.getValue());
+            }
+
+            // Sort Response control
+            else if(ctrlID.equals(RSP_SORT)) {
+                return new LdapSortResponseControl(
+                    rawCtrl.isCritical(), rawCtrl.getValue());
+            }
+
+            // Virtual List Response control
+            else if(ctrlID.equals(RSP_VIRTUALLIST)) {
+                return new LdapVirtualListResponseControl(
+                    rawCtrl.isCritical(), rawCtrl.getValue());
+            }
+
+            // No match try another ControlFactory
+            return null;
+        }
+        catch (Exception ex) {
+            throw ExceptionMapper.getNamingException(ex);
+        }
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapPersistSearchControl.java
@@ -0,0 +1,247 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import javax.naming.ldap.Control;
+import netscape.ldap.controls.*;
+
+/**
+ * Represents an LDAP v3 server control that specifies a persistent
+ * search (an ongoing search operation), which allows your LDAP client
+ * to get notification of changes to the directory.  (The OID for this
+ * control is 2.16.840.1.113730.3.4.3.)  You can use this control in
+ * conjunction with an "entry change notification" control.
+ * <P>
+ *
+ * To use persistent searching for change notification, you create a
+ * "persistent search" control that specifies the types of changes that
+ * you want to track.  You include the control in a search request.
+ * If an entry in the directory is changed, the server determines if
+ * the entry matches the search criteria in your request and if the
+ * change is the type of change that you are tracking.  If both of
+ * these are true, the server sends the entry to your client.
+ * <P>
+ *
+ * The server can also include an "entry change notification" control
+ * with the entry.  (The OID for this control is 2.16.840.1.113730.3.4.7.)
+ * This control contains additional information about the
+ * change made to the entry, including the type of change made,
+ * the change number (which corresponds to an item in the server's
+ * change log, if the server supports a change log), and, if the
+ * entry was renamed, the old DN of the entry.
+ * <P>
+ *
+ * When constructing an <CODE>LDAPPersistSearchControl</CODE> object,
+ * you can specify the following information:
+ * <P>
+ *
+ * <UL>
+ * <LI>the type of change you want to track (added, modified, deleted,
+ * or renamed entries)
+ * <LI>a preference indicating whether or not you want the server to
+ * return all entries that initially matched the search criteria
+ * (rather than only the entries that change)
+ * <LI>a preference indicating whether or not you want entry change
+ * notification controls included with every entry returned by the
+ * server
+ * </UL>
+ * <P>
+ * @see com.netscape.jndi.ldap.controls.LdapEntryChangeControl
+ */
+
+public class LdapPersistSearchControl extends LDAPPersistSearchControl implements Control {
+
+    /**
+     * Change type specifying that you want to track additions of new
+     * entries to the directory.  You can either specify this change type
+     * when constructing an <CODE>LdapPersistSearchControl</CODE> or
+     * by using the <CODE>setChangeTypes</CODE> method.
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#getChangeTypes
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#setChangeTypes
+     */
+    public static final int ADD = LDAPPersistSearchControl.ADD;
+
+    /**
+     * Change type specifying that you want to track removals of
+     * entries from the directory.  You can either specify this change type
+     * when constructing an <CODE>LdapPersistSearchControl</CODE> or
+     * by using the <CODE>setChangeTypes</CODE> method.
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#getChangeTypes
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#setChangeTypes
+     */
+    public static final int DELETE = LDAPPersistSearchControl.DELETE;
+
+    /**
+     * Change type specifying that you want to track modifications of
+     * entries in the directory.  You can either specify this change type
+     * when constructing an <CODE>LdapPersistSearchControl</CODE> or
+     * by using the <CODE>setChangeTypes</CODE> method.
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#getChangeTypes
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#setChangeTypes
+     */
+    public static final int MODIFY = LDAPPersistSearchControl.MODIFY;
+
+    /**
+     * Change type specifying that you want to track modifications of the
+     * DNs of entries in the directory.  You can either specify this change type
+     * when constructing an <CODE>LdapPersistSearchControl</CODE> or
+     * by using the <CODE>setChangeTypes</CODE> method.
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#getChangeTypes
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#setChangeTypes
+     */
+    public static final int MODDN = LDAPPersistSearchControl.MODDN;
+    
+    /**
+     * Constructs an <CODE>LdapPersistSearchControl</CODE> object
+     * that specifies a persistent search.
+     *
+     * @param changeTypes The change types to be monitored. You can perform
+     * a bitwise OR on any of the following values and specify the result as
+     * the change types:
+     * <UL>
+     * <LI><CODE>LdapPersistSearchControl.ADD</CODE> (to track new entries
+     * added to the directory)
+     * <LI><CODE>LdapPersistSearchControl.DELETE</CODE> (to track entries
+     * removed from the directory)
+     * <LI><CODE>LdapPersistSearchControl.MODIFY</CODE> (to track entries
+     * that have been modified)
+     * <LI><CODE>LdapPersistSearchControl.MODDN</CODE> (to track entries
+     * that have been renamed)
+     * </UL>
+     * @param changesOnly <code>true</code> if you do not want the server
+     * to return all existing entries in the directory that match the
+     * search criteria.  (You just want the changed entries to be returned.)
+     * @param returnControls <code>true</code> you want the server to return
+     * entry change controls with each entry in the search results.
+     * @param isCritical <code>true</code> if this control is critical to
+     * the search operation (for example, if the server does not support
+     * this control, you may not want the server to perform the search
+     * at all.)
+     * @see com.netscape.jndi.ldap.controls.LdapEntryChangeControl
+     */
+    public LdapPersistSearchControl(int changeTypes, boolean changesOnly,
+        boolean returnControls, boolean isCritical) {
+        super(changeTypes, changesOnly, returnControls, isCritical);
+    }
+
+    /**
+     * Gets the change types monitored by this control.
+     * @return Integer representing the change types that you want monitored.
+     * This value can be the bitwise OR of <code>ADD, DELETE, MODIFY,</code>
+     * and/or <code>MODDN</code>. If the change type is unknown,
+     * this method returns -1.
+     */
+    public int getChangeTypes() {
+        return super.getChangeTypes();
+    }
+
+    /**
+     * Indicates whether you want the server to send any existing
+     * entries that already match the search criteria or only the
+     * entries that have changed.
+     * @return If <code>true</code>, the server returns only the
+     * entries that have changed.  If <code>false</code>, the server
+     * also returns any existing entries that match the search criteria
+     * but have not changed.
+     */
+    public boolean getChangesOnly() {
+        return super.getChangesOnly();
+    }
+
+    /**
+     * Indicates whether or not the server includes an "entry change
+     * notification" control with each entry it sends back to the client
+     * during the persistent search.
+     * @return <code>true</code> if the server includes "entry change
+     * notification" controls with the entries it sends during the
+     * persistent search.
+     * @see com.netscape.jndi.ldap.controls.LdapEntryChangeControl
+     */
+    public boolean getReturnControls() {
+        return super.getReturnControls();
+    }
+
+    /**
+     * Sets the change types that you want monitored by this control.
+     * @param types Integer representing the change types that you want monitored.
+     * This value can be the bitwise OR of <code>ADD, DELETE, MODIFY,</code>
+     * and/or <code>MODDN</code>.
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#getChangeTypes
+     */
+    public void setChangeTypes(int types) {
+        super.setChangeTypes(types);
+    }
+
+    /**
+     * Specifies whether you want the server to send any existing
+     * entries that already match the search criteria or only the
+     * entries that have changed.
+     * @param changesOnly If <code>true</code>, the server returns only the
+     * entries that have changed.  If <code>false</code>, the server
+     * also returns any existing entries that match the search criteria
+     * but have not changed.
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#getChangesOnly
+     */
+    public void setChangesOnly(boolean changesOnly) {
+        super.setChangesOnly(changesOnly);
+    }
+
+    /**
+     * Specifies whether you want the server to include an "entry change
+     * notification" control with each entry it sends back to the client
+     * during the persistent search.
+     * @param returnControls If <code>true</code>, the server includes
+     * "entry change notification" controls with the entries it sends
+     * during the persistent search.
+     * @see com.netscape.jndi.ldap.controls.LdapEntryChangeControl
+     * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl#setReturnControls
+     */
+    public void setReturnControls(boolean returnControls) {
+        super.setReturnControls(returnControls);
+    }
+
+    /**
+     * Retrieves the ASN.1 BER encoded value of the LDAP control.
+     * Null is returned if the value is absent.
+     * @return A possibly null byte array representing the ASN.1 BER
+     * encoded value of the LDAP control.
+     */
+    public byte[] getEncodedValue() {
+        return getValue();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapSortKey.java
@@ -0,0 +1,140 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import netscape.ldap.LDAPSortKey;
+
+/**
+ * Represents sorting instructions for a particular attribute.
+ *
+ */
+public class LdapSortKey extends LDAPSortKey{
+
+    /**
+     * Constructs a new <CODE>LdapSortKey</CODE> object that will
+     * sort based on the specified instructions.
+     * @param keyDescription A single attribute specification to sort by.
+     * If preceded by a hyphen ("-"), the attribute is sorted in reverse order.
+     * You can also specify the object ID (OID) of a matching rule after
+     * a colon (":"). For example:
+     * <P>
+     * <UL>
+     * <LI><CODE>"cn"</CODE> (sort by the <CODE>cn</CODE> attribute) <P>
+     * <LI><CODE>"-cn"</CODE> (sort by the <CODE>cn</CODE> attribute in
+     * reverse order) <P>
+     * <LI><CODE>"-cn:1.2.3.4"</CODE> (sort by the <CODE>cn</CODE>
+     * attribute in reverse order and use the matching rule identified
+     * by the OID 1.2.3.4) <P>
+     *</UL>
+     * @see com.netscape.jndi.ldap.controls.LdapSortControl
+     * @see com.netscape.jndi.ldap.controls.LdapVirtualListControl
+     */
+    public LdapSortKey( String keyDescription ) {
+        super(keyDescription);
+    }
+
+    /**
+     * Constructs a new <CODE>LdapSortKey</CODE> object that will
+     * sort based on the specified attribute and sort order.
+     * @param key A single attribute to sort by.  For example:
+     * <P>
+     * <UL>
+     * <LI><CODE>"cn"</CODE> (sort by the <CODE>cn</CODE> attribute)
+     * <LI><CODE>"givenname"</CODE> (sort by the <CODE>givenname</CODE>
+     * attribute)
+     * </UL>
+     * @param reverse If <CODE>true</CODE>, the sorting is done in
+     * descending order.
+     * @see com.netscape.jndi.ldap.controls.LdapSortControl
+     * @see com.netscape.jndi.ldap.controls.LdapVirtualListControl
+     */
+    public LdapSortKey( String key,
+                        boolean reverse) {
+        super(key,reverse);
+    }
+
+    /**
+     * Constructs a new <CODE>LdapSortKey</CODE> object that will
+     * sort based on the specified attribute, sort order, and matching
+     * rule.
+     * @param key A single attribute to sort by. For example:
+     * <P>
+     * <UL>
+     * <LI><CODE>"cn"</CODE> (sort by the <CODE>cn</CODE> attribute)
+     * <LI><CODE>"givenname"</CODE> (sort by the <CODE>givenname</CODE>
+     * attribute)
+     * </UL>
+     * @param reverse If <CODE>true</CODE>, the sorting is done in
+     * descending order.
+     * @param matchRule Object ID (OID) of the matching rule for
+     * the attribute (for example, <CODE>1.2.3.4</CODE>).
+     * @see com.netscape.jndi.ldap.controls.LdapSortControl
+     * @see com.netscape.jndi.ldap.controls.LdapVirtualListControl
+     */
+    public LdapSortKey( String key,
+                        boolean reverse,
+                        String matchRule) {
+        super(key, reverse, matchRule);
+    }
+
+    /**
+     * Returns the attribute to sort by.
+     * @return A single attribute to sort by.
+     */
+    public String getKey() {
+        return super.getKey();
+    }
+
+    /**
+     * Returns <CODE>true</CODE> if sorting is to be done in descending order.
+     * @return <CODE>true</CODE> if sorting is to be done in descending order.
+     */
+    public boolean getReverse() {
+        return super.getReverse();
+    }
+
+    /**
+     * Returns the object ID (OID) of the matching rule used for sorting.
+     * If no matching rule is specified, <CODE>null</CODE> is returned.
+     * @return The object ID (OID) of the matching rule, or <CODE>null</CODE>
+     * if the sorting instructions specify no matching rule.
+     */
+    public String getMatchRule() {
+        return super.getMatchRule();
+    }
+}
\ No newline at end of file
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapEntryChangeControl.java
@@ -0,0 +1,134 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import javax.naming.ldap.Control;
+import netscape.ldap.controls.*;
+
+/**
+ * Represents an LDAP v3 server control that specifies information
+ * about a change to an entry in the directory.  (The OID for this
+ * control is 2.16.840.1.113730.3.4.7.)  You need to use this control in
+ * conjunction with a "persistent search" control (represented
+ * by <CODE>LdapPersistentSearchControl</CODE> object.
+ * <P>
+ *
+ * To use persistent searching for change notification, you create a
+ * "persistent search" control that specifies the types of changes that
+ * you want to track.  When an entry is changed, the server sends that
+ * entry back to your client and may include an "entry change notification"
+ * control that specifies additional information about the change.
+ * <P>
+ *
+ * Once you retrieve an <CODE>LdapEntryChangeControl</CODE> object from
+ * the server, you can get the following additional information about
+ * the change made to the entry:
+ * <P>
+ *
+ * <UL>
+ * <LI>The type of change made (add, modify, delete, or modify DN)
+ * <LI>The change number identifying the record of the change in the
+ * change log (if the server supports change logs)
+ * <LI>If the entry was renamed, the old DN of the entry
+ * </UL>
+ * <P>
+ *
+ * @see com.netscape.jndi.ldap.controls.LdapPersistSearchControl
+ */
+public class LdapEntryChangeControl extends LDAPEntryChangeControl implements Control {
+
+    /**
+     * Constructs a new <CODE>LdapEntryChangeControl</CODE> object.
+     * This constructor is used by the NetscapeControlFactory
+     *
+     */
+    LdapEntryChangeControl(boolean critical, byte[] value) throws Exception {
+        super(ENTRYCHANGED, critical, value);
+    }
+
+    /**
+     * Gets the change number, which identifies the record of the change
+     * in the server's change log.
+     * @return Change number identifying the change made.
+     */
+    public int getChangeNumber() {
+        return super.getChangeNumber();
+    }
+
+    /**
+     * Gets the change type, which identifies the type of change
+     * that occurred.
+     * @return Change type identifying the type of change that
+     * occurred.  This can be one of the following values:
+     * <P>
+     *
+     * <UL>
+     * <LI><CODE>LdapPersistSearchControl.ADD</CODE> (a new entry was
+     * added to the directory)
+     * <LI><CODE>LdapPersistSearchControl.DELETE</CODE> (an entry was
+     * removed from the directory)
+     * <LI><CODE>LdapPersistSearchControl.MODIFY</CODE> (an entry was
+     * modified)
+     * <LI><CODE>LdapPersistSearchControl.MODDN</CODE> (an entry was
+     * renamed)
+     * </UL>
+     * <P>
+     */
+    public int getChangeType() {
+        return super.getChangeType();
+    }
+
+    /**
+     * Gets the previous DN of the entry (if the entry was renamed).
+     * @return The previous distinguished name of the entry.
+     */
+    public String getPreviousDN() {
+        return super.getPreviousDN();
+    }
+
+    /**
+     * Retrieves the ASN.1 BER encoded value of the LDAP control.
+     * Null is returned if the value is absent.
+     * @return A possibly null byte array representing the ASN.1 BER
+     * encoded value of the LDAP control.
+     */
+    public byte[] getEncodedValue() {
+        return getValue();
+    }    
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapSortResponseControl.java
@@ -0,0 +1,229 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import javax.naming.NamingException;
+import javax.naming.ldap.Control;
+import netscape.ldap.LDAPControl;
+import netscape.ldap.LDAPException;
+import netscape.ldap.controls.*;
+import com.netscape.jndi.ldap.common.ExceptionMapper;
+
+/**
+ * The LDAP server sends back a sort response control to indicate
+ * the result of the sorting operation. (The OID for this control
+ * is 1.2.840.113556.1.4.474.)
+ * <P>
+ *
+ * This control contains:
+ * <P>
+ *
+ * <UL>
+ * <LI>the result code from the sorting operation
+ * <LI>optionally, the first attribute type in the sort key list
+ * that resulted in an error (for example, if the attribute does
+ * not exist)
+ * </UL>
+ * <P>
+ *
+ * To parse this control, use the <CODE>parseResponse</CODE> method.
+ * <P>
+ *
+ * The following table lists what kinds of results to expect from the
+ * LDAP server under different situations:
+ * <P>
+ *
+ * <TABLE BORDER=1 COLS=4>
+ * <TR VALIGN=BASELINE>
+ *     <TH>Does the Server Support the Sorting Control?</TH>
+ *     <TH>Is the Sorting Control Marked As Critical?</TH>
+ *     <TH>Other Conditions</TH>
+ *     <TH>Results from LDAP Server</TH>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD ROWSPAN=2>
+ *     No
+ *     </TD>
+ *     <TD>
+ *     Yes
+ *     </TD>
+ *     <TD>
+ *     None
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server does not send back any entries.
+ *     <LI>An LDAPException.UNAVAILABLE_CRITICAL_EXTENSION
+ *     exception is thrown.
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD>
+ *     No
+ *     </TD>
+ *     <TD>
+ *     None
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server ignores the sorting control and
+ *     returns the entries unsorted.
+ *     </UL>
+ *     <P>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD ROWSPAN=4>
+ *     Yes
+ *     </TD>
+ *     <TD>
+ *     Yes
+ *     </TD>
+ *     <TD ROWSPAN=2>
+ *     The server cannot sort the results using the specified
+ *     sort key list.
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server does not send back any entries.
+ *     <LI>An LDAPException.UNAVAILABLE_CRITICAL_EXTENSION
+ *     exception is thrown.
+ *     <LI>The server sends back the sorting response control, which
+ *     specifies the result code of the sort attempt and (optionally)
+ *     the attribute type that caused the error.
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD>
+ *     No
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server returns the entries unsorted.
+ *     <LI>The server sends back the sorting response control, which
+ *     specifies the result code of the sort attempt and (optionally)
+ *     the attribute type that caused the error.
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD ROWSPAN=2>
+ *     N/A (could either be marked as critical or not)
+ *     </TD>
+ *     <TD>
+ *     The server successfully sorted the entries.
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server sends back the sorted entries.
+ *     <LI>The server sends back the sorting response control, which
+ *     specifies the result code of the sort attempt
+ *     (LDAPException.SUCCESS).
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * <TR VALIGN=BASELINE>
+ *     <TD>
+ *     The search itself failed (for any reason).
+ *     </TD>
+ *     <TD>
+ *     <UL>
+ *     <LI>The server sends back a result code for the search
+ *     operation.
+ *     <LI>The server does not send back the sorting response control.
+ *     </UL>
+ *     </TD>
+ * </TR>
+ * </TABLE>
+ * <P>
+ * @see com.netscape.jndi.ldap.controls.LdapSortKey
+ * @see com.netscape.jndi.ldap.controls.LdapSortControl
+ */
+public class LdapSortResponseControl extends LDAPSortControl implements Control {
+
+    /**
+     * Constructs a new <CODE>LdapEntryChangeControl</CODE> object.
+     * This constructor is used by the NetscapeControlFactory
+     *
+     */
+    LdapSortResponseControl(boolean critical, byte[] value) throws Exception{
+        super(SORTRESPONSE, critical, value);
+    }
+    
+    /**
+     * Get the first attribute type from the sort key list that 
+     * resulted in an error
+     * @return Attribute name that resulted in an error
+     */
+    public String getFailedAttribute() {
+        return super.getFailedAttribute();
+    }
+    
+    /**
+     * Return the sort result code
+     * @return The sort result code
+     */
+    public int getResultCode() {
+        return super.getResultCode();
+    }
+
+    /**
+     * Return corresponding NamingException for the sort error code
+     * @return NamingException for the sort error code
+     */
+    public NamingException getSortException() {
+        if (getResultCode() == 0) { // success
+            return null;
+        }
+        return ExceptionMapper.getNamingException(
+            new LDAPException("Server Sort Failed", getResultCode()));
+    }  
+
+    /**
+     * Retrieves the ASN.1 BER encoded value of the LDAP control.
+     * Null is returned if the value is absent.
+     * @return A possibly null byte array representing the ASN.1 BER
+     * encoded value of the LDAP control.
+     */
+    public byte[] getEncodedValue() {
+        return getValue();
+    }    
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapPasswordExpiringControl.java
@@ -0,0 +1,75 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import javax.naming.ldap.Control;
+import netscape.ldap.controls.*;
+
+/**
+ * Represents an LDAP v3 server control that may be returned if a
+ * password is about to expire, and password policy is enabled on the server.
+ * The OID for this control is 2.16.840.1.113730.3.4.5.
+ * <P>
+ */
+public class LdapPasswordExpiringControl extends LDAPPasswordExpiringControl implements Control {
+
+    /**
+     * This constractor is used by the NetscapeControlFactory
+     */
+    LdapPasswordExpiringControl(boolean critical, byte[] value) throws Exception{
+        super(EXPIRING, critical, value);              
+    }
+    
+    /**
+     * Return parsed number of seconds before password expires
+     * @return number of seconds before password expires
+     */
+    public int getSecondsToExipre() {
+        return super.getSecondsToExpiration();
+    }    
+
+    /**
+     * Retrieves the ASN.1 BER encoded value of the LDAP control.
+     * Null is returned if the value is absent.
+     * @return A possibly null byte array representing the ASN.1 BER
+     * encoded value of the LDAP control.
+     */
+    public byte[] getEncodedValue() {
+        return getValue();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapPasswordExpiredControl.java
@@ -0,0 +1,76 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import javax.naming.ldap.Control;
+import netscape.ldap.controls.*;
+
+/**
+ * Represents an LDAP v3 server control that may be returned if a
+ * password has expired, and password policy is enabled on the server.
+ * The OID for this control is 2.16.840.1.113730.3.4.4.
+ * <P>
+ */
+
+public class LdapPasswordExpiredControl extends LDAPPasswordExpiredControl implements Control{
+
+    /**
+     * This constractor is used by the NetscapeControlFactory
+     */
+    LdapPasswordExpiredControl(boolean critical, byte[] value) throws Exception{
+        super(EXPIRED, critical, value);
+    }
+    
+    /**
+     * Return string message passed in the control
+     * @return message string
+     */
+    public String getMessage() {
+        return super.getMessage();
+    }    
+
+    /**
+     * Retrieves the ASN.1 BER encoded value of the LDAP control.
+     * Null is returned if the value is absent.
+     * @return A possibly null byte array representing the ASN.1 BER
+     * encoded value of the LDAP control.
+     */
+    public byte[] getEncodedValue() {
+        return getValue();
+    }    
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapVirtualListResponseControl.java
@@ -0,0 +1,111 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import javax.naming.ldap.Control;
+import netscape.ldap.controls.*;
+
+
+/**
+ * Represents control data for returning paged results from a search.
+ *
+ *
+ *<PRE>
+ *      VirtualListViewResponse ::= SEQUENCE {
+ *               firstPosition    INTEGER,
+ *               contentCount     INTEGER,
+ *               virtualListViewResult ENUMERATED {
+ *                 success                  (0),
+ *                 unwillingToPerform       (53),
+ *                 insufficientAccessRights (50),
+ *                 operationsError          (1),
+ *                 busy                     (51),
+ *                 timeLimitExceeded        (3),
+ *                 adminLimitExceeded       (11),
+ *                 sortControlMissing       (60),
+ *                 indexRangeError          (?),
+ *               }
+ *     }
+ *</PRE>
+ */
+
+public class LdapVirtualListResponseControl extends LDAPVirtualListResponse implements Control{
+
+    /**
+     * Constructs a new <CODE>LDAPVirtualListResponse</CODE> object.
+     * @param value A BER encoded byte array.
+     * This constructor is used by the NetscapeControlFactory
+     */
+    LdapVirtualListResponseControl(boolean critical, byte[] value)throws Exception  {
+        super(VIRTUALLISTRESPONSE, critical, value);
+    }
+
+    /**
+     * Gets the size of the virtual result set.
+     * @return The size of the virtual result set, or -1 if not known.
+     */
+    public int getContentCount() {
+        return super.getContentCount();
+    }
+
+    /**
+     * Gets the index of the first entry returned.
+     * @return The index of the first entry returned.
+     */
+    public int getFirstPosition() {
+        return super.getFirstPosition();
+    }
+
+    /**
+     * Gets the result code.
+     * @return The result code.
+     */
+    public int getResultCode() {
+        return super.getResultCode();
+    }
+    
+    /**
+     * Retrieves the ASN.1 BER encoded value of the LDAP control.
+     * Null is returned if the value is absent.
+     * @return A possibly null byte array representing the ASN.1 BER
+     * encoded value of the LDAP control.
+     */
+    public byte[] getEncodedValue() {
+        return getValue();
+    }    
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapSortControl.java
@@ -0,0 +1,130 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import javax.naming.ldap.Control;
+import netscape.ldap.controls.*;
+
+/**
+ * Represents an LDAP v3 server control that specifies that you want
+ * the server to return sorted search results.  (The OID for this
+ * control is 1.2.840.113556.1.4.473.)
+ * <P>
+ *
+ * When constructing an <CODE>LDAPSortControl</CODE> object, you can
+ * specify the order in which you want the results sorted.
+ * You can also specify whether or not this control is critical
+ * to the search operation.
+ * <P>
+ *
+ * To specify the sort order, you construct an <CODE>LdapSortKey</CODE>
+ * object and pass it to the <CODE>LdapSortControl</CODE> constructor.
+ * The <CODE>LdapSortKey</CODE> object represents a list of the attribute
+ * types used for sorting (a "sort key list").
+ *
+ * The LDAP server sends back a sort response control to indicate
+ * the result of the sorting operation. (The OID for this control
+ * is 1.2.840.113556.1.4.474.)
+ *
+ * @see com.netscape.jndi.ldap.controls.LdapSortKey
+ * @see com.netscape.jndi.ldap.controls.LdapSortResponseControl
+ */
+public class LdapSortControl extends LDAPSortControl implements Control{
+    /**
+     * Constructs an <CODE>LDAPSortControl</CODE> object with a single
+     * sorting key.
+     * @param key A single attribute to sort by.
+     * @param critical <CODE>true</CODE> if the LDAP operation should be
+     * discarded when the server does not support this control (in other
+     * words, this control is critical to the LDAP operation).
+     * @see com.netscape.jndi.ldap.controls.LdapSortKey
+     */
+    public LdapSortControl(LdapSortKey key,
+                           boolean critical) {
+        super (key, critical);
+    }
+
+    /**
+     * Constructs an <CODE>LDAPSortControl</CODE> object with an array of
+     * sorting keys.
+     * @param keys The attributes to sort by.
+     * @param critical <CODE>true</CODE> if the LDAP operation should be
+     * discarded when the server does not support this control (in other
+     * words, this control is critical to the LDAP operation).
+     * @see com.netscape.jndi.ldap.controls.LdapSortKey
+     */
+    public LdapSortControl(LdapSortKey[] keys,
+                           boolean critical) {
+        super(keys, critical);
+    }
+
+
+    static LdapSortKey[] toSortKey(String[] keysIn) {
+        LdapSortKey[] keysOut = new LdapSortKey[keysIn.length];
+        for (int i=0; i < keysIn.length; i++) {
+            keysOut[i] = new LdapSortKey(keysIn[i]);
+        }
+        return keysOut;
+    }
+
+    /**
+     * Constructs an <CODE>LDAPSortControl</CODE> object with an array of
+     * sorting keys.
+     * @param keys The attributes to sort by.
+     * @param critical <CODE>true</CODE> if the LDAP operation should be
+     * discarded when the server does not support this control (in other
+     * words, this control is critical to the LDAP operation).
+     * @see com.netscape.jndi.ldap.controls.LdapSortKey
+     */
+    public LdapSortControl(String[] keys,
+                           boolean critical) {
+        super(toSortKey(keys), critical);
+    }
+
+
+    /**
+     * Retrieves the ASN.1 BER encoded value of the LDAP control.
+     * Null is returned if the value is absent.
+     * @return A possibly null byte array representing the ASN.1 BER
+     * encoded value of the LDAP control.
+     */
+    public byte[] getEncodedValue() {
+        return getValue();
+    }    
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/controls/LdapVirtualListControl.java
@@ -0,0 +1,170 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.controls;
+
+import javax.naming.ldap.Control;
+import netscape.ldap.controls.*;
+
+/**
+ * Represents control data for returning paged results from a search.
+ *
+ * <PRE>
+ *      VirtualListViewRequest ::= SEQUENCE {
+ *                      beforeCount    INTEGER,
+ *                      afterCount     INTEGER,
+ *                      CHOICE {
+ *                      byIndex [0] SEQUENCE {
+ *                          index           INTEGER,
+ *                          contentCount    INTEGER }
+ *                      byFilter [1] jumpTo    Substring }
+ * </PRE>
+ *
+ */
+
+public class LdapVirtualListControl extends LDAPVirtualListControl implements Control {
+
+    /**
+     * Constructs a new <CODE>LDAPVirtualListControl</CODE> object. Use this
+     * constructor on an initial search operation, specifying the first
+     * entry to be matched, or the initial part of it.
+     * @param jumpTo An LDAP search expression defining the result set.
+     * @param beforeCount The number of results before the top/center to
+     * return per page.
+     * @param afterCount The number of results after the top/center to
+     * return per page.
+     */
+    public LdapVirtualListControl( String jumpTo, int beforeCount,
+                                   int afterCount  ) {
+        super( jumpTo, beforeCount, afterCount);
+    }
+
+    /**
+     * Constructs a new <CODE>LDAPVirtualListControl</CODE> object. Use this
+     * constructor on a subsquent search operation, after we know the
+     * size of the virtual list, to fetch a subset.
+     * @param startIndex The index into the virtual list of an entry to
+     * return.
+     * @param beforeCount The number of results before the top/center to
+     * return per page.
+     * @param afterCount The number of results after the top/center to
+     * return per page.
+     */
+    public LdapVirtualListControl( int startIndex, int beforeCount,
+                                   int afterCount, int contentCount  ) {
+        super( startIndex, beforeCount, afterCount, contentCount );
+    }
+
+    /**
+     * Sets the starting index, and the number of entries before and after
+     * to return. Apply this method to a control returned from a previous
+     * search, to specify what result range to return on the next search.
+     * @param startIndex The index into the virtual list of an entry to
+     * return.
+     * @param beforeCount The number of results before startIndex to
+     * return per page.
+     * @param afterCount The number of results after startIndex to
+     * return per page.
+     */
+    public void setRange( int startIndex, int beforeCount, int afterCount  ) {
+        super.setRange(startIndex, beforeCount, afterCount);
+    }
+
+    /**
+     * Sets the search expression, and the number of entries before and after
+     * to return.
+     * @param jumpTo An LDAP search expression defining the result set.
+     * return.
+     * @param beforeCount The number of results before startIndex to
+     * return per page.
+     * @param afterCount The number of results after startIndex to
+     * return per page.
+     */
+    public void setRange( String jumpTo, int beforeCount, int afterCount  ) {
+        super.setRange(jumpTo, beforeCount, afterCount);
+    }
+
+    /**
+     * Gets the size of the virtual result set.
+     * @return The size of the virtual result set, or -1 if not known.
+     */
+    public int getIndex() {
+        return super.getIndex();
+    }
+
+    /**
+     * Gets the size of the virtual result set.
+     * @return The size of the virtual result set, or -1 if not known.
+     */
+    public int getListSize() {
+        return super.getListSize();
+    }
+
+    /**
+     * Sets the size of the virtual result set.
+     * @param listSize The virtual result set size.
+     */
+    public void setListSize( int listSize ) {
+        super.setListSize(listSize);
+    }
+
+    /**
+     * Gets the number of results before the top/center to return per page.
+     * @return The number of results before the top/center to return per page.
+     */
+    public int getBeforeCount() {
+        return super.getBeforeCount();
+    }
+
+    /**
+     * Gets the number of results after the top/center to return per page.
+     * @return The number of results after the top/center to return per page.
+     */
+    public int getAfterCount() {
+        return super.getAfterCount();
+    }
+    
+    /**
+     * Retrieves the ASN.1 BER encoded value of the LDAP control.
+     * Null is returned if the value is absent.
+     * @return A possibly null byte array representing the ASN.1 BER
+     * encoded value of the LDAP control.
+     */
+    public byte[] getEncodedValue() {
+        return getValue();
+    }     
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaMatchingRule.java
@@ -0,0 +1,235 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import java.util.*;
+
+public class SchemaMatchingRule extends SchemaElement {
+
+    
+    private static final String APPLIES = "APPLIES";    
+        
+    LDAPMatchingRuleSchema m_ldapMatchingRule;
+    
+    // Attribute IDs that are exposed through Netscape LdapJDK
+    private static String[] m_allAttrIds = {NUMERICOID, NAME, DESC, OBSOLETE, SYNTAX, APPLIES };
+    
+    LDAPConnection m_ld;
+    
+    public SchemaMatchingRule(LDAPMatchingRuleSchema ldapMatchingRule,  SchemaManager schemaManager) {
+        super(schemaManager);
+        m_ldapMatchingRule = ldapMatchingRule;
+        m_path = ATTRDEF + "/" + m_ldapMatchingRule.getName();
+    }
+
+    public SchemaMatchingRule(Attributes attrs,  SchemaManager schemaManager) throws NamingException {
+        super(schemaManager);
+        m_ldapMatchingRule = parseDefAttributes(attrs);
+        m_path = ATTRDEF + "/" + m_ldapMatchingRule.getName();
+    }    
+    
+    /**
+     * Parse Definition Attributes for a LDAP matching rule
+     */
+    static LDAPMatchingRuleSchema parseDefAttributes(Attributes attrs) throws NamingException {        
+        String name=null, oid=null, desc=null, syntax=null;
+        boolean obsolete = false;
+        Vector applies = new Vector();
+
+        for (Enumeration attrEnum = attrs.getAll(); attrEnum.hasMoreElements(); ) {
+            Attribute attr = (Attribute) attrEnum.nextElement();
+            String attrName = attr.getID();
+            if (attrName.equals(NAME)) {
+                name = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(NUMERICOID)) {
+                oid = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(SYNTAX)) {
+                syntax = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(DESC)) {
+                desc = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(APPLIES)) {
+                for (Enumeration valEnum = attr.getAll(); valEnum.hasMoreElements(); ) {
+                    applies.addElement((String)valEnum.nextElement());
+                }
+            }            
+            else if (attrName.equals(OBSOLETE)) {                     
+                obsolete = parseTrueFalseValue(attr);
+            }
+            else { 
+                throw new NamingException("Invalid schema attribute type for matching rule definition "    + attrName);
+            }
+        }    
+            
+        LDAPMatchingRuleSchema mrule = new LDAPMatchingRuleSchema(name, oid, desc, vectorToStringAry(applies), syntax);
+        
+        if (obsolete) {
+            mrule.setQualifier(OBSOLETE, "");
+        }
+        return mrule;
+    }
+    
+        
+    /**
+     * Exctract specified attributes from the ldapMatchingRule
+     */
+    Attributes extractAttributeIds(String[] attrIds) throws NamingException{
+        Attributes attrs = new BasicAttributes();
+        String val = null;
+        for (int i = 0; i < attrIds.length; i++) {
+            if (attrIds[i].equals(NUMERICOID)) {
+                val = m_ldapMatchingRule.getID();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(NUMERICOID, val));
+                }                    
+            }
+            else if (attrIds[i].equals(NAME)) {
+                val = m_ldapMatchingRule.getName();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(NAME, val));
+                }                    
+            }
+            else if (attrIds[i].equals(DESC)) {
+                val = m_ldapMatchingRule.getDescription();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(DESC, val));
+                }                    
+            }
+            else if (attrIds[i].equals(SYNTAX)) {
+                val = m_ldapMatchingRule.getSyntaxString();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(SYNTAX, val));
+                }                    
+            }
+            else if (attrIds[i].equals(APPLIES)) {
+                String[] appliesToAttrs = m_ldapMatchingRule.getAttributes();
+                if (appliesToAttrs != null && appliesToAttrs.length > 0) {
+                    BasicAttribute applies = new BasicAttribute(APPLIES);
+                    for (int a=0; a < appliesToAttrs.length; a++) {
+                        applies.add(appliesToAttrs[a]);
+                    }
+                    attrs.put(applies);
+                }    
+            }
+            else if (attrIds[i].equals(OBSOLETE)) {
+                if (m_ldapMatchingRule.getQualifier(OBSOLETE)!= null) {
+                    attrs.put(new BasicAttribute(OBSOLETE, "true"));
+                }                    
+            }
+
+            else {
+                throw new NamingException("Invalid schema attribute type for matching rule definition "    + attrIds[i]);
+            }
+        }
+        return attrs;
+    }    
+        
+        
+    /**
+     * DirContext Attribute Operations
+     */
+
+    public Attributes getAttributes(String name) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        return extractAttributeIds(m_allAttrIds);
+    }
+
+    public Attributes getAttributes(String name, String[] attrIds) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        return extractAttributeIds(attrIds);
+    }
+
+    public Attributes getAttributes(Name name) throws NamingException {
+        return getAttributes(name.toString());
+    }
+
+    public Attributes getAttributes(Name name, String[] attrIds) throws NamingException {
+        return getAttributes(name.toString(), attrIds);
+    }
+
+    public void modifyAttributes(String name, int mod_op, Attributes attrs) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        Attributes modAttrs = extractAttributeIds(m_allAttrIds);
+        modifySchemaElementAttrs(modAttrs, mod_op, attrs);
+        LDAPMatchingRuleSchema modLdapMatchingRule = parseDefAttributes(modAttrs);
+        m_schemaMgr.modifyMatchingRule(m_ldapMatchingRule, modLdapMatchingRule);
+        m_ldapMatchingRule = modLdapMatchingRule;
+    }
+
+    public void modifyAttributes(String name, ModificationItem[] mods) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        Attributes modAttrs = extractAttributeIds(m_allAttrIds);
+        modifySchemaElementAttrs(modAttrs, mods);
+        LDAPMatchingRuleSchema modLdapMatchingRule = parseDefAttributes(modAttrs);
+        m_schemaMgr.modifyMatchingRule(m_ldapMatchingRule, modLdapMatchingRule);
+        m_ldapMatchingRule = modLdapMatchingRule;
+    }
+
+    public void modifyAttributes(Name name, int mod_op, Attributes attrs) throws NamingException {
+        modifyAttributes(name.toString(), mod_op, attrs);
+    }
+
+    public void modifyAttributes(Name name, ModificationItem[] mods) throws NamingException {
+        modifyAttributes(name.toString(), mods);
+    }
+    
+    /**
+     * Search operations are not implemented because of complexity. Ir will require
+     * to implement the full LDAP search filter sematics in the client. (The search 
+     * filter sematics is implemented by the Directory server).
+     */
+
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaManager.java
@@ -0,0 +1,276 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+import netscape.ldap.*;
+import java.util.*;
+import com.netscape.jndi.ldap.common.*;
+
+/**
+ * A wrapper calss for LDAPSchema. It main purpose is to manage loading of schema
+ * on demand. The schema is loaded when accessed for the first time, or after changes
+ * to the schema have been made.
+ */
+class SchemaManager {
+
+    /**
+     * LdapJDK main schema object
+     */
+    private LDAPSchema m_schema;
+    
+    /**
+     * LDAP Connection object
+     */
+    private LDAPConnection m_ld;
+    
+    /**
+     * Flag whether schema needs to be loaded by calling fetchSchema()
+     */
+    private boolean m_isLoaded;
+    
+    /**
+     * Flag whether schema objects have been modified in the Directory (add, remove)
+     * but the change has not been propagated to the cached m_schema object
+     */
+    private boolean m_isObjectClassDirty, m_isAttributeDirty, m_isMatchingRuleDirty;
+    
+    /**
+     * Must constract with LDAP Connection
+     */
+    private SchemaManager() {}
+    
+    /**
+     * Connstructor
+     */
+    public SchemaManager(LDAPConnection ld) {
+        m_ld = ld;
+        m_isLoaded = false;
+        m_isObjectClassDirty = m_isAttributeDirty = m_isMatchingRuleDirty = false;
+    }
+    
+    /**
+     * Load the schema
+     */
+    void load() throws NamingException {
+        try {
+            m_schema = new LDAPSchema();
+            m_schema.fetchSchema(m_ld);
+            m_isLoaded = true;
+            m_isObjectClassDirty = m_isAttributeDirty = m_isMatchingRuleDirty = false;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }    
+    
+    LDAPObjectClassSchema getObjectClass(String name) throws NamingException {
+        if (!m_isLoaded || m_isObjectClassDirty) {
+            load();
+        }
+        return m_schema.getObjectClass(name);
+    }    
+
+    LDAPAttributeSchema getAttribute(String name) throws NamingException {
+        if (!m_isLoaded || m_isAttributeDirty) {
+            load();
+        }
+        return m_schema.getAttribute(name);
+    }    
+
+    LDAPMatchingRuleSchema getMatchingRule(String name) throws NamingException {
+        if (!m_isLoaded || m_isMatchingRuleDirty) {
+            load();
+        }
+        return m_schema.getMatchingRule(name);
+    }
+
+
+    Enumeration getObjectClassNames() throws NamingException {
+        if (!m_isLoaded || m_isObjectClassDirty) {
+            load();
+        }
+        return m_schema.getObjectClassNames();
+    }    
+
+    Enumeration getAttributeNames() throws NamingException {
+        if (!m_isLoaded || m_isAttributeDirty) {
+            load();
+        }
+        return m_schema.getAttributeNames();
+    }    
+
+    Enumeration getMatchingRuleNames() throws NamingException {
+        if (!m_isLoaded || m_isMatchingRuleDirty) {
+            load();
+        }
+        return m_schema.getMatchingRuleNames();
+    }
+
+    Enumeration getObjectClasses() throws NamingException {
+        if (!m_isLoaded || m_isObjectClassDirty) {
+            load();
+        }
+        return m_schema.getObjectClasses();
+    }    
+
+    Enumeration getAttributes() throws NamingException {
+        if (!m_isLoaded || m_isAttributeDirty) {
+            load();
+        }
+        return m_schema.getAttributes();
+    }    
+
+    Enumeration getMatchingRules() throws NamingException {
+        if (!m_isLoaded || m_isMatchingRuleDirty) {
+            load();
+        }
+        return m_schema.getMatchingRules();
+    }
+
+     void createObjectClass(LDAPObjectClassSchema objclass) throws NamingException {
+        try {
+            objclass.add(m_ld);
+            m_isObjectClassDirty = true;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }    
+
+    void createAttribute(LDAPAttributeSchema attr) throws NamingException {
+        try {
+            attr.add(m_ld);
+            m_isAttributeDirty = true;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }    
+
+     void createMatchingRule(LDAPMatchingRuleSchema mrule) throws NamingException {
+        try {
+            mrule.add(m_ld);
+            m_isMatchingRuleDirty = true;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+     void removeObjectClass(String name) throws NamingException {
+         LDAPObjectClassSchema objclass = getObjectClass(name);
+         
+        if (objclass == null) {
+            throw new NameNotFoundException(name);
+        }
+        
+        try {
+            objclass.remove(m_ld);
+            m_isObjectClassDirty = true;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }    
+
+    void removeAttribute(String name) throws NamingException {
+         LDAPAttributeSchema attr = getAttribute(name);
+         
+        if (attr == null) {
+            throw new NameNotFoundException(name);
+        }
+
+        try {
+            attr.remove(m_ld);
+            m_isAttributeDirty = true;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }    
+
+     void removeMatchingRule(String name) throws NamingException {
+         LDAPMatchingRuleSchema mrule = getMatchingRule(name);
+         
+        if (mrule == null) {
+            throw new NameNotFoundException(name);
+        }
+
+        try {
+            mrule.remove(m_ld);
+            m_isMatchingRuleDirty = true;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+     void modifyObjectClass(LDAPObjectClassSchema objclass, LDAPObjectClassSchema modObjClass) throws NamingException {
+        try {
+            objclass.modify(m_ld, modObjClass);
+            m_isObjectClassDirty = true;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }    
+
+    void modifyAttribute(LDAPAttributeSchema attr, LDAPAttributeSchema modAttr) throws NamingException {
+        try {
+            attr.modify(m_ld, modAttr);
+            m_isAttributeDirty = true;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }    
+
+     void modifyMatchingRule(LDAPMatchingRuleSchema mrule, LDAPMatchingRuleSchema modMRule) throws NamingException {
+        try {
+            mrule.modify(m_ld, modMRule);
+            m_isMatchingRuleDirty = true;
+        }
+        catch (LDAPException e) {
+            throw ExceptionMapper.getNamingException(e);
+        }
+    }
+
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaMatchingRuleContainer.java
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import java.util.*;
+
+public class SchemaMatchingRuleContainer extends SchemaElementContainer {
+
+    public SchemaMatchingRuleContainer(SchemaManager schemaMgr) throws NamingException{
+        super(schemaMgr, MRULEDEF);
+    }
+    
+    /**
+     * Ldap entry operations
+     */
+
+    public DirContext createSchemaElement(String name, Attributes attrs) throws NamingException {
+        if (name.length() == 0) {
+            throw new NamingException("Empty name for schema objectclass");
+        }
+        LDAPMatchingRuleSchema mrule = SchemaMatchingRule.parseDefAttributes(attrs);
+        m_schemaMgr.createMatchingRule(mrule);
+        return new SchemaMatchingRule(mrule, m_schemaMgr);
+
+    }
+
+    public void removeSchemaElement(String name) throws NamingException {
+        if (name.length() == 0) {
+            throw new NamingException("Can not delete schema object container");
+        }    
+        m_schemaMgr.removeMatchingRule(name);
+    }
+
+    /**
+     * List Operations
+     */
+
+    public NamingEnumeration getNameList(String name) throws NamingException {
+        SchemaDirContext schemaObj = (SchemaDirContext)lookup(name);
+        if (schemaObj == this) {
+            return new SchemaElementNameEnum(m_schemaMgr.getMatchingRuleNames());
+        }
+        else {
+            throw new NotContextException(name);
+        }
+    }
+
+    public NamingEnumeration getBindingsList(String name) throws NamingException {
+        SchemaDirContext schemaObj = (SchemaDirContext)lookup(name);
+        if (schemaObj == this) {
+            return new SchemaElementBindingEnum(m_schemaMgr.getMatchingRules(), m_schemaMgr);
+        }
+        else {
+            throw new NotContextException(name);
+        }
+    }
+
+    /**
+     * Lookup Operations
+     */
+
+    public Object lookupSchemaElement(String name) throws NamingException {    
+        if (name.length() == 0) {
+            return this;
+        }
+        
+        // No caching; Always create a new object
+        LDAPMatchingRuleSchema mrule = m_schemaMgr.getMatchingRule(name);
+        if (mrule == null) {
+            throw new NameNotFoundException(name);
+        }
+        return new SchemaMatchingRule(mrule, m_schemaMgr);
+
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaDirContext.java
@@ -0,0 +1,180 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+import com.netscape.jndi.ldap.common.DirContextAdapter;
+
+import java.util.*;
+
+public class SchemaDirContext extends DirContextAdapter {
+
+    public static final String CLASSDEF = "ClassDefinition";
+    public static final String ATTRDEF = "AttributeDefinition";
+    public static final String MRULEDEF = "MatchingRule";
+    
+
+    String m_path;
+
+    public void close() throws NamingException {
+        ; //NOP
+    }
+
+    /**
+     * Name operations
+     */
+
+    public String composeName(String name, String prefix) throws NamingException {
+        return name + "," + prefix;
+    }
+
+    public Name composeName(Name name, Name prefix) throws NamingException {
+        String compoundName = composeName(name.toString(), prefix.toString());
+        return SchemaNameParser.getParser().parse(compoundName);
+    }
+
+    public String getNameInNamespace() throws NamingException {
+        return new String(m_path);
+    }
+
+    public NameParser getNameParser(String name) throws NamingException {
+        return SchemaNameParser.getParser();
+    }
+
+    public NameParser getNameParser(Name name) throws NamingException {
+        return SchemaNameParser.getParser();
+    }
+
+     
+    /**
+     * Naming Bind operations
+     */
+
+    public void bind(String name, Object obj) throws NamingException {
+        if (obj instanceof DirContext) {
+            createSubcontext(name, ((DirContext)obj).getAttributes(""));
+        }
+        else {
+            throw new IllegalArgumentException("Can not bind this type of object");
+        }    
+    }
+
+    public void bind(Name name, Object obj) throws NamingException {
+        bind(name.toString(), obj);
+    }
+
+    public void rebind(String name, Object obj) throws NamingException {
+        try {
+            bind(name, obj);
+        }
+        catch (NameAlreadyBoundException ex) {
+            unbind(name);
+            bind(name, obj);
+        }
+    }
+
+    public void rebind(Name name, Object obj) throws NamingException {
+        rebind(name.toString(), obj);
+    }
+
+    public void rename(String oldName, String newName) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rename(Name oldName, Name newName) throws NamingException {
+        rename(oldName.toString(), newName.toString());
+    }
+
+    public void unbind(String name) throws NamingException {
+        // In ldap every entry is naming context
+        destroySubcontext(name);
+    }
+
+    public void unbind(Name name) throws NamingException {
+        // In ldap every entry is naming context
+        destroySubcontext(name);
+    }
+
+    /**
+     * Empty enumeration for list operations
+     */
+    class EmptyNamingEnumeration implements NamingEnumeration {
+
+        public Object next() throws NamingException{
+            throw new NoSuchElementException("EmptyNamingEnumeration");                
+        }
+
+        public Object nextElement() {
+            throw new NoSuchElementException("EmptyNamingEnumeration");                
+        }
+
+        public boolean hasMore() throws NamingException{
+            return false;
+        }
+
+        public boolean hasMoreElements() {
+            return false;
+        }
+
+        public void close() {}
+    }
+    
+    static class SchemaObjectSubordinateNamePair {
+        SchemaDirContext schemaObj;
+        String subordinateName;
+        
+        public SchemaObjectSubordinateNamePair(SchemaDirContext object, String subordinateName) {
+            this.schemaObj = object;
+            this.subordinateName = subordinateName;
+        }
+        
+        public String toString() {
+            StringBuffer str = new StringBuffer("SchemaObjectSubordinateNamePair{obj:");
+            str.append(((schemaObj == null) ? "null" : schemaObj.toString()));
+            str.append(" name:");
+            str.append(subordinateName);
+            str.append("}");
+            return str.toString();
+        }
+    }    
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaNameParser.java
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import java.util.Hashtable;
+import java.util.Properties;
+import javax.naming.*;
+
+class SchemaNameParser implements NameParser {
+
+    private static SchemaNameParser m_parser;
+    
+    // A table with compound name syntax properties
+    static Properties nameSyntax;
+    static {
+        nameSyntax = new Properties();
+        nameSyntax.put("jndi.syntax.direction", "left_to_right");
+        nameSyntax.put("jndi.syntax.separator", "/");
+        nameSyntax.put("jndi.syntax.ignorecase", "true");
+    }
+
+    // Can not be constructed
+    private SchemaNameParser() {}
+    
+    // Shared instance must be used
+    public static SchemaNameParser getParser() {
+        if (m_parser == null) {
+            m_parser = new SchemaNameParser();
+        }
+        return m_parser;
+    }
+    
+    // implements parse
+    public Name parse(String name) throws NamingException {
+        return new CompoundName(name, nameSyntax);
+    }
+    
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaElementContainer.java
@@ -0,0 +1,255 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import java.util.*;
+
+public abstract class SchemaElementContainer extends SchemaDirContext {
+
+    SchemaManager m_schemaMgr;
+    
+    public SchemaElementContainer(SchemaManager schemaMgr, String path) throws NamingException{
+        m_schemaMgr = schemaMgr;
+        m_path = path;
+    }
+    
+    /**
+     * Create a new SchemaElement. Called by craeteSubcontext
+     */
+    abstract DirContext createSchemaElement(String name, Attributes attrs) throws NamingException;
+
+    /**
+     * Delete a new SchemaElement. Called by destroySubcontext
+     */
+    abstract void removeSchemaElement(String name) throws NamingException;
+    
+    /**
+     * Return a list of names for subordinate SchemaElement. Called by list()
+     */
+    abstract NamingEnumeration getNameList(String name) throws NamingException;
+
+     /**
+     * Return a list of bindings for subordinate SchemaElement. Called by
+     * listBindings()
+     */
+    abstract NamingEnumeration getBindingsList(String name) throws NamingException;
+    
+    /**
+     * Get a SchemaElement by name
+     */
+    abstract Object lookupSchemaElement(String name) throws NamingException;
+    
+
+    /**
+     * Attribute Operations
+     */
+    public Attributes getAttributes(String name) throws NamingException {
+        
+        SchemaDirContext schemaElement = (SchemaDirContext)lookup(name);
+        if (schemaElement == this) {
+            throw new OperationNotSupportedException("No Attributes for " + m_path);
+        }
+        else {
+            return schemaElement.getAttributes("");
+        }
+    }
+
+    public Attributes getAttributes(String name, String[] attrIds) throws NamingException {
+        SchemaDirContext schemaElement = (SchemaDirContext)lookup(name);
+        if (schemaElement == this) {
+            throw new OperationNotSupportedException("No Attributes for " + m_path);
+        }
+        else {
+            return schemaElement.getAttributes("", attrIds);
+        }
+    }
+
+    public Attributes getAttributes(Name name) throws NamingException {
+        return getAttributes(name.toString());
+    }
+
+    public Attributes getAttributes(Name name, String[] attrIds) throws NamingException {
+        return getAttributes(name.toString(), attrIds);
+    }
+
+    public void modifyAttributes(String name, int mod_op, Attributes attrs) throws NamingException {
+        SchemaDirContext schemaElement = (SchemaDirContext)lookup(name);
+        if (schemaElement == this) {
+            throw new OperationNotSupportedException("No Attributes for " + m_path);
+        }
+        else {
+            schemaElement.modifyAttributes("", mod_op, attrs);
+        }
+    }
+
+    public void modifyAttributes(String name, ModificationItem[] mods) throws NamingException {
+        SchemaDirContext schemaElement = (SchemaDirContext)lookup(name);
+        if (schemaElement == this) {
+            throw new OperationNotSupportedException("No Attributes for " + m_path);
+        }
+        else {
+            schemaElement.modifyAttributes("", mods);
+        }
+    }
+
+    public void modifyAttributes(Name name, int mod_op, Attributes attrs) throws NamingException {
+        modifyAttributes(name.toString(), mod_op, attrs);
+    }
+
+    public void modifyAttributes(Name name, ModificationItem[] mods) throws NamingException {
+        modifyAttributes(name.toString(), mods);
+    }
+
+    /**
+     * Ldap entry operations
+     */
+
+    public Context createSubcontext(String name) throws NamingException {
+        // Directory entry must have attributes
+        throw new OperationNotSupportedException();
+    }
+
+    public Context createSubcontext(Name name) throws NamingException {
+        // Directory entry must have attributes
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext createSubcontext(String name, Attributes attrs) throws NamingException {
+        return createSchemaElement(name, attrs);
+    }
+
+    public DirContext createSubcontext(Name name, Attributes attrs) throws NamingException {
+        return createSubcontext(name.toString(), attrs);
+    }
+
+    public void destroySubcontext(String name) throws NamingException {
+        removeSchemaElement(name);
+    }
+
+    public void destroySubcontext(Name name) throws NamingException {
+        destroySubcontext(name.toString());
+    }
+
+    /**
+     * Naming Bind operations
+     */
+
+    public void bind(String name, Object obj) throws NamingException {
+        if (obj instanceof DirContext) {
+            createSubcontext(name, ((DirContext)obj).getAttributes(""));
+        }
+        else {
+            throw new IllegalArgumentException("Can not bind this type of object");
+        }    
+    }
+
+    public void bind(Name name, Object obj) throws NamingException {
+        bind(name.toString(), obj);
+    }
+
+    public void rebind(String name, Object obj) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rebind(Name name, Object obj) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rename(String oldName, String newName) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rename(Name oldName, Name newName) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void unbind(String name) throws NamingException {
+        destroySubcontext(name);
+    }
+
+    public void unbind(Name name) throws NamingException {
+        destroySubcontext(name);
+    }
+
+    /**
+     * List Operations
+     */
+
+    public NamingEnumeration list(String name) throws NamingException {
+        return getNameList(name);
+    }
+
+    public NamingEnumeration list(Name name) throws NamingException {
+        return list(name.toString());
+    }
+
+    public NamingEnumeration listBindings(String name) throws NamingException {
+        return getBindingsList(name);
+    }
+
+    public NamingEnumeration listBindings(Name name) throws NamingException {
+        return listBindings(name.toString());
+    }
+
+    /**
+     * Lookup Operations
+     */
+
+    public Object lookup(String name) throws NamingException {    
+        return lookupSchemaElement(name);
+    }
+
+    public Object lookup(Name name) throws NamingException {
+        return lookup(name.toString());
+    }
+
+    public Object lookupLink(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Object lookupLink(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaElementBindingEnum.java
@@ -0,0 +1,93 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+
+import java.util.*;
+
+class SchemaElementBindingEnum implements NamingEnumeration {
+
+    /**
+     * Enumeration of schema name-object bindings packaged into Binding object.
+     */
+    Enumeration m_schemaElementEnum;
+    
+    SchemaManager m_schemaMgr;
+
+    static final String _className = "javax.naming.directory.DirContext"; // for class name is bindings
+
+    public SchemaElementBindingEnum(Enumeration schemaElementEnum, SchemaManager schemaMgr) {
+        m_schemaElementEnum = schemaElementEnum;
+        m_schemaMgr = schemaMgr;
+    }
+
+    public Object next() throws NamingException{
+        return nextElement();
+    }
+
+    public Object nextElement() {
+        DirContext obj = null;
+        LDAPSchemaElement schemaElement = (LDAPSchemaElement) m_schemaElementEnum.nextElement();
+        if (schemaElement instanceof LDAPObjectClassSchema) {
+            obj = new SchemaObjectClass((LDAPObjectClassSchema) schemaElement, m_schemaMgr);
+        }
+        else if (schemaElement instanceof LDAPAttributeSchema) {
+            obj = new SchemaAttribute((LDAPAttributeSchema) schemaElement, m_schemaMgr);
+        }
+        else if (schemaElement instanceof LDAPMatchingRuleSchema) {
+            obj = new SchemaMatchingRule((LDAPMatchingRuleSchema) schemaElement, m_schemaMgr);
+        }
+        return new Binding(schemaElement.getName(), _className, obj, /*isRelative=*/true);
+    }
+
+    public boolean hasMore() throws NamingException{
+        return m_schemaElementEnum.hasMoreElements();
+    }
+
+    public boolean hasMoreElements() {
+        return m_schemaElementEnum.hasMoreElements();
+    }
+
+    public void close() {}
+}
+
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaElement.java
@@ -0,0 +1,266 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import java.util.*;
+
+public class SchemaElement extends SchemaDirContext {
+
+    SchemaManager m_schemaMgr;
+    
+    // Attributes used to define schema elements
+    static final String NUMERICOID = "NUMERICOID";
+    static final String NAME = "NAME";
+    static final String DESC = "DESC";
+    static final String SYNTAX = "SYNTAX";
+    static final String SUP = "SUP";
+    static final String MUST = "MUST";
+    static final String MAY = "MAY";    
+    static final String SINGLEVALUE = "SINGLE-VALUE";
+        
+    // These attribute definition properties are  not supported by LdapJDK and DS
+    // Accept them for the appropriate schema element, but ignore them
+    static final String OBSOLETE = "OBSOLETE";    
+    static final String EQUALITY = "EQUALITY";
+    static final String ORDERING = "ORDERING";
+    static final String SUBSTRING = "SUBSTRING";
+    static final String COLLECTIVE = "COLLECTIVE";
+    static final String NOUSERMOD = "NO-USER-MODIFICATION";
+    static final String USAGE = "USAGE";
+    static final String ABSTRACT = "ABSTRACT";
+    static final String STRUCTURAL = "STRUCTURAL";
+    static final String AUXILIARY = "AUXILIARY";
+    
+
+    // Syntax string recognized by Netscape LdapJDK
+    static final String cisString       = "1.3.6.1.4.1.1466.115.121.1.15";
+    static final String binaryString    = "1.3.6.1.4.1.1466.115.121.1.5";
+    static final String telephoneString = "1.3.6.1.4.1.1466.115.121.1.50";
+    static final String cesString       = "1.3.6.1.4.1.1466.115.121.1.26";
+    static final String intString       = "1.3.6.1.4.1.1466.115.121.1.27";
+    static final String dnString        = "1.3.6.1.4.1.1466.115.121.1.12";
+    
+    SchemaElement(SchemaManager schemaMgr) {
+        m_schemaMgr = schemaMgr;
+    }    
+    
+    /**
+     * Map a syntax oid string to a constant recognized by LdapJDK
+     */
+    static int syntaxStringToInt(String syntax) throws NamingException{
+        if (syntax.equals(cisString)) {
+            return LDAPSchemaElement.cis;
+        }
+        else if (syntax.equals(cesString)) {
+            return LDAPSchemaElement.ces;
+        }
+        else if (syntax.equals(telephoneString)) {
+            return LDAPSchemaElement.telephone;
+        }
+        else if (syntax.equals(intString)) {
+            return LDAPSchemaElement.integer;
+        }
+        else if (syntax.equals(dnString)) {
+            return LDAPSchemaElement.dn;
+        }
+        else if (syntax.equals(binaryString)) {
+            return LDAPSchemaElement.binary;
+        }
+        else {
+            throw new InvalidAttributeValueException(syntax);
+        }    
+    }    
+
+    /**
+     * Map a syntax identifier to a oid string
+     */
+    static String syntaxIntToString(int syntax) throws NamingException{
+        if (syntax == LDAPSchemaElement.cis) {
+            return cisString;
+        }
+        else if (syntax == LDAPSchemaElement.ces) {
+            return cesString;
+        }
+        else if (syntax == LDAPSchemaElement.telephone) {
+            return telephoneString;
+        }
+        else if (syntax == LDAPSchemaElement.integer) {
+            return intString;
+        }
+        else if (syntax == LDAPSchemaElement.dn) {
+            return dnString;
+        }
+        else if (syntax == LDAPSchemaElement.binary) {
+            return binaryString;
+        }
+        else {
+            throw new InvalidAttributeValueException("Interanal error, unexpected syntax value " + syntax);
+        }    
+    }    
+
+    /**
+     * Convert string vector to an array
+     */
+    static String[] vectorToStringAry(Vector v) {
+        String[] ary = new String[v.size()];
+        for(int i=0; i<v.size(); i++) {
+            ary[i] = (String) v.elementAt(i);
+        }
+        return ary;
+    }
+
+    /**
+     * List Operations
+     */
+
+    public NamingEnumeration list(String name) throws NamingException {
+        return new EmptyNamingEnumeration();
+    }
+
+    public NamingEnumeration list(Name name) throws NamingException {
+        return new EmptyNamingEnumeration();
+    }
+
+    public NamingEnumeration listBindings(String name) throws NamingException {
+        return new EmptyNamingEnumeration();
+    }
+
+    public NamingEnumeration listBindings(Name name) throws NamingException {
+        return new EmptyNamingEnumeration();
+    }
+
+    /**
+     * Modify the current set of the schema element's attributes
+     */
+    void modifySchemaElementAttrs (Attributes attrs, ModificationItem[] jndiMods) throws NamingException{
+        LDAPModificationSet mods = new LDAPModificationSet();
+        for (int i=0; i < jndiMods.length; i++) {
+            int modop = jndiMods[i].getModificationOp();
+            Attribute attr = jndiMods[i].getAttribute();
+            Attributes modAttrs = new BasicAttributes(/*ignorecase=*/true);
+            modAttrs.put(attr);
+            modifySchemaElementAttrs(attrs, modop, modAttrs);
+        }
+    }
+
+    /**
+     * Modify the current set of the schema element's attributes
+     */
+    void modifySchemaElementAttrs (Attributes attrs, int modop, Attributes modAttrs) throws NamingException{
+        LDAPModificationSet mods = new LDAPModificationSet();
+        for (NamingEnumeration attrEnum = modAttrs.getAll(); attrEnum.hasMore();) {
+            Attribute attr = (Attribute)attrEnum.next();
+            if (modop == DirContext.ADD_ATTRIBUTE) {
+                Attribute curAttr = attrs.get(attr.getID());
+                if (curAttr == null) {
+                    attrs.put(attr);
+                }
+                else {
+                    for (NamingEnumeration vals = attr.getAll(); vals.hasMore();) {
+                        curAttr.add(vals.nextElement());
+                    }
+                }
+            }
+            else if (modop == DirContext.REPLACE_ATTRIBUTE) {
+                attrs.put(attr);
+            }    
+            else if (modop == DirContext.REMOVE_ATTRIBUTE) {
+                Attribute curAttr = attrs.get(attr.getID());
+                if (curAttr == null) {
+                    throw new NoSuchAttributeException(attr.getID());
+                }
+                else if (attr.size() == 0) { // remove the attr
+                    attrs.remove(attr.getID());
+                }    
+                else {
+                    for (NamingEnumeration vals = attr.getAll(); vals.hasMore();) {
+                        String val = (String) vals.nextElement();
+                        curAttr.remove(val);
+                        // Schema definition Values are case insensitive 
+                        curAttr.remove(val.toLowerCase());
+                    }
+                    if (curAttr.size() == 0) { // remove attr if no values left
+                        attrs.remove(attr.getID());
+                    }    
+                }                
+            }
+            else {
+                throw new IllegalArgumentException("Illegal Attribute Modification Operation");
+            }
+        }
+    }         
+
+    /**
+     * Parse value for a schema attribute. Return true if the value is
+     * "true", return false if the value is "false" or absent
+     */
+    static boolean parseTrueFalseValue(Attribute attr) throws NamingException{
+        
+        for (NamingEnumeration valEnum = attr.getAll(); valEnum.hasMore(); ) {
+            String flag = (String)valEnum.nextElement();
+            if (flag.equals("true")) {
+                return true;
+            }
+            else if (flag.equals("false")) {
+                return false;
+            }
+            else {
+                throw new InvalidAttributeValueException(attr.getID() +
+                          " value must be \"true\", \"false\" or absent");
+            }
+        }
+        return false; // no values
+    }
+    
+    /**
+     * Read a string value for a schema attribute
+     */
+    static String getSchemaAttrValue(Attribute attr) throws NamingException {
+        for (Enumeration valEnum = attr.getAll(); valEnum.hasMoreElements(); ) {
+            return (String)valEnum.nextElement();
+        }
+        throw new InvalidAttributeValueException(attr.getID() + " must have a value");
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaObjectClassContainer.java
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import java.util.*;
+
+public class SchemaObjectClassContainer extends SchemaElementContainer {
+
+    public SchemaObjectClassContainer(SchemaManager schemaMgr) throws NamingException{
+        super(schemaMgr, CLASSDEF);
+    }
+    
+    /**
+     * Ldap entry operations
+     */
+
+    public DirContext createSchemaElement(String name, Attributes attrs) throws NamingException {
+        if (name.length() == 0) {
+            throw new NamingException("Empty name for schema objectclass");
+        }
+        LDAPObjectClassSchema objclass = SchemaObjectClass.parseDefAttributes(attrs);
+        m_schemaMgr.createObjectClass(objclass);
+        return new SchemaObjectClass(objclass, m_schemaMgr);
+
+    }
+
+    public void removeSchemaElement(String name) throws NamingException {
+        if (name.length() == 0) {
+            throw new NamingException("Can not delete schema object container");
+        }    
+        m_schemaMgr.removeObjectClass(name);
+    }
+
+    /**
+     * List Operations
+     */
+
+    public NamingEnumeration getNameList(String name) throws NamingException {
+        SchemaDirContext schemaObj = (SchemaDirContext)lookup(name);
+        if (schemaObj == this) {
+            return new SchemaElementNameEnum(m_schemaMgr.getObjectClassNames());
+        }
+        else {
+            throw new NotContextException(name);
+        }
+    }
+
+    public NamingEnumeration getBindingsList(String name) throws NamingException {
+        SchemaDirContext schemaObj = (SchemaDirContext)lookup(name);
+        if (schemaObj == this) {
+            return new SchemaElementBindingEnum(m_schemaMgr.getObjectClasses(), m_schemaMgr);
+        }
+        else {
+            throw new NotContextException(name);
+        }
+    }
+
+    /**
+     * Lookup Operations
+     */
+
+    public Object lookupSchemaElement(String name) throws NamingException {    
+        if (name.length() == 0) {
+            return this;
+        }
+        
+        // No caching; Always create a new object
+        LDAPObjectClassSchema objclass = m_schemaMgr.getObjectClass(name);
+        if (objclass == null) {
+            throw new NameNotFoundException(name);
+        }
+        return new SchemaObjectClass(objclass, m_schemaMgr);
+
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaElementNameEnum.java
@@ -0,0 +1,80 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+
+import java.util.*;
+
+class SchemaElementNameEnum implements NamingEnumeration {
+
+    /**
+     * Enumeration of schema object names packaged into NameClassPair.
+     * The class in NameClassPair is DirContext
+     */
+    Enumeration m_nameEnum; 
+    
+    static final String _className = "javax.naming.directory.DirContext"; // for class name is bindings";
+
+    public SchemaElementNameEnum(Enumeration nameEnum) {
+        m_nameEnum = nameEnum;
+    }
+
+    public Object next() throws NamingException{
+        return nextElement();
+    }
+
+    public Object nextElement() {
+        String name = (String) m_nameEnum.nextElement();
+        return new NameClassPair(name, _className, /*isRelative=*/true);
+    }
+
+    public boolean hasMore() throws NamingException{
+        return m_nameEnum.hasMoreElements();
+    }
+
+    public boolean hasMoreElements() {
+        return m_nameEnum.hasMoreElements();
+    }
+
+    public void close() {}
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaAttribute.java
@@ -0,0 +1,307 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import java.util.*;
+
+public class SchemaAttribute extends SchemaElement {
+
+    LDAPAttributeSchema m_ldapAttribute;
+    
+    // Attribute IDs that are exposed through Netscape LdapJDK
+    private static String[] m_allAttrIds = {NUMERICOID, NAME, DESC, OBSOLETE,
+                                            SUP, EQUALITY, ORDERING, SUBSTRING,
+                                            SYNTAX, SINGLEVALUE, COLLECTIVE,
+                                            NOUSERMOD, USAGE
+    };
+    
+    public SchemaAttribute(LDAPAttributeSchema ldapAttribute, SchemaManager schemaManager) {
+        super(schemaManager);
+        m_ldapAttribute = ldapAttribute;
+        m_path = ATTRDEF + "/" + m_ldapAttribute.getName();
+    }
+
+    public SchemaAttribute(Attributes attrs,  SchemaManager schemaManager) throws NamingException {
+        super(schemaManager);        
+        m_ldapAttribute = parseDefAttributes(attrs);
+        m_path = ATTRDEF + "/" + m_ldapAttribute.getName();
+    }    
+    
+    /**
+     * Parse Definition Attributes for a LDAP attribute
+     */
+    static LDAPAttributeSchema parseDefAttributes(Attributes attrs) throws NamingException {        
+        String name=null, oid=null, desc=null, syntax=null, usage=null, sup=null;
+        String equality=null, ordering=null, substring=null;
+        boolean singleValued=false, collective=false, obsolete=false, noUserMod=false;
+
+        for (Enumeration attrEnum = attrs.getAll(); attrEnum.hasMoreElements(); ) {
+            Attribute attr = (Attribute) attrEnum.nextElement();
+            String attrName = attr.getID();
+            if (attrName.equals(NAME)) {
+                name = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(NUMERICOID)) {
+                oid = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(SYNTAX)) {
+                syntax = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(DESC)) {
+                desc = getSchemaAttrValue(attr);
+            }            
+            else if (attrName.equals(SINGLEVALUE)) {
+                singleValued = parseTrueFalseValue(attr);
+            }            
+            else if (attrName.equals(SUP)) {
+                sup = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(USAGE)) {
+                usage = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(OBSOLETE)) {
+                obsolete = parseTrueFalseValue(attr);
+            }
+            else if (attrName.equals(COLLECTIVE)) {
+                collective = parseTrueFalseValue(attr);
+            }
+            else if (attrName.equals(NOUSERMOD)) {
+                noUserMod = parseTrueFalseValue(attr);
+            }
+            else if (attrName.equals(EQUALITY)) {
+                equality = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(ORDERING)) {
+                ordering = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(SUBSTRING)) {
+                substring = getSchemaAttrValue(attr);
+            }
+
+            else { 
+                throw new NamingException("Invalid schema attribute type for attribute definition "    + attrName);
+            }
+        }    
+            
+        LDAPAttributeSchema attrSchema = new LDAPAttributeSchema(name, oid, desc, syntax, singleValued, sup, null);
+        
+        if (obsolete) {
+            attrSchema.setQualifier(OBSOLETE, "");
+        }            
+        if (collective) {
+            attrSchema.setQualifier(COLLECTIVE, "");
+        }            
+        if (noUserMod) {
+            attrSchema.setQualifier(NOUSERMOD, "");
+        }            
+        if (equality != null) {
+            attrSchema.setQualifier(EQUALITY, equality);
+        }            
+        if (ordering != null) {
+            attrSchema.setQualifier(ORDERING, ordering);
+        }            
+        if (substring != null) {
+            attrSchema.setQualifier(SUBSTRING, substring);
+        }            
+        if (usage != null) {
+            attrSchema.setQualifier(USAGE, usage);
+        } 
+        
+        return attrSchema;
+    }
+    
+        
+    /**
+     * Exctract specified attributes from the ldapObjectClass
+     */
+    Attributes extractAttributeIds(String[] attrIds) throws NamingException{
+        Attributes attrs = new BasicAttributes();
+        String val = null, multiVal[]=null;
+        for (int i = 0; i < attrIds.length; i++) {
+            if (attrIds[i].equals(NUMERICOID)) {
+                val = m_ldapAttribute.getID();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(NUMERICOID, val));
+                }                    
+            }
+            else if (attrIds[i].equals(NAME)) {
+                val = m_ldapAttribute.getName();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(NAME, val));
+                }                    
+            }
+            else if (attrIds[i].equals(DESC)) {
+                val = m_ldapAttribute.getDescription();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(DESC, val));
+                }                    
+            }
+            else if (attrIds[i].equals(SYNTAX)) {
+                val = m_ldapAttribute.getSyntaxString();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(SYNTAX, val));
+                }                    
+            }
+            else if (attrIds[i].equals(SINGLEVALUE)) {
+                if (m_ldapAttribute.isSingleValued()) {
+                    attrs.put(new BasicAttribute(SINGLEVALUE, "true"));
+                }
+            }
+            else if (attrIds[i].equals(SUP)) {
+                val = m_ldapAttribute.getSuperior();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(SUP, val));
+                }                    
+            }
+            else if (attrIds[i].equals(USAGE)) {
+                multiVal = m_ldapAttribute.getQualifier(USAGE);
+                if (multiVal != null) {
+                    attrs.put(new BasicAttribute(USAGE, multiVal));
+                }                    
+            }
+            else if (attrIds[i].equals(OBSOLETE)) {
+                if (m_ldapAttribute.getQualifier(OBSOLETE) != null) {
+                    attrs.put(new BasicAttribute(OBSOLETE, "true"));
+                }
+            }
+            else if (attrIds[i].equals(COLLECTIVE)) {
+                if (m_ldapAttribute.getQualifier(COLLECTIVE) != null) {
+                    attrs.put(new BasicAttribute(COLLECTIVE, "true"));
+                }
+            }
+            else if (attrIds[i].equals(NOUSERMOD)) {
+                if (m_ldapAttribute.getQualifier(NOUSERMOD) != null) {
+                    attrs.put(new BasicAttribute(NOUSERMOD, "true"));
+                }
+            }
+            else if (attrIds[i].equals(EQUALITY)) {
+                multiVal = m_ldapAttribute.getQualifier(EQUALITY);
+                if (multiVal != null) {
+                    attrs.put(new BasicAttribute(EQUALITY, multiVal));
+                }
+            }
+            else if (attrIds[i].equals(ORDERING)) {
+                multiVal = m_ldapAttribute.getQualifier(ORDERING);
+                if (multiVal != null) {
+                    attrs.put(new BasicAttribute(ORDERING, multiVal));
+                }
+            }
+            else if (attrIds[i].equals(SUBSTRING)) {
+                multiVal = m_ldapAttribute.getQualifier(SUBSTRING);
+                if (multiVal != null) {
+                    attrs.put(new BasicAttribute(SUBSTRING, multiVal));
+                }
+            }
+            else { 
+                throw new NamingException("Invalid schema attribute type for attribute definition "    + attrIds[i]);
+            }
+        }
+        return attrs;
+    }    
+        
+        
+    /**
+     * DirContext Attribute Operations
+     */
+
+    public Attributes getAttributes(String name) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        return extractAttributeIds(m_allAttrIds);
+    }
+
+    public Attributes getAttributes(String name, String[] attrIds) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        return extractAttributeIds(attrIds);
+    }
+
+    public Attributes getAttributes(Name name) throws NamingException {
+        return getAttributes(name.toString());
+    }
+
+    public Attributes getAttributes(Name name, String[] attrIds) throws NamingException {
+        return getAttributes(name.toString(), attrIds);
+    }
+
+    public void modifyAttributes(String name, int mod_op, Attributes attrs) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        Attributes modAttrs = extractAttributeIds(m_allAttrIds);
+        modifySchemaElementAttrs(modAttrs, mod_op, attrs);
+        LDAPAttributeSchema modLdapAttribute = parseDefAttributes(modAttrs);
+        m_schemaMgr.modifyAttribute(m_ldapAttribute, modLdapAttribute);
+        m_ldapAttribute = modLdapAttribute;
+    }
+
+    public void modifyAttributes(String name, ModificationItem[] mods) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        Attributes modAttrs = extractAttributeIds(m_allAttrIds);
+        modifySchemaElementAttrs(modAttrs, mods);
+        LDAPAttributeSchema modLdapAttribute = parseDefAttributes(modAttrs);
+        m_schemaMgr.modifyAttribute(m_ldapAttribute, modLdapAttribute);
+        m_ldapAttribute = modLdapAttribute;
+    }
+
+    public void modifyAttributes(Name name, int mod_op, Attributes attrs) throws NamingException {
+        modifyAttributes(name.toString(), mod_op, attrs);
+    }
+
+    public void modifyAttributes(Name name, ModificationItem[] mods) throws NamingException {
+        modifyAttributes(name.toString(), mods);
+    }
+    
+    /**
+     * Search operations are not implemented because of complexity. Ir will require
+     * to implement the full LDAP search filter sematics in the client. (The search 
+     * filter sematics is implemented by the Directory server).
+     */
+    
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaAttributeContainer.java
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import java.util.*;
+
+public class SchemaAttributeContainer extends SchemaElementContainer {
+
+    public SchemaAttributeContainer(SchemaManager schemaMgr) throws NamingException{
+        super(schemaMgr, ATTRDEF);
+    }
+    
+    /**
+     * Ldap entry operations
+     */
+
+    public DirContext createSchemaElement(String name, Attributes attrs) throws NamingException {
+        if (name.length() == 0) {
+            throw new NamingException("Empty name for schema objectclass");
+        }
+        LDAPAttributeSchema attr = SchemaAttribute.parseDefAttributes(attrs);
+        m_schemaMgr.createAttribute(attr);
+        return new SchemaAttribute(attr, m_schemaMgr);
+
+    }
+
+    public void removeSchemaElement(String name) throws NamingException {
+        if (name.length() == 0) {
+            throw new NamingException("Can not delete schema object container");
+        }
+        m_schemaMgr.removeAttribute(name);
+    }
+
+    /**
+     * List Operations
+     */
+
+    public NamingEnumeration getNameList(String name) throws NamingException {
+        SchemaDirContext schemaObj = (SchemaDirContext)lookup(name);
+        if (schemaObj == this) {
+            return new SchemaElementNameEnum(m_schemaMgr.getAttributeNames());
+        }
+        else {
+            throw new NotContextException(name);
+        }
+    }
+
+    public NamingEnumeration getBindingsList(String name) throws NamingException {
+        SchemaDirContext schemaObj = (SchemaDirContext)lookup(name);
+        if (schemaObj == this) {
+            return new SchemaElementBindingEnum(m_schemaMgr.getAttributes(), m_schemaMgr);
+        }
+        else {
+            throw new NotContextException(name);
+        }
+    }
+
+    /**
+     * Lookup Operations
+     */
+
+    public Object lookupSchemaElement(String name) throws NamingException {    
+        if (name.length() == 0) {
+            return this;
+        }
+        
+        // No caching; Always create a new object
+        LDAPAttributeSchema attr = m_schemaMgr.getAttribute(name);
+        if (attr == null) {
+            throw new NameNotFoundException(name);
+        }
+        return new SchemaAttribute(attr, m_schemaMgr);
+
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaRoot.java
@@ -0,0 +1,380 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import java.util.*;
+
+public class SchemaRoot extends SchemaDirContext {
+
+    static final String m_className = "javax.naming.directory.DirContext"; // for class name is bindings
+    
+    SchemaDirContext m_classContainer, m_attrContainer, m_matchRuleContainer;
+    
+    SchemaManager m_schemaMgr;
+    
+    public SchemaRoot(LDAPConnection ld) throws NamingException{
+        m_path = "";
+        m_schemaMgr = new SchemaManager(ld);
+        m_classContainer = new SchemaObjectClassContainer(m_schemaMgr);
+        m_attrContainer = new SchemaAttributeContainer(m_schemaMgr);
+        m_matchRuleContainer = new SchemaMatchingRuleContainer(m_schemaMgr);
+    }
+
+    SchemaObjectSubordinateNamePair resolveSchemaObject(String name) throws NamingException{
+        
+        SchemaDirContext obj = null;
+        
+        if (name.length() == 0) {
+            obj = this;
+        }
+        else if (name.startsWith(CLASSDEF) || name.startsWith(CLASSDEF.toLowerCase())) {
+            name = name.substring(CLASSDEF.length());
+            obj = m_classContainer;
+        }    
+        else if (name.startsWith(ATTRDEF) || name.startsWith(ATTRDEF.toLowerCase())) {
+            name = name.substring(ATTRDEF.length());
+            obj = m_attrContainer;
+        }    
+        else if (name.startsWith(MRULEDEF) || name.startsWith(MRULEDEF.toLowerCase())) {
+            name = name.substring(MRULEDEF.length());
+            obj = m_matchRuleContainer;
+            
+        }
+        else {
+            throw new NameNotFoundException(name);
+        }
+        
+        if (name.length() > 1 && name.startsWith("/")) {
+            name = name.substring(1);
+        }    
+        return new SchemaObjectSubordinateNamePair(obj, name);
+    }    
+    
+
+    /**
+     * Attribute Operations
+     */
+
+    public Attributes getAttributes(String name) throws NamingException {
+        SchemaObjectSubordinateNamePair objNamePair = resolveSchemaObject(name);        
+        if (objNamePair.schemaObj == this) {
+            throw new OperationNotSupportedException();
+        }
+        else {
+            return objNamePair.schemaObj.getAttributes(objNamePair.subordinateName);
+        }
+    }
+
+    public Attributes getAttributes(String name, String[] attrIds) throws NamingException {
+        SchemaObjectSubordinateNamePair objNamePair = resolveSchemaObject(name);        
+        if (objNamePair.schemaObj == this) {
+            throw new OperationNotSupportedException();
+        }
+        else {
+            return objNamePair.schemaObj.getAttributes(objNamePair.subordinateName, attrIds);
+        }
+    }
+
+    public Attributes getAttributes(Name name) throws NamingException {
+        return getAttributes(name.toString());
+    }
+
+    public Attributes getAttributes(Name name, String[] attrIds) throws NamingException {
+        return getAttributes(name.toString(), attrIds);
+    }
+
+    public void modifyAttributes(String name, int mod_op, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void modifyAttributes(String name, ModificationItem[] mods) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void modifyAttributes(Name name, int mod_op, Attributes attrs) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void modifyAttributes(Name name, ModificationItem[] mods) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    /**
+     * Ldap entry operations
+     */
+
+    public Context createSubcontext(String name) throws NamingException {
+        // Directory entry must have attributes
+        throw new OperationNotSupportedException();
+    }
+
+    public Context createSubcontext(Name name) throws NamingException {
+        // Directory entry must have attributes
+        throw new OperationNotSupportedException();
+    }
+
+    public DirContext createSubcontext(String name, Attributes attrs) throws NamingException {
+        SchemaObjectSubordinateNamePair objNamePair = resolveSchemaObject(name);
+        if (objNamePair.schemaObj == this) {
+            throw new OperationNotSupportedException();
+        }
+        else {
+            return objNamePair.schemaObj.createSubcontext(objNamePair.subordinateName, attrs);
+        }
+    }
+
+    public DirContext createSubcontext(Name name, Attributes attrs) throws NamingException {
+        return createSubcontext(name.toString(), attrs);
+    }
+
+    public void destroySubcontext(String name) throws NamingException {
+        SchemaObjectSubordinateNamePair objNamePair = resolveSchemaObject(name);
+        if (objNamePair.schemaObj == this) {
+            throw new OperationNotSupportedException();
+        }
+        else {
+            objNamePair.schemaObj.destroySubcontext(objNamePair.subordinateName);
+        }
+    }
+
+    public void destroySubcontext(Name name) throws NamingException {
+        destroySubcontext(name.toString());
+    }
+
+    /**
+     * Naming Bind operations
+     */
+
+    public void bind(String name, Object obj) throws NamingException {
+        if (obj instanceof DirContext) {
+            createSubcontext(name, ((DirContext)obj).getAttributes(""));
+        }
+        else {
+            throw new IllegalArgumentException("Can not bind this type of object");
+        }    
+    }
+
+    public void bind(Name name, Object obj) throws NamingException {
+        bind(name.toString(), obj);
+    }
+
+    public void rebind(String name, Object obj) throws NamingException {
+        unbind(name);
+        bind(name, obj);
+    }
+
+    public void rebind(Name name, Object obj) throws NamingException {
+        rebind(name.toString(), obj);
+    }
+
+    public void rename(String oldName, String newName) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public void rename(Name oldName, Name newName) throws NamingException {
+        rename(oldName.toString(), newName.toString());
+    }
+
+    public void unbind(String name) throws NamingException {
+        // In ldap every entry is naming context
+        destroySubcontext(name);
+    }
+
+    public void unbind(Name name) throws NamingException {
+        // In ldap every entry is naming context
+        destroySubcontext(name);
+    }
+
+    /**
+     * List Operations
+     */
+
+    public NamingEnumeration list(String name) throws NamingException {
+        SchemaObjectSubordinateNamePair objNamePair = resolveSchemaObject(name);
+        if (objNamePair.schemaObj == this) {
+            return new SchemaRootNameClassPairEnum();
+        }
+        else {
+            return objNamePair.schemaObj.list(objNamePair.subordinateName);
+        }
+    }
+
+    public NamingEnumeration list(Name name) throws NamingException {
+        return list(name.toString());
+    }
+
+    public NamingEnumeration listBindings(String name) throws NamingException {
+        SchemaObjectSubordinateNamePair objNamePair = resolveSchemaObject(name);
+        if (objNamePair.schemaObj == this) {
+            return new SchemaRootBindingEnum();
+        }
+        else {
+            return objNamePair.schemaObj.listBindings(objNamePair.subordinateName);
+        }
+
+    }
+
+    public NamingEnumeration listBindings(Name name) throws NamingException {
+        return listBindings(name.toString());
+    }
+
+    /**
+     * Lookup Operations
+     */
+
+    public Object lookup(String name) throws NamingException {
+        SchemaObjectSubordinateNamePair objNamePair = resolveSchemaObject(name);
+        if (objNamePair.schemaObj == this) {
+            return this;
+        }
+        else {
+            return objNamePair.schemaObj.lookup(objNamePair.subordinateName);
+        }
+
+    }
+
+    public Object lookup(Name name) throws NamingException {
+        return lookup(name.toString());
+    }
+
+    public Object lookupLink(String name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    public Object lookupLink(Name name) throws NamingException {
+        throw new OperationNotSupportedException();
+    }
+
+    /**
+     * Test program
+     */
+    public static void main(String args[]) {
+        try {
+            String name = args[0];
+            System.out.println((new SchemaRoot(null)).resolveSchemaObject(name));
+        }
+        catch (Exception e) {
+            System.err.println(e);
+        }    
+    }
+    
+    /**
+     * NamigEnumeration of NameClassPairs
+     */
+    class SchemaRootNameClassPairEnum implements NamingEnumeration {
+
+        private int m_idx = -1;
+
+        public Object next() {
+            return nextElement();
+        }
+
+        public Object nextElement() {
+            m_idx++;
+            if (m_idx == 0 ) {
+                return new NameClassPair(CLASSDEF, m_className);
+            }
+            else if (m_idx == 1) {
+                return new NameClassPair(ATTRDEF, m_className);
+            }
+            else if (m_idx == 2) {
+                return new NameClassPair(MRULEDEF, m_className);
+            }
+            else {
+                throw new NoSuchElementException("SchemaRootEnumerator");
+            }    
+                
+        }
+
+        public boolean hasMore() {
+            return hasMoreElements();
+        }
+
+        public boolean hasMoreElements() {
+            return m_idx < 2;
+        }
+
+        public void close() {}
+    }
+
+    /**
+     * NamingEnumeration of Bindings
+     */
+    class SchemaRootBindingEnum implements NamingEnumeration {
+
+        private int m_idx = -1;
+
+        public Object next() {
+            return nextElement();
+        }
+
+        public Object nextElement() {
+            m_idx++;
+            if (m_idx == 0 ) {
+                return new Binding(CLASSDEF, m_className, m_classContainer);
+            }
+            else if (m_idx == 1) {
+                return new Binding(ATTRDEF, m_className, m_attrContainer);
+            }
+            else if (m_idx == 2) {
+                return new Binding(MRULEDEF, m_className, m_matchRuleContainer);
+            }
+            else {
+                throw new NoSuchElementException("SchemaRootEnumerator");
+            }    
+                
+        }
+
+        public boolean hasMore() {
+            return hasMoreElements();
+        }
+
+        public boolean hasMoreElements() {
+            return m_idx < 2;
+        }
+
+        public void close() {}
+    }
+}
--- /dev/null
+++ ldapjdk-4.18/mozilla/directory/java-sdk/src/com/netscape/jndi/ldap/schema/SchemaObjectClass.java
@@ -0,0 +1,280 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1999
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package com.netscape.jndi.ldap.schema;
+
+import javax.naming.*;
+import javax.naming.directory.*;
+import javax.naming.ldap.*;
+
+import netscape.ldap.*;
+import netscape.ldap.controls.*;
+
+import java.util.*;
+
+public class SchemaObjectClass extends SchemaElement {
+
+     LDAPObjectClassSchema m_ldapObjectClass;
+     
+    // Attribute IDs that are exposed through Netscape LdapJDK
+    private static String[] m_allAttrIds = {NUMERICOID, NAME, DESC, OBSOLETE, SUP,
+                                            ABSTRACT, STRUCTURAL, AUXILIARY, MUST, MAY };
+    
+    public SchemaObjectClass(LDAPObjectClassSchema ldapObjectClass, SchemaManager schemaManager) {
+        super(schemaManager);        
+        m_ldapObjectClass = ldapObjectClass;
+        m_path = CLASSDEF + "/" + m_ldapObjectClass.getName();
+    }
+
+    public SchemaObjectClass(Attributes attrs, SchemaManager schemaManager) throws NamingException {
+        super(schemaManager);
+        m_ldapObjectClass = parseDefAttributes(attrs);
+        m_path = CLASSDEF + "/" + m_ldapObjectClass.getName();
+    }    
+    
+    /**
+     * Parse Definition Attributes for a LDAP objectcalss
+     */
+    static LDAPObjectClassSchema parseDefAttributes(Attributes attrs) throws NamingException {        
+        String name=null, oid=null, desc=null, sup=null;
+        boolean obsolete=false, abs=false, structural = false, aux = false;
+        Vector must=new Vector(), may=new Vector();
+
+        for (Enumeration attrEnum = attrs.getAll(); attrEnum.hasMoreElements(); ) {
+            Attribute attr = (Attribute) attrEnum.nextElement();
+            String attrName = attr.getID();
+            if (attrName.equals(NAME)) {
+                name = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(NUMERICOID)) {
+                oid = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(SUP)) {
+                sup = getSchemaAttrValue(attr);
+            }
+            else if (attrName.equals(DESC)) {
+                desc = getSchemaAttrValue(attr);
+            }            
+            else if (attrName.equals(MAY)) {
+                for (Enumeration valEnum = attr.getAll(); valEnum.hasMoreElements(); ) {
+                    may.addElement((String)valEnum.nextElement());
+                }
+            }
+            else if (attrName.equals(MUST)) {
+                for (Enumeration valEnum = attr.getAll(); valEnum.hasMoreElements(); ) {
+                    must.addElement((String)valEnum.nextElement());
+                }
+            }
+            else if (attrName.equals(OBSOLETE)) {
+                obsolete = parseTrueFalseValue(attr);
+            }
+            else if (attrName.equals(ABSTRACT)) {
+                abs = parseTrueFalseValue(attr);
+            }
+            else if (attrName.equals(STRUCTURAL)) {
+                structural = parseTrueFalseValue(attr);
+            }
+            else if (attrName.equals(AUXILIARY)) {
+                aux = parseTrueFalseValue(attr);
+            }
+            else { 
+                throw new NamingException("Invalid schema attribute type for object class definition "    + attrName);
+            }
+        }    
+            
+        LDAPObjectClassSchema objectClass =
+            new LDAPObjectClassSchema(name, oid, sup, desc,
+                                      vectorToStringAry(must),
+                                      vectorToStringAry(may));
+
+        if (obsolete) {
+            objectClass.setQualifier(OBSOLETE, "");
+        }
+        if (abs) {
+            objectClass.setQualifier(ABSTRACT, "");
+        }
+        if (structural) {
+            objectClass.setQualifier(STRUCTURAL, "");
+        }
+        if (aux) {
+            objectClass.setQualifier(AUXILIARY, "");
+        }
+            
+        return objectClass;
+    }
+        
+    /**
+     * Exctract specified attributes from the ldapObjectClass
+     */
+    Attributes extractAttributeIds(String[] attrIds) throws NamingException{
+        Attributes attrs = new BasicAttributes();
+        String val = null, multiVal[]=null;
+        for (int i = 0; i < attrIds.length; i++) {
+            if (attrIds[i].equals(NUMERICOID)) {
+                val = m_ldapObjectClass.getID();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(NUMERICOID, val));
+                }
+            }
+            else if (attrIds[i].equals(NAME)) {
+                val = m_ldapObjectClass.getName();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(NAME, val));
+                }                   
+            }
+            else if (attrIds[i].equals(DESC)) {
+                val = m_ldapObjectClass.getDescription();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(DESC, val));
+                }                    
+            }
+            else if (attrIds[i].equals(SUP)) {
+                val = m_ldapObjectClass.getSuperior();
+                if (val != null) {
+                    attrs.put(new BasicAttribute(SUP, val));
+                }                    
+            }
+            else if (attrIds[i].equals(MAY)) {
+                BasicAttribute optional = new BasicAttribute(MAY);
+                for (Enumeration e = m_ldapObjectClass.getOptionalAttributes(); e.hasMoreElements();) {
+                    optional.add(e.nextElement());
+                }
+                if (optional.size() != 0) {
+                    attrs.put(optional);
+                }
+            }
+            else if (attrIds[i].equals(MUST)) {
+                BasicAttribute required = new BasicAttribute(MUST);
+                for (Enumeration e = m_ldapObjectClass.getRequiredAttributes(); e.hasMoreElements();) {
+                    required.add(e.nextElement());
+                }
+                if (required.size() != 0) {
+                    attrs.put(required);
+                }
+            }
+            else if (attrIds[i].equals(OBSOLETE)) {
+                if (m_ldapObjectClass.getQualifier(OBSOLETE)!= null) {
+                    attrs.put(new BasicAttribute(OBSOLETE, "true"));
+                }                    
+            }
+            else if (attrIds[i].equals(ABSTRACT)) {
+                if (m_ldapObjectClass.getQualifier(ABSTRACT)!= null) {
+                    attrs.put(new BasicAttribute(ABSTRACT, "true"));
+                }                    
+            }
+            else if (attrIds[i].equals(STRUCTURAL)) {
+                if (m_ldapObjectClass.getQualifier(STRUCTURAL)!= null) {
+                    attrs.put(new BasicAttribute(STRUCTURAL, "true"));
+                }                    
+            }
+            else if (attrIds[i].equals(AUXILIARY)) {
+                if (m_ldapObjectClass.getQualifier(AUXILIARY)!= null) {
+                    attrs.put(new BasicAttribute(AUXILIARY, "true"));
+                }                    
+            }
+            else { 
+                throw new NamingException("Invalid schema attribute type for object class definition "    + attrIds[i]);
+            }
+        }
+
+        return attrs;
+    }    
+        
+        
+    /**
+     * DirContext Attribute Operations
+     */
+
+    public Attributes getAttributes(String name) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        return extractAttributeIds(m_allAttrIds);
+    }
+
+    public Attributes getAttributes(String name, String[] attrIds) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        return extractAttributeIds(attrIds);
+    }
+
+    public Attributes getAttributes(Name name) throws NamingException {
+        return getAttributes(name.toString());
+    }
+
+    public Attributes getAttributes(Name name, String[] attrIds) throws NamingException {
+        return getAttributes(name.toString(), attrIds);
+    }
+
+    public void modifyAttributes(String name, int mod_op, Attributes attrs) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        Attributes modAttrs = extractAttributeIds(m_allAttrIds);
+        modifySchemaElementAttrs(modAttrs, mod_op, attrs);
+        LDAPObjectClassSchema modLdapObjectClass = parseDefAttributes(modAttrs);
+        m_schemaMgr.modifyObjectClass(m_ldapObjectClass, modLdapObjectClass);
+        m_ldapObjectClass = modLdapObjectClass;
+    }
+
+    public void modifyAttributes(String name, ModificationItem[] mods) throws NamingException {
+        if (name.length() != 0) { // no subcontexts
+            throw new NameNotFoundException(name); // no such object
+        }
+        Attributes modAttrs = extractAttributeIds(m_allAttrIds);
+        modifySchemaElementAttrs(modAttrs, mods);
+        LDAPObjectClassSchema modLdapObjectClass = parseDefAttributes(modAttrs);
+        m_schemaMgr.modifyObjectClass(m_ldapObjectClass, modLdapObjectClass);
+        m_ldapObjectClass = modLdapObjectClass;
+    }
+
+    public void modifyAttributes(Name name, int mod_op, Attributes attrs) throws NamingException {
+        modifyAttributes(name.toString(), mod_op, attrs);
+    }
+
+    public void modifyAttributes(Name name, ModificationItem[] mods) throws NamingException {
+        modifyAttributes(name.toString(), mods);
+    }
+    
+    /**
+     * Search operations are not implemented because of complexity. Ir will require
+     * to implement the full LDAP search filter sematics in the client. (The search 
+     * filter sematics is implemented by the Directory server).
+     */
+
+}
