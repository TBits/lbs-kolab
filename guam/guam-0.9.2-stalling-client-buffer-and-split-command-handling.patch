diff --git a/apps/kolab_guam/src/kolab_guam_session.erl b/apps/kolab_guam/src/kolab_guam_session.erl
index ca4e633..e547c55 100644
--- a/apps/kolab_guam/src/kolab_guam_session.erl
+++ b/apps/kolab_guam/src/kolab_guam_session.erl
@@ -201,19 +201,37 @@ process_client_data(Socket, Data, #state{ rules_deciding = UndecidedRules, tls_c
             BufferThisData =
             case PostAction of
                 perform_passthrough ->
+                    %lager:info("sending (no buffer): ~s", [ModifiedData]),
                     eimap:passthrough_data(ImapSession, ModifiedData),
                     <<>>;
                 buffer_data ->
-                    Data
+                    % Originally Aaron uses Data here, but later on this buffer is assumed to be
+                    % already decoded, so we do have to use PreprocessData here, I think.
+                    case binary:matches(PreprocessData, <<"\r\n">>) of
+                        [] ->
+                            %lager:info("buffering: ~s", [PreprocessData]),
+                            PreprocessData;
+                        List ->
+                            {FoundPos, _} = lists:last(List),
+                            % I would like to have some binary:match for the last instead of the
+                            % first occurrence; but I'm really inexperienced in erlang so I don't
+                            % know how to solve this efficiently, so I'm using binary:matches with
+                            % using the last element only
+                            SplitPos = FoundPos + 2,
+                            eimap:passthrough_data(ImapSession, binary:part(PreprocessData, 0, SplitPos)),
+                            %lager:info("sending first part: ~s", [binary:part(PreprocessData, 0, SplitPos)] ),
+                            %lager:info("buffering second part: ~s", [binary:part(PreprocessData, SplitPos, size(PreprocessData)-SplitPos)]),
+                            binary:part(PreprocessData, SplitPos, size(PreprocessData)-SplitPos)
+                    end
             end,
             { TLS, Socket, Inflator, Deflator, NewUndecidedRules, NewActiveRules, BufferThisData, NewSplitCommand, NewSplitResetTrigger }
     end,
     set_socket_active(TLSActive, CurrentSocket),
-    PrevBuffered = State#state.buffered_client_data,
+    %buffered_client_data is already in DataToBuffer via preprocess_client_data
     { noreply, State#state{ rules_deciding = CurrentUndecidedRules, rules_active = CurrentActiveRules,
                             socket = CurrentSocket, client_tls_active = TLSActive,
                             inflator = CurrentInflator, deflator = CurrentDeflator,
-                            buffered_client_data = <<PrevBuffered/binary, DataToBuffer/binary>>,
+                            buffered_client_data = <<DataToBuffer/binary>>,
                             current_command_split = SplitCommand,
                             command_split_reset_trigger = SplitResetTrigger } }.
 
@@ -261,7 +279,7 @@ apply_next_rule_serverside(ImapSession, ServerData, ActiveRulesAcc, [{ Module, R
     apply_next_rule_serverside(ImapSession, ModifiedData, [{ Module, ModifiedRuleState } | ActiveRulesAcc], ActiveRules).
 
 apply_ruleset_clientside(_ImapSession, _Socket, ClientData, _CurrentCommandSplit, [], []) ->
-    { ClientData, [], [], [], [], perform_passthrough };
+    { ClientData, undefined, [], [], [], perform_passthrough };
 apply_ruleset_clientside(ImapSession, Socket, ClientData, CurrentCommandSplit, UndecidedRules, CurrentlyActiveRules) ->
     { PostAction, SplitCommand, SplitResetTrigger } =
         case CurrentCommandSplit of
