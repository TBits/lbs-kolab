commit 7db53d9c3fc00baa1fe4fb8ca7c9ae63c61e853b
Author: Christian Mollekopf <chrigi_1@fastmail.fm>
Date:   Mon Feb 19 16:52:33 2018 +0100

    Allow empty lines in commands.
    
    During DIGEST-MD5 authentication the client response with a an empty
    line (Just \r\n). eimap_utils:split_command_into_components Either
    returns a full command or an empty one, and thus cannot differentiate
    between an empty and an incomplete command, and then erroneously tries
    to buffer until the rest arrives (which is not existinent).
    Ideally we would fix split_command_into_components into returning
    something entirely different if the command is empty but complete,
    but this fixes the problem at hand by matching for that special case.

diff --git a/apps/kolab_guam/src/kolab_guam_session.erl b/apps/kolab_guam/src/kolab_guam_session.erl
index 4d95797..ca4e633 100644
--- a/apps/kolab_guam/src/kolab_guam_session.erl
+++ b/apps/kolab_guam/src/kolab_guam_session.erl
@@ -266,9 +266,15 @@ apply_ruleset_clientside(ImapSession, Socket, ClientData, CurrentCommandSplit, U
     { PostAction, SplitCommand, SplitResetTrigger } =
         case CurrentCommandSplit of
             undefined ->
-                case eimap_utils:split_command_into_components(ClientData) of
-                    { _Tag, <<>>, <<>> } -> { buffer_data, undefined, reset_for_next_client_command };
-                    { _Tag, Command, _Data } = Split -> { perform_passthrough, Split, when_to_reset_split(Command) }
+                %We first have to check whether the command is an empty line. In such a case split_command_into_components would return an empty command,
+                %even though the command is complete.
+                case ClientData of
+                    <<"\r\n">> -> { perform_passthrough, CurrentCommandSplit, reset_for_next_client_command };
+                    _ ->
+                        case eimap_utils:split_command_into_components(ClientData) of
+                            { _Tag, <<>>, <<>> } -> { buffer_data, undefined, reset_for_next_client_command };
+                            { _Tag, Command, _Data } = Split -> { perform_passthrough, Split, when_to_reset_split(Command) }
+                        end
                 end;
             _ ->  { perform_passthrough, CurrentCommandSplit, reset_for_next_client_command }
         end,
